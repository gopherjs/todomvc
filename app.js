"use strict";
Error.stackTraceLimit = -1;

var go$reservedKeywords = ["abstract", "arguments", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "eval", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "let", "long", "native", "new", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with", "yield"];

var go$global;
if (typeof window !== "undefined") {
	go$global = window;
} else if (typeof GLOBAL !== "undefined") {
	go$global = GLOBAL;
}

var go$idCounter = 1;
var go$keys = function(m) { return m ? Object.keys(m) : []; };
var go$min = Math.min;
var go$parseInt = parseInt;
var go$parseFloat = parseFloat;
var go$reflect, go$newStringPtr;
var Go$Array = Array;
var Go$Error = Error;

var go$mapArray = function(array, f) {
	var newArray = new array.constructor(array.length), i;
	for (i = 0; i < array.length; i++) {
		newArray[i] = f(array[i]);
	}
	return newArray;
};

var go$newType = function(size, kind, string, name, pkgPath, constructor) {
	var typ;
	switch(kind) {
	case "Bool":
	case "Int":
	case "Int8":
	case "Int16":
	case "Int32":
	case "Uint":
	case "Uint8" :
	case "Uint16":
	case "Uint32":
	case "Uintptr":
	case "Float32":
	case "Float64":
	case "String":
	case "UnsafePointer":
		typ = function(v) { this.go$val = v; };
		typ.prototype.go$key = function() { return string + "$" + this.go$val; };
		break;

	case "Int64":
		typ = function(high, low) {
			this.high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;
			this.low = low >>> 0;
			this.go$val = this;
		};
		typ.prototype.go$key = function() { return string + "$" + this.high + "$" + this.low; };
		break;

	case "Uint64":
		typ = function(high, low) {
			this.high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;
			this.low = low >>> 0;
			this.go$val = this;
		};
		typ.prototype.go$key = function() { return string + "$" + this.high + "$" + this.low; };
		break;

	case "Complex64":
	case "Complex128":
		typ = function(real, imag) {
			this.real = real;
			this.imag = imag;
			this.go$val = this;
		};
		typ.prototype.go$key = function() { return string + "$" + this.real + "$" + this.imag; };
		break;

	case "Array":
		typ = function(v) { this.go$val = v; };
		typ.Ptr = go$newType(4, "Ptr", "*" + string, "", "", function(array) {
			this.go$get = function() { return array; };
			this.go$val = array;
		});
		typ.init = function(elem, len) {
			typ.elem = elem;
			typ.len = len;
			typ.prototype.go$key = function() {
				return string + "$" + go$mapArray(this.go$val, function(e) {
					var key = e.go$key ? e.go$key() : String(e);
					return key.replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
				}).join("$");
			};
			typ.extendReflectType = function(rt) {
				rt.arrayType = new go$reflect.arrayType(rt, elem.reflectType(), undefined, len);
			};
			typ.Ptr.init(typ);
		};
		break;

	case "Chan":
		typ = function() { this.go$val = this; };
		typ.prototype.go$key = function() {
			if (this.go$id === undefined) {
				this.go$id = go$idCounter;
				go$idCounter++;
			}
			return String(this.go$id);
		};
		typ.init = function(elem, sendOnly, recvOnly) {
			typ.nil = new typ();
			typ.extendReflectType = function(rt) {
				rt.chanType = new go$reflect.chanType(rt, elem.reflectType(), sendOnly ? go$reflect.SendDir : (recvOnly ? go$reflect.RecvDir : go$reflect.BothDir));
			};
		};
		break;

	case "Func":
		typ = function(v) { this.go$val = v; };
		typ.init = function(params, results, variadic) {
			typ.params = params;
			typ.results = results;
			typ.variadic = variadic;
			typ.extendReflectType = function(rt) {
				var typeSlice = (go$sliceType(go$ptrType(go$reflect.rtype)));
				rt.funcType = new go$reflect.funcType(rt, variadic, new typeSlice(go$mapArray(params, function(p) { return p.reflectType(); })), new typeSlice(go$mapArray(results, function(p) { return p.reflectType(); })));
			};
		};
		break;

	case "Interface":
		typ = { implementedBy: [] };
		typ.init = function(methods) {
			typ.extendReflectType = function(rt) {
				var imethods = go$mapArray(methods, function(m) {
					return new go$reflect.imethod(go$newStringPtr(m[0]), go$newStringPtr(m[1]), m[2].reflectType());
				});
				var methodSlice = (go$sliceType(go$ptrType(go$reflect.imethod)));
				rt.interfaceType = new go$reflect.interfaceType(rt, new methodSlice(imethods));
			};
		};
		break;

	case "Map":
		typ = function(v) { this.go$val = v; };
		typ.init = function(key, elem) {
			typ.key = key;
			typ.elem = elem;
			typ.extendReflectType = function(rt) {
				rt.mapType = new go$reflect.mapType(rt, key.reflectType(), elem.reflectType(), undefined, undefined);
			};
		};
		break;

	case "Ptr":
		typ = constructor || function(getter, setter) {
			this.go$get = getter;
			this.go$set = setter;
			this.go$val = this;
		};
		typ.prototype.go$key = function() {
			if (this.go$id === undefined) {
				this.go$id = go$idCounter;
				go$idCounter++;
			}
			return String(this.go$id);
		};
		typ.init = function(elem) {
			typ.nil = new typ(go$throwNilPointerError, go$throwNilPointerError);
			typ.extendReflectType = function(rt) {
				rt.ptrType = new go$reflect.ptrType(rt, elem.reflectType());
			};
		};
		break;

	case "Slice":
		var nativeArray;
		typ = function(array) {
			if (array.constructor !== nativeArray) {
				array = new nativeArray(array);
			}
			this.array = array;
			this.offset = 0;
			this.length = array.length;
			this.capacity = array.length;
			this.go$val = this;
		};
		typ.make = function(length, capacity, zero) {
			capacity = capacity || length;
			var array = new nativeArray(capacity), i;
			for (i = 0; i < capacity; i++) {
				array[i] = zero();
			}
			var slice = new typ(array);
			slice.length = length;
			return slice;
		};
		typ.init = function(elem) {
			typ.elem = elem;
			nativeArray = go$nativeArray(elem.kind);
			typ.nil = new typ([]);
			typ.extendReflectType = function(rt) {
				rt.sliceType = new go$reflect.sliceType(rt, elem.reflectType());
			};
		};
		break;

	case "Struct":
		typ = function(v) { this.go$val = v; };
		typ.Ptr = go$newType(4, "Ptr", "*" + string, "", "", constructor);
		typ.Ptr.Struct = typ;
		typ.init = function(fields) {
			typ.Ptr.init(typ);
			typ.Ptr.nil = new constructor();
			var i;
			for (i = 0; i < fields.length; i++) {
				var field = fields[i];
				Object.defineProperty(typ.Ptr.nil, field[0], { get: go$throwNilPointerError, set: go$throwNilPointerError });
			}
			typ.prototype.go$key = function() {
				var keys = new Array(fields.length);
				for (i = 0; i < fields.length; i++) {
					var v = this.go$val[go$fieldName(fields, i)];
					var key = v.go$key ? v.go$key() : String(v);
					keys[i] = key.replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
				}
				return string + "$" + keys.join("$");
			};
			typ.extendReflectType = function(rt) {
				var reflectFields = new Array(fields.length), i;
				for (i = 0; i < fields.length; i++) {
					var field = fields[i];
					reflectFields[i] = new go$reflect.structField(go$newStringPtr(field[0]), go$newStringPtr(field[1]), field[2].reflectType(), go$newStringPtr(field[3]), i);
				}
				rt.structType = new go$reflect.structType(rt, new (go$sliceType(go$reflect.structField))(reflectFields));
			};
		};
		break;

	default:
		throw go$panic("invalid kind: " + kind);
	}

	typ.kind = kind;
	typ.string = string;
	typ.typeName = name;
	typ.pkgPath = pkgPath;
	var rt = null;
	typ.reflectType = function() {
		if (rt === null) {
			rt = new go$reflect.rtype(size, 0, 0, 0, 0, go$reflect.kinds[kind], undefined, undefined, go$newStringPtr(string), undefined, undefined);
			rt.jsType = typ;

			var methods = [];
			if (typ.methods !== undefined) {
				var i;
				for (i = 0; i < typ.methods.length; i++) {
					var m = typ.methods[i];
					methods.push(new go$reflect.method(go$newStringPtr(m[0]), go$newStringPtr(m[1]), go$funcType(m[2], m[3], m[4]).reflectType(), go$funcType([typ].concat(m[2]), m[3], m[4]).reflectType(), undefined, undefined));
				}
			}
			if (name !== "" || methods.length !== 0) {
				var methodSlice = (go$sliceType(go$ptrType(go$reflect.method)));
				rt.uncommonType = new go$reflect.uncommonType(go$newStringPtr(name), go$newStringPtr(pkgPath), new methodSlice(methods));
			}

			if (typ.extendReflectType !== undefined) {
				typ.extendReflectType(rt);
			}
		}
		return rt;
	};
	return typ;
};

var Go$Bool          = go$newType( 1, "Bool",          "bool",           "bool",       "", null);
var Go$Int           = go$newType( 4, "Int",           "int",            "int",        "", null);
var Go$Int8          = go$newType( 1, "Int8",          "int8",           "int8",       "", null);
var Go$Int16         = go$newType( 2, "Int16",         "int16",          "int16",      "", null);
var Go$Int32         = go$newType( 4, "Int32",         "int32",          "int32",      "", null);
var Go$Int64         = go$newType( 8, "Int64",         "int64",          "int64",      "", null);
var Go$Uint          = go$newType( 4, "Uint",          "uint",           "uint",       "", null);
var Go$Uint8         = go$newType( 1, "Uint8",         "uint8",          "uint8",      "", null);
var Go$Uint16        = go$newType( 2, "Uint16",        "uint16",         "uint16",     "", null);
var Go$Uint32        = go$newType( 4, "Uint32",        "uint32",         "uint32",     "", null);
var Go$Uint64        = go$newType( 8, "Uint64",        "uint64",         "uint64",     "", null);
var Go$Uintptr       = go$newType( 4, "Uintptr",       "uintptr",        "uintptr",    "", null);
var Go$Float32       = go$newType( 4, "Float32",       "float32",        "float32",    "", null);
var Go$Float64       = go$newType( 8, "Float64",       "float64",        "float64",    "", null);
var Go$Complex64     = go$newType( 8, "Complex64",     "complex64",      "complex64",  "", null);
var Go$Complex128    = go$newType(16, "Complex128",    "complex128",     "complex128", "", null);
var Go$String        = go$newType( 0, "String",        "string",         "string",     "", null);
var Go$UnsafePointer = go$newType( 4, "UnsafePointer", "unsafe.Pointer", "Pointer",    "", null);

var go$nativeArray = function(elemKind) {
	return ({ Int: Int32Array, Int8: Int8Array, Int16: Int16Array, Int32: Int32Array, Uint: Uint32Array, Uint8: Uint8Array, Uint16: Uint16Array, Uint32: Uint32Array, Uintptr: Uint32Array, Float32: Float32Array, Float64: Float64Array })[elemKind] || Array;
};
var go$toNativeArray = function(elemKind, array) {
	var nativeArray = go$nativeArray(elemKind);
	if (nativeArray === Array) {
		return array;
	}
	return new nativeArray(array);
};
var go$makeNativeArray = function(elemKind, length, zero) {
	var array = new (go$nativeArray(elemKind))(length), i;
	for (i = 0; i < length; i++) {
		array[i] = zero();
	}
	return array;
};
var go$arrayTypes = {};
var go$arrayType = function(elem, len) {
	var string = "[" + len + "]" + elem.string;
	var typ = go$arrayTypes[string];
	if (typ === undefined) {
		typ = go$newType(0, "Array", string, "", "", null);
		typ.init(elem, len);
		go$arrayTypes[string] = typ;
	}
	return typ;
};

var go$chanType = function(elem, sendOnly, recvOnly) {
	var string = (recvOnly ? "<-" : "") + "chan" + (sendOnly ? "<- " : " ") + elem.string;
	var field = sendOnly ? "SendChan" : (recvOnly ? "RecvChan" : "Chan");
	var typ = elem[field];
	if (typ === undefined) {
		typ = go$newType(0, "Chan", string, "", "", null);
		typ.init(elem, sendOnly, recvOnly);
		elem[field] = typ;
	}
	return typ;
};

var go$funcTypes = {};
var go$funcType = function(params, results, variadic) {
	var paramTypes = go$mapArray(params, function(p) { return p.string; });
	if (variadic) {
		paramTypes[paramTypes.length - 1] = "..." + paramTypes[paramTypes.length - 1].substr(2);
	}
	var string = "func(" + paramTypes.join(", ") + ")";
	if (results.length === 1) {
		string += " " + results[0].string;
	} else if (results.length > 1) {
		string += " (" + go$mapArray(results, function(r) { return r.string; }).join(", ") + ")";
	}
	var typ = go$funcTypes[string];
	if (typ === undefined) {
		typ = go$newType(0, "Func", string, "", "", null);
		typ.init(params, results, variadic);
		go$funcTypes[string] = typ;
	}
	return typ;
};

var go$interfaceTypes = {};
var go$interfaceType = function(methods) {
	var string = "interface {}";
	if (methods.length !== 0) {
		string = "interface { " + go$mapArray(methods, function(m) {
			return (m[1] !== "" ? m[1] + "." : "") + m[0] + m[2].string.substr(4);
		}).join("; ") + " }";
	}
	var typ = go$interfaceTypes[string];
	if (typ === undefined) {
		typ = go$newType(0, "Interface", string, "", "", null);
		typ.init(methods);
		go$interfaceTypes[string] = typ;
	}
	return typ;
};
var go$emptyInterface = go$interfaceType([]);
var go$interfaceNil = { go$key: function() { return "nil"; } };
var go$error = go$newType(8, "Interface", "error", "error", "", null);
go$error.init([["Error", "", go$funcType([], [Go$String], false)]]);

var Go$Map = function() {};
(function() {
	var names = Object.getOwnPropertyNames(Object.prototype), i;
	for (i = 0; i < names.length; i++) {
		Go$Map.prototype[names[i]] = undefined;
	}
})();
var go$mapTypes = {};
var go$mapType = function(key, elem) {
	var string = "map[" + key.string + "]" + elem.string;
	var typ = go$mapTypes[string];
	if (typ === undefined) {
		typ = go$newType(0, "Map", string, "", "", null);
		typ.init(key, elem);
		go$mapTypes[string] = typ;
	}
	return typ;
};

var go$throwNilPointerError = function() { go$throwRuntimeError("invalid memory address or nil pointer dereference"); };
var go$ptrType = function(elem) {
	var typ = elem.Ptr;
	if (typ === undefined) {
		typ = go$newType(0, "Ptr", "*" + elem.string, "", "", null);
		typ.init(elem);
		elem.Ptr = typ;
	}
	return typ;
};

var go$sliceType = function(elem) {
	var typ = elem.Slice;
	if (typ === undefined) {
		typ = go$newType(0, "Slice", "[]" + elem.string, "", "", null);
		typ.init(elem);
		elem.Slice = typ;
	}
	return typ;
};

var go$fieldName = function(fields, i) {
	var field = fields[i];
	var name = field[0];
	if (name === "") {
		var ntyp = field[2];
		if (ntyp.kind === "Ptr") {
			ntyp = ntyp.elem;
		}
		return ntyp.typeName;
	}
	if (name === "_" || go$reservedKeywords.indexOf(name) != -1) {
		return name + "$" + i;
	}
	return name;
};

var go$structTypes = {};
var go$structType = function(fields) {
	var string = "struct { " + go$mapArray(fields, function(f) {
		return f[0] + " " + f[2].string + (f[3] !== "" ? (' "' + f[3].replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"') : "");
	}).join("; ") + " }";
	var typ = go$structTypes[string];
	if (typ === undefined) {
		typ = go$newType(0, "Struct", string, "", "", function() {
			this.go$val = this;
			var i;
			for (i = 0; i < fields.length; i++) {
				this[go$fieldName(fields, i)] = arguments[i];
			}
		});
		typ.init(fields);
		var i, j;
		for (i = 0; i < fields.length; i++) {
			var field = fields[i];
			if (field[0] === "" && field[2].prototype !== undefined) {
				var methods = Object.keys(field[2].prototype);
				for (j = 0; j < methods.length; j++) {
					(function(fieldName, methodName, method) {
						typ.prototype[methodName] = function() {
							return method.apply(this.go$val[fieldName], arguments);
						};
						typ.Ptr.prototype[methodName] = function() {
							return method.apply(this[fieldName], arguments);
						};
					})(field[0], methods[j], field[2].prototype[methods[j]]);
				}
			}
		}
		go$structTypes[string] = typ;
	}
	return typ;
};

var go$stringPtrMap = new Go$Map();
go$newStringPtr = function(str) {
	if (str === undefined || str === "") {
		return go$ptrType(Go$String).nil;
	}
	var ptr = go$stringPtrMap[str];
	if (ptr === undefined) {
		ptr = new (go$ptrType(Go$String))(function() { return str; }, function(v) { str = v; });
		go$stringPtrMap[str] = ptr;
	}
	return ptr;
};
var go$newDataPointer = function(data, constructor) {
	return new constructor(function() { return data; }, function(v) { data = v; });
};

var go$float32bits = function(f) {
	var s, e;
	if (f === 0) {
		if (f === 0 && 1 / f === 1 / -0) {
			return 2147483648;
		}
		return 0;
	}
	if (!(f === f)) {
		return 2143289344;
	}
	s = 0;
	if (f < 0) {
		s = 2147483648;
		f = -f;
	}
	e = 150;
	while (f >= 1.6777216e+07) {
		f = f / (2);
		if (e === 255) {
			break;
		}
		e = (e + (1) >>> 0);
	}
	while (f < 8.388608e+06) {
		e = (e - (1) >>> 0);
		if (e === 0) {
			break;
		}
		f = f * (2);
	}
	return ((((s | (((e >>> 0) << 23) >>> 0)) >>> 0) | ((((((f + 0.5) >> 0) >>> 0) &~ 8388608) >>> 0))) >>> 0);
};

var go$flatten64 = function(x) {
	return x.high * 4294967296 + x.low;
};
var go$shiftLeft64 = function(x, y) {
	if (y === 0) {
		return x;
	}
	if (y < 32) {
		return new x.constructor(x.high << y | x.low >>> (32 - y), (x.low << y) >>> 0);
	}
	if (y < 64) {
		return new x.constructor(x.low << (y - 32), 0);
	}
	return new x.constructor(0, 0);
};
var go$shiftRightInt64 = function(x, y) {
	if (y === 0) {
		return x;
	}
	if (y < 32) {
		return new x.constructor(x.high >> y, (x.low >>> y | x.high << (32 - y)) >>> 0);
	}
	if (y < 64) {
		return new x.constructor(x.high >> 31, (x.high >> (y - 32)) >>> 0);
	}
	if (x.high < 0) {
		return new x.constructor(-1, 4294967295);
	}
	return new x.constructor(0, 0);
};
var go$shiftRightUint64 = function(x, y) {
	if (y === 0) {
		return x;
	}
	if (y < 32) {
		return new x.constructor(x.high >>> y, (x.low >>> y | x.high << (32 - y)) >>> 0);
	}
	if (y < 64) {
		return new x.constructor(0, x.high >>> (y - 32));
	}
	return new x.constructor(0, 0);
};
var go$mul64 = function(x, y) {
	var high = 0, low = 0, i;
	if ((y.low & 1) !== 0) {
		high = x.high;
		low = x.low;
	}
	for (i = 1; i < 32; i++) {
		if ((y.low & 1<<i) !== 0) {
			high += x.high << i | x.low >>> (32 - i);
			low += (x.low << i) >>> 0;
		}
	}
	for (i = 0; i < 32; i++) {
		if ((y.high & 1<<i) !== 0) {
			high += x.low << i;
		}
	}
	return new x.constructor(high, low);
};
var go$div64 = function(x, y, returnRemainder) {
	if (y.high === 0 && y.low === 0) {
		go$throwRuntimeError("integer divide by zero");
	}

	var s = 1;
	var rs = 1;

	var xHigh = x.high;
	var xLow = x.low;
	if (xHigh < 0) {
		s = -1;
		rs = -1;
		xHigh = -xHigh;
		if (xLow !== 0) {
			xHigh--;
			xLow = 4294967296 - xLow;
		}
	}

	var yHigh = y.high;
	var yLow = y.low;
	if (y.high < 0) {
		s *= -1;
		yHigh = -yHigh;
		if (yLow !== 0) {
			yHigh--;
			yLow = 4294967296 - yLow;
		}
	}

	var high = 0, low = 0, n = 0, i;
	while (yHigh < 2147483648 && ((xHigh > yHigh) || (xHigh === yHigh && xLow > yLow))) {
		yHigh = (yHigh << 1 | yLow >>> 31) >>> 0;
		yLow = (yLow << 1) >>> 0;
		n++;
	}
	for (i = 0; i <= n; i++) {
		high = high << 1 | low >>> 31;
		low = (low << 1) >>> 0;
		if ((xHigh > yHigh) || (xHigh === yHigh && xLow >= yLow)) {
			xHigh = xHigh - yHigh;
			xLow = xLow - yLow;
			if (xLow < 0) {
				xHigh--;
				xLow += 4294967296;
			}
			low++;
			if (low === 4294967296) {
				high++;
				low = 0;
			}
		}
		yLow = (yLow >>> 1 | yHigh << (32 - 1)) >>> 0;
		yHigh = yHigh >>> 1;
	}

	if (returnRemainder) {
		return new x.constructor(xHigh * rs, xLow * rs);
	}
	return new x.constructor(high * s, low * s);
};

var go$divComplex = function(n, d) {
	var ninf = n.real === 1/0 || n.real === -1/0 || n.imag === 1/0 || n.imag === -1/0;
	var dinf = d.real === 1/0 || d.real === -1/0 || d.imag === 1/0 || d.imag === -1/0;
	var nnan = !ninf && (n.real !== n.real || n.imag !== n.imag);
	var dnan = !dinf && (d.real !== d.real || d.imag !== d.imag);
	if(nnan || dnan) {
		return new n.constructor(0/0, 0/0);
	}
	if (ninf && !dinf) {
		return new n.constructor(1/0, 1/0);
	}
	if (!ninf && dinf) {
		return new n.constructor(0, 0);
	}
	if (d.real === 0 && d.imag === 0) {
		if (n.real === 0 && n.imag === 0) {
			return new n.constructor(0/0, 0/0);
		}
		return new n.constructor(1/0, 1/0);
	}
	var a = Math.abs(d.real);
	var b = Math.abs(d.imag);
	if (a <= b) {
		var ratio = d.real / d.imag;
		var denom = d.real * ratio + d.imag;
		return new n.constructor((n.real * ratio + n.imag) / denom, (n.imag * ratio - n.real) / denom);
	}
	var ratio = d.imag / d.real;
	var denom = d.imag * ratio + d.real;
	return new n.constructor((n.imag * ratio + n.real) / denom, (n.imag - n.real * ratio) / denom);
};

var go$subslice = function(slice, low, high, max) {
	if (low < 0 || high < low || max < high || high > slice.capacity || max > slice.capacity) {
		go$throwRuntimeError("slice bounds out of range");
	}
	var s = new slice.constructor(slice.array);
	s.offset = slice.offset + low;
	s.length = slice.length - low;
	s.capacity = slice.capacity - low;
	if (high !== undefined) {
		s.length = high - low;
	}
	if (max !== undefined) {
		s.capacity = max - low;
	}
	return s;
};

var go$sliceToArray = function(slice) {
	if (slice.length === 0) {
		return [];
	}
	if (slice.array.constructor !== Array) {
		return slice.array.subarray(slice.offset, slice.offset + slice.length);
	}
	return slice.array.slice(slice.offset, slice.offset + slice.length);
};

var go$decodeRune = function(str, pos) {
	var c0 = str.charCodeAt(pos);

	if (c0 < 0x80) {
		return [c0, 1];
	}

	if (c0 !== c0 || c0 < 0xC0) {
		return [0xFFFD, 1];
	}

	var c1 = str.charCodeAt(pos + 1);
	if (c1 !== c1 || c1 < 0x80 || 0xC0 <= c1) {
		return [0xFFFD, 1];
	}

	if (c0 < 0xE0) {
		var r = (c0 & 0x1F) << 6 | (c1 & 0x3F);
		if (r <= 0x7F) {
			return [0xFFFD, 1];
		}
		return [r, 2];
	}

	var c2 = str.charCodeAt(pos + 2);
	if (c2 !== c2 || c2 < 0x80 || 0xC0 <= c2) {
		return [0xFFFD, 1];
	}

	if (c0 < 0xF0) {
		var r = (c0 & 0x0F) << 12 | (c1 & 0x3F) << 6 | (c2 & 0x3F);
		if (r <= 0x7FF) {
			return [0xFFFD, 1];
		}
		if (0xD800 <= r && r <= 0xDFFF) {
			return [0xFFFD, 1];
		}
		return [r, 3];
	}

	var c3 = str.charCodeAt(pos + 3);
	if (c3 !== c3 || c3 < 0x80 || 0xC0 <= c3) {
		return [0xFFFD, 1];
	}

	if (c0 < 0xF8) {
		var r = (c0 & 0x07) << 18 | (c1 & 0x3F) << 12 | (c2 & 0x3F) << 6 | (c3 & 0x3F);
		if (r <= 0xFFFF || 0x10FFFF < r) {
			return [0xFFFD, 1];
		}
		return [r, 4];
	}

	return [0xFFFD, 1];
};

var go$encodeRune = function(r) {
	if (r < 0 || r > 0x10FFFF || (0xD800 <= r && r <= 0xDFFF)) {
		r = 0xFFFD;
	}
	if (r <= 0x7F) {
		return String.fromCharCode(r);
	}
	if (r <= 0x7FF) {
		return String.fromCharCode(0xC0 | r >> 6, 0x80 | (r & 0x3F));
	}
	if (r <= 0xFFFF) {
		return String.fromCharCode(0xE0 | r >> 12, 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
	}
	return String.fromCharCode(0xF0 | r >> 18, 0x80 | (r >> 12 & 0x3F), 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
};

var go$stringToBytes = function(str, terminateWithNull) {
	var array = new Uint8Array(terminateWithNull ? str.length + 1 : str.length), i;
	for (i = 0; i < str.length; i++) {
		array[i] = str.charCodeAt(i);
	}
	if (terminateWithNull) {
		array[str.length] = 0;
	}
	return array;
};

var go$bytesToString = function(slice) {
	if (slice.length === 0) {
		return "";
	}
	var str = "", i;
	for (i = 0; i < slice.length; i += 10000) {
		str += String.fromCharCode.apply(null, slice.array.subarray(slice.offset + i, slice.offset + Math.min(slice.length, i + 10000)));
	}
	return str;
};

var go$stringToRunes = function(str) {
	var array = new Int32Array(str.length);
	var rune, i, j = 0;
	for (i = 0; i < str.length; i += rune[1], j++) {
		rune = go$decodeRune(str, i);
		array[j] = rune[0];
	}
	return array.subarray(0, j);
};

var go$runesToString = function(slice) {
	if (slice.length === 0) {
		return "";
	}
	var str = "", i;
	for (i = 0; i < slice.length; i++) {
		str += go$encodeRune(slice.array[slice.offset + i]);
	}
	return str;
};

var go$needsExternalization = function(t) {
	switch (t.kind) {
		case "Int64":
		case "Uint64":
		case "Array":
		case "Func":
		case "Interface":
		case "Map":
		case "Slice":
		case "String":
			return true;
		default:
			return false;
	}
};

var go$externalize = function(v, t) {
	switch (t.kind) {
	case "Int64":
	case "Uint64":
		return go$flatten64(v);
	case "Array":
		if (go$needsExternalization(t.elem)) {
			return go$mapArray(v, function(e) { return go$externalize(e, t.elem); });
		}
		return v;
	case "Func":
		if (v === go$throwNilPointerError) {
			return null;
		}
		var convert = false;
		var i;
		for (i = 0; i < t.params.length; i++) {
			convert = convert || (t.params[i] !== go$packages["github.com/neelance/gopherjs/js"].Object);
		}
		for (i = 0; i < t.results.length; i++) {
			convert = convert || go$needsExternalization(t.results[i]);
		}
		if (!convert) {
			return v;
		}
		return function() {
			var args = [], i;
			for (i = 0; i < t.params.length; i++) {
				if (t.variadic && i === t.params.length - 1) {
					var vt = t.params[i].elem, varargs = [], j;
					for (j = i; j < arguments.length; j++) {
						varargs.push(go$internalize(arguments[j], vt));
					}
					args.push(new (t.params[i])(varargs));
					break;
				}
				args.push(go$internalize(arguments[i], t.params[i]));
			}
			var result = v.apply(undefined, args);
			switch (t.results.length) {
			case 0:
				return;
			case 1:
				return go$externalize(result, t.results[0]);
			default:
				for (i = 0; i < t.results.length; i++) {
					result[i] = go$externalize(result[i], t.results[i]);
				}
				return result;
			}
		};
	case "Interface":
		if (v === null) {
			return null;
		}
		if (v.constructor.kind === undefined) {
			return v; // js.Object
		}
		return go$externalize(v.go$val, v.constructor);
	case "Map":
		var m = {};
		var keys = go$keys(v), i;
		for (i = 0; i < keys.length; i++) {
			var entry = v[keys[i]];
			m[go$externalize(entry.k, t.key)] = go$externalize(entry.v, t.elem);
		}
		return m;
	case "Slice":
		if (go$needsExternalization(t.elem)) {
			return go$mapArray(go$sliceToArray(v), function(e) { return go$externalize(e, t.elem); });
		}
		return go$sliceToArray(v);
	case "String":
		var s = "", r, i, j = 0;
		for (i = 0; i < v.length; i += r[1], j++) {
			r = go$decodeRune(v, i);
			s += String.fromCharCode(r[0]);
		}
		return s;
	case "Struct":
		var timePkg = go$packages["time"];
		if (timePkg && v.constructor === timePkg.Time.Ptr) {
			var milli = go$div64(v.UnixNano(), new Go$Int64(0, 1000000));
			return new Date(go$flatten64(milli));
		}
		return v;
	default:
		return v;
	}
};

var go$internalize = function(v, t, recv) {
	switch (t.kind) {
	case "Bool":
		return !!v;
	case "Int":
		return parseInt(v);
	case "Int8":
		return parseInt(v) << 24 >> 24;
	case "Int16":
		return parseInt(v) << 16 >> 16;
	case "Int32":
		return parseInt(v) >> 0;
	case "Uint":
		return parseInt(v);
	case "Uint8" :
		return parseInt(v) << 24 >>> 24;
	case "Uint16":
		return parseInt(v) << 16 >>> 16;
	case "Uint32":
	case "Uintptr":
		return parseInt(v) >>> 0;
	case "Int64":
	case "Uint64":
		return new t(0, v);
	case "Float32":
	case "Float64":
		return parseFloat(v);
	case "Array":
		if (v.length !== t.len) {
			throw go$panic("got array with wrong size from JavaScript native");
		}
		return go$mapArray(v, function(e) { return go$internalize(e, t.elem); });
	case "Func":
		return function() {
			var args = [], i;
			for (i = 0; i < t.params.length; i++) {
				if (t.variadic && i === t.params.length - 1) {
					var vt = t.params[i].elem, varargs = arguments[i], j;
					for (j = 0; j < varargs.length; j++) {
						args.push(go$externalize(varargs.array[varargs.offset + j], vt));
					}
					break;
				}
				args.push(go$externalize(arguments[i], t.params[i]));
			}
			var result = v.apply(recv, args);
			switch (t.results.length) {
			case 0:
				return;
			case 1:
				return go$internalize(result, t.results[0]);
			default:
				for (i = 0; i < t.results.length; i++) {
					result[i] = go$internalize(result[i], t.results[i]);
				}
				return result;
			}
		};
	case "Interface":
		if (t === go$packages["github.com/neelance/gopherjs/js"].Object) {
			return v;
		}
		switch (v.constructor) {
		case Int8Array:
			return new (go$sliceType(Go$Int8))(v);
		case Int16Array:
			return new (go$sliceType(Go$Int16))(v);
		case Int32Array:
			return new (go$sliceType(Go$Int))(v);
		case Uint8Array:
			return new (go$sliceType(Go$Uint8))(v);
		case Uint16Array:
			return new (go$sliceType(Go$Uint16))(v);
		case Uint32Array:
			return new (go$sliceType(Go$Uint))(v);
		case Float32Array:
			return new (go$sliceType(Go$Float32))(v);
		case Float64Array:
			return new (go$sliceType(Go$Float64))(v);
		case Array:
			return go$internalize(v, go$sliceType(go$emptyInterface));
		case Boolean:
			return new Go$Bool(!!v);
		case Date:
			var timePkg = go$packages["time"];
			if (timePkg) {
				return new timePkg.Time(timePkg.Unix(new Go$Int64(0, 0), new Go$Int64(0, v.getTime() * 1000000)));
			}
		case Function:
			var funcType = go$funcType([go$sliceType(go$emptyInterface)], [go$packages["github.com/neelance/gopherjs/js"].Object], true);
			return new funcType(go$internalize(v, funcType));
		case Number:
			return new Go$Float64(parseFloat(v));
		case Object:
			var mapType = go$mapType(Go$String, go$emptyInterface);
			return new mapType(go$internalize(v, mapType));
		case String:
			return new Go$String(go$internalize(v, Go$String));
		}
		return v;
	case "Map":
		var m = new Go$Map();
		var keys = go$keys(v), i;
		for (i = 0; i < keys.length; i++) {
			var key = go$internalize(keys[i], t.key);
			m[key.go$key ? key.go$key() : key] = { k: key, v: go$internalize(v[keys[i]], t.elem) };
		}
		return m;
	case "Slice":
		return new t(go$mapArray(v, function(e) { return go$internalize(e, t.elem); }));
	case "String":
		v = String(v);
		var s = "", i;
		for (i = 0; i < v.length; i++) {
			s += go$encodeRune(v.charCodeAt(i));
		}
		return s;
	default:
		return v;
	}
};

var go$copySlice = function(dst, src) {
	var n = Math.min(src.length, dst.length), i;
	if (dst.array.constructor !== Array && n !== 0) {
		dst.array.set(src.array.subarray(src.offset, src.offset + n), dst.offset);
		return n;
	}
	for (i = 0; i < n; i++) {
		dst.array[dst.offset + i] = src.array[src.offset + i];
	}
	return n;
};

var go$copyString = function(dst, src) {
	var n = Math.min(src.length, dst.length), i;
	for (i = 0; i < n; i++) {
		dst.array[dst.offset + i] = src.charCodeAt(i);
	}
	return n;
};

var go$copyArray = function(dst, src) {
	var i;
	for (i = 0; i < src.length; i++) {
		dst[i] = src[i];
	}
};

var go$growSlice = function(slice, length) {
	var newCapacity = Math.max(length, slice.capacity < 1024 ? slice.capacity * 2 : Math.floor(slice.capacity * 5 / 4));

	var newArray;
	if (slice.array.constructor === Array) {
		newArray = slice.array;
		if (slice.offset !== 0 || newArray.length !== slice.offset + slice.capacity) {
			newArray = newArray.slice(slice.offset);
		}
		newArray.length = newCapacity;
	} else {
		newArray = new slice.array.constructor(newCapacity);
		newArray.set(slice.array.subarray(slice.offset));
	}

	var newSlice = new slice.constructor(newArray);
	newSlice.length = slice.length;
	newSlice.capacity = newCapacity;
	return newSlice;
};

var go$append = function(slice) {
	if (arguments.length === 1) {
		return slice;
	}

	var newLength = slice.length + arguments.length - 1;
	if (newLength > slice.capacity) {
		slice = go$growSlice(slice, newLength);
	}

	var array = slice.array;
	var leftOffset = slice.offset + slice.length - 1, i;
	for (i = 1; i < arguments.length; i++) {
		array[leftOffset + i] = arguments[i];
	}

	var newSlice = new slice.constructor(array);
	newSlice.offset = slice.offset;
	newSlice.length = newLength;
	newSlice.capacity = slice.capacity;
	return newSlice;
};

var go$appendSlice = function(slice, toAppend) {
	if (toAppend.length === 0) {
		return slice;
	}

	var newLength = slice.length + toAppend.length;
	if (newLength > slice.capacity) {
		slice = go$growSlice(slice, newLength);
	}

	var array = slice.array;
	var leftOffset = slice.offset + slice.length, rightOffset = toAppend.offset, i;
	for (i = 0; i < toAppend.length; i++) {
		array[leftOffset + i] = toAppend.array[rightOffset + i];
	}

	var newSlice = new slice.constructor(array);
	newSlice.offset = slice.offset;
	newSlice.length = newLength;
	newSlice.capacity = slice.capacity;
	return newSlice;
};

var go$panic = function(value) {
	var message;
	if (value.constructor === Go$String) {
		message = value.go$val;
	} else if (value.Error !== undefined) {
		message = value.Error();
	} else if (value.String !== undefined) {
		message = value.String();
	} else {
		message = value;
	}
	var err = new Error(message);
	err.go$panicValue = value;
	return err;
};
var go$notSupported = function(feature) {
	var err = new Error("not supported by GopherJS: " + feature + " (hint: the file optional.go.patch contains patches for core packages)");
	err.go$notSupported = feature;
	throw err;
};
var go$throwRuntimeError; // set by package "runtime"

var go$errorStack = [], go$jsErr = null;

var go$pushErr = function(err) {
	if (err.go$panicValue === undefined) {
		var jsPkg = go$packages["github.com/neelance/gopherjs/js"];
		if (err.go$notSupported !== undefined || jsPkg === undefined) {
			go$jsErr = err;
			return;
		}
		err.go$panicValue = new jsPkg.Error.Ptr(err);
	}
	go$errorStack.push({ frame: go$getStackDepth() - 1, error: err });
};

var go$callDeferred = function(deferred) {
	if (go$jsErr !== null) {
		throw go$jsErr;
	}
	var i;
	for (i = deferred.length - 1; i >= 0; i--) {
		var call = deferred[i];
		try {
			if (call.recv !== undefined) {
				call.recv[call.method].apply(call.recv, call.args);
				continue;
			}
			call.fun.apply(undefined, call.args);
		} catch (err) {
			go$errorStack.push({ frame: go$getStackDepth(), error: err });
		}
	}
	var err = go$errorStack[go$errorStack.length - 1];
	if (err !== undefined && err.frame === go$getStackDepth()) {
		go$errorStack.pop();
		throw err.error;
	}
};

var go$recover = function() {
	var err = go$errorStack[go$errorStack.length - 1];
	if (err === undefined || err.frame !== go$getStackDepth() - 2) {
		return null;
	}
	go$errorStack.pop();
	return err.error.go$panicValue;
};

var go$getStack = function() {
	return (new Error()).stack.split("\n");
};

var go$getStackDepth = function() {
	var s = go$getStack(), d = 0, i;
	for (i = 0; i < s.length; i++) {
		if (s[i].indexOf("go$callDeferred") == -1) {
			d++;
		}
	}
	return d;
};

var go$interfaceIsEqual = function(a, b) {
	if (a === null || b === null) {
		return a === null && b === null;
	}
	if (a.constructor !== b.constructor) {
		return false;
	}
	switch (a.constructor.kind) {
	case "Float32":
		return go$float32bits(a.go$val) === go$float32bits(b.go$val);
	case "Complex64":
		return go$float32bits(a.go$val.real) === go$float32bits(b.go$val.real) && go$float32bits(a.go$val.imag) === go$float32bits(b.go$val.imag);
	case "Complex128":
		return a.go$val.real === b.go$val.real && a.go$val.imag === b.go$val.imag;
	case "Int64":
	case "Uint64":
		return a.go$val.high === b.go$val.high && a.go$val.low === b.go$val.low;
	case "Array":
		return go$arrayIsEqual(a.go$val, b.go$val);
	case "Ptr":
		if (a.constructor.Struct) {
			return a === b;
		}
		return go$pointerIsEqual(a, b);
	case "Func":
	case "Map":
	case "Slice":
	case "Struct":
		go$throwRuntimeError("comparing uncomparable type " + a.constructor);
	case undefined: // js.Object
		return a === b;
	default:
		return a.go$val === b.go$val;
	}
};
var go$arrayIsEqual = function(a, b) {
	if (a.length != b.length) {
		return false;
	}
	var i;
	for (i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}
	return true;
};
var go$sliceIsEqual = function(a, ai, b, bi) {
	return a.array === b.array && a.offset + ai === b.offset + bi;
};
var go$pointerIsEqual = function(a, b) {
	if (a === b) {
		return true;
	}
	if (a.go$get === go$throwNilPointerError || b.go$get === go$throwNilPointerError) {
		return a.go$get === go$throwNilPointerError && b.go$get === go$throwNilPointerError;
	}
	var old = a.go$get();
	var dummy = new Object();
	a.go$set(dummy);
	var equal = b.go$get() === dummy;
	a.go$set(old);
	return equal;
};

var go$typeAssertionFailed = function(obj, expected) {
	var got = "nil";
	if (obj !== null) {
		got = obj.constructor.string;
	}
	throw go$panic("interface conversion: interface is " + got + ", not " + expected.string);
};

var go$now = function() { var msec = (new Date()).getTime(); return [new Go$Int64(0, Math.floor(msec / 1000)), (msec % 1000) * 1000000]; };

var go$packages = {};
go$packages["runtime"] = (function() {
	var go$pkg = {};
	var MemProfileRecord;
	MemProfileRecord = go$newType(0, "Struct", "runtime.MemProfileRecord", "MemProfileRecord", "runtime", function(AllocBytes_, FreeBytes_, AllocObjects_, FreeObjects_, Stack0_) {
		this.go$val = this;
		this.AllocBytes = AllocBytes_ !== undefined ? AllocBytes_ : new Go$Int64(0, 0);
		this.FreeBytes = FreeBytes_ !== undefined ? FreeBytes_ : new Go$Int64(0, 0);
		this.AllocObjects = AllocObjects_ !== undefined ? AllocObjects_ : new Go$Int64(0, 0);
		this.FreeObjects = FreeObjects_ !== undefined ? FreeObjects_ : new Go$Int64(0, 0);
		this.Stack0 = Stack0_ !== undefined ? Stack0_ : go$makeNativeArray("Uintptr", 32, function() { return 0; });
	});
	go$pkg.MemProfileRecord = MemProfileRecord;
	var StackRecord;
	StackRecord = go$newType(0, "Struct", "runtime.StackRecord", "StackRecord", "runtime", function(Stack0_) {
		this.go$val = this;
		this.Stack0 = Stack0_ !== undefined ? Stack0_ : go$makeNativeArray("Uintptr", 32, function() { return 0; });
	});
	go$pkg.StackRecord = StackRecord;
	var BlockProfileRecord;
	BlockProfileRecord = go$newType(0, "Struct", "runtime.BlockProfileRecord", "BlockProfileRecord", "runtime", function(Count_, Cycles_, StackRecord_) {
		this.go$val = this;
		this.Count = Count_ !== undefined ? Count_ : new Go$Int64(0, 0);
		this.Cycles = Cycles_ !== undefined ? Cycles_ : new Go$Int64(0, 0);
		this.StackRecord = StackRecord_ !== undefined ? StackRecord_ : new StackRecord.Ptr();
	});
	BlockProfileRecord.prototype.Stack = function() { return this.go$val.Stack(); };
	BlockProfileRecord.Ptr.prototype.Stack = function() { return this.StackRecord.Stack(); };
	go$pkg.BlockProfileRecord = BlockProfileRecord;
	var Error;
	Error = go$newType(0, "Interface", "runtime.Error", "Error", "runtime", null);
	go$pkg.Error = Error;
	var TypeAssertionError;
	TypeAssertionError = go$newType(0, "Struct", "runtime.TypeAssertionError", "TypeAssertionError", "runtime", function(interfaceString_, concreteString_, assertedString_, missingMethod_) {
		this.go$val = this;
		this.interfaceString = interfaceString_ !== undefined ? interfaceString_ : "";
		this.concreteString = concreteString_ !== undefined ? concreteString_ : "";
		this.assertedString = assertedString_ !== undefined ? assertedString_ : "";
		this.missingMethod = missingMethod_ !== undefined ? missingMethod_ : "";
	});
	go$pkg.TypeAssertionError = TypeAssertionError;
	var errorString;
	errorString = go$newType(0, "String", "runtime.errorString", "errorString", "runtime", null);
	go$pkg.errorString = errorString;
	var errorCString;
	errorCString = go$newType(4, "Uintptr", "runtime.errorCString", "errorCString", "runtime", null);
	go$pkg.errorCString = errorCString;
	var stringer;
	stringer = go$newType(0, "Interface", "runtime.stringer", "stringer", "runtime", null);
	go$pkg.stringer = stringer;
	var Func;
	Func = go$newType(0, "Struct", "runtime.Func", "Func", "runtime", function(opaque_) {
		this.go$val = this;
		this.opaque = opaque_ !== undefined ? opaque_ : new (go$structType([])).Ptr();
	});
	go$pkg.Func = Func;
	var MemStats;
	MemStats = go$newType(0, "Struct", "runtime.MemStats", "MemStats", "runtime", function(Alloc_, TotalAlloc_, Sys_, Lookups_, Mallocs_, Frees_, HeapAlloc_, HeapSys_, HeapIdle_, HeapInuse_, HeapReleased_, HeapObjects_, StackInuse_, StackSys_, MSpanInuse_, MSpanSys_, MCacheInuse_, MCacheSys_, BuckHashSys_, GCSys_, OtherSys_, NextGC_, LastGC_, PauseTotalNs_, PauseNs_, NumGC_, EnableGC_, DebugGC_, BySize_) {
		this.go$val = this;
		this.Alloc = Alloc_ !== undefined ? Alloc_ : new Go$Uint64(0, 0);
		this.TotalAlloc = TotalAlloc_ !== undefined ? TotalAlloc_ : new Go$Uint64(0, 0);
		this.Sys = Sys_ !== undefined ? Sys_ : new Go$Uint64(0, 0);
		this.Lookups = Lookups_ !== undefined ? Lookups_ : new Go$Uint64(0, 0);
		this.Mallocs = Mallocs_ !== undefined ? Mallocs_ : new Go$Uint64(0, 0);
		this.Frees = Frees_ !== undefined ? Frees_ : new Go$Uint64(0, 0);
		this.HeapAlloc = HeapAlloc_ !== undefined ? HeapAlloc_ : new Go$Uint64(0, 0);
		this.HeapSys = HeapSys_ !== undefined ? HeapSys_ : new Go$Uint64(0, 0);
		this.HeapIdle = HeapIdle_ !== undefined ? HeapIdle_ : new Go$Uint64(0, 0);
		this.HeapInuse = HeapInuse_ !== undefined ? HeapInuse_ : new Go$Uint64(0, 0);
		this.HeapReleased = HeapReleased_ !== undefined ? HeapReleased_ : new Go$Uint64(0, 0);
		this.HeapObjects = HeapObjects_ !== undefined ? HeapObjects_ : new Go$Uint64(0, 0);
		this.StackInuse = StackInuse_ !== undefined ? StackInuse_ : new Go$Uint64(0, 0);
		this.StackSys = StackSys_ !== undefined ? StackSys_ : new Go$Uint64(0, 0);
		this.MSpanInuse = MSpanInuse_ !== undefined ? MSpanInuse_ : new Go$Uint64(0, 0);
		this.MSpanSys = MSpanSys_ !== undefined ? MSpanSys_ : new Go$Uint64(0, 0);
		this.MCacheInuse = MCacheInuse_ !== undefined ? MCacheInuse_ : new Go$Uint64(0, 0);
		this.MCacheSys = MCacheSys_ !== undefined ? MCacheSys_ : new Go$Uint64(0, 0);
		this.BuckHashSys = BuckHashSys_ !== undefined ? BuckHashSys_ : new Go$Uint64(0, 0);
		this.GCSys = GCSys_ !== undefined ? GCSys_ : new Go$Uint64(0, 0);
		this.OtherSys = OtherSys_ !== undefined ? OtherSys_ : new Go$Uint64(0, 0);
		this.NextGC = NextGC_ !== undefined ? NextGC_ : new Go$Uint64(0, 0);
		this.LastGC = LastGC_ !== undefined ? LastGC_ : new Go$Uint64(0, 0);
		this.PauseTotalNs = PauseTotalNs_ !== undefined ? PauseTotalNs_ : new Go$Uint64(0, 0);
		this.PauseNs = PauseNs_ !== undefined ? PauseNs_ : go$makeNativeArray("Uint64", 256, function() { return new Go$Uint64(0, 0); });
		this.NumGC = NumGC_ !== undefined ? NumGC_ : 0;
		this.EnableGC = EnableGC_ !== undefined ? EnableGC_ : false;
		this.DebugGC = DebugGC_ !== undefined ? DebugGC_ : false;
		this.BySize = BySize_ !== undefined ? BySize_ : go$makeNativeArray("Struct", 61, function() { return new (go$structType([["Size", "", Go$Uint32, ""], ["Mallocs", "", Go$Uint64, ""], ["Frees", "", Go$Uint64, ""]])).Ptr(0, new Go$Uint64(0, 0), new Go$Uint64(0, 0)); });
	});
	go$pkg.MemStats = MemStats;
	var rtype;
	rtype = go$newType(0, "Struct", "runtime.rtype", "rtype", "runtime", function(size_, hash_, _$2_, align_, fieldAlign_, kind_, alg_, gc_, string_, uncommonType_, ptrToThis_) {
		this.go$val = this;
		this.size = size_ !== undefined ? size_ : 0;
		this.hash = hash_ !== undefined ? hash_ : 0;
		this._$2 = _$2_ !== undefined ? _$2_ : 0;
		this.align = align_ !== undefined ? align_ : 0;
		this.fieldAlign = fieldAlign_ !== undefined ? fieldAlign_ : 0;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.alg = alg_ !== undefined ? alg_ : 0;
		this.gc = gc_ !== undefined ? gc_ : 0;
		this.string = string_ !== undefined ? string_ : (go$ptrType(Go$String)).nil;
		this.uncommonType = uncommonType_ !== undefined ? uncommonType_ : (go$ptrType(uncommonType)).nil;
		this.ptrToThis = ptrToThis_ !== undefined ? ptrToThis_ : (go$ptrType(rtype)).nil;
	});
	go$pkg.rtype = rtype;
	var _method;
	_method = go$newType(0, "Struct", "runtime._method", "_method", "runtime", function(name_, pkgPath_, mtyp_, typ_, ifn_, tfn_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.mtyp = mtyp_ !== undefined ? mtyp_ : (go$ptrType(rtype)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.ifn = ifn_ !== undefined ? ifn_ : 0;
		this.tfn = tfn_ !== undefined ? tfn_ : 0;
	});
	go$pkg._method = _method;
	var uncommonType;
	uncommonType = go$newType(0, "Struct", "runtime.uncommonType", "uncommonType", "runtime", function(name_, pkgPath_, methods_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.methods = methods_ !== undefined ? methods_ : (go$sliceType(_method)).nil;
	});
	go$pkg.uncommonType = uncommonType;
	var _imethod;
	_imethod = go$newType(0, "Struct", "runtime._imethod", "_imethod", "runtime", function(name_, pkgPath_, typ_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
	});
	go$pkg._imethod = _imethod;
	var interfaceType;
	interfaceType = go$newType(0, "Struct", "runtime.interfaceType", "interfaceType", "runtime", function(rtype_, methods_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.methods = methods_ !== undefined ? methods_ : (go$sliceType(_imethod)).nil;
	});
	go$pkg.interfaceType = interfaceType;
	var lock;
	lock = go$newType(0, "Struct", "runtime.lock", "lock", "runtime", function(key_) {
		this.go$val = this;
		this.key = key_ !== undefined ? key_ : new Go$Uint64(0, 0);
	});
	go$pkg.lock = lock;
	var note;
	note = go$newType(0, "Struct", "runtime.note", "note", "runtime", function(key_) {
		this.go$val = this;
		this.key = key_ !== undefined ? key_ : new Go$Uint64(0, 0);
	});
	go$pkg.note = note;
	var _string;
	_string = go$newType(0, "Struct", "runtime._string", "_string", "runtime", function(str_, len_) {
		this.go$val = this;
		this.str = str_ !== undefined ? str_ : (go$ptrType(Go$Uint8)).nil;
		this.len = len_ !== undefined ? len_ : new Go$Int64(0, 0);
	});
	go$pkg._string = _string;
	var funcval;
	funcval = go$newType(0, "Struct", "runtime.funcval", "funcval", "runtime", function(fn_) {
		this.go$val = this;
		this.fn = fn_ !== undefined ? fn_ : go$throwNilPointerError;
	});
	go$pkg.funcval = funcval;
	var iface;
	iface = go$newType(0, "Struct", "runtime.iface", "iface", "runtime", function(tab_, data_) {
		this.go$val = this;
		this.tab = tab_ !== undefined ? tab_ : (go$ptrType(itab)).nil;
		this.data = data_ !== undefined ? data_ : 0;
	});
	go$pkg.iface = iface;
	var eface;
	eface = go$newType(0, "Struct", "runtime.eface", "eface", "runtime", function(_type_, data_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : (go$ptrType(_type)).nil;
		this.data = data_ !== undefined ? data_ : 0;
	});
	go$pkg.eface = eface;
	var _complex64;
	_complex64 = go$newType(0, "Struct", "runtime._complex64", "_complex64", "runtime", function(real_, imag_) {
		this.go$val = this;
		this.real = real_ !== undefined ? real_ : 0;
		this.imag = imag_ !== undefined ? imag_ : 0;
	});
	go$pkg._complex64 = _complex64;
	var _complex128;
	_complex128 = go$newType(0, "Struct", "runtime._complex128", "_complex128", "runtime", function(real_, imag_) {
		this.go$val = this;
		this.real = real_ !== undefined ? real_ : 0;
		this.imag = imag_ !== undefined ? imag_ : 0;
	});
	go$pkg._complex128 = _complex128;
	var slice;
	slice = go$newType(0, "Struct", "runtime.slice", "slice", "runtime", function(array_, len_, cap_) {
		this.go$val = this;
		this.array = array_ !== undefined ? array_ : (go$ptrType(Go$Uint8)).nil;
		this.len = len_ !== undefined ? len_ : new Go$Uint64(0, 0);
		this.cap = cap_ !== undefined ? cap_ : new Go$Uint64(0, 0);
	});
	go$pkg.slice = slice;
	var gobuf;
	gobuf = go$newType(0, "Struct", "runtime.gobuf", "gobuf", "runtime", function(sp_, pc_, g_, ret_, ctxt_, lr_) {
		this.go$val = this;
		this.sp = sp_ !== undefined ? sp_ : new Go$Uint64(0, 0);
		this.pc = pc_ !== undefined ? pc_ : new Go$Uint64(0, 0);
		this.g = g_ !== undefined ? g_ : (go$ptrType(g)).nil;
		this.ret = ret_ !== undefined ? ret_ : new Go$Uint64(0, 0);
		this.ctxt = ctxt_ !== undefined ? ctxt_ : 0;
		this.lr = lr_ !== undefined ? lr_ : new Go$Uint64(0, 0);
	});
	go$pkg.gobuf = gobuf;
	var gcstats;
	gcstats = go$newType(0, "Struct", "runtime.gcstats", "gcstats", "runtime", function(nhandoff_, nhandoffcnt_, nprocyield_, nosyield_, nsleep_) {
		this.go$val = this;
		this.nhandoff = nhandoff_ !== undefined ? nhandoff_ : new Go$Uint64(0, 0);
		this.nhandoffcnt = nhandoffcnt_ !== undefined ? nhandoffcnt_ : new Go$Uint64(0, 0);
		this.nprocyield = nprocyield_ !== undefined ? nprocyield_ : new Go$Uint64(0, 0);
		this.nosyield = nosyield_ !== undefined ? nosyield_ : new Go$Uint64(0, 0);
		this.nsleep = nsleep_ !== undefined ? nsleep_ : new Go$Uint64(0, 0);
	});
	go$pkg.gcstats = gcstats;
	var wincall;
	wincall = go$newType(0, "Struct", "runtime.wincall", "wincall", "runtime", function(fn_, n_, args_, r1_, r2_, err_) {
		this.go$val = this;
		this.fn = fn_ !== undefined ? fn_ : go$throwNilPointerError;
		this.n = n_ !== undefined ? n_ : new Go$Uint64(0, 0);
		this.args = args_ !== undefined ? args_ : 0;
		this.r1 = r1_ !== undefined ? r1_ : new Go$Uint64(0, 0);
		this.r2 = r2_ !== undefined ? r2_ : new Go$Uint64(0, 0);
		this.err = err_ !== undefined ? err_ : new Go$Uint64(0, 0);
	});
	go$pkg.wincall = wincall;
	var seh;
	seh = go$newType(0, "Struct", "runtime.seh", "seh", "runtime", function(prev_, handler_) {
		this.go$val = this;
		this.prev = prev_ !== undefined ? prev_ : 0;
		this.handler = handler_ !== undefined ? handler_ : 0;
	});
	go$pkg.seh = seh;
	var wincallbackcontext;
	wincallbackcontext = go$newType(0, "Struct", "runtime.wincallbackcontext", "wincallbackcontext", "runtime", function(gobody_, argsize_, restorestack_) {
		this.go$val = this;
		this.gobody = gobody_ !== undefined ? gobody_ : 0;
		this.argsize = argsize_ !== undefined ? argsize_ : new Go$Uint64(0, 0);
		this.restorestack = restorestack_ !== undefined ? restorestack_ : new Go$Uint64(0, 0);
	});
	go$pkg.wincallbackcontext = wincallbackcontext;
	var g;
	g = go$newType(0, "Struct", "runtime.g", "g", "runtime", function(stackguard0_, stackbase_, panicwrap_, selgen_, _defer_, _panic_, sched_, syscallstack_, syscallsp_, syscallpc_, syscallguard_, stackguard_, stack0_, stacksize_, alllink_, param_, status_, goid_, waitreason_, schedlink_, ispanic_, issystem_, isbackground_, preempt_, raceignore_, m_, lockedm_, sig_, writenbuf_, writebuf_, dchunk_, dchunknext_, sigcode0_, sigcode1_, sigpc_, gopc_, racectx_, end_) {
		this.go$val = this;
		this.stackguard0 = stackguard0_ !== undefined ? stackguard0_ : new Go$Uint64(0, 0);
		this.stackbase = stackbase_ !== undefined ? stackbase_ : new Go$Uint64(0, 0);
		this.panicwrap = panicwrap_ !== undefined ? panicwrap_ : 0;
		this.selgen = selgen_ !== undefined ? selgen_ : 0;
		this._defer = _defer_ !== undefined ? _defer_ : (go$ptrType(_defer)).nil;
		this._panic = _panic_ !== undefined ? _panic_ : (go$ptrType(_panic)).nil;
		this.sched = sched_ !== undefined ? sched_ : new gobuf.Ptr();
		this.syscallstack = syscallstack_ !== undefined ? syscallstack_ : new Go$Uint64(0, 0);
		this.syscallsp = syscallsp_ !== undefined ? syscallsp_ : new Go$Uint64(0, 0);
		this.syscallpc = syscallpc_ !== undefined ? syscallpc_ : new Go$Uint64(0, 0);
		this.syscallguard = syscallguard_ !== undefined ? syscallguard_ : new Go$Uint64(0, 0);
		this.stackguard = stackguard_ !== undefined ? stackguard_ : new Go$Uint64(0, 0);
		this.stack0 = stack0_ !== undefined ? stack0_ : new Go$Uint64(0, 0);
		this.stacksize = stacksize_ !== undefined ? stacksize_ : new Go$Uint64(0, 0);
		this.alllink = alllink_ !== undefined ? alllink_ : (go$ptrType(g)).nil;
		this.param = param_ !== undefined ? param_ : 0;
		this.status = status_ !== undefined ? status_ : 0;
		this.goid = goid_ !== undefined ? goid_ : new Go$Int64(0, 0);
		this.waitreason = waitreason_ !== undefined ? waitreason_ : (go$ptrType(Go$Int8)).nil;
		this.schedlink = schedlink_ !== undefined ? schedlink_ : (go$ptrType(g)).nil;
		this.ispanic = ispanic_ !== undefined ? ispanic_ : 0;
		this.issystem = issystem_ !== undefined ? issystem_ : 0;
		this.isbackground = isbackground_ !== undefined ? isbackground_ : 0;
		this.preempt = preempt_ !== undefined ? preempt_ : 0;
		this.raceignore = raceignore_ !== undefined ? raceignore_ : 0;
		this.m = m_ !== undefined ? m_ : (go$ptrType(m)).nil;
		this.lockedm = lockedm_ !== undefined ? lockedm_ : (go$ptrType(m)).nil;
		this.sig = sig_ !== undefined ? sig_ : 0;
		this.writenbuf = writenbuf_ !== undefined ? writenbuf_ : 0;
		this.writebuf = writebuf_ !== undefined ? writebuf_ : (go$ptrType(Go$Uint8)).nil;
		this.dchunk = dchunk_ !== undefined ? dchunk_ : (go$ptrType(deferchunk)).nil;
		this.dchunknext = dchunknext_ !== undefined ? dchunknext_ : (go$ptrType(deferchunk)).nil;
		this.sigcode0 = sigcode0_ !== undefined ? sigcode0_ : new Go$Uint64(0, 0);
		this.sigcode1 = sigcode1_ !== undefined ? sigcode1_ : new Go$Uint64(0, 0);
		this.sigpc = sigpc_ !== undefined ? sigpc_ : new Go$Uint64(0, 0);
		this.gopc = gopc_ !== undefined ? gopc_ : new Go$Uint64(0, 0);
		this.racectx = racectx_ !== undefined ? racectx_ : new Go$Uint64(0, 0);
		this.end = end_ !== undefined ? end_ : go$makeNativeArray("Uint64", 0, function() { return new Go$Uint64(0, 0); });
	});
	go$pkg.g = g;
	var m;
	m = go$newType(0, "Struct", "runtime.m", "m", "runtime", function(g0_, moreargp_, morebuf_, moreframesize_, moreargsize_, cret_, procid_, gsignal_, tls_, mstartfn_, curg_, caughtsig_, p_, nextp_, id_, mallocing_, throwing_, gcing_, locks_, dying_, profilehz_, helpgc_, spinning_, fastrand_, ncgocall_, ncgo_, cgomal_, park_, alllink_, schedlink_, machport_, mcache_, stackinuse_, stackcachepos_, stackcachecnt_, stackcache_, lockedg_, createstack_, freglo_, freghi_, fflag_, locked_, nextwaitm_, waitsema_, waitsemacount_, waitsemalock_, gcstats_, racecall_, needextram_, waitunlockf_, waitlock_, settype_buf_, settype_bufsize_, thread_, wincall_, seh_, end_) {
		this.go$val = this;
		this.g0 = g0_ !== undefined ? g0_ : (go$ptrType(g)).nil;
		this.moreargp = moreargp_ !== undefined ? moreargp_ : 0;
		this.morebuf = morebuf_ !== undefined ? morebuf_ : new gobuf.Ptr();
		this.moreframesize = moreframesize_ !== undefined ? moreframesize_ : 0;
		this.moreargsize = moreargsize_ !== undefined ? moreargsize_ : 0;
		this.cret = cret_ !== undefined ? cret_ : new Go$Uint64(0, 0);
		this.procid = procid_ !== undefined ? procid_ : new Go$Uint64(0, 0);
		this.gsignal = gsignal_ !== undefined ? gsignal_ : (go$ptrType(g)).nil;
		this.tls = tls_ !== undefined ? tls_ : go$makeNativeArray("Uint64", 4, function() { return new Go$Uint64(0, 0); });
		this.mstartfn = mstartfn_ !== undefined ? mstartfn_ : go$throwNilPointerError;
		this.curg = curg_ !== undefined ? curg_ : (go$ptrType(g)).nil;
		this.caughtsig = caughtsig_ !== undefined ? caughtsig_ : (go$ptrType(g)).nil;
		this.p = p_ !== undefined ? p_ : (go$ptrType(p)).nil;
		this.nextp = nextp_ !== undefined ? nextp_ : (go$ptrType(p)).nil;
		this.id = id_ !== undefined ? id_ : 0;
		this.mallocing = mallocing_ !== undefined ? mallocing_ : 0;
		this.throwing = throwing_ !== undefined ? throwing_ : 0;
		this.gcing = gcing_ !== undefined ? gcing_ : 0;
		this.locks = locks_ !== undefined ? locks_ : 0;
		this.dying = dying_ !== undefined ? dying_ : 0;
		this.profilehz = profilehz_ !== undefined ? profilehz_ : 0;
		this.helpgc = helpgc_ !== undefined ? helpgc_ : 0;
		this.spinning = spinning_ !== undefined ? spinning_ : 0;
		this.fastrand = fastrand_ !== undefined ? fastrand_ : 0;
		this.ncgocall = ncgocall_ !== undefined ? ncgocall_ : new Go$Uint64(0, 0);
		this.ncgo = ncgo_ !== undefined ? ncgo_ : 0;
		this.cgomal = cgomal_ !== undefined ? cgomal_ : (go$ptrType(cgomal)).nil;
		this.park = park_ !== undefined ? park_ : new note.Ptr();
		this.alllink = alllink_ !== undefined ? alllink_ : (go$ptrType(m)).nil;
		this.schedlink = schedlink_ !== undefined ? schedlink_ : (go$ptrType(m)).nil;
		this.machport = machport_ !== undefined ? machport_ : 0;
		this.mcache = mcache_ !== undefined ? mcache_ : (go$ptrType(mcache)).nil;
		this.stackinuse = stackinuse_ !== undefined ? stackinuse_ : 0;
		this.stackcachepos = stackcachepos_ !== undefined ? stackcachepos_ : 0;
		this.stackcachecnt = stackcachecnt_ !== undefined ? stackcachecnt_ : 0;
		this.stackcache = stackcache_ !== undefined ? stackcache_ : go$makeNativeArray("UnsafePointer", 32, function() { return 0; });
		this.lockedg = lockedg_ !== undefined ? lockedg_ : (go$ptrType(g)).nil;
		this.createstack = createstack_ !== undefined ? createstack_ : go$makeNativeArray("Uint64", 32, function() { return new Go$Uint64(0, 0); });
		this.freglo = freglo_ !== undefined ? freglo_ : go$makeNativeArray("Uint32", 16, function() { return 0; });
		this.freghi = freghi_ !== undefined ? freghi_ : go$makeNativeArray("Uint32", 16, function() { return 0; });
		this.fflag = fflag_ !== undefined ? fflag_ : 0;
		this.locked = locked_ !== undefined ? locked_ : 0;
		this.nextwaitm = nextwaitm_ !== undefined ? nextwaitm_ : (go$ptrType(m)).nil;
		this.waitsema = waitsema_ !== undefined ? waitsema_ : new Go$Uint64(0, 0);
		this.waitsemacount = waitsemacount_ !== undefined ? waitsemacount_ : 0;
		this.waitsemalock = waitsemalock_ !== undefined ? waitsemalock_ : 0;
		this.gcstats = gcstats_ !== undefined ? gcstats_ : new gcstats.Ptr();
		this.racecall = racecall_ !== undefined ? racecall_ : 0;
		this.needextram = needextram_ !== undefined ? needextram_ : 0;
		this.waitunlockf = waitunlockf_ !== undefined ? waitunlockf_ : go$throwNilPointerError;
		this.waitlock = waitlock_ !== undefined ? waitlock_ : 0;
		this.settype_buf = settype_buf_ !== undefined ? settype_buf_ : go$makeNativeArray("Uint64", 1024, function() { return new Go$Uint64(0, 0); });
		this.settype_bufsize = settype_bufsize_ !== undefined ? settype_bufsize_ : new Go$Uint64(0, 0);
		this.thread = thread_ !== undefined ? thread_ : 0;
		this.wincall = wincall_ !== undefined ? wincall_ : new wincall.Ptr();
		this.seh = seh_ !== undefined ? seh_ : (go$ptrType(seh)).nil;
		this.end = end_ !== undefined ? end_ : go$makeNativeArray("Uint64", 0, function() { return new Go$Uint64(0, 0); });
	});
	go$pkg.m = m;
	var p;
	p = go$newType(0, "Struct", "runtime.p", "p", "runtime", function(lock_, id_, status_, link_, schedtick_, syscalltick_, m_, mcache_, runq_, runqhead_, runqtail_, runqsize_, gfree_, gfreecnt_, pad_) {
		this.go$val = this;
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
		this.id = id_ !== undefined ? id_ : 0;
		this.status = status_ !== undefined ? status_ : 0;
		this.link = link_ !== undefined ? link_ : (go$ptrType(p)).nil;
		this.schedtick = schedtick_ !== undefined ? schedtick_ : 0;
		this.syscalltick = syscalltick_ !== undefined ? syscalltick_ : 0;
		this.m = m_ !== undefined ? m_ : (go$ptrType(m)).nil;
		this.mcache = mcache_ !== undefined ? mcache_ : (go$ptrType(mcache)).nil;
		this.runq = runq_ !== undefined ? runq_ : (go$ptrType((go$ptrType(g)))).nil;
		this.runqhead = runqhead_ !== undefined ? runqhead_ : 0;
		this.runqtail = runqtail_ !== undefined ? runqtail_ : 0;
		this.runqsize = runqsize_ !== undefined ? runqsize_ : 0;
		this.gfree = gfree_ !== undefined ? gfree_ : (go$ptrType(g)).nil;
		this.gfreecnt = gfreecnt_ !== undefined ? gfreecnt_ : 0;
		this.pad = pad_ !== undefined ? pad_ : go$makeNativeArray("Uint8", 64, function() { return 0; });
	});
	go$pkg.p = p;
	var stktop;
	stktop = go$newType(0, "Struct", "runtime.stktop", "stktop", "runtime", function(stackguard_, stackbase_, gobuf_, argsize_, panicwrap_, argp_, free_, _panic_) {
		this.go$val = this;
		this.stackguard = stackguard_ !== undefined ? stackguard_ : new Go$Uint64(0, 0);
		this.stackbase = stackbase_ !== undefined ? stackbase_ : new Go$Uint64(0, 0);
		this.gobuf = gobuf_ !== undefined ? gobuf_ : new gobuf.Ptr();
		this.argsize = argsize_ !== undefined ? argsize_ : 0;
		this.panicwrap = panicwrap_ !== undefined ? panicwrap_ : 0;
		this.argp = argp_ !== undefined ? argp_ : (go$ptrType(Go$Uint8)).nil;
		this.free = free_ !== undefined ? free_ : new Go$Uint64(0, 0);
		this._panic = _panic_ !== undefined ? _panic_ : 0;
	});
	go$pkg.stktop = stktop;
	var sigtab;
	sigtab = go$newType(0, "Struct", "runtime.sigtab", "sigtab", "runtime", function(flags_, name_) {
		this.go$val = this;
		this.flags = flags_ !== undefined ? flags_ : 0;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$Int8)).nil;
	});
	go$pkg.sigtab = sigtab;
	var _func;
	_func = go$newType(0, "Struct", "runtime._func", "_func", "runtime", function(entry_, nameoff_, args_, frame_, pcsp_, pcfile_, pcln_, npcdata_, nfuncdata_) {
		this.go$val = this;
		this.entry = entry_ !== undefined ? entry_ : new Go$Uint64(0, 0);
		this.nameoff = nameoff_ !== undefined ? nameoff_ : 0;
		this.args = args_ !== undefined ? args_ : 0;
		this.frame = frame_ !== undefined ? frame_ : 0;
		this.pcsp = pcsp_ !== undefined ? pcsp_ : 0;
		this.pcfile = pcfile_ !== undefined ? pcfile_ : 0;
		this.pcln = pcln_ !== undefined ? pcln_ : 0;
		this.npcdata = npcdata_ !== undefined ? npcdata_ : 0;
		this.nfuncdata = nfuncdata_ !== undefined ? nfuncdata_ : 0;
	});
	go$pkg._func = _func;
	var itab;
	itab = go$newType(0, "Struct", "runtime.itab", "itab", "runtime", function(inter_, _type_, link_, bad_, unused_, fun_) {
		this.go$val = this;
		this.inter = inter_ !== undefined ? inter_ : (go$ptrType(interfacetype)).nil;
		this._type = _type_ !== undefined ? _type_ : (go$ptrType(_type)).nil;
		this.link = link_ !== undefined ? link_ : (go$ptrType(itab)).nil;
		this.bad = bad_ !== undefined ? bad_ : 0;
		this.unused = unused_ !== undefined ? unused_ : 0;
		this.fun = fun_ !== undefined ? fun_ : go$makeNativeArray("Func", 0, function() { return go$throwNilPointerError; });
	});
	go$pkg.itab = itab;
	var timers;
	timers = go$newType(0, "Struct", "runtime.timers", "timers", "runtime", function(lock_, timerproc_, sleeping_, rescheduling_, waitnote_, t_, len_, cap_) {
		this.go$val = this;
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
		this.timerproc = timerproc_ !== undefined ? timerproc_ : (go$ptrType(g)).nil;
		this.sleeping = sleeping_ !== undefined ? sleeping_ : 0;
		this.rescheduling = rescheduling_ !== undefined ? rescheduling_ : 0;
		this.waitnote = waitnote_ !== undefined ? waitnote_ : new note.Ptr();
		this.t = t_ !== undefined ? t_ : (go$ptrType((go$ptrType(timer)))).nil;
		this.len = len_ !== undefined ? len_ : 0;
		this.cap = cap_ !== undefined ? cap_ : 0;
	});
	go$pkg.timers = timers;
	var timer;
	timer = go$newType(0, "Struct", "runtime.timer", "timer", "runtime", function(i_, when_, period_, fv_, arg_) {
		this.go$val = this;
		this.i = i_ !== undefined ? i_ : 0;
		this.when = when_ !== undefined ? when_ : new Go$Int64(0, 0);
		this.period = period_ !== undefined ? period_ : new Go$Int64(0, 0);
		this.fv = fv_ !== undefined ? fv_ : (go$ptrType(funcval)).nil;
		this.arg = arg_ !== undefined ? arg_ : new eface.Ptr();
	});
	go$pkg.timer = timer;
	var lfnode;
	lfnode = go$newType(0, "Struct", "runtime.lfnode", "lfnode", "runtime", function(next_, pushcnt_) {
		this.go$val = this;
		this.next = next_ !== undefined ? next_ : (go$ptrType(lfnode)).nil;
		this.pushcnt = pushcnt_ !== undefined ? pushcnt_ : new Go$Uint64(0, 0);
	});
	go$pkg.lfnode = lfnode;
	var parfor;
	parfor = go$newType(0, "Struct", "runtime.parfor", "parfor", "runtime", function(body_, done_, nthr_, nthrmax_, thrseq_, cnt_, ctx_, wait_, thr_, pad_, nsteal_, nstealcnt_, nprocyield_, nosyield_, nsleep_) {
		this.go$val = this;
		this.body = body_ !== undefined ? body_ : go$throwNilPointerError;
		this.done = done_ !== undefined ? done_ : 0;
		this.nthr = nthr_ !== undefined ? nthr_ : 0;
		this.nthrmax = nthrmax_ !== undefined ? nthrmax_ : 0;
		this.thrseq = thrseq_ !== undefined ? thrseq_ : 0;
		this.cnt = cnt_ !== undefined ? cnt_ : 0;
		this.ctx = ctx_ !== undefined ? ctx_ : 0;
		this.wait = wait_ !== undefined ? wait_ : 0;
		this.thr = thr_ !== undefined ? thr_ : (go$ptrType(parforthread)).nil;
		this.pad = pad_ !== undefined ? pad_ : 0;
		this.nsteal = nsteal_ !== undefined ? nsteal_ : new Go$Uint64(0, 0);
		this.nstealcnt = nstealcnt_ !== undefined ? nstealcnt_ : new Go$Uint64(0, 0);
		this.nprocyield = nprocyield_ !== undefined ? nprocyield_ : new Go$Uint64(0, 0);
		this.nosyield = nosyield_ !== undefined ? nosyield_ : new Go$Uint64(0, 0);
		this.nsleep = nsleep_ !== undefined ? nsleep_ : new Go$Uint64(0, 0);
	});
	go$pkg.parfor = parfor;
	var cgomal;
	cgomal = go$newType(0, "Struct", "runtime.cgomal", "cgomal", "runtime", function(next_, alloc_) {
		this.go$val = this;
		this.next = next_ !== undefined ? next_ : (go$ptrType(cgomal)).nil;
		this.alloc = alloc_ !== undefined ? alloc_ : 0;
	});
	go$pkg.cgomal = cgomal;
	var debugvars;
	debugvars = go$newType(0, "Struct", "runtime.debugvars", "debugvars", "runtime", function(gctrace_, schedtrace_, scheddetail_) {
		this.go$val = this;
		this.gctrace = gctrace_ !== undefined ? gctrace_ : 0;
		this.schedtrace = schedtrace_ !== undefined ? schedtrace_ : 0;
		this.scheddetail = scheddetail_ !== undefined ? scheddetail_ : 0;
	});
	go$pkg.debugvars = debugvars;
	var alg;
	alg = go$newType(0, "Struct", "runtime.alg", "alg", "runtime", function(hash_, equal_, print_, copy_) {
		this.go$val = this;
		this.hash = hash_ !== undefined ? hash_ : go$throwNilPointerError;
		this.equal = equal_ !== undefined ? equal_ : go$throwNilPointerError;
		this.print = print_ !== undefined ? print_ : go$throwNilPointerError;
		this.copy = copy_ !== undefined ? copy_ : go$throwNilPointerError;
	});
	go$pkg.alg = alg;
	var _defer;
	_defer = go$newType(0, "Struct", "runtime._defer", "_defer", "runtime", function(siz_, special_, free_, argp_, pc_, fn_, link_, args_) {
		this.go$val = this;
		this.siz = siz_ !== undefined ? siz_ : 0;
		this.special = special_ !== undefined ? special_ : 0;
		this.free = free_ !== undefined ? free_ : 0;
		this.argp = argp_ !== undefined ? argp_ : (go$ptrType(Go$Uint8)).nil;
		this.pc = pc_ !== undefined ? pc_ : (go$ptrType(Go$Uint8)).nil;
		this.fn = fn_ !== undefined ? fn_ : (go$ptrType(funcval)).nil;
		this.link = link_ !== undefined ? link_ : (go$ptrType(_defer)).nil;
		this.args = args_ !== undefined ? args_ : go$makeNativeArray("UnsafePointer", 1, function() { return 0; });
	});
	go$pkg._defer = _defer;
	var deferchunk;
	deferchunk = go$newType(0, "Struct", "runtime.deferchunk", "deferchunk", "runtime", function(prev_, off_) {
		this.go$val = this;
		this.prev = prev_ !== undefined ? prev_ : (go$ptrType(deferchunk)).nil;
		this.off = off_ !== undefined ? off_ : new Go$Uint64(0, 0);
	});
	go$pkg.deferchunk = deferchunk;
	var _panic;
	_panic = go$newType(0, "Struct", "runtime._panic", "_panic", "runtime", function(arg_, stackbase_, link_, recovered_) {
		this.go$val = this;
		this.arg = arg_ !== undefined ? arg_ : new eface.Ptr();
		this.stackbase = stackbase_ !== undefined ? stackbase_ : new Go$Uint64(0, 0);
		this.link = link_ !== undefined ? link_ : (go$ptrType(_panic)).nil;
		this.recovered = recovered_ !== undefined ? recovered_ : 0;
	});
	go$pkg._panic = _panic;
	var stkframe;
	stkframe = go$newType(0, "Struct", "runtime.stkframe", "stkframe", "runtime", function(fn_, pc_, lr_, sp_, fp_, varp_, argp_, arglen_) {
		this.go$val = this;
		this.fn = fn_ !== undefined ? fn_ : (go$ptrType(_func)).nil;
		this.pc = pc_ !== undefined ? pc_ : new Go$Uint64(0, 0);
		this.lr = lr_ !== undefined ? lr_ : new Go$Uint64(0, 0);
		this.sp = sp_ !== undefined ? sp_ : new Go$Uint64(0, 0);
		this.fp = fp_ !== undefined ? fp_ : new Go$Uint64(0, 0);
		this.varp = varp_ !== undefined ? varp_ : (go$ptrType(Go$Uint8)).nil;
		this.argp = argp_ !== undefined ? argp_ : (go$ptrType(Go$Uint8)).nil;
		this.arglen = arglen_ !== undefined ? arglen_ : new Go$Uint64(0, 0);
	});
	go$pkg.stkframe = stkframe;
	var mlink;
	mlink = go$newType(0, "Struct", "runtime.mlink", "mlink", "runtime", function(next_) {
		this.go$val = this;
		this.next = next_ !== undefined ? next_ : (go$ptrType(mlink)).nil;
	});
	go$pkg.mlink = mlink;
	var fixalloc;
	fixalloc = go$newType(0, "Struct", "runtime.fixalloc", "fixalloc", "runtime", function(size_, first_, arg_, list_, chunk_, nchunk_, inuse_, stat_) {
		this.go$val = this;
		this.size = size_ !== undefined ? size_ : new Go$Uint64(0, 0);
		this.first = first_ !== undefined ? first_ : go$throwNilPointerError;
		this.arg = arg_ !== undefined ? arg_ : 0;
		this.list = list_ !== undefined ? list_ : (go$ptrType(mlink)).nil;
		this.chunk = chunk_ !== undefined ? chunk_ : (go$ptrType(Go$Uint8)).nil;
		this.nchunk = nchunk_ !== undefined ? nchunk_ : 0;
		this.inuse = inuse_ !== undefined ? inuse_ : new Go$Uint64(0, 0);
		this.stat = stat_ !== undefined ? stat_ : (go$ptrType(Go$Uint64)).nil;
	});
	go$pkg.fixalloc = fixalloc;
	var _1_;
	_1_ = go$newType(0, "Struct", "runtime._1_", "_1_", "runtime", function(size_, nmalloc_, nfree_) {
		this.go$val = this;
		this.size = size_ !== undefined ? size_ : 0;
		this.nmalloc = nmalloc_ !== undefined ? nmalloc_ : new Go$Uint64(0, 0);
		this.nfree = nfree_ !== undefined ? nfree_ : new Go$Uint64(0, 0);
	});
	go$pkg._1_ = _1_;
	var mstats;
	mstats = go$newType(0, "Struct", "runtime.mstats", "mstats", "runtime", function(alloc_, total_alloc_, sys_, nlookup_, nmalloc_, nfree_, heap_alloc_, heap_sys_, heap_idle_, heap_inuse_, heap_released_, heap_objects_, stacks_inuse_, stacks_sys_, mspan_inuse_, mspan_sys_, mcache_inuse_, mcache_sys_, buckhash_sys_, gc_sys_, other_sys_, next_gc_, last_gc_, pause_total_ns_, pause_ns_, numgc_, enablegc_, debuggc_, by_size_) {
		this.go$val = this;
		this.alloc = alloc_ !== undefined ? alloc_ : new Go$Uint64(0, 0);
		this.total_alloc = total_alloc_ !== undefined ? total_alloc_ : new Go$Uint64(0, 0);
		this.sys = sys_ !== undefined ? sys_ : new Go$Uint64(0, 0);
		this.nlookup = nlookup_ !== undefined ? nlookup_ : new Go$Uint64(0, 0);
		this.nmalloc = nmalloc_ !== undefined ? nmalloc_ : new Go$Uint64(0, 0);
		this.nfree = nfree_ !== undefined ? nfree_ : new Go$Uint64(0, 0);
		this.heap_alloc = heap_alloc_ !== undefined ? heap_alloc_ : new Go$Uint64(0, 0);
		this.heap_sys = heap_sys_ !== undefined ? heap_sys_ : new Go$Uint64(0, 0);
		this.heap_idle = heap_idle_ !== undefined ? heap_idle_ : new Go$Uint64(0, 0);
		this.heap_inuse = heap_inuse_ !== undefined ? heap_inuse_ : new Go$Uint64(0, 0);
		this.heap_released = heap_released_ !== undefined ? heap_released_ : new Go$Uint64(0, 0);
		this.heap_objects = heap_objects_ !== undefined ? heap_objects_ : new Go$Uint64(0, 0);
		this.stacks_inuse = stacks_inuse_ !== undefined ? stacks_inuse_ : new Go$Uint64(0, 0);
		this.stacks_sys = stacks_sys_ !== undefined ? stacks_sys_ : new Go$Uint64(0, 0);
		this.mspan_inuse = mspan_inuse_ !== undefined ? mspan_inuse_ : new Go$Uint64(0, 0);
		this.mspan_sys = mspan_sys_ !== undefined ? mspan_sys_ : new Go$Uint64(0, 0);
		this.mcache_inuse = mcache_inuse_ !== undefined ? mcache_inuse_ : new Go$Uint64(0, 0);
		this.mcache_sys = mcache_sys_ !== undefined ? mcache_sys_ : new Go$Uint64(0, 0);
		this.buckhash_sys = buckhash_sys_ !== undefined ? buckhash_sys_ : new Go$Uint64(0, 0);
		this.gc_sys = gc_sys_ !== undefined ? gc_sys_ : new Go$Uint64(0, 0);
		this.other_sys = other_sys_ !== undefined ? other_sys_ : new Go$Uint64(0, 0);
		this.next_gc = next_gc_ !== undefined ? next_gc_ : new Go$Uint64(0, 0);
		this.last_gc = last_gc_ !== undefined ? last_gc_ : new Go$Uint64(0, 0);
		this.pause_total_ns = pause_total_ns_ !== undefined ? pause_total_ns_ : new Go$Uint64(0, 0);
		this.pause_ns = pause_ns_ !== undefined ? pause_ns_ : go$makeNativeArray("Uint64", 256, function() { return new Go$Uint64(0, 0); });
		this.numgc = numgc_ !== undefined ? numgc_ : 0;
		this.enablegc = enablegc_ !== undefined ? enablegc_ : 0;
		this.debuggc = debuggc_ !== undefined ? debuggc_ : 0;
		this.by_size = by_size_ !== undefined ? by_size_ : go$makeNativeArray("Struct", 61, function() { return new _1_.Ptr(); });
	});
	go$pkg.mstats = mstats;
	var mcachelist;
	mcachelist = go$newType(0, "Struct", "runtime.mcachelist", "mcachelist", "runtime", function(list_, nlist_) {
		this.go$val = this;
		this.list = list_ !== undefined ? list_ : (go$ptrType(mlink)).nil;
		this.nlist = nlist_ !== undefined ? nlist_ : 0;
	});
	go$pkg.mcachelist = mcachelist;
	var mcache;
	mcache = go$newType(0, "Struct", "runtime.mcache", "mcache", "runtime", function(next_sample_, local_cachealloc_, list_, local_nlookup_, local_largefree_, local_nlargefree_, local_nsmallfree_) {
		this.go$val = this;
		this.next_sample = next_sample_ !== undefined ? next_sample_ : 0;
		this.local_cachealloc = local_cachealloc_ !== undefined ? local_cachealloc_ : new Go$Int64(0, 0);
		this.list = list_ !== undefined ? list_ : go$makeNativeArray("Struct", 61, function() { return new mcachelist.Ptr(); });
		this.local_nlookup = local_nlookup_ !== undefined ? local_nlookup_ : new Go$Uint64(0, 0);
		this.local_largefree = local_largefree_ !== undefined ? local_largefree_ : new Go$Uint64(0, 0);
		this.local_nlargefree = local_nlargefree_ !== undefined ? local_nlargefree_ : new Go$Uint64(0, 0);
		this.local_nsmallfree = local_nsmallfree_ !== undefined ? local_nsmallfree_ : go$makeNativeArray("Uint64", 61, function() { return new Go$Uint64(0, 0); });
	});
	go$pkg.mcache = mcache;
	var mtypes;
	mtypes = go$newType(0, "Struct", "runtime.mtypes", "mtypes", "runtime", function(compression_, data_) {
		this.go$val = this;
		this.compression = compression_ !== undefined ? compression_ : 0;
		this.data = data_ !== undefined ? data_ : new Go$Uint64(0, 0);
	});
	go$pkg.mtypes = mtypes;
	var mspan;
	mspan = go$newType(0, "Struct", "runtime.mspan", "mspan", "runtime", function(next_, prev_, start_, npages_, freelist_, ref_, sizeclass_, elemsize_, state_, unusedsince_, npreleased_, limit_, types_) {
		this.go$val = this;
		this.next = next_ !== undefined ? next_ : (go$ptrType(mspan)).nil;
		this.prev = prev_ !== undefined ? prev_ : (go$ptrType(mspan)).nil;
		this.start = start_ !== undefined ? start_ : new Go$Uint64(0, 0);
		this.npages = npages_ !== undefined ? npages_ : new Go$Uint64(0, 0);
		this.freelist = freelist_ !== undefined ? freelist_ : (go$ptrType(mlink)).nil;
		this.ref = ref_ !== undefined ? ref_ : 0;
		this.sizeclass = sizeclass_ !== undefined ? sizeclass_ : 0;
		this.elemsize = elemsize_ !== undefined ? elemsize_ : new Go$Uint64(0, 0);
		this.state = state_ !== undefined ? state_ : 0;
		this.unusedsince = unusedsince_ !== undefined ? unusedsince_ : new Go$Int64(0, 0);
		this.npreleased = npreleased_ !== undefined ? npreleased_ : new Go$Uint64(0, 0);
		this.limit = limit_ !== undefined ? limit_ : (go$ptrType(Go$Uint8)).nil;
		this.types = types_ !== undefined ? types_ : new mtypes.Ptr();
	});
	go$pkg.mspan = mspan;
	var mcentral;
	mcentral = go$newType(0, "Struct", "runtime.mcentral", "mcentral", "runtime", function(lock_, sizeclass_, nonempty_, empty_, nfree_) {
		this.go$val = this;
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
		this.sizeclass = sizeclass_ !== undefined ? sizeclass_ : 0;
		this.nonempty = nonempty_ !== undefined ? nonempty_ : new mspan.Ptr();
		this.empty = empty_ !== undefined ? empty_ : new mspan.Ptr();
		this.nfree = nfree_ !== undefined ? nfree_ : 0;
	});
	go$pkg.mcentral = mcentral;
	var _2_;
	_2_ = go$newType(0, "Struct", "runtime._2_", "_2_", "runtime", function(mcentral_, pad_) {
		this.go$val = this;
		this.mcentral = mcentral_ !== undefined ? mcentral_ : new mcentral.Ptr();
		this.pad = pad_ !== undefined ? pad_ : go$makeNativeArray("Uint8", 64, function() { return 0; });
	});
	go$pkg._2_ = _2_;
	var mheap;
	mheap = go$newType(0, "Struct", "runtime.mheap", "mheap", "runtime", function(lock_, free_, large_, allspans_, nspan_, nspancap_, spans_, spans_mapped_, bitmap_, bitmap_mapped_, arena_start_, arena_used_, arena_end_, central_, spanalloc_, cachealloc_, largefree_, nlargefree_, nsmallfree_) {
		this.go$val = this;
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
		this.free = free_ !== undefined ? free_ : go$makeNativeArray("Struct", 256, function() { return new mspan.Ptr(); });
		this.large = large_ !== undefined ? large_ : new mspan.Ptr();
		this.allspans = allspans_ !== undefined ? allspans_ : (go$ptrType((go$ptrType(mspan)))).nil;
		this.nspan = nspan_ !== undefined ? nspan_ : 0;
		this.nspancap = nspancap_ !== undefined ? nspancap_ : 0;
		this.spans = spans_ !== undefined ? spans_ : (go$ptrType((go$ptrType(mspan)))).nil;
		this.spans_mapped = spans_mapped_ !== undefined ? spans_mapped_ : new Go$Uint64(0, 0);
		this.bitmap = bitmap_ !== undefined ? bitmap_ : (go$ptrType(Go$Uint8)).nil;
		this.bitmap_mapped = bitmap_mapped_ !== undefined ? bitmap_mapped_ : new Go$Uint64(0, 0);
		this.arena_start = arena_start_ !== undefined ? arena_start_ : (go$ptrType(Go$Uint8)).nil;
		this.arena_used = arena_used_ !== undefined ? arena_used_ : (go$ptrType(Go$Uint8)).nil;
		this.arena_end = arena_end_ !== undefined ? arena_end_ : (go$ptrType(Go$Uint8)).nil;
		this.central = central_ !== undefined ? central_ : go$makeNativeArray("Struct", 61, function() { return new _2_.Ptr(); });
		this.spanalloc = spanalloc_ !== undefined ? spanalloc_ : new fixalloc.Ptr();
		this.cachealloc = cachealloc_ !== undefined ? cachealloc_ : new fixalloc.Ptr();
		this.largefree = largefree_ !== undefined ? largefree_ : new Go$Uint64(0, 0);
		this.nlargefree = nlargefree_ !== undefined ? nlargefree_ : new Go$Uint64(0, 0);
		this.nsmallfree = nsmallfree_ !== undefined ? nsmallfree_ : go$makeNativeArray("Uint64", 61, function() { return new Go$Uint64(0, 0); });
	});
	go$pkg.mheap = mheap;
	var _type;
	_type = go$newType(0, "Struct", "runtime._type", "_type", "runtime", function(size_, hash_, _unused_, align_, fieldalign_, kind_, alg_, gc_, _string_, x_, ptrto_) {
		this.go$val = this;
		this.size = size_ !== undefined ? size_ : new Go$Uint64(0, 0);
		this.hash = hash_ !== undefined ? hash_ : 0;
		this._unused = _unused_ !== undefined ? _unused_ : 0;
		this.align = align_ !== undefined ? align_ : 0;
		this.fieldalign = fieldalign_ !== undefined ? fieldalign_ : 0;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.alg = alg_ !== undefined ? alg_ : (go$ptrType(alg)).nil;
		this.gc = gc_ !== undefined ? gc_ : 0;
		this._string = _string_ !== undefined ? _string_ : (go$ptrType(Go$String)).nil;
		this.x = x_ !== undefined ? x_ : (go$ptrType(uncommontype)).nil;
		this.ptrto = ptrto_ !== undefined ? ptrto_ : (go$ptrType(_type)).nil;
	});
	go$pkg._type = _type;
	var method;
	method = go$newType(0, "Struct", "runtime.method", "method", "runtime", function(name_, pkgpath_, mtyp_, typ_, ifn_, tfn_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgpath = pkgpath_ !== undefined ? pkgpath_ : (go$ptrType(Go$String)).nil;
		this.mtyp = mtyp_ !== undefined ? mtyp_ : (go$ptrType(_type)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(_type)).nil;
		this.ifn = ifn_ !== undefined ? ifn_ : go$throwNilPointerError;
		this.tfn = tfn_ !== undefined ? tfn_ : go$throwNilPointerError;
	});
	go$pkg.method = method;
	var uncommontype;
	uncommontype = go$newType(0, "Struct", "runtime.uncommontype", "uncommontype", "runtime", function(name_, pkgpath_, mhdr_, m_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgpath = pkgpath_ !== undefined ? pkgpath_ : (go$ptrType(Go$String)).nil;
		this.mhdr = mhdr_ !== undefined ? mhdr_ : (go$sliceType(Go$Uint8)).nil;
		this.m = m_ !== undefined ? m_ : go$makeNativeArray("Struct", 0, function() { return new method.Ptr(); });
	});
	go$pkg.uncommontype = uncommontype;
	var imethod;
	imethod = go$newType(0, "Struct", "runtime.imethod", "imethod", "runtime", function(name_, pkgpath_, _type_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgpath = pkgpath_ !== undefined ? pkgpath_ : (go$ptrType(Go$String)).nil;
		this._type = _type_ !== undefined ? _type_ : (go$ptrType(_type)).nil;
	});
	go$pkg.imethod = imethod;
	var interfacetype;
	interfacetype = go$newType(0, "Struct", "runtime.interfacetype", "interfacetype", "runtime", function(_type_, mhdr_, m_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : new _type.Ptr();
		this.mhdr = mhdr_ !== undefined ? mhdr_ : (go$sliceType(Go$Uint8)).nil;
		this.m = m_ !== undefined ? m_ : go$makeNativeArray("Struct", 0, function() { return new imethod.Ptr(); });
	});
	go$pkg.interfacetype = interfacetype;
	var maptype;
	maptype = go$newType(0, "Struct", "runtime.maptype", "maptype", "runtime", function(_type_, key_, elem_, bucket_, hmap_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : new _type.Ptr();
		this.key = key_ !== undefined ? key_ : (go$ptrType(_type)).nil;
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(_type)).nil;
		this.bucket = bucket_ !== undefined ? bucket_ : (go$ptrType(_type)).nil;
		this.hmap = hmap_ !== undefined ? hmap_ : (go$ptrType(_type)).nil;
	});
	go$pkg.maptype = maptype;
	var chantype;
	chantype = go$newType(0, "Struct", "runtime.chantype", "chantype", "runtime", function(_type_, elem_, dir_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : new _type.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(_type)).nil;
		this.dir = dir_ !== undefined ? dir_ : new Go$Uint64(0, 0);
	});
	go$pkg.chantype = chantype;
	var slicetype;
	slicetype = go$newType(0, "Struct", "runtime.slicetype", "slicetype", "runtime", function(_type_, elem_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : new _type.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(_type)).nil;
	});
	go$pkg.slicetype = slicetype;
	var functype;
	functype = go$newType(0, "Struct", "runtime.functype", "functype", "runtime", function(_type_, dotdotdot_, in$2_, out_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : new _type.Ptr();
		this.dotdotdot = dotdotdot_ !== undefined ? dotdotdot_ : 0;
		this.in$2 = in$2_ !== undefined ? in$2_ : (go$sliceType(Go$Uint8)).nil;
		this.out = out_ !== undefined ? out_ : (go$sliceType(Go$Uint8)).nil;
	});
	go$pkg.functype = functype;
	var ptrtype;
	ptrtype = go$newType(0, "Struct", "runtime.ptrtype", "ptrtype", "runtime", function(_type_, elem_) {
		this.go$val = this;
		this._type = _type_ !== undefined ? _type_ : new _type.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(_type)).nil;
	});
	go$pkg.ptrtype = ptrtype;
	var sched;
	sched = go$newType(0, "Struct", "runtime.sched", "sched", "runtime", function(lock_, goidgen_, midle_, nmidle_, nmidlelocked_, mcount_, maxmcount_, pidle_, npidle_, nmspinning_, runqhead_, runqtail_, runqsize_, gflock_, gfree_, gcwaiting_, stopwait_, stopnote_, sysmonwait_, sysmonnote_, lastpoll_, profilehz_) {
		this.go$val = this;
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
		this.goidgen = goidgen_ !== undefined ? goidgen_ : new Go$Uint64(0, 0);
		this.midle = midle_ !== undefined ? midle_ : (go$ptrType(m)).nil;
		this.nmidle = nmidle_ !== undefined ? nmidle_ : 0;
		this.nmidlelocked = nmidlelocked_ !== undefined ? nmidlelocked_ : 0;
		this.mcount = mcount_ !== undefined ? mcount_ : 0;
		this.maxmcount = maxmcount_ !== undefined ? maxmcount_ : 0;
		this.pidle = pidle_ !== undefined ? pidle_ : (go$ptrType(p)).nil;
		this.npidle = npidle_ !== undefined ? npidle_ : 0;
		this.nmspinning = nmspinning_ !== undefined ? nmspinning_ : 0;
		this.runqhead = runqhead_ !== undefined ? runqhead_ : (go$ptrType(g)).nil;
		this.runqtail = runqtail_ !== undefined ? runqtail_ : (go$ptrType(g)).nil;
		this.runqsize = runqsize_ !== undefined ? runqsize_ : 0;
		this.gflock = gflock_ !== undefined ? gflock_ : new lock.Ptr();
		this.gfree = gfree_ !== undefined ? gfree_ : (go$ptrType(g)).nil;
		this.gcwaiting = gcwaiting_ !== undefined ? gcwaiting_ : 0;
		this.stopwait = stopwait_ !== undefined ? stopwait_ : 0;
		this.stopnote = stopnote_ !== undefined ? stopnote_ : new note.Ptr();
		this.sysmonwait = sysmonwait_ !== undefined ? sysmonwait_ : 0;
		this.sysmonnote = sysmonnote_ !== undefined ? sysmonnote_ : new note.Ptr();
		this.lastpoll = lastpoll_ !== undefined ? lastpoll_ : new Go$Uint64(0, 0);
		this.profilehz = profilehz_ !== undefined ? profilehz_ : 0;
	});
	go$pkg.sched = sched;
	var cgothreadstart;
	cgothreadstart = go$newType(0, "Struct", "runtime.cgothreadstart", "cgothreadstart", "runtime", function(m_, g_, fn_) {
		this.go$val = this;
		this.m = m_ !== undefined ? m_ : (go$ptrType(m)).nil;
		this.g = g_ !== undefined ? g_ : (go$ptrType(g)).nil;
		this.fn = fn_ !== undefined ? fn_ : go$throwNilPointerError;
	});
	go$pkg.cgothreadstart = cgothreadstart;
	var _3_;
	_3_ = go$newType(0, "Struct", "runtime._3_", "_3_", "runtime", function(lock_, fn_, hz_, pcbuf_) {
		this.go$val = this;
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
		this.fn = fn_ !== undefined ? fn_ : go$throwNilPointerError;
		this.hz = hz_ !== undefined ? hz_ : 0;
		this.pcbuf = pcbuf_ !== undefined ? pcbuf_ : go$makeNativeArray("Uint64", 100, function() { return new Go$Uint64(0, 0); });
	});
	go$pkg._3_ = _3_;
	var pdesc;
	pdesc = go$newType(0, "Struct", "runtime.pdesc", "pdesc", "runtime", function(schedtick_, schedwhen_, syscalltick_, syscallwhen_) {
		this.go$val = this;
		this.schedtick = schedtick_ !== undefined ? schedtick_ : 0;
		this.schedwhen = schedwhen_ !== undefined ? schedwhen_ : new Go$Int64(0, 0);
		this.syscalltick = syscalltick_ !== undefined ? syscalltick_ : 0;
		this.syscallwhen = syscallwhen_ !== undefined ? syscallwhen_ : new Go$Int64(0, 0);
	});
	go$pkg.pdesc = pdesc;
	var bucket;
	bucket = go$newType(0, "Struct", "runtime.bucket", "bucket", "runtime", function(tophash_, overflow_, data_) {
		this.go$val = this;
		this.tophash = tophash_ !== undefined ? tophash_ : go$makeNativeArray("Uint8", 8, function() { return 0; });
		this.overflow = overflow_ !== undefined ? overflow_ : (go$ptrType(bucket)).nil;
		this.data = data_ !== undefined ? data_ : go$makeNativeArray("Uint8", 1, function() { return 0; });
	});
	go$pkg.bucket = bucket;
	var hmap;
	hmap = go$newType(0, "Struct", "runtime.hmap", "hmap", "runtime", function(count_, flags_, hash0_, b_, keysize_, valuesize_, bucketsize_, buckets_, oldbuckets_, nevacuate_) {
		this.go$val = this;
		this.count = count_ !== undefined ? count_ : new Go$Uint64(0, 0);
		this.flags = flags_ !== undefined ? flags_ : 0;
		this.hash0 = hash0_ !== undefined ? hash0_ : 0;
		this.b = b_ !== undefined ? b_ : 0;
		this.keysize = keysize_ !== undefined ? keysize_ : 0;
		this.valuesize = valuesize_ !== undefined ? valuesize_ : 0;
		this.bucketsize = bucketsize_ !== undefined ? bucketsize_ : 0;
		this.buckets = buckets_ !== undefined ? buckets_ : (go$ptrType(Go$Uint8)).nil;
		this.oldbuckets = oldbuckets_ !== undefined ? oldbuckets_ : (go$ptrType(Go$Uint8)).nil;
		this.nevacuate = nevacuate_ !== undefined ? nevacuate_ : new Go$Uint64(0, 0);
	});
	go$pkg.hmap = hmap;
	var hash_iter;
	hash_iter = go$newType(0, "Struct", "runtime.hash_iter", "hash_iter", "runtime", function(key_, value_, t_, h_, endbucket_, wrapped_, b_, buckets_, bucket_, bptr_, i_, check_bucket_) {
		this.go$val = this;
		this.key = key_ !== undefined ? key_ : (go$ptrType(Go$Uint8)).nil;
		this.value = value_ !== undefined ? value_ : (go$ptrType(Go$Uint8)).nil;
		this.t = t_ !== undefined ? t_ : (go$ptrType(maptype)).nil;
		this.h = h_ !== undefined ? h_ : (go$ptrType(hmap)).nil;
		this.endbucket = endbucket_ !== undefined ? endbucket_ : new Go$Uint64(0, 0);
		this.wrapped = wrapped_ !== undefined ? wrapped_ : 0;
		this.b = b_ !== undefined ? b_ : 0;
		this.buckets = buckets_ !== undefined ? buckets_ : (go$ptrType(Go$Uint8)).nil;
		this.bucket = bucket_ !== undefined ? bucket_ : new Go$Uint64(0, 0);
		this.bptr = bptr_ !== undefined ? bptr_ : (go$ptrType(bucket)).nil;
		this.i = i_ !== undefined ? i_ : new Go$Uint64(0, 0);
		this.check_bucket = check_bucket_ !== undefined ? check_bucket_ : new Go$Int64(0, 0);
	});
	go$pkg.hash_iter = hash_iter;
	var sudog;
	sudog = go$newType(0, "Struct", "runtime.sudog", "sudog", "runtime", function(g_, selgen_, link_, releasetime_, elem_) {
		this.go$val = this;
		this.g = g_ !== undefined ? g_ : (go$ptrType(g)).nil;
		this.selgen = selgen_ !== undefined ? selgen_ : 0;
		this.link = link_ !== undefined ? link_ : (go$ptrType(sudog)).nil;
		this.releasetime = releasetime_ !== undefined ? releasetime_ : new Go$Int64(0, 0);
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(Go$Uint8)).nil;
	});
	go$pkg.sudog = sudog;
	var waitq;
	waitq = go$newType(0, "Struct", "runtime.waitq", "waitq", "runtime", function(first_, last_) {
		this.go$val = this;
		this.first = first_ !== undefined ? first_ : (go$ptrType(sudog)).nil;
		this.last = last_ !== undefined ? last_ : (go$ptrType(sudog)).nil;
	});
	go$pkg.waitq = waitq;
	var hchan;
	hchan = go$newType(0, "Struct", "runtime.hchan", "hchan", "runtime", function(qcount_, dataqsiz_, elemsize_, pad_, closed_, elemalg_, sendx_, recvx_, recvq_, sendq_, lock_) {
		this.go$val = this;
		this.qcount = qcount_ !== undefined ? qcount_ : new Go$Uint64(0, 0);
		this.dataqsiz = dataqsiz_ !== undefined ? dataqsiz_ : new Go$Uint64(0, 0);
		this.elemsize = elemsize_ !== undefined ? elemsize_ : 0;
		this.pad = pad_ !== undefined ? pad_ : 0;
		this.closed = closed_ !== undefined ? closed_ : 0;
		this.elemalg = elemalg_ !== undefined ? elemalg_ : (go$ptrType(alg)).nil;
		this.sendx = sendx_ !== undefined ? sendx_ : new Go$Uint64(0, 0);
		this.recvx = recvx_ !== undefined ? recvx_ : new Go$Uint64(0, 0);
		this.recvq = recvq_ !== undefined ? recvq_ : new waitq.Ptr();
		this.sendq = sendq_ !== undefined ? sendq_ : new waitq.Ptr();
		this.lock = lock_ !== undefined ? lock_ : new lock.Ptr();
	});
	go$pkg.hchan = hchan;
	var scase;
	scase = go$newType(0, "Struct", "runtime.scase", "scase", "runtime", function(sg_, _chan_, pc_, kind_, so_, receivedp_) {
		this.go$val = this;
		this.sg = sg_ !== undefined ? sg_ : new sudog.Ptr();
		this._chan = _chan_ !== undefined ? _chan_ : (go$ptrType(hchan)).nil;
		this.pc = pc_ !== undefined ? pc_ : (go$ptrType(Go$Uint8)).nil;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.so = so_ !== undefined ? so_ : 0;
		this.receivedp = receivedp_ !== undefined ? receivedp_ : (go$ptrType(Go$Uint8)).nil;
	});
	go$pkg.scase = scase;
	var _select;
	_select = go$newType(0, "Struct", "runtime._select", "_select", "runtime", function(tcase_, ncase_, pollorder_, lockorder_, scase_) {
		this.go$val = this;
		this.tcase = tcase_ !== undefined ? tcase_ : 0;
		this.ncase = ncase_ !== undefined ? ncase_ : 0;
		this.pollorder = pollorder_ !== undefined ? pollorder_ : (go$ptrType(Go$Uint16)).nil;
		this.lockorder = lockorder_ !== undefined ? lockorder_ : (go$ptrType((go$ptrType(hchan)))).nil;
		this.scase = scase_ !== undefined ? scase_ : go$makeNativeArray("Struct", 1, function() { return new scase.Ptr(); });
	});
	go$pkg._select = _select;
	var runtimeselect;
	runtimeselect = go$newType(0, "Struct", "runtime.runtimeselect", "runtimeselect", "runtime", function(dir_, typ_, ch_, val_) {
		this.go$val = this;
		this.dir = dir_ !== undefined ? dir_ : new Go$Uint64(0, 0);
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(chantype)).nil;
		this.ch = ch_ !== undefined ? ch_ : (go$ptrType(hchan)).nil;
		this.val = val_ !== undefined ? val_ : new Go$Uint64(0, 0);
	});
	go$pkg.runtimeselect = runtimeselect;
	var parforthread;
	parforthread = go$newType(0, "Struct", "runtime.parforthread", "parforthread", "runtime", function(pos_, nsteal_, nstealcnt_, nprocyield_, nosyield_, nsleep_, pad_) {
		this.go$val = this;
		this.pos = pos_ !== undefined ? pos_ : new Go$Uint64(0, 0);
		this.nsteal = nsteal_ !== undefined ? nsteal_ : new Go$Uint64(0, 0);
		this.nstealcnt = nstealcnt_ !== undefined ? nstealcnt_ : new Go$Uint64(0, 0);
		this.nprocyield = nprocyield_ !== undefined ? nprocyield_ : new Go$Uint64(0, 0);
		this.nosyield = nosyield_ !== undefined ? nosyield_ : new Go$Uint64(0, 0);
		this.nsleep = nsleep_ !== undefined ? nsleep_ : new Go$Uint64(0, 0);
		this.pad = pad_ !== undefined ? pad_ : go$makeNativeArray("Uint8", 64, function() { return 0; });
	});
	go$pkg.parforthread = parforthread;
	MemProfileRecord.init([["AllocBytes", "", Go$Int64, ""], ["FreeBytes", "", Go$Int64, ""], ["AllocObjects", "", Go$Int64, ""], ["FreeObjects", "", Go$Int64, ""], ["Stack0", "", (go$arrayType(Go$Uintptr, 32)), ""]]);
	(go$ptrType(MemProfileRecord)).methods = [["InUseBytes", "", [], [Go$Int64], false], ["InUseObjects", "", [], [Go$Int64], false], ["Stack", "", [], [(go$sliceType(Go$Uintptr))], false]];
	StackRecord.init([["Stack0", "", (go$arrayType(Go$Uintptr, 32)), ""]]);
	(go$ptrType(StackRecord)).methods = [["Stack", "", [], [(go$sliceType(Go$Uintptr))], false]];
	BlockProfileRecord.init([["Count", "", Go$Int64, ""], ["Cycles", "", Go$Int64, ""], ["", "", StackRecord, ""]]);
	(go$ptrType(BlockProfileRecord)).methods = [["Stack", "", [], [(go$sliceType(Go$Uintptr))], false]];
	Error.init([["Error", "", (go$funcType([], [Go$String], false))], ["RuntimeError", "", (go$funcType([], [], false))]]);
	TypeAssertionError.init([["interfaceString", "runtime", Go$String, ""], ["concreteString", "runtime", Go$String, ""], ["assertedString", "runtime", Go$String, ""], ["missingMethod", "runtime", Go$String, ""]]);
	(go$ptrType(TypeAssertionError)).methods = [["Error", "", [], [Go$String], false], ["RuntimeError", "", [], [], false]];
	errorString.methods = [["Error", "", [], [Go$String], false], ["RuntimeError", "", [], [], false]];
	(go$ptrType(errorString)).methods = [["Error", "", [], [Go$String], false], ["RuntimeError", "", [], [], false]];
	errorCString.methods = [["Error", "", [], [Go$String], false], ["RuntimeError", "", [], [], false]];
	(go$ptrType(errorCString)).methods = [["Error", "", [], [Go$String], false], ["RuntimeError", "", [], [], false]];
	stringer.init([["String", "", (go$funcType([], [Go$String], false))]]);
	Func.init([["opaque", "runtime", (go$structType([])), ""]]);
	(go$ptrType(Func)).methods = [["Entry", "", [], [Go$Uintptr], false], ["FileLine", "", [Go$Uintptr], [Go$String, Go$Int], false], ["Name", "", [], [Go$String], false]];
	MemStats.init([["Alloc", "", Go$Uint64, ""], ["TotalAlloc", "", Go$Uint64, ""], ["Sys", "", Go$Uint64, ""], ["Lookups", "", Go$Uint64, ""], ["Mallocs", "", Go$Uint64, ""], ["Frees", "", Go$Uint64, ""], ["HeapAlloc", "", Go$Uint64, ""], ["HeapSys", "", Go$Uint64, ""], ["HeapIdle", "", Go$Uint64, ""], ["HeapInuse", "", Go$Uint64, ""], ["HeapReleased", "", Go$Uint64, ""], ["HeapObjects", "", Go$Uint64, ""], ["StackInuse", "", Go$Uint64, ""], ["StackSys", "", Go$Uint64, ""], ["MSpanInuse", "", Go$Uint64, ""], ["MSpanSys", "", Go$Uint64, ""], ["MCacheInuse", "", Go$Uint64, ""], ["MCacheSys", "", Go$Uint64, ""], ["BuckHashSys", "", Go$Uint64, ""], ["GCSys", "", Go$Uint64, ""], ["OtherSys", "", Go$Uint64, ""], ["NextGC", "", Go$Uint64, ""], ["LastGC", "", Go$Uint64, ""], ["PauseTotalNs", "", Go$Uint64, ""], ["PauseNs", "", (go$arrayType(Go$Uint64, 256)), ""], ["NumGC", "", Go$Uint32, ""], ["EnableGC", "", Go$Bool, ""], ["DebugGC", "", Go$Bool, ""], ["BySize", "", (go$arrayType((go$structType([["Size", "", Go$Uint32, ""], ["Mallocs", "", Go$Uint64, ""], ["Frees", "", Go$Uint64, ""]])), 61)), ""]]);
	rtype.init([["size", "runtime", Go$Uintptr, ""], ["hash", "runtime", Go$Uint32, ""], ["_", "runtime", Go$Uint8, ""], ["align", "runtime", Go$Uint8, ""], ["fieldAlign", "runtime", Go$Uint8, ""], ["kind", "runtime", Go$Uint8, ""], ["alg", "runtime", Go$UnsafePointer, ""], ["gc", "runtime", Go$UnsafePointer, ""], ["string", "runtime", (go$ptrType(Go$String)), ""], ["", "runtime", (go$ptrType(uncommonType)), ""], ["ptrToThis", "runtime", (go$ptrType(rtype)), ""]]);
	_method.init([["name", "runtime", (go$ptrType(Go$String)), ""], ["pkgPath", "runtime", (go$ptrType(Go$String)), ""], ["mtyp", "runtime", (go$ptrType(rtype)), ""], ["typ", "runtime", (go$ptrType(rtype)), ""], ["ifn", "runtime", Go$UnsafePointer, ""], ["tfn", "runtime", Go$UnsafePointer, ""]]);
	uncommonType.init([["name", "runtime", (go$ptrType(Go$String)), ""], ["pkgPath", "runtime", (go$ptrType(Go$String)), ""], ["methods", "runtime", (go$sliceType(_method)), ""]]);
	_imethod.init([["name", "runtime", (go$ptrType(Go$String)), ""], ["pkgPath", "runtime", (go$ptrType(Go$String)), ""], ["typ", "runtime", (go$ptrType(rtype)), ""]]);
	interfaceType.init([["", "runtime", rtype, ""], ["methods", "runtime", (go$sliceType(_imethod)), ""]]);
	lock.init([["key", "runtime", Go$Uint64, ""]]);
	note.init([["key", "runtime", Go$Uint64, ""]]);
	_string.init([["str", "runtime", (go$ptrType(Go$Uint8)), ""], ["len", "runtime", Go$Int64, ""]]);
	funcval.init([["fn", "runtime", (go$funcType([], [], false)), ""]]);
	iface.init([["tab", "runtime", (go$ptrType(itab)), ""], ["data", "runtime", Go$UnsafePointer, ""]]);
	eface.init([["_type", "runtime", (go$ptrType(_type)), ""], ["data", "runtime", Go$UnsafePointer, ""]]);
	_complex64.init([["real", "runtime", Go$Float32, ""], ["imag", "runtime", Go$Float32, ""]]);
	_complex128.init([["real", "runtime", Go$Float64, ""], ["imag", "runtime", Go$Float64, ""]]);
	slice.init([["array", "runtime", (go$ptrType(Go$Uint8)), ""], ["len", "runtime", Go$Uint64, ""], ["cap", "runtime", Go$Uint64, ""]]);
	gobuf.init([["sp", "runtime", Go$Uint64, ""], ["pc", "runtime", Go$Uint64, ""], ["g", "runtime", (go$ptrType(g)), ""], ["ret", "runtime", Go$Uint64, ""], ["ctxt", "runtime", Go$UnsafePointer, ""], ["lr", "runtime", Go$Uint64, ""]]);
	gcstats.init([["nhandoff", "runtime", Go$Uint64, ""], ["nhandoffcnt", "runtime", Go$Uint64, ""], ["nprocyield", "runtime", Go$Uint64, ""], ["nosyield", "runtime", Go$Uint64, ""], ["nsleep", "runtime", Go$Uint64, ""]]);
	wincall.init([["fn", "runtime", (go$funcType([Go$UnsafePointer], [], false)), ""], ["n", "runtime", Go$Uint64, ""], ["args", "runtime", Go$UnsafePointer, ""], ["r1", "runtime", Go$Uint64, ""], ["r2", "runtime", Go$Uint64, ""], ["err", "runtime", Go$Uint64, ""]]);
	seh.init([["prev", "runtime", Go$UnsafePointer, ""], ["handler", "runtime", Go$UnsafePointer, ""]]);
	wincallbackcontext.init([["gobody", "runtime", Go$UnsafePointer, ""], ["argsize", "runtime", Go$Uint64, ""], ["restorestack", "runtime", Go$Uint64, ""]]);
	g.init([["stackguard0", "runtime", Go$Uint64, ""], ["stackbase", "runtime", Go$Uint64, ""], ["panicwrap", "runtime", Go$Uint32, ""], ["selgen", "runtime", Go$Uint32, ""], ["_defer", "runtime", (go$ptrType(_defer)), ""], ["_panic", "runtime", (go$ptrType(_panic)), ""], ["sched", "runtime", gobuf, ""], ["syscallstack", "runtime", Go$Uint64, ""], ["syscallsp", "runtime", Go$Uint64, ""], ["syscallpc", "runtime", Go$Uint64, ""], ["syscallguard", "runtime", Go$Uint64, ""], ["stackguard", "runtime", Go$Uint64, ""], ["stack0", "runtime", Go$Uint64, ""], ["stacksize", "runtime", Go$Uint64, ""], ["alllink", "runtime", (go$ptrType(g)), ""], ["param", "runtime", Go$UnsafePointer, ""], ["status", "runtime", Go$Int16, ""], ["goid", "runtime", Go$Int64, ""], ["waitreason", "runtime", (go$ptrType(Go$Int8)), ""], ["schedlink", "runtime", (go$ptrType(g)), ""], ["ispanic", "runtime", Go$Uint8, ""], ["issystem", "runtime", Go$Uint8, ""], ["isbackground", "runtime", Go$Uint8, ""], ["preempt", "runtime", Go$Uint8, ""], ["raceignore", "runtime", Go$Int8, ""], ["m", "runtime", (go$ptrType(m)), ""], ["lockedm", "runtime", (go$ptrType(m)), ""], ["sig", "runtime", Go$Int32, ""], ["writenbuf", "runtime", Go$Int32, ""], ["writebuf", "runtime", (go$ptrType(Go$Uint8)), ""], ["dchunk", "runtime", (go$ptrType(deferchunk)), ""], ["dchunknext", "runtime", (go$ptrType(deferchunk)), ""], ["sigcode0", "runtime", Go$Uint64, ""], ["sigcode1", "runtime", Go$Uint64, ""], ["sigpc", "runtime", Go$Uint64, ""], ["gopc", "runtime", Go$Uint64, ""], ["racectx", "runtime", Go$Uint64, ""], ["end", "runtime", (go$arrayType(Go$Uint64, 0)), ""]]);
	m.init([["g0", "runtime", (go$ptrType(g)), ""], ["moreargp", "runtime", Go$UnsafePointer, ""], ["morebuf", "runtime", gobuf, ""], ["moreframesize", "runtime", Go$Uint32, ""], ["moreargsize", "runtime", Go$Uint32, ""], ["cret", "runtime", Go$Uint64, ""], ["procid", "runtime", Go$Uint64, ""], ["gsignal", "runtime", (go$ptrType(g)), ""], ["tls", "runtime", (go$arrayType(Go$Uint64, 4)), ""], ["mstartfn", "runtime", (go$funcType([], [], false)), ""], ["curg", "runtime", (go$ptrType(g)), ""], ["caughtsig", "runtime", (go$ptrType(g)), ""], ["p", "runtime", (go$ptrType(p)), ""], ["nextp", "runtime", (go$ptrType(p)), ""], ["id", "runtime", Go$Int32, ""], ["mallocing", "runtime", Go$Int32, ""], ["throwing", "runtime", Go$Int32, ""], ["gcing", "runtime", Go$Int32, ""], ["locks", "runtime", Go$Int32, ""], ["dying", "runtime", Go$Int32, ""], ["profilehz", "runtime", Go$Int32, ""], ["helpgc", "runtime", Go$Int32, ""], ["spinning", "runtime", Go$Uint8, ""], ["fastrand", "runtime", Go$Uint32, ""], ["ncgocall", "runtime", Go$Uint64, ""], ["ncgo", "runtime", Go$Int32, ""], ["cgomal", "runtime", (go$ptrType(cgomal)), ""], ["park", "runtime", note, ""], ["alllink", "runtime", (go$ptrType(m)), ""], ["schedlink", "runtime", (go$ptrType(m)), ""], ["machport", "runtime", Go$Uint32, ""], ["mcache", "runtime", (go$ptrType(mcache)), ""], ["stackinuse", "runtime", Go$Int32, ""], ["stackcachepos", "runtime", Go$Uint32, ""], ["stackcachecnt", "runtime", Go$Uint32, ""], ["stackcache", "runtime", (go$arrayType(Go$UnsafePointer, 32)), ""], ["lockedg", "runtime", (go$ptrType(g)), ""], ["createstack", "runtime", (go$arrayType(Go$Uint64, 32)), ""], ["freglo", "runtime", (go$arrayType(Go$Uint32, 16)), ""], ["freghi", "runtime", (go$arrayType(Go$Uint32, 16)), ""], ["fflag", "runtime", Go$Uint32, ""], ["locked", "runtime", Go$Uint32, ""], ["nextwaitm", "runtime", (go$ptrType(m)), ""], ["waitsema", "runtime", Go$Uint64, ""], ["waitsemacount", "runtime", Go$Uint32, ""], ["waitsemalock", "runtime", Go$Uint32, ""], ["gcstats", "runtime", gcstats, ""], ["racecall", "runtime", Go$Uint8, ""], ["needextram", "runtime", Go$Uint8, ""], ["waitunlockf", "runtime", (go$funcType([(go$ptrType(lock))], [], false)), ""], ["waitlock", "runtime", Go$UnsafePointer, ""], ["settype_buf", "runtime", (go$arrayType(Go$Uint64, 1024)), ""], ["settype_bufsize", "runtime", Go$Uint64, ""], ["thread", "runtime", Go$UnsafePointer, ""], ["wincall", "runtime", wincall, ""], ["seh", "runtime", (go$ptrType(seh)), ""], ["end", "runtime", (go$arrayType(Go$Uint64, 0)), ""]]);
	p.init([["", "runtime", lock, ""], ["id", "runtime", Go$Int32, ""], ["status", "runtime", Go$Uint32, ""], ["link", "runtime", (go$ptrType(p)), ""], ["schedtick", "runtime", Go$Uint32, ""], ["syscalltick", "runtime", Go$Uint32, ""], ["m", "runtime", (go$ptrType(m)), ""], ["mcache", "runtime", (go$ptrType(mcache)), ""], ["runq", "runtime", (go$ptrType((go$ptrType(g)))), ""], ["runqhead", "runtime", Go$Int32, ""], ["runqtail", "runtime", Go$Int32, ""], ["runqsize", "runtime", Go$Int32, ""], ["gfree", "runtime", (go$ptrType(g)), ""], ["gfreecnt", "runtime", Go$Int32, ""], ["pad", "runtime", (go$arrayType(Go$Uint8, 64)), ""]]);
	stktop.init([["stackguard", "runtime", Go$Uint64, ""], ["stackbase", "runtime", Go$Uint64, ""], ["gobuf", "runtime", gobuf, ""], ["argsize", "runtime", Go$Uint32, ""], ["panicwrap", "runtime", Go$Uint32, ""], ["argp", "runtime", (go$ptrType(Go$Uint8)), ""], ["free", "runtime", Go$Uint64, ""], ["_panic", "runtime", Go$Uint8, ""]]);
	sigtab.init([["flags", "runtime", Go$Int32, ""], ["name", "runtime", (go$ptrType(Go$Int8)), ""]]);
	_func.init([["entry", "runtime", Go$Uint64, ""], ["nameoff", "runtime", Go$Int32, ""], ["args", "runtime", Go$Int32, ""], ["frame", "runtime", Go$Int32, ""], ["pcsp", "runtime", Go$Int32, ""], ["pcfile", "runtime", Go$Int32, ""], ["pcln", "runtime", Go$Int32, ""], ["npcdata", "runtime", Go$Int32, ""], ["nfuncdata", "runtime", Go$Int32, ""]]);
	itab.init([["inter", "runtime", (go$ptrType(interfacetype)), ""], ["_type", "runtime", (go$ptrType(_type)), ""], ["link", "runtime", (go$ptrType(itab)), ""], ["bad", "runtime", Go$Int32, ""], ["unused", "runtime", Go$Int32, ""], ["fun", "runtime", (go$arrayType((go$funcType([], [], false)), 0)), ""]]);
	timers.init([["", "runtime", lock, ""], ["timerproc", "runtime", (go$ptrType(g)), ""], ["sleeping", "runtime", Go$Uint8, ""], ["rescheduling", "runtime", Go$Uint8, ""], ["waitnote", "runtime", note, ""], ["t", "runtime", (go$ptrType((go$ptrType(timer)))), ""], ["len", "runtime", Go$Int32, ""], ["cap", "runtime", Go$Int32, ""]]);
	timer.init([["i", "runtime", Go$Int32, ""], ["when", "runtime", Go$Int64, ""], ["period", "runtime", Go$Int64, ""], ["fv", "runtime", (go$ptrType(funcval)), ""], ["arg", "runtime", eface, ""]]);
	lfnode.init([["next", "runtime", (go$ptrType(lfnode)), ""], ["pushcnt", "runtime", Go$Uint64, ""]]);
	parfor.init([["body", "runtime", (go$funcType([(go$ptrType(parfor)), Go$Uint32], [], false)), ""], ["done", "runtime", Go$Uint32, ""], ["nthr", "runtime", Go$Uint32, ""], ["nthrmax", "runtime", Go$Uint32, ""], ["thrseq", "runtime", Go$Uint32, ""], ["cnt", "runtime", Go$Uint32, ""], ["ctx", "runtime", Go$UnsafePointer, ""], ["wait", "runtime", Go$Uint8, ""], ["thr", "runtime", (go$ptrType(parforthread)), ""], ["pad", "runtime", Go$Uint32, ""], ["nsteal", "runtime", Go$Uint64, ""], ["nstealcnt", "runtime", Go$Uint64, ""], ["nprocyield", "runtime", Go$Uint64, ""], ["nosyield", "runtime", Go$Uint64, ""], ["nsleep", "runtime", Go$Uint64, ""]]);
	cgomal.init([["next", "runtime", (go$ptrType(cgomal)), ""], ["alloc", "runtime", Go$UnsafePointer, ""]]);
	debugvars.init([["gctrace", "runtime", Go$Int32, ""], ["schedtrace", "runtime", Go$Int32, ""], ["scheddetail", "runtime", Go$Int32, ""]]);
	alg.init([["hash", "runtime", (go$funcType([(go$ptrType(Go$Uint64)), Go$Uint64, Go$UnsafePointer], [], false)), ""], ["equal", "runtime", (go$funcType([(go$ptrType(Go$Uint8)), Go$Uint64, Go$UnsafePointer, Go$UnsafePointer], [], false)), ""], ["print", "runtime", (go$funcType([Go$Uint64, Go$UnsafePointer], [], false)), ""], ["copy", "runtime", (go$funcType([Go$Uint64, Go$UnsafePointer, Go$UnsafePointer], [], false)), ""]]);
	_defer.init([["siz", "runtime", Go$Int32, ""], ["special", "runtime", Go$Uint8, ""], ["free", "runtime", Go$Uint8, ""], ["argp", "runtime", (go$ptrType(Go$Uint8)), ""], ["pc", "runtime", (go$ptrType(Go$Uint8)), ""], ["fn", "runtime", (go$ptrType(funcval)), ""], ["link", "runtime", (go$ptrType(_defer)), ""], ["args", "runtime", (go$arrayType(Go$UnsafePointer, 1)), ""]]);
	deferchunk.init([["prev", "runtime", (go$ptrType(deferchunk)), ""], ["off", "runtime", Go$Uint64, ""]]);
	_panic.init([["arg", "runtime", eface, ""], ["stackbase", "runtime", Go$Uint64, ""], ["link", "runtime", (go$ptrType(_panic)), ""], ["recovered", "runtime", Go$Uint8, ""]]);
	stkframe.init([["fn", "runtime", (go$ptrType(_func)), ""], ["pc", "runtime", Go$Uint64, ""], ["lr", "runtime", Go$Uint64, ""], ["sp", "runtime", Go$Uint64, ""], ["fp", "runtime", Go$Uint64, ""], ["varp", "runtime", (go$ptrType(Go$Uint8)), ""], ["argp", "runtime", (go$ptrType(Go$Uint8)), ""], ["arglen", "runtime", Go$Uint64, ""]]);
	mlink.init([["next", "runtime", (go$ptrType(mlink)), ""]]);
	fixalloc.init([["size", "runtime", Go$Uint64, ""], ["first", "runtime", (go$funcType([Go$UnsafePointer, (go$ptrType(Go$Uint8))], [], false)), ""], ["arg", "runtime", Go$UnsafePointer, ""], ["list", "runtime", (go$ptrType(mlink)), ""], ["chunk", "runtime", (go$ptrType(Go$Uint8)), ""], ["nchunk", "runtime", Go$Uint32, ""], ["inuse", "runtime", Go$Uint64, ""], ["stat", "runtime", (go$ptrType(Go$Uint64)), ""]]);
	_1_.init([["size", "runtime", Go$Uint32, ""], ["nmalloc", "runtime", Go$Uint64, ""], ["nfree", "runtime", Go$Uint64, ""]]);
	mstats.init([["alloc", "runtime", Go$Uint64, ""], ["total_alloc", "runtime", Go$Uint64, ""], ["sys", "runtime", Go$Uint64, ""], ["nlookup", "runtime", Go$Uint64, ""], ["nmalloc", "runtime", Go$Uint64, ""], ["nfree", "runtime", Go$Uint64, ""], ["heap_alloc", "runtime", Go$Uint64, ""], ["heap_sys", "runtime", Go$Uint64, ""], ["heap_idle", "runtime", Go$Uint64, ""], ["heap_inuse", "runtime", Go$Uint64, ""], ["heap_released", "runtime", Go$Uint64, ""], ["heap_objects", "runtime", Go$Uint64, ""], ["stacks_inuse", "runtime", Go$Uint64, ""], ["stacks_sys", "runtime", Go$Uint64, ""], ["mspan_inuse", "runtime", Go$Uint64, ""], ["mspan_sys", "runtime", Go$Uint64, ""], ["mcache_inuse", "runtime", Go$Uint64, ""], ["mcache_sys", "runtime", Go$Uint64, ""], ["buckhash_sys", "runtime", Go$Uint64, ""], ["gc_sys", "runtime", Go$Uint64, ""], ["other_sys", "runtime", Go$Uint64, ""], ["next_gc", "runtime", Go$Uint64, ""], ["last_gc", "runtime", Go$Uint64, ""], ["pause_total_ns", "runtime", Go$Uint64, ""], ["pause_ns", "runtime", (go$arrayType(Go$Uint64, 256)), ""], ["numgc", "runtime", Go$Uint32, ""], ["enablegc", "runtime", Go$Uint8, ""], ["debuggc", "runtime", Go$Uint8, ""], ["by_size", "runtime", (go$arrayType(_1_, 61)), ""]]);
	mcachelist.init([["list", "runtime", (go$ptrType(mlink)), ""], ["nlist", "runtime", Go$Uint32, ""]]);
	mcache.init([["next_sample", "runtime", Go$Int32, ""], ["local_cachealloc", "runtime", Go$Int64, ""], ["list", "runtime", (go$arrayType(mcachelist, 61)), ""], ["local_nlookup", "runtime", Go$Uint64, ""], ["local_largefree", "runtime", Go$Uint64, ""], ["local_nlargefree", "runtime", Go$Uint64, ""], ["local_nsmallfree", "runtime", (go$arrayType(Go$Uint64, 61)), ""]]);
	mtypes.init([["compression", "runtime", Go$Uint8, ""], ["data", "runtime", Go$Uint64, ""]]);
	mspan.init([["next", "runtime", (go$ptrType(mspan)), ""], ["prev", "runtime", (go$ptrType(mspan)), ""], ["start", "runtime", Go$Uint64, ""], ["npages", "runtime", Go$Uint64, ""], ["freelist", "runtime", (go$ptrType(mlink)), ""], ["ref", "runtime", Go$Uint32, ""], ["sizeclass", "runtime", Go$Int32, ""], ["elemsize", "runtime", Go$Uint64, ""], ["state", "runtime", Go$Uint32, ""], ["unusedsince", "runtime", Go$Int64, ""], ["npreleased", "runtime", Go$Uint64, ""], ["limit", "runtime", (go$ptrType(Go$Uint8)), ""], ["types", "runtime", mtypes, ""]]);
	mcentral.init([["", "runtime", lock, ""], ["sizeclass", "runtime", Go$Int32, ""], ["nonempty", "runtime", mspan, ""], ["empty", "runtime", mspan, ""], ["nfree", "runtime", Go$Int32, ""]]);
	_2_.init([["", "runtime", mcentral, ""], ["pad", "runtime", (go$arrayType(Go$Uint8, 64)), ""]]);
	mheap.init([["", "runtime", lock, ""], ["free", "runtime", (go$arrayType(mspan, 256)), ""], ["large", "runtime", mspan, ""], ["allspans", "runtime", (go$ptrType((go$ptrType(mspan)))), ""], ["nspan", "runtime", Go$Uint32, ""], ["nspancap", "runtime", Go$Uint32, ""], ["spans", "runtime", (go$ptrType((go$ptrType(mspan)))), ""], ["spans_mapped", "runtime", Go$Uint64, ""], ["bitmap", "runtime", (go$ptrType(Go$Uint8)), ""], ["bitmap_mapped", "runtime", Go$Uint64, ""], ["arena_start", "runtime", (go$ptrType(Go$Uint8)), ""], ["arena_used", "runtime", (go$ptrType(Go$Uint8)), ""], ["arena_end", "runtime", (go$ptrType(Go$Uint8)), ""], ["central", "runtime", (go$arrayType(_2_, 61)), ""], ["spanalloc", "runtime", fixalloc, ""], ["cachealloc", "runtime", fixalloc, ""], ["largefree", "runtime", Go$Uint64, ""], ["nlargefree", "runtime", Go$Uint64, ""], ["nsmallfree", "runtime", (go$arrayType(Go$Uint64, 61)), ""]]);
	_type.init([["size", "runtime", Go$Uint64, ""], ["hash", "runtime", Go$Uint32, ""], ["_unused", "runtime", Go$Uint8, ""], ["align", "runtime", Go$Uint8, ""], ["fieldalign", "runtime", Go$Uint8, ""], ["kind", "runtime", Go$Uint8, ""], ["alg", "runtime", (go$ptrType(alg)), ""], ["gc", "runtime", Go$UnsafePointer, ""], ["_string", "runtime", (go$ptrType(Go$String)), ""], ["x", "runtime", (go$ptrType(uncommontype)), ""], ["ptrto", "runtime", (go$ptrType(_type)), ""]]);
	method.init([["name", "runtime", (go$ptrType(Go$String)), ""], ["pkgpath", "runtime", (go$ptrType(Go$String)), ""], ["mtyp", "runtime", (go$ptrType(_type)), ""], ["typ", "runtime", (go$ptrType(_type)), ""], ["ifn", "runtime", (go$funcType([], [], false)), ""], ["tfn", "runtime", (go$funcType([], [], false)), ""]]);
	uncommontype.init([["name", "runtime", (go$ptrType(Go$String)), ""], ["pkgpath", "runtime", (go$ptrType(Go$String)), ""], ["mhdr", "runtime", (go$sliceType(Go$Uint8)), ""], ["m", "runtime", (go$arrayType(method, 0)), ""]]);
	imethod.init([["name", "runtime", (go$ptrType(Go$String)), ""], ["pkgpath", "runtime", (go$ptrType(Go$String)), ""], ["_type", "runtime", (go$ptrType(_type)), ""]]);
	interfacetype.init([["", "runtime", _type, ""], ["mhdr", "runtime", (go$sliceType(Go$Uint8)), ""], ["m", "runtime", (go$arrayType(imethod, 0)), ""]]);
	maptype.init([["", "runtime", _type, ""], ["key", "runtime", (go$ptrType(_type)), ""], ["elem", "runtime", (go$ptrType(_type)), ""], ["bucket", "runtime", (go$ptrType(_type)), ""], ["hmap", "runtime", (go$ptrType(_type)), ""]]);
	chantype.init([["", "runtime", _type, ""], ["elem", "runtime", (go$ptrType(_type)), ""], ["dir", "runtime", Go$Uint64, ""]]);
	slicetype.init([["", "runtime", _type, ""], ["elem", "runtime", (go$ptrType(_type)), ""]]);
	functype.init([["", "runtime", _type, ""], ["dotdotdot", "runtime", Go$Uint8, ""], ["in", "runtime", (go$sliceType(Go$Uint8)), ""], ["out", "runtime", (go$sliceType(Go$Uint8)), ""]]);
	ptrtype.init([["", "runtime", _type, ""], ["elem", "runtime", (go$ptrType(_type)), ""]]);
	sched.init([["", "runtime", lock, ""], ["goidgen", "runtime", Go$Uint64, ""], ["midle", "runtime", (go$ptrType(m)), ""], ["nmidle", "runtime", Go$Int32, ""], ["nmidlelocked", "runtime", Go$Int32, ""], ["mcount", "runtime", Go$Int32, ""], ["maxmcount", "runtime", Go$Int32, ""], ["pidle", "runtime", (go$ptrType(p)), ""], ["npidle", "runtime", Go$Uint32, ""], ["nmspinning", "runtime", Go$Uint32, ""], ["runqhead", "runtime", (go$ptrType(g)), ""], ["runqtail", "runtime", (go$ptrType(g)), ""], ["runqsize", "runtime", Go$Int32, ""], ["gflock", "runtime", lock, ""], ["gfree", "runtime", (go$ptrType(g)), ""], ["gcwaiting", "runtime", Go$Uint32, ""], ["stopwait", "runtime", Go$Int32, ""], ["stopnote", "runtime", note, ""], ["sysmonwait", "runtime", Go$Uint32, ""], ["sysmonnote", "runtime", note, ""], ["lastpoll", "runtime", Go$Uint64, ""], ["profilehz", "runtime", Go$Int32, ""]]);
	cgothreadstart.init([["m", "runtime", (go$ptrType(m)), ""], ["g", "runtime", (go$ptrType(g)), ""], ["fn", "runtime", (go$funcType([], [], false)), ""]]);
	_3_.init([["", "runtime", lock, ""], ["fn", "runtime", (go$funcType([(go$ptrType(Go$Uint64)), Go$Int32], [], false)), ""], ["hz", "runtime", Go$Int32, ""], ["pcbuf", "runtime", (go$arrayType(Go$Uint64, 100)), ""]]);
	pdesc.init([["schedtick", "runtime", Go$Uint32, ""], ["schedwhen", "runtime", Go$Int64, ""], ["syscalltick", "runtime", Go$Uint32, ""], ["syscallwhen", "runtime", Go$Int64, ""]]);
	bucket.init([["tophash", "runtime", (go$arrayType(Go$Uint8, 8)), ""], ["overflow", "runtime", (go$ptrType(bucket)), ""], ["data", "runtime", (go$arrayType(Go$Uint8, 1)), ""]]);
	hmap.init([["count", "runtime", Go$Uint64, ""], ["flags", "runtime", Go$Uint32, ""], ["hash0", "runtime", Go$Uint32, ""], ["b", "runtime", Go$Uint8, ""], ["keysize", "runtime", Go$Uint8, ""], ["valuesize", "runtime", Go$Uint8, ""], ["bucketsize", "runtime", Go$Uint16, ""], ["buckets", "runtime", (go$ptrType(Go$Uint8)), ""], ["oldbuckets", "runtime", (go$ptrType(Go$Uint8)), ""], ["nevacuate", "runtime", Go$Uint64, ""]]);
	hash_iter.init([["key", "runtime", (go$ptrType(Go$Uint8)), ""], ["value", "runtime", (go$ptrType(Go$Uint8)), ""], ["t", "runtime", (go$ptrType(maptype)), ""], ["h", "runtime", (go$ptrType(hmap)), ""], ["endbucket", "runtime", Go$Uint64, ""], ["wrapped", "runtime", Go$Uint8, ""], ["b", "runtime", Go$Uint8, ""], ["buckets", "runtime", (go$ptrType(Go$Uint8)), ""], ["bucket", "runtime", Go$Uint64, ""], ["bptr", "runtime", (go$ptrType(bucket)), ""], ["i", "runtime", Go$Uint64, ""], ["check_bucket", "runtime", Go$Int64, ""]]);
	sudog.init([["g", "runtime", (go$ptrType(g)), ""], ["selgen", "runtime", Go$Uint32, ""], ["link", "runtime", (go$ptrType(sudog)), ""], ["releasetime", "runtime", Go$Int64, ""], ["elem", "runtime", (go$ptrType(Go$Uint8)), ""]]);
	waitq.init([["first", "runtime", (go$ptrType(sudog)), ""], ["last", "runtime", (go$ptrType(sudog)), ""]]);
	hchan.init([["qcount", "runtime", Go$Uint64, ""], ["dataqsiz", "runtime", Go$Uint64, ""], ["elemsize", "runtime", Go$Uint16, ""], ["pad", "runtime", Go$Uint16, ""], ["closed", "runtime", Go$Uint8, ""], ["elemalg", "runtime", (go$ptrType(alg)), ""], ["sendx", "runtime", Go$Uint64, ""], ["recvx", "runtime", Go$Uint64, ""], ["recvq", "runtime", waitq, ""], ["sendq", "runtime", waitq, ""], ["", "runtime", lock, ""]]);
	scase.init([["sg", "runtime", sudog, ""], ["_chan", "runtime", (go$ptrType(hchan)), ""], ["pc", "runtime", (go$ptrType(Go$Uint8)), ""], ["kind", "runtime", Go$Uint16, ""], ["so", "runtime", Go$Uint16, ""], ["receivedp", "runtime", (go$ptrType(Go$Uint8)), ""]]);
	_select.init([["tcase", "runtime", Go$Uint16, ""], ["ncase", "runtime", Go$Uint16, ""], ["pollorder", "runtime", (go$ptrType(Go$Uint16)), ""], ["lockorder", "runtime", (go$ptrType((go$ptrType(hchan)))), ""], ["scase", "runtime", (go$arrayType(scase, 1)), ""]]);
	runtimeselect.init([["dir", "runtime", Go$Uint64, ""], ["typ", "runtime", (go$ptrType(chantype)), ""], ["ch", "runtime", (go$ptrType(hchan)), ""], ["val", "runtime", Go$Uint64, ""]]);
	parforthread.init([["pos", "runtime", Go$Uint64, ""], ["nsteal", "runtime", Go$Uint64, ""], ["nstealcnt", "runtime", Go$Uint64, ""], ["nprocyield", "runtime", Go$Uint64, ""], ["nosyield", "runtime", Go$Uint64, ""], ["nsleep", "runtime", Go$Uint64, ""], ["pad", "runtime", (go$arrayType(Go$Uint8, 64)), ""]]);
	var sizeof_C_MStats, memStats, precisestack, algarray, startup_random_data, startup_random_data_len, emptystring, zerobase, allg, lastg, allm, allp, gomaxprocs, needextram, panicking, goos, ncpu, iscgo, sysargs, maxstring, hchansize, cpuid_ecx, cpuid_edx, debug, maxstacksize, blockprofilerate, worldsema, nan, posinf, neginf, memstats, class_to_size, class_to_allocnpages, size_to_class8, size_to_class128, checking, m0, g0, extram, newprocs, scavenger, initdone, _cgo_thread_start, prof, experiment, hash, ifacelock, typelink, etypelink, empty_value, hashload;
	var Breakpoint = go$pkg.Breakpoint = function() {
		throw go$panic("Native function not implemented: Breakpoint");
	};
	var LockOSThread = go$pkg.LockOSThread = function() {
		throw go$panic("Native function not implemented: LockOSThread");
	};
	var UnlockOSThread = go$pkg.UnlockOSThread = function() {
		throw go$panic("Native function not implemented: UnlockOSThread");
	};
	var GOMAXPROCS = go$pkg.GOMAXPROCS = function(n) {
			if (n > 1) {
				go$notSupported("GOMAXPROCS != 1");
			}
			return 1;
		};
	var NumCPU = go$pkg.NumCPU = function() { return 1; };
	var NumCgoCall = go$pkg.NumCgoCall = function() {
		throw go$panic("Native function not implemented: NumCgoCall");
	};
	var NumGoroutine = go$pkg.NumGoroutine = function() {
		throw go$panic("Native function not implemented: NumGoroutine");
	};
	MemProfileRecord.Ptr.prototype.InUseBytes = function() {
		var r, x, x$1;
		r = this;
		return (x = r.AllocBytes, x$1 = r.FreeBytes, new Go$Int64(x.high - x$1.high, x.low - x$1.low));
	};
	MemProfileRecord.prototype.InUseBytes = function() { return this.go$val.InUseBytes(); };
	MemProfileRecord.Ptr.prototype.InUseObjects = function() {
		var r, x, x$1;
		r = this;
		return (x = r.AllocObjects, x$1 = r.FreeObjects, new Go$Int64(x.high - x$1.high, x.low - x$1.low));
	};
	MemProfileRecord.prototype.InUseObjects = function() { return this.go$val.InUseObjects(); };
	MemProfileRecord.Ptr.prototype.Stack = function() {
		var r, _ref, _i, v, i;
		r = this;
		_ref = r.Stack0;
		_i = 0;
		while (_i < 32) {
			v = _ref[_i];
			i = _i;
			if (v === 0) {
				return go$subslice(new (go$sliceType(Go$Uintptr))(r.Stack0), 0, i);
			}
			_i++;
		}
		return go$subslice(new (go$sliceType(Go$Uintptr))(r.Stack0), 0);
	};
	MemProfileRecord.prototype.Stack = function() { return this.go$val.Stack(); };
	var MemProfile = go$pkg.MemProfile = function(p$1, inuseZero) {
		throw go$panic("Native function not implemented: MemProfile");
	};
	StackRecord.Ptr.prototype.Stack = function() {
		var r, _ref, _i, v, i;
		r = this;
		_ref = r.Stack0;
		_i = 0;
		while (_i < 32) {
			v = _ref[_i];
			i = _i;
			if (v === 0) {
				return go$subslice(new (go$sliceType(Go$Uintptr))(r.Stack0), 0, i);
			}
			_i++;
		}
		return go$subslice(new (go$sliceType(Go$Uintptr))(r.Stack0), 0);
	};
	StackRecord.prototype.Stack = function() { return this.go$val.Stack(); };
	var ThreadCreateProfile = go$pkg.ThreadCreateProfile = function(p$1) {
		throw go$panic("Native function not implemented: ThreadCreateProfile");
	};
	var GoroutineProfile = go$pkg.GoroutineProfile = function(p$1) {
		throw go$panic("Native function not implemented: GoroutineProfile");
	};
	var CPUProfile = go$pkg.CPUProfile = function() {
		throw go$panic("Native function not implemented: CPUProfile");
	};
	var SetCPUProfileRate = go$pkg.SetCPUProfileRate = function(hz) {
		throw go$panic("Native function not implemented: SetCPUProfileRate");
	};
	var SetBlockProfileRate = go$pkg.SetBlockProfileRate = function(rate) {
		throw go$panic("Native function not implemented: SetBlockProfileRate");
	};
	var BlockProfile = go$pkg.BlockProfile = function(p$1) {
		throw go$panic("Native function not implemented: BlockProfile");
	};
	var Stack = go$pkg.Stack = function(buf, all) {
		throw go$panic("Native function not implemented: Stack");
	};
	TypeAssertionError.Ptr.prototype.RuntimeError = function() {
	};
	TypeAssertionError.prototype.RuntimeError = function() { return this.go$val.RuntimeError(); };
	TypeAssertionError.Ptr.prototype.Error = function() {
		var e, inter;
		e = this;
		inter = e.interfaceString;
		if (inter === "") {
			inter = "interface";
		}
		if (e.concreteString === "") {
			return "interface conversion: " + inter + " is nil, not " + e.assertedString;
		}
		if (e.missingMethod === "") {
			return "interface conversion: " + inter + " is " + e.concreteString + ", not " + e.assertedString;
		}
		return "interface conversion: " + e.concreteString + " is not " + e.assertedString + ": missing method " + e.missingMethod;
	};
	TypeAssertionError.prototype.Error = function() { return this.go$val.Error(); };
	var newTypeAssertionError = function(ps1, ps2, ps3, pmeth, ret) {
		var _tuple, s1, s2, s3, meth;
		_tuple = ["", "", "", ""], s1 = _tuple[0], s2 = _tuple[1], s3 = _tuple[2], meth = _tuple[3];
		if (!(go$pointerIsEqual(ps1, (go$ptrType(Go$String)).nil))) {
			s1 = ps1.go$get();
		}
		if (!(go$pointerIsEqual(ps2, (go$ptrType(Go$String)).nil))) {
			s2 = ps2.go$get();
		}
		if (!(go$pointerIsEqual(ps3, (go$ptrType(Go$String)).nil))) {
			s3 = ps3.go$get();
		}
		if (!(go$pointerIsEqual(pmeth, (go$ptrType(Go$String)).nil))) {
			meth = pmeth.go$get();
		}
		ret.go$set(new TypeAssertionError.Ptr(s1, s2, s3, meth));
	};
	errorString.prototype.RuntimeError = function() {
		var e;
		e = this.go$val;
	};
	go$ptrType(errorString).prototype.RuntimeError = function() { return new errorString(this.go$get()).RuntimeError(); };
	errorString.prototype.Error = function() {
		var e;
		e = this.go$val;
		return "runtime error: " + e;
	};
	go$ptrType(errorString).prototype.Error = function() { return new errorString(this.go$get()).Error(); };
	var newErrorString = function(s, ret) {
		ret.go$set(new errorString(s));
	};
	errorCString.prototype.RuntimeError = function() {
		var e;
		e = this.go$val;
	};
	go$ptrType(errorCString).prototype.RuntimeError = function() { return new errorCString(this.go$get()).RuntimeError(); };
	var cstringToGo = function() {
		throw go$panic("Native function not implemented: cstringToGo");
	};
	errorCString.prototype.Error = function() {
		var e;
		e = this.go$val;
		return "runtime error: " + cstringToGo((e >>> 0));
	};
	go$ptrType(errorCString).prototype.Error = function() { return new errorCString(this.go$get()).Error(); };
	var newErrorCString = function(s, ret) {
		ret.go$set(new errorCString((s >>> 0)));
	};
	var typestring = function() {
		throw go$panic("Native function not implemented: typestring");
	};
	var printany = function(i) {
		var v, _ref, _type$1;
		_ref = i;
		_type$1 = _ref !== null ? _ref.constructor : null;
		if (_type$1 === null) {
			v = _ref;
			console.log("nil");
		} else if (stringer.implementedBy.indexOf(_type$1) !== -1) {
			v = _ref;
			console.log(v.String());
		} else if (go$error.implementedBy.indexOf(_type$1) !== -1) {
			v = _ref;
			console.log(v.Error());
		} else if (_type$1 === Go$Int) {
			v = _ref.go$val;
			console.log(v);
		} else if (_type$1 === Go$String) {
			v = _ref.go$val;
			console.log(v);
		} else {
			v = _ref;
			console.log("(", typestring(i), ") ", i);
		}
	};
	var panicwrap = function(pkg, typ, meth) {
		throw go$panic(new Go$String("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"));
	};
	var Gosched = go$pkg.Gosched = function() {
		throw go$panic("Native function not implemented: Gosched");
	};
	var Goexit = go$pkg.Goexit = function() {
			var err = new Go$Error();
			err.go$exit = true;
			throw err;
		};
	var Caller = go$pkg.Caller = function(skip) {
			var line = go$getStack()[skip + 3];
			if (line === undefined) {
				return [0, "", 0, false];
			}
			var parts = line.substring(line.indexOf("(") + 1, line.indexOf(")")).split(":");
			return [0, parts[0], parseInt(parts[1]), true];
		};
	var Callers = go$pkg.Callers = function(skip, pc) {
		throw go$panic("Native function not implemented: Callers");
	};
	var FuncForPC = go$pkg.FuncForPC = function(pc) {
		throw go$panic("Native function not implemented: FuncForPC");
	};
	Func.Ptr.prototype.Name = function() {
		var f;
		f = this;
		return funcname_go(f);
	};
	Func.prototype.Name = function() { return this.go$val.Name(); };
	Func.Ptr.prototype.Entry = function() {
		var f;
		f = this;
		return funcentry_go(f);
	};
	Func.prototype.Entry = function() { return this.go$val.Entry(); };
	Func.Ptr.prototype.FileLine = function(pc) {
		var file, line, f, _tuple;
		file = "";
		line = 0;
		f = this;
		_tuple = funcline_go(f, pc), file = _tuple[0], line = _tuple[1];
		return [file, line];
	};
	Func.prototype.FileLine = function(pc) { return this.go$val.FileLine(pc); };
	var funcline_go = function() {
		throw go$panic("Native function not implemented: funcline_go");
	};
	var funcname_go = function() {
		throw go$panic("Native function not implemented: funcname_go");
	};
	var funcentry_go = function() {
		throw go$panic("Native function not implemented: funcentry_go");
	};
	var SetFinalizer = go$pkg.SetFinalizer = function() {};
	var getgoroot = function() {
			return (typeof process !== 'undefined') ? (process.env["GOROOT"] || "") : "/";
		};
	var GOROOT = go$pkg.GOROOT = function() {
		var s;
		s = getgoroot();
		if (!(s === "")) {
			return s;
		}
		return "c:\\go";
	};
	var Version = go$pkg.Version = function() {
		return "go1.2";
	};
	var ReadMemStats = go$pkg.ReadMemStats = function() {};
	var GC = go$pkg.GC = function() {};
	var gc_m_ptr = function(ret) {
		ret.go$set((go$ptrType(m)).nil);
	};
	var gc_itab_ptr = function(ret) {
		ret.go$set((go$ptrType(itab)).nil);
	};
	var funpack64 = function(f) {
		var sign, mant, exp, inf, nan$1, _ref;
		sign = new Go$Uint64(0, 0);
		mant = new Go$Uint64(0, 0);
		exp = 0;
		inf = false;
		nan$1 = false;
		sign = new Go$Uint64(f.high & 2147483648, (f.low & 0) >>> 0);
		mant = new Go$Uint64(f.high & 1048575, (f.low & 4294967295) >>> 0);
		exp = (go$shiftRightUint64(f, 52).low >> 0) & 2047;
		_ref = exp;
		if (_ref === 2047) {
			if (!((mant.high === 0 && mant.low === 0))) {
				nan$1 = true;
				return [sign, mant, exp, inf, nan$1];
			}
			inf = true;
			return [sign, mant, exp, inf, nan$1];
		} else if (_ref === 0) {
			if (!((mant.high === 0 && mant.low === 0))) {
				exp = exp + -1022 >> 0;
				while ((mant.high < 1048576 || (mant.high === 1048576 && mant.low < 0))) {
					mant = go$shiftLeft64(mant, 1);
					exp = exp - 1 >> 0;
				}
			}
		} else {
			mant = new Go$Uint64(mant.high | 1048576, (mant.low | 0) >>> 0);
			exp = exp + -1023 >> 0;
		}
		return [sign, mant, exp, inf, nan$1];
	};
	var funpack32 = function(f) {
		var sign, mant, exp, inf, nan$1, _ref;
		sign = 0;
		mant = 0;
		exp = 0;
		inf = false;
		nan$1 = false;
		sign = (f & 2147483648) >>> 0;
		mant = (f & 8388607) >>> 0;
		exp = ((f >>> 23 >>> 0) >> 0) & 255;
		_ref = exp;
		if (_ref === 255) {
			if (!((mant === 0))) {
				nan$1 = true;
				return [sign, mant, exp, inf, nan$1];
			}
			inf = true;
			return [sign, mant, exp, inf, nan$1];
		} else if (_ref === 0) {
			if (!((mant === 0))) {
				exp = exp + -126 >> 0;
				while (mant < 8388608) {
					mant = mant << 1 >>> 0;
					exp = exp - 1 >> 0;
				}
			}
		} else {
			mant = (mant | 8388608) >>> 0;
			exp = exp + -127 >> 0;
		}
		return [sign, mant, exp, inf, nan$1];
	};
	var fpack64 = function(sign, mant, exp, trunc) {
		var _tuple, mant0, exp0, trunc0, x, x$1, x$2, _tuple$1, x$3, x$4, x$5, x$6, x$7, x$8;
		_tuple = [mant, exp, trunc], mant0 = _tuple[0], exp0 = _tuple[1], trunc0 = _tuple[2];
		if ((mant.high === 0 && mant.low === 0)) {
			return sign;
		}
		while ((mant.high < 1048576 || (mant.high === 1048576 && mant.low < 0))) {
			mant = go$shiftLeft64(mant, 1);
			exp = exp - 1 >> 0;
		}
		while ((mant.high > 4194304 || (mant.high === 4194304 && mant.low >= 0))) {
			trunc = (x = new Go$Uint64(mant.high & 0, (mant.low & 1) >>> 0), new Go$Uint64(trunc.high | x.high, (trunc.low | x.low) >>> 0));
			mant = go$shiftRightUint64(mant, 1);
			exp = exp + 1 >> 0;
		}
		if ((mant.high > 2097152 || (mant.high === 2097152 && mant.low >= 0))) {
			if (!((x$1 = new Go$Uint64(mant.high & 0, (mant.low & 1) >>> 0), (x$1.high === 0 && x$1.low === 0))) && (!((trunc.high === 0 && trunc.low === 0)) || !((x$2 = new Go$Uint64(mant.high & 0, (mant.low & 2) >>> 0), (x$2.high === 0 && x$2.low === 0))))) {
				mant = new Go$Uint64(mant.high + 0, mant.low + 1);
				if ((mant.high > 4194304 || (mant.high === 4194304 && mant.low >= 0))) {
					mant = go$shiftRightUint64(mant, 1);
					exp = exp + 1 >> 0;
				}
			}
			mant = go$shiftRightUint64(mant, 1);
			exp = exp + 1 >> 0;
		}
		if (exp >= 1024) {
			return new Go$Uint64(sign.high ^ 2146435072, (sign.low ^ 0) >>> 0);
		}
		if (exp < -1022) {
			if (exp < -1075) {
				return new Go$Uint64(sign.high | 0, (sign.low | 0) >>> 0);
			}
			_tuple$1 = [mant0, exp0, trunc0], mant = _tuple$1[0], exp = _tuple$1[1], trunc = _tuple$1[2];
			while (exp < -1023) {
				trunc = (x$3 = new Go$Uint64(mant.high & 0, (mant.low & 1) >>> 0), new Go$Uint64(trunc.high | x$3.high, (trunc.low | x$3.low) >>> 0));
				mant = go$shiftRightUint64(mant, 1);
				exp = exp + 1 >> 0;
			}
			if (!((x$4 = new Go$Uint64(mant.high & 0, (mant.low & 1) >>> 0), (x$4.high === 0 && x$4.low === 0))) && (!((trunc.high === 0 && trunc.low === 0)) || !((x$5 = new Go$Uint64(mant.high & 0, (mant.low & 2) >>> 0), (x$5.high === 0 && x$5.low === 0))))) {
				mant = new Go$Uint64(mant.high + 0, mant.low + 1);
			}
			mant = go$shiftRightUint64(mant, 1);
			exp = exp + 1 >> 0;
			if ((mant.high < 1048576 || (mant.high === 1048576 && mant.low < 0))) {
				return new Go$Uint64(sign.high | mant.high, (sign.low | mant.low) >>> 0);
			}
		}
		return (x$6 = (x$7 = go$shiftLeft64(new Go$Uint64(0, (exp - -1023 >> 0)), 52), new Go$Uint64(sign.high | x$7.high, (sign.low | x$7.low) >>> 0)), x$8 = new Go$Uint64(mant.high & 1048575, (mant.low & 4294967295) >>> 0), new Go$Uint64(x$6.high | x$8.high, (x$6.low | x$8.low) >>> 0));
	};
	var fpack32 = function(sign, mant, exp, trunc) {
		var _tuple, mant0, exp0, trunc0, _tuple$1;
		_tuple = [mant, exp, trunc], mant0 = _tuple[0], exp0 = _tuple[1], trunc0 = _tuple[2];
		if (mant === 0) {
			return sign;
		}
		while (mant < 8388608) {
			mant = mant << 1 >>> 0;
			exp = exp - 1 >> 0;
		}
		while (mant >= 33554432) {
			trunc = (trunc | (((mant & 1) >>> 0))) >>> 0;
			mant = mant >>> 1 >>> 0;
			exp = exp + 1 >> 0;
		}
		if (mant >= 16777216) {
			if (!((((mant & 1) >>> 0) === 0)) && (!((trunc === 0)) || !((((mant & 2) >>> 0) === 0)))) {
				mant = mant + 1 >>> 0;
				if (mant >= 33554432) {
					mant = mant >>> 1 >>> 0;
					exp = exp + 1 >> 0;
				}
			}
			mant = mant >>> 1 >>> 0;
			exp = exp + 1 >> 0;
		}
		if (exp >= 128) {
			return (sign ^ 2139095040) >>> 0;
		}
		if (exp < -126) {
			if (exp < -150) {
				return (sign | 0) >>> 0;
			}
			_tuple$1 = [mant0, exp0, trunc0], mant = _tuple$1[0], exp = _tuple$1[1], trunc = _tuple$1[2];
			while (exp < -127) {
				trunc = (trunc | (((mant & 1) >>> 0))) >>> 0;
				mant = mant >>> 1 >>> 0;
				exp = exp + 1 >> 0;
			}
			if (!((((mant & 1) >>> 0) === 0)) && (!((trunc === 0)) || !((((mant & 2) >>> 0) === 0)))) {
				mant = mant + 1 >>> 0;
			}
			mant = mant >>> 1 >>> 0;
			exp = exp + 1 >> 0;
			if (mant < 8388608) {
				return (sign | mant) >>> 0;
			}
		}
		return (((sign | (((exp - -127 >> 0) >>> 0) << 23 >>> 0)) >>> 0) | ((mant & 8388607) >>> 0)) >>> 0;
	};
	var fadd64 = function(f, g$1) {
		var _tuple, fs, fm, fe, fi, fn, _tuple$1, gs, gm, ge, gi, gn, x, _tuple$2, shift, x$1, x$2, trunc, x$3, x$4;
		_tuple = funpack64(f), fs = _tuple[0], fm = _tuple[1], fe = _tuple[2], fi = _tuple[3], fn = _tuple[4];
		_tuple$1 = funpack64(g$1), gs = _tuple$1[0], gm = _tuple$1[1], ge = _tuple$1[2], gi = _tuple$1[3], gn = _tuple$1[4];
		if (fn || gn) {
			return new Go$Uint64(2146435072, 1);
		} else if (fi && gi && !((fs.high === gs.high && fs.low === gs.low))) {
			return new Go$Uint64(2146435072, 1);
		} else if (fi) {
			return f;
		} else if (gi) {
			return g$1;
		} else if ((fm.high === 0 && fm.low === 0) && (gm.high === 0 && gm.low === 0) && !((fs.high === 0 && fs.low === 0)) && !((gs.high === 0 && gs.low === 0))) {
			return f;
		} else if ((fm.high === 0 && fm.low === 0)) {
			if ((gm.high === 0 && gm.low === 0)) {
				g$1 = (x = gs, new Go$Uint64(g$1.high ^ x.high, (g$1.low ^ x.low) >>> 0));
			}
			return g$1;
		} else if ((gm.high === 0 && gm.low === 0)) {
			return f;
		}
		if (fe < ge || (fe === ge) && (fm.high < gm.high || (fm.high === gm.high && fm.low < gm.low))) {
			_tuple$2 = [g$1, f, gs, gm, ge, fs, fm, fe], f = _tuple$2[0], g$1 = _tuple$2[1], fs = _tuple$2[2], fm = _tuple$2[3], fe = _tuple$2[4], gs = _tuple$2[5], gm = _tuple$2[6], ge = _tuple$2[7];
		}
		shift = ((fe - ge >> 0) >>> 0);
		fm = go$shiftLeft64(fm, 2);
		gm = go$shiftLeft64(gm, 2);
		trunc = (x$1 = (x$2 = go$shiftLeft64(new Go$Uint64(0, 1), shift), new Go$Uint64(x$2.high - 0, x$2.low - 1)), new Go$Uint64(gm.high & x$1.high, (gm.low & x$1.low) >>> 0));
		gm = go$shiftRightUint64(gm, (shift));
		if ((fs.high === gs.high && fs.low === gs.low)) {
			fm = (x$3 = gm, new Go$Uint64(fm.high + x$3.high, fm.low + x$3.low));
		} else {
			fm = (x$4 = gm, new Go$Uint64(fm.high - x$4.high, fm.low - x$4.low));
			if (!((trunc.high === 0 && trunc.low === 0))) {
				fm = new Go$Uint64(fm.high - 0, fm.low - 1);
			}
		}
		if ((fm.high === 0 && fm.low === 0)) {
			fs = new Go$Uint64(0, 0);
		}
		return fpack64(fs, fm, fe - 2 >> 0, trunc);
	};
	var fsub64 = function(f, g$1) {
		return fadd64(f, fneg64(g$1));
	};
	var fneg64 = function(f) {
		return new Go$Uint64(f.high ^ 2147483648, (f.low ^ 0) >>> 0);
	};
	var fmul64 = function(f, g$1) {
		var _tuple, fs, fm, fe, fi, fn, _tuple$1, gs, gm, ge, gi, gn, _tuple$2, lo, hi, shift, x, x$1, trunc, x$2, x$3, mant;
		_tuple = funpack64(f), fs = _tuple[0], fm = _tuple[1], fe = _tuple[2], fi = _tuple[3], fn = _tuple[4];
		_tuple$1 = funpack64(g$1), gs = _tuple$1[0], gm = _tuple$1[1], ge = _tuple$1[2], gi = _tuple$1[3], gn = _tuple$1[4];
		if (fn || gn) {
			return new Go$Uint64(2146435072, 1);
		} else if (fi && gi) {
			return new Go$Uint64(f.high ^ gs.high, (f.low ^ gs.low) >>> 0);
		} else if (fi && (gm.high === 0 && gm.low === 0) || (fm.high === 0 && fm.low === 0) && gi) {
			return new Go$Uint64(2146435072, 1);
		} else if ((fm.high === 0 && fm.low === 0)) {
			return new Go$Uint64(f.high ^ gs.high, (f.low ^ gs.low) >>> 0);
		} else if ((gm.high === 0 && gm.low === 0)) {
			return new Go$Uint64(g$1.high ^ fs.high, (g$1.low ^ fs.low) >>> 0);
		}
		_tuple$2 = mullu(fm, gm), lo = _tuple$2[0], hi = _tuple$2[1];
		shift = 51;
		trunc = (x = (x$1 = go$shiftLeft64(new Go$Uint64(0, 1), shift), new Go$Uint64(x$1.high - 0, x$1.low - 1)), new Go$Uint64(lo.high & x.high, (lo.low & x.low) >>> 0));
		mant = (x$2 = go$shiftLeft64(hi, ((64 - shift >>> 0))), x$3 = go$shiftRightUint64(lo, shift), new Go$Uint64(x$2.high | x$3.high, (x$2.low | x$3.low) >>> 0));
		return fpack64(new Go$Uint64(fs.high ^ gs.high, (fs.low ^ gs.low) >>> 0), mant, (fe + ge >> 0) - 1 >> 0, trunc);
	};
	var fdiv64 = function(f, g$1) {
		var _tuple, fs, fm, fe, fi, fn, _tuple$1, gs, gm, ge, gi, gn, x, x$1, _tuple$2, shift, _tuple$3, q, r;
		_tuple = funpack64(f), fs = _tuple[0], fm = _tuple[1], fe = _tuple[2], fi = _tuple[3], fn = _tuple[4];
		_tuple$1 = funpack64(g$1), gs = _tuple$1[0], gm = _tuple$1[1], ge = _tuple$1[2], gi = _tuple$1[3], gn = _tuple$1[4];
		if (fn || gn) {
			return new Go$Uint64(2146435072, 1);
		} else if (fi && gi) {
			return new Go$Uint64(2146435072, 1);
		} else if (!fi && !gi && (fm.high === 0 && fm.low === 0) && (gm.high === 0 && gm.low === 0)) {
			return new Go$Uint64(2146435072, 1);
		} else if (fi || !gi && (gm.high === 0 && gm.low === 0)) {
			return (x = new Go$Uint64(fs.high ^ gs.high, (fs.low ^ gs.low) >>> 0), new Go$Uint64(x.high ^ 2146435072, (x.low ^ 0) >>> 0));
		} else if (gi || (fm.high === 0 && fm.low === 0)) {
			return (x$1 = new Go$Uint64(fs.high ^ gs.high, (fs.low ^ gs.low) >>> 0), new Go$Uint64(x$1.high ^ 0, (x$1.low ^ 0) >>> 0));
		}
		_tuple$2 = [fi, fn, gi, gn];
		shift = 54;
		_tuple$3 = divlu(go$shiftRightUint64(fm, ((64 - shift >>> 0))), go$shiftLeft64(fm, shift), gm), q = _tuple$3[0], r = _tuple$3[1];
		return fpack64(new Go$Uint64(fs.high ^ gs.high, (fs.low ^ gs.low) >>> 0), q, (fe - ge >> 0) - 2 >> 0, r);
	};
	var f64to32 = function(f) {
		var _tuple, fs, fm, fe, fi, fn, fs32;
		_tuple = funpack64(f), fs = _tuple[0], fm = _tuple[1], fe = _tuple[2], fi = _tuple[3], fn = _tuple[4];
		if (fn) {
			return 2139095041;
		}
		fs32 = (go$shiftRightUint64(fs, 32).low >>> 0);
		if (fi) {
			return (fs32 ^ 2139095040) >>> 0;
		}
		return fpack32(fs32, (go$shiftRightUint64(fm, 28).low >>> 0), fe - 1 >> 0, (new Go$Uint64(fm.high & 0, (fm.low & 268435455) >>> 0).low >>> 0));
	};
	var f32to64 = function(f) {
		var _tuple, fs, fm, fe, fi, fn, fs64;
		_tuple = funpack32(f), fs = _tuple[0], fm = _tuple[1], fe = _tuple[2], fi = _tuple[3], fn = _tuple[4];
		if (fn) {
			return new Go$Uint64(2146435072, 1);
		}
		fs64 = go$shiftLeft64(new Go$Uint64(0, fs), 32);
		if (fi) {
			return new Go$Uint64(fs64.high ^ 2146435072, (fs64.low ^ 0) >>> 0);
		}
		return fpack64(fs64, go$shiftLeft64(new Go$Uint64(0, fm), 29), fe, new Go$Uint64(0, 0));
	};
	var fcmp64 = function(f, g$1) {
		var cmp, isnan, _tuple, fs, fm, fi, fn, _tuple$1, gs, gm, gi, gn, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8;
		cmp = 0;
		isnan = false;
		_tuple = funpack64(f), fs = _tuple[0], fm = _tuple[1], fi = _tuple[3], fn = _tuple[4];
		_tuple$1 = funpack64(g$1), gs = _tuple$1[0], gm = _tuple$1[1], gi = _tuple$1[3], gn = _tuple$1[4];
		if (fn || gn) {
			_tuple$2 = [0, true], cmp = _tuple$2[0], isnan = _tuple$2[1];
			return [cmp, isnan];
		} else if (!fi && !gi && (fm.high === 0 && fm.low === 0) && (gm.high === 0 && gm.low === 0)) {
			_tuple$3 = [0, false], cmp = _tuple$3[0], isnan = _tuple$3[1];
			return [cmp, isnan];
		} else if ((fs.high > gs.high || (fs.high === gs.high && fs.low > gs.low))) {
			_tuple$4 = [-1, false], cmp = _tuple$4[0], isnan = _tuple$4[1];
			return [cmp, isnan];
		} else if ((fs.high < gs.high || (fs.high === gs.high && fs.low < gs.low))) {
			_tuple$5 = [1, false], cmp = _tuple$5[0], isnan = _tuple$5[1];
			return [cmp, isnan];
		} else if ((fs.high === 0 && fs.low === 0) && (f.high < g$1.high || (f.high === g$1.high && f.low < g$1.low)) || !((fs.high === 0 && fs.low === 0)) && (f.high > g$1.high || (f.high === g$1.high && f.low > g$1.low))) {
			_tuple$6 = [-1, false], cmp = _tuple$6[0], isnan = _tuple$6[1];
			return [cmp, isnan];
		} else if ((fs.high === 0 && fs.low === 0) && (f.high > g$1.high || (f.high === g$1.high && f.low > g$1.low)) || !((fs.high === 0 && fs.low === 0)) && (f.high < g$1.high || (f.high === g$1.high && f.low < g$1.low))) {
			_tuple$7 = [1, false], cmp = _tuple$7[0], isnan = _tuple$7[1];
			return [cmp, isnan];
		}
		_tuple$8 = [0, false], cmp = _tuple$8[0], isnan = _tuple$8[1];
		return [cmp, isnan];
	};
	var f64toint = function(f) {
		var val, ok, _tuple, fs, fm, fe, fi, fn, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6;
		val = new Go$Int64(0, 0);
		ok = false;
		_tuple = funpack64(f), fs = _tuple[0], fm = _tuple[1], fe = _tuple[2], fi = _tuple[3], fn = _tuple[4];
		if (fi || fn) {
			_tuple$1 = [new Go$Int64(0, 0), false], val = _tuple$1[0], ok = _tuple$1[1];
			return [val, ok];
		} else if (fe < -1) {
			_tuple$2 = [new Go$Int64(0, 0), false], val = _tuple$2[0], ok = _tuple$2[1];
			return [val, ok];
		} else if (fe > 63) {
			if (!((fs.high === 0 && fs.low === 0)) && (fm.high === 0 && fm.low === 0)) {
				_tuple$3 = [new Go$Int64(-2147483648, 0), true], val = _tuple$3[0], ok = _tuple$3[1];
				return [val, ok];
			}
			if (!((fs.high === 0 && fs.low === 0))) {
				_tuple$4 = [new Go$Int64(0, 0), false], val = _tuple$4[0], ok = _tuple$4[1];
				return [val, ok];
			}
			_tuple$5 = [new Go$Int64(0, 0), false], val = _tuple$5[0], ok = _tuple$5[1];
			return [val, ok];
		}
		while (fe > 52) {
			fe = fe - 1 >> 0;
			fm = go$shiftLeft64(fm, 1);
		}
		while (fe < 52) {
			fe = fe + 1 >> 0;
			fm = go$shiftRightUint64(fm, 1);
		}
		val = new Go$Int64(fm.high, fm.low);
		if (!((fs.high === 0 && fs.low === 0))) {
			val = new Go$Int64(-val.high, -val.low);
		}
		_tuple$6 = [val, true], val = _tuple$6[0], ok = _tuple$6[1];
		return [val, ok];
	};
	var fintto64 = function(val) {
		var f, x, fs, mant;
		f = new Go$Uint64(0, 0);
		fs = (x = new Go$Uint64(val.high, val.low), new Go$Uint64(x.high & 2147483648, (x.low & 0) >>> 0));
		mant = new Go$Uint64(val.high, val.low);
		if (!((fs.high === 0 && fs.low === 0))) {
			mant = new Go$Uint64(-mant.high, -mant.low);
		}
		f = fpack64(fs, mant, 52, new Go$Uint64(0, 0));
		return f;
	};
	var mullu = function(u, v) {
		var lo, hi, u0, u1, v0, v1, w0, x, x$1, t, w1, w2, x$2, x$3, x$4, x$5, _tuple;
		lo = new Go$Uint64(0, 0);
		hi = new Go$Uint64(0, 0);
		u0 = new Go$Uint64(u.high & 0, (u.low & 4294967295) >>> 0);
		u1 = go$shiftRightUint64(u, 32);
		v0 = new Go$Uint64(v.high & 0, (v.low & 4294967295) >>> 0);
		v1 = go$shiftRightUint64(v, 32);
		w0 = go$mul64(u0, v0);
		t = (x = go$mul64(u1, v0), x$1 = go$shiftRightUint64(w0, 32), new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
		w1 = new Go$Uint64(t.high & 0, (t.low & 4294967295) >>> 0);
		w2 = go$shiftRightUint64(t, 32);
		w1 = (x$2 = go$mul64(u0, v1), new Go$Uint64(w1.high + x$2.high, w1.low + x$2.low));
		_tuple = [go$mul64(u, v), (x$3 = (x$4 = go$mul64(u1, v1), new Go$Uint64(x$4.high + w2.high, x$4.low + w2.low)), x$5 = go$shiftRightUint64(w1, 32), new Go$Uint64(x$3.high + x$5.high, x$3.low + x$5.low))], lo = _tuple[0], hi = _tuple[1];
		return [lo, hi];
	};
	var divlu = function(u1, u0, v) {
		var q, r, _tuple, s, x, vn1, vn0, x$1, x$2, un32, un10, un1, un0, q1, x$3, rhat, x$4, x$5, x$6, x$7, x$8, x$9, x$10, un21, q0, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, _tuple$1;
		q = new Go$Uint64(0, 0);
		r = new Go$Uint64(0, 0);
		if ((u1.high > v.high || (u1.high === v.high && u1.low >= v.low))) {
			_tuple = [new Go$Uint64(4294967295, 4294967295), new Go$Uint64(4294967295, 4294967295)], q = _tuple[0], r = _tuple[1];
			return [q, r];
		}
		s = 0;
		while ((x = new Go$Uint64(v.high & 2147483648, (v.low & 0) >>> 0), (x.high === 0 && x.low === 0))) {
			s = s + 1 >>> 0;
			v = go$shiftLeft64(v, 1);
		}
		vn1 = go$shiftRightUint64(v, 32);
		vn0 = new Go$Uint64(v.high & 0, (v.low & 4294967295) >>> 0);
		un32 = (x$1 = go$shiftLeft64(u1, s), x$2 = go$shiftRightUint64(u0, ((64 - s >>> 0))), new Go$Uint64(x$1.high | x$2.high, (x$1.low | x$2.low) >>> 0));
		un10 = go$shiftLeft64(u0, s);
		un1 = go$shiftRightUint64(un10, 32);
		un0 = new Go$Uint64(un10.high & 0, (un10.low & 4294967295) >>> 0);
		q1 = go$div64(un32, vn1, false);
		rhat = (x$3 = go$mul64(q1, vn1), new Go$Uint64(un32.high - x$3.high, un32.low - x$3.low));
		again1: switch (0) { default: if ((q1.high > 1 || (q1.high === 1 && q1.low >= 0)) || (x$4 = go$mul64(q1, vn0), x$5 = (x$6 = go$mul64(new Go$Uint64(1, 0), rhat), new Go$Uint64(x$6.high + un1.high, x$6.low + un1.low)), (x$4.high > x$5.high || (x$4.high === x$5.high && x$4.low > x$5.low)))) {
			q1 = new Go$Uint64(q1.high - 0, q1.low - 1);
			rhat = (x$7 = vn1, new Go$Uint64(rhat.high + x$7.high, rhat.low + x$7.low));
			if ((rhat.high < 1 || (rhat.high === 1 && rhat.low < 0))) {
				go$notSupported("goto");
			}
		} }
		un21 = (x$8 = (x$9 = go$mul64(un32, new Go$Uint64(1, 0)), new Go$Uint64(x$9.high + un1.high, x$9.low + un1.low)), x$10 = go$mul64(q1, v), new Go$Uint64(x$8.high - x$10.high, x$8.low - x$10.low));
		q0 = go$div64(un21, vn1, false);
		rhat = (x$11 = go$mul64(q0, vn1), new Go$Uint64(un21.high - x$11.high, un21.low - x$11.low));
		again2: switch (0) { default: if ((q0.high > 1 || (q0.high === 1 && q0.low >= 0)) || (x$12 = go$mul64(q0, vn0), x$13 = (x$14 = go$mul64(new Go$Uint64(1, 0), rhat), new Go$Uint64(x$14.high + un0.high, x$14.low + un0.low)), (x$12.high > x$13.high || (x$12.high === x$13.high && x$12.low > x$13.low)))) {
			q0 = new Go$Uint64(q0.high - 0, q0.low - 1);
			rhat = (x$15 = vn1, new Go$Uint64(rhat.high + x$15.high, rhat.low + x$15.low));
			if ((rhat.high < 1 || (rhat.high === 1 && rhat.low < 0))) {
				go$notSupported("goto");
			}
		} }
		_tuple$1 = [(x$16 = go$mul64(q1, new Go$Uint64(1, 0)), new Go$Uint64(x$16.high + q0.high, x$16.low + q0.low)), go$shiftRightUint64(((x$17 = (x$18 = go$mul64(un21, new Go$Uint64(1, 0)), new Go$Uint64(x$18.high + un0.high, x$18.low + un0.low)), x$19 = go$mul64(q0, v), new Go$Uint64(x$17.high - x$19.high, x$17.low - x$19.low))), s)], q = _tuple$1[0], r = _tuple$1[1];
		return [q, r];
	};
	var fadd64c = function(f, g$1, ret) {
		ret.go$set(fadd64(f, g$1));
	};
	var fsub64c = function(f, g$1, ret) {
		ret.go$set(fsub64(f, g$1));
	};
	var fmul64c = function(f, g$1, ret) {
		ret.go$set(fmul64(f, g$1));
	};
	var fdiv64c = function(f, g$1, ret) {
		ret.go$set(fdiv64(f, g$1));
	};
	var fneg64c = function(f, ret) {
		ret.go$set(fneg64(f));
	};
	var f32to64c = function(f, ret) {
		ret.go$set(f32to64(f));
	};
	var f64to32c = function(f, ret) {
		ret.go$set(f64to32(f));
	};
	var fcmp64c = function(f, g$1, ret, retnan) {
		var _tuple;
		_tuple = fcmp64(f, g$1), ret.go$set(_tuple[0]), retnan.go$set(_tuple[1]);
	};
	var fintto64c = function(val, ret) {
		ret.go$set(fintto64(val));
	};
	var f64tointc = function(f, ret, retok) {
		var _tuple;
		_tuple = f64toint(f), ret.go$set(_tuple[0]), retok.go$set(_tuple[1]);
	};
	go$pkg.init = function() {
		sizeof_C_MStats = 0;
		memStats = new MemStats.Ptr();
		precisestack = 0;
		algarray = go$makeNativeArray("Struct", 22, function() { return new alg.Ptr(); });
		startup_random_data = (go$ptrType(Go$Uint8)).nil;
		startup_random_data_len = 0;
		emptystring = "";
		zerobase = new Go$Uint64(0, 0);
		allg = (go$ptrType(g)).nil;
		lastg = (go$ptrType(g)).nil;
		allm = (go$ptrType(m)).nil;
		allp = (go$ptrType((go$ptrType(p)))).nil;
		gomaxprocs = 0;
		needextram = 0;
		panicking = 0;
		goos = (go$ptrType(Go$Int8)).nil;
		ncpu = 0;
		iscgo = 0;
		sysargs = go$throwNilPointerError;
		maxstring = new Go$Uint64(0, 0);
		hchansize = 0;
		cpuid_ecx = 0;
		cpuid_edx = 0;
		debug = new debugvars.Ptr();
		maxstacksize = new Go$Uint64(0, 0);
		blockprofilerate = new Go$Int64(0, 0);
		worldsema = 0;
		nan = 0;
		posinf = 0;
		neginf = 0;
		memstats = new mstats.Ptr();
		class_to_size = go$makeNativeArray("Int32", 61, function() { return 0; });
		class_to_allocnpages = go$makeNativeArray("Int32", 61, function() { return 0; });
		size_to_class8 = go$makeNativeArray("Int8", 129, function() { return 0; });
		size_to_class128 = go$makeNativeArray("Int8", 249, function() { return 0; });
		checking = 0;
		m0 = new m.Ptr();
		g0 = new g.Ptr();
		extram = (go$ptrType(m)).nil;
		newprocs = 0;
		scavenger = new funcval.Ptr();
		initdone = new funcval.Ptr();
		_cgo_thread_start = go$throwNilPointerError;
		prof = new _3_.Ptr();
		experiment = go$makeNativeArray("Int8", 0, function() { return 0; });
		hash = go$makeNativeArray("Ptr", 1009, function() { return (go$ptrType(itab)).nil; });
		ifacelock = new lock.Ptr();
		typelink = go$makeNativeArray("Ptr", 0, function() { return (go$ptrType(_type)).nil; });
		etypelink = go$makeNativeArray("Ptr", 0, function() { return (go$ptrType(_type)).nil; });
		empty_value = go$makeNativeArray("Uint8", 128, function() { return 0; });
		hashload = 0;

			go$throwRuntimeError = function(msg) { throw go$panic(new errorString(msg)); };
			sizeof_C_MStats = 3712;
				go$pkg.MemProfileRate = 524288;
		if (!((sizeof_C_MStats === 3712))) {
			console.log(sizeof_C_MStats, 3712);
			throw go$panic(new Go$String("MStats vs MemStatsType size mismatch"));
		}
	};
	return go$pkg;
})();
go$packages["github.com/neelance/gopherjs/js"] = (function() {
	var go$pkg = {};
	var Object;
	Object = go$newType(0, "Interface", "js.Object", "Object", "github.com/neelance/gopherjs/js", null);
	go$pkg.Object = Object;
	var Error;
	Error = go$newType(0, "Struct", "js.Error", "Error", "github.com/neelance/gopherjs/js", function(Object_) {
		this.go$val = this;
		this.Object = Object_ !== undefined ? Object_ : null;
	});
	Error.prototype.Bool = function() { return this.go$val.Bool(); };
	Error.Ptr.prototype.Bool = function() { return this.Object.Bool(); };
	Error.prototype.Call = function(name, args) { return this.go$val.Call(name, args); };
	Error.Ptr.prototype.Call = function(name, args) { return this.Object.Call(name, args); };
	Error.prototype.Float = function() { return this.go$val.Float(); };
	Error.Ptr.prototype.Float = function() { return this.Object.Float(); };
	Error.prototype.Get = function(name) { return this.go$val.Get(name); };
	Error.Ptr.prototype.Get = function(name) { return this.Object.Get(name); };
	Error.prototype.Index = function(i) { return this.go$val.Index(i); };
	Error.Ptr.prototype.Index = function(i) { return this.Object.Index(i); };
	Error.prototype.Int = function() { return this.go$val.Int(); };
	Error.Ptr.prototype.Int = function() { return this.Object.Int(); };
	Error.prototype.Interface = function() { return this.go$val.Interface(); };
	Error.Ptr.prototype.Interface = function() { return this.Object.Interface(); };
	Error.prototype.Invoke = function(args) { return this.go$val.Invoke(args); };
	Error.Ptr.prototype.Invoke = function(args) { return this.Object.Invoke(args); };
	Error.prototype.IsNull = function() { return this.go$val.IsNull(); };
	Error.Ptr.prototype.IsNull = function() { return this.Object.IsNull(); };
	Error.prototype.IsUndefined = function() { return this.go$val.IsUndefined(); };
	Error.Ptr.prototype.IsUndefined = function() { return this.Object.IsUndefined(); };
	Error.prototype.Length = function() { return this.go$val.Length(); };
	Error.Ptr.prototype.Length = function() { return this.Object.Length(); };
	Error.prototype.New = function(args) { return this.go$val.New(args); };
	Error.Ptr.prototype.New = function(args) { return this.Object.New(args); };
	Error.prototype.Set = function(name, value) { return this.go$val.Set(name, value); };
	Error.Ptr.prototype.Set = function(name, value) { return this.Object.Set(name, value); };
	Error.prototype.SetIndex = function(i, value) { return this.go$val.SetIndex(i, value); };
	Error.Ptr.prototype.SetIndex = function(i, value) { return this.Object.SetIndex(i, value); };
	Error.prototype.String = function() { return this.go$val.String(); };
	Error.Ptr.prototype.String = function() { return this.Object.String(); };
	go$pkg.Error = Error;
	Object.init([["Bool", "", (go$funcType([], [Go$Bool], false))], ["Call", "", (go$funcType([Go$String, (go$sliceType(go$emptyInterface))], [Object], true))], ["Float", "", (go$funcType([], [Go$Float64], false))], ["Get", "", (go$funcType([Go$String], [Object], false))], ["Index", "", (go$funcType([Go$Int], [Object], false))], ["Int", "", (go$funcType([], [Go$Int], false))], ["Interface", "", (go$funcType([], [go$emptyInterface], false))], ["Invoke", "", (go$funcType([(go$sliceType(go$emptyInterface))], [Object], true))], ["IsNull", "", (go$funcType([], [Go$Bool], false))], ["IsUndefined", "", (go$funcType([], [Go$Bool], false))], ["Length", "", (go$funcType([], [Go$Int], false))], ["New", "", (go$funcType([(go$sliceType(go$emptyInterface))], [Object], true))], ["Set", "", (go$funcType([Go$String, go$emptyInterface], [], false))], ["SetIndex", "", (go$funcType([Go$Int, go$emptyInterface], [], false))], ["String", "", (go$funcType([], [Go$String], false))]]);
	Error.init([["", "", Object, ""]]);
	Error.methods = [["Bool", "", [], [Go$Bool], false], ["Call", "", [Go$String, (go$sliceType(go$emptyInterface))], [Object], true], ["Float", "", [], [Go$Float64], false], ["Get", "", [Go$String], [Object], false], ["Index", "", [Go$Int], [Object], false], ["Int", "", [], [Go$Int], false], ["Interface", "", [], [go$emptyInterface], false], ["Invoke", "", [(go$sliceType(go$emptyInterface))], [Object], true], ["IsNull", "", [], [Go$Bool], false], ["IsUndefined", "", [], [Go$Bool], false], ["Length", "", [], [Go$Int], false], ["New", "", [(go$sliceType(go$emptyInterface))], [Object], true], ["Set", "", [Go$String, go$emptyInterface], [], false], ["SetIndex", "", [Go$Int, go$emptyInterface], [], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Error)).methods = [["Bool", "", [], [Go$Bool], false], ["Call", "", [Go$String, (go$sliceType(go$emptyInterface))], [Object], true], ["Error", "", [], [Go$String], false], ["Float", "", [], [Go$Float64], false], ["Get", "", [Go$String], [Object], false], ["Index", "", [Go$Int], [Object], false], ["Int", "", [], [Go$Int], false], ["Interface", "", [], [go$emptyInterface], false], ["Invoke", "", [(go$sliceType(go$emptyInterface))], [Object], true], ["IsNull", "", [], [Go$Bool], false], ["IsUndefined", "", [], [Go$Bool], false], ["Length", "", [], [Go$Int], false], ["New", "", [(go$sliceType(go$emptyInterface))], [Object], true], ["Set", "", [Go$String, go$emptyInterface], [], false], ["SetIndex", "", [Go$Int, go$emptyInterface], [], false], ["String", "", [], [Go$String], false]];
	Error.Ptr.prototype.Error = function() {
		var err;
		err = this;
		return "JavaScript error: " + go$internalize(err.Object.message, Go$String);
	};
	Error.prototype.Error = function() { return this.go$val.Error(); };
	var Global = go$pkg.Global = function(name) {
		return null;
	};
	var This = go$pkg.This = function() {
		return null;
	};
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["github.com/rusco/jquery"] = (function() {
	var go$pkg = {};
	var js = go$packages["github.com/neelance/gopherjs/js"];
	var JQuery;
	JQuery = go$newType(0, "Struct", "jquery.JQuery", "JQuery", "github.com/rusco/jquery", function(o_) {
		this.go$val = this;
		this.o = o_ !== undefined ? o_ : null;
	});
	go$pkg.JQuery = JQuery;
	var Event;
	Event = go$newType(0, "Struct", "jquery.Event", "Event", "github.com/rusco/jquery", function(Object_, This_, KeyCode_, Target_, Data_) {
		this.go$val = this;
		this.Object = Object_ !== undefined ? Object_ : null;
		this.This = This_ !== undefined ? This_ : null;
		this.KeyCode = KeyCode_ !== undefined ? KeyCode_ : 0;
		this.Target = Target_ !== undefined ? Target_ : 0;
		this.Data = Data_ !== undefined ? Data_ : null;
	});
	Event.prototype.Bool = function() { return this.go$val.Bool(); };
	Event.Ptr.prototype.Bool = function() { return this.Object.Bool(); };
	Event.prototype.Call = function(name, args) { return this.go$val.Call(name, args); };
	Event.Ptr.prototype.Call = function(name, args) { return this.Object.Call(name, args); };
	Event.prototype.Float = function() { return this.go$val.Float(); };
	Event.Ptr.prototype.Float = function() { return this.Object.Float(); };
	Event.prototype.Get = function(name) { return this.go$val.Get(name); };
	Event.Ptr.prototype.Get = function(name) { return this.Object.Get(name); };
	Event.prototype.Index = function(i) { return this.go$val.Index(i); };
	Event.Ptr.prototype.Index = function(i) { return this.Object.Index(i); };
	Event.prototype.Int = function() { return this.go$val.Int(); };
	Event.Ptr.prototype.Int = function() { return this.Object.Int(); };
	Event.prototype.Interface = function() { return this.go$val.Interface(); };
	Event.Ptr.prototype.Interface = function() { return this.Object.Interface(); };
	Event.prototype.Invoke = function(args) { return this.go$val.Invoke(args); };
	Event.Ptr.prototype.Invoke = function(args) { return this.Object.Invoke(args); };
	Event.prototype.IsNull = function() { return this.go$val.IsNull(); };
	Event.Ptr.prototype.IsNull = function() { return this.Object.IsNull(); };
	Event.prototype.IsUndefined = function() { return this.go$val.IsUndefined(); };
	Event.Ptr.prototype.IsUndefined = function() { return this.Object.IsUndefined(); };
	Event.prototype.Length = function() { return this.go$val.Length(); };
	Event.Ptr.prototype.Length = function() { return this.Object.Length(); };
	Event.prototype.New = function(args) { return this.go$val.New(args); };
	Event.Ptr.prototype.New = function(args) { return this.Object.New(args); };
	Event.prototype.Set = function(name, value) { return this.go$val.Set(name, value); };
	Event.Ptr.prototype.Set = function(name, value) { return this.Object.Set(name, value); };
	Event.prototype.SetIndex = function(i, value) { return this.go$val.SetIndex(i, value); };
	Event.Ptr.prototype.SetIndex = function(i, value) { return this.Object.SetIndex(i, value); };
	Event.prototype.String = function() { return this.go$val.String(); };
	Event.Ptr.prototype.String = function() { return this.Object.String(); };
	go$pkg.Event = Event;
	JQuery.init([["o", "github.com/rusco/jquery", js.Object, ""]]);
	(go$ptrType(JQuery)).methods = [["Add", "", [Go$String], [(go$ptrType(JQuery))], false], ["AddClass", "", [Go$String], [(go$ptrType(JQuery))], false], ["AddContext", "", [Go$String, go$emptyInterface], [(go$ptrType(JQuery))], false], ["AddElems", "", [(go$sliceType(go$emptyInterface))], [(go$ptrType(JQuery))], true], ["AddHtml", "", [Go$String], [(go$ptrType(JQuery))], false], ["AddJquery", "", [JQuery], [(go$ptrType(JQuery))], false], ["AppendTo", "", [Go$String], [(go$ptrType(JQuery))], false], ["Attr", "", [Go$String], [Go$String], false], ["Blur", "", [], [(go$ptrType(JQuery))], false], ["ClearQueue", "", [Go$String], [(go$ptrType(JQuery))], false], ["Clone", "", [], [(go$ptrType(JQuery))], false], ["CloneDeep", "", [Go$Bool, Go$Bool], [(go$ptrType(JQuery))], false], ["CloneWithDataAndEvents", "", [Go$Bool], [(go$ptrType(JQuery))], false], ["Closest", "", [Go$String], [(go$ptrType(JQuery))], false], ["Css", "", [Go$String], [Go$String], false], ["Data", "", [Go$String], [Go$String], false], ["DataByKey", "", [Go$String], [go$emptyInterface], false], ["Dequeue", "", [Go$String], [(go$ptrType(JQuery))], false], ["End", "", [], [(go$ptrType(JQuery))], false], ["Find", "", [Go$String], [(go$ptrType(JQuery))], false], ["Focus", "", [], [(go$ptrType(JQuery))], false], ["Height", "", [], [Go$Int], false], ["Hide", "", [], [(go$ptrType(JQuery))], false], ["Html", "", [], [Go$String], false], ["HtmlFn", "", [(go$funcType([Go$Int, Go$String], [Go$String], false))], [(go$ptrType(JQuery))], false], ["Jquery", "", [], [Go$String], false], ["Length", "", [], [Go$Int], false], ["Next", "", [], [(go$ptrType(JQuery))], false], ["NextSelector", "", [Go$String], [(go$ptrType(JQuery))], false], ["Off", "", [Go$String, (go$funcType([], [], false))], [(go$ptrType(JQuery))], false], ["On", "", [Go$String, (go$funcType([(go$ptrType(Event))], [], false))], [(go$ptrType(JQuery))], false], ["OnSelector", "", [Go$String, Go$String, (go$funcType([(go$ptrType(Event))], [], false))], [(go$ptrType(JQuery))], false], ["One", "", [Go$String, (go$funcType([(go$ptrType(Event))], [], false))], [(go$ptrType(JQuery))], false], ["Prop", "", [Go$String], [Go$Bool], false], ["RemoveClass", "", [Go$String], [(go$ptrType(JQuery))], false], ["RemoveData", "", [Go$String], [(go$ptrType(JQuery))], false], ["ScrollLeft", "", [], [Go$Int], false], ["ScrollTop", "", [], [Go$Int], false], ["Selector", "", [], [Go$String], false], ["SetCss", "", [go$emptyInterface, go$emptyInterface], [(go$ptrType(JQuery))], false], ["SetData", "", [Go$String, go$emptyInterface], [(go$ptrType(JQuery))], false], ["SetHeight", "", [Go$String], [(go$ptrType(JQuery))], false], ["SetHtml", "", [Go$String], [(go$ptrType(JQuery))], false], ["SetProp", "", [Go$String, Go$Bool], [(go$ptrType(JQuery))], false], ["SetScrollLeft", "", [Go$Int], [(go$ptrType(JQuery))], false], ["SetScrollTop", "", [Go$Int], [(go$ptrType(JQuery))], false], ["SetText", "", [Go$String], [(go$ptrType(JQuery))], false], ["SetVal", "", [Go$String], [(go$ptrType(JQuery))], false], ["SetWidth", "", [Go$String], [(go$ptrType(JQuery))], false], ["Show", "", [], [(go$ptrType(JQuery))], false], ["Size", "", [], [Go$Int], false], ["Text", "", [], [Go$String], false], ["TextFn", "", [(go$funcType([Go$Int, Go$String], [Go$String], false))], [(go$ptrType(JQuery))], false], ["Toggle", "", [Go$Bool], [(go$ptrType(JQuery))], false], ["ToggleClass", "", [Go$Bool], [(go$ptrType(JQuery))], false], ["ToggleClassName", "", [Go$String, Go$Bool], [(go$ptrType(JQuery))], false], ["Val", "", [], [Go$String], false], ["Width", "", [], [Go$Int], false], ["WidthFn", "", [(go$funcType([Go$Int, Go$String], [Go$String], false))], [(go$ptrType(JQuery))], false], ["addBack", "github.com/rusco/jquery", [], [(go$ptrType(JQuery))], false], ["addBackSelector", "github.com/rusco/jquery", [Go$String], [(go$ptrType(JQuery))], false], ["serialize", "github.com/rusco/jquery", [], [Go$String], false]];
	Event.init([["", "", js.Object, ""], ["This", "", js.Object, ""], ["KeyCode", "", Go$Int, "js \"keyCode\""], ["Target", "", Go$Int, "js \"target\""], ["Data", "", go$emptyInterface, "js \"data\""]]);
	Event.methods = [["Bool", "", [], [Go$Bool], false], ["Call", "", [Go$String, (go$sliceType(go$emptyInterface))], [js.Object], true], ["Float", "", [], [Go$Float64], false], ["Get", "", [Go$String], [js.Object], false], ["Index", "", [Go$Int], [js.Object], false], ["Int", "", [], [Go$Int], false], ["Interface", "", [], [go$emptyInterface], false], ["Invoke", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["IsNull", "", [], [Go$Bool], false], ["IsUndefined", "", [], [Go$Bool], false], ["Length", "", [], [Go$Int], false], ["New", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["Set", "", [Go$String, go$emptyInterface], [], false], ["SetIndex", "", [Go$Int, go$emptyInterface], [], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Event)).methods = [["Bool", "", [], [Go$Bool], false], ["Call", "", [Go$String, (go$sliceType(go$emptyInterface))], [js.Object], true], ["Float", "", [], [Go$Float64], false], ["Get", "", [Go$String], [js.Object], false], ["Index", "", [Go$Int], [js.Object], false], ["Int", "", [], [Go$Int], false], ["Interface", "", [], [go$emptyInterface], false], ["Invoke", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["IsNull", "", [], [Go$Bool], false], ["IsUndefined", "", [], [Go$Bool], false], ["Length", "", [], [Go$Int], false], ["New", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["Set", "", [Go$String, go$emptyInterface], [], false], ["SetIndex", "", [Go$Int, go$emptyInterface], [], false], ["String", "", [], [Go$String], false]];
	var NewJQuery = go$pkg.NewJQuery = function(args) {
		var _slice, _index, jQ, _slice$1, _index$1, _slice$2, _index$2, jQ$1;
		if (args.length === 1) {
			jQ = new go$global.jQuery(go$externalize((_slice = args, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), Go$String));
			return new JQuery.Ptr(jQ);
		} else if (args.length === 2) {
			jQ$1 = new go$global.jQuery(go$externalize((_slice$1 = args, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), Go$String), go$externalize((_slice$2 = args, _index$2 = 1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), Go$String));
			return new JQuery.Ptr(jQ$1);
		} else {
			return new JQuery.Ptr(new go$global.jQuery());
		}
	};
	var NewJQueryFromObject = go$pkg.NewJQueryFromObject = function(o) {
		var jQ;
		jQ = new go$global.jQuery(o);
		return new JQuery.Ptr(jQ);
	};
	var Trim = go$pkg.Trim = function(text) {
		return go$internalize(go$global.jQuery.trim(go$externalize(text, Go$String)), Go$String);
	};
	JQuery.Ptr.prototype.Jquery = function() {
		var j;
		j = this;
		return go$internalize(j.o.jquery, Go$String);
	};
	JQuery.prototype.Jquery = function() { return this.go$val.Jquery(); };
	JQuery.Ptr.prototype.Length = function() {
		var j;
		j = this;
		return go$parseInt(j.o.length) >> 0;
	};
	JQuery.prototype.Length = function() { return this.go$val.Length(); };
	JQuery.Ptr.prototype.Size = function() {
		var j;
		j = this;
		return go$parseInt(j.o.size) >> 0;
	};
	JQuery.prototype.Size = function() { return this.go$val.Size(); };
	JQuery.Ptr.prototype.Selector = function() {
		var j;
		j = this;
		return go$internalize(j.o.selector, Go$String);
	};
	JQuery.prototype.Selector = function() { return this.go$val.Selector(); };
	JQuery.Ptr.prototype.serialize = function() {
		var j;
		j = this;
		return go$internalize(j.o.serialize(), Go$String);
	};
	JQuery.prototype.serialize = function() { return this.go$val.serialize(); };
	JQuery.Ptr.prototype.addBack = function() {
		var j;
		j = this;
		j.o = j.o.addBack();
		return j;
	};
	JQuery.prototype.addBack = function() { return this.go$val.addBack(); };
	JQuery.Ptr.prototype.addBackSelector = function(selector) {
		var j;
		j = this;
		j.o = j.o.addBack(go$externalize(selector, Go$String));
		return j;
	};
	JQuery.prototype.addBackSelector = function(selector) { return this.go$val.addBackSelector(selector); };
	JQuery.Ptr.prototype.Css = function(name) {
		var j;
		j = this;
		return go$internalize(j.o.css(go$externalize(name, Go$String)), Go$String);
	};
	JQuery.prototype.Css = function(name) { return this.go$val.Css(name); };
	JQuery.Ptr.prototype.SetCss = function(name, value) {
		var j;
		j = this;
		j.o.css(go$externalize(name, go$emptyInterface), go$externalize(value, go$emptyInterface));
		return j;
	};
	JQuery.prototype.SetCss = function(name, value) { return this.go$val.SetCss(name, value); };
	JQuery.Ptr.prototype.Text = function() {
		var j;
		j = this;
		return go$internalize(j.o.text(), Go$String);
	};
	JQuery.prototype.Text = function() { return this.go$val.Text(); };
	JQuery.Ptr.prototype.SetText = function(name) {
		var j;
		j = this;
		j.o.text(go$externalize(name, Go$String));
		return j;
	};
	JQuery.prototype.SetText = function(name) { return this.go$val.SetText(name); };
	JQuery.Ptr.prototype.Val = function() {
		var j;
		j = this;
		return go$internalize(j.o.val(), Go$String);
	};
	JQuery.prototype.Val = function() { return this.go$val.Val(); };
	JQuery.Ptr.prototype.SetVal = function(name) {
		var j;
		j = this;
		j.o.val(go$externalize(name, Go$String));
		return j;
	};
	JQuery.prototype.SetVal = function(name) { return this.go$val.SetVal(name); };
	JQuery.Ptr.prototype.Prop = function(property) {
		var j;
		j = this;
		return !!(j.o.prop(go$externalize(property, Go$String)));
	};
	JQuery.prototype.Prop = function(property) { return this.go$val.Prop(property); };
	JQuery.Ptr.prototype.SetProp = function(name, value) {
		var j;
		j = this;
		j.o.prop(go$externalize(name, Go$String), go$externalize(value, Go$Bool));
		return j;
	};
	JQuery.prototype.SetProp = function(name, value) { return this.go$val.SetProp(name, value); };
	JQuery.Ptr.prototype.Attr = function(property) {
		var j;
		j = this;
		return go$internalize(j.o.attr(go$externalize(property, Go$String)), Go$String);
	};
	JQuery.prototype.Attr = function(property) { return this.go$val.Attr(property); };
	JQuery.Ptr.prototype.AddClass = function(property) {
		var j;
		j = this;
		j.o.addClass(go$externalize(property, Go$String));
		return j;
	};
	JQuery.prototype.AddClass = function(property) { return this.go$val.AddClass(property); };
	JQuery.Ptr.prototype.RemoveClass = function(property) {
		var j;
		j = this;
		j.o.removeClass(go$externalize(property, Go$String));
		return j;
	};
	JQuery.prototype.RemoveClass = function(property) { return this.go$val.RemoveClass(property); };
	JQuery.Ptr.prototype.ToggleClassName = function(className, swtch) {
		var j;
		j = this;
		j.o.toggleClass(go$externalize(className, Go$String), go$externalize(swtch, Go$Bool));
		return j;
	};
	JQuery.prototype.ToggleClassName = function(className, swtch) { return this.go$val.ToggleClassName(className, swtch); };
	JQuery.Ptr.prototype.ToggleClass = function(swtch) {
		var j;
		j = this;
		j.o.toggleClass(go$externalize(swtch, Go$Bool));
		return j;
	};
	JQuery.prototype.ToggleClass = function(swtch) { return this.go$val.ToggleClass(swtch); };
	JQuery.Ptr.prototype.Focus = function() {
		var j;
		j = this;
		j.o.focus();
		return j;
	};
	JQuery.prototype.Focus = function() { return this.go$val.Focus(); };
	JQuery.Ptr.prototype.Blur = function() {
		var j;
		j = this;
		j.o.blur();
		return j;
	};
	JQuery.prototype.Blur = function() { return this.go$val.Blur(); };
	JQuery.Ptr.prototype.On = function(event, handler) {
		var j;
		j = this;
		j.o.on(go$externalize(event, Go$String), go$externalize((function(e) {
			handler(new Event.Ptr(e, this, 0, 0, null));
		}), (go$funcType([js.Object], [], false))));
		return j;
	};
	JQuery.prototype.On = function(event, handler) { return this.go$val.On(event, handler); };
	JQuery.Ptr.prototype.OnSelector = function(event, selector, handler) {
		var j;
		j = this;
		j.o.on(go$externalize(event, Go$String), go$externalize(selector, Go$String), go$externalize((function(e) {
			handler(new Event.Ptr(e, this, 0, 0, null));
		}), (go$funcType([js.Object], [], false))));
		return j;
	};
	JQuery.prototype.OnSelector = function(event, selector, handler) { return this.go$val.OnSelector(event, selector, handler); };
	JQuery.Ptr.prototype.One = function(event, handler) {
		var j;
		j = this;
		j.o.one(go$externalize(event, Go$String), go$externalize((function(e) {
			handler(new Event.Ptr(e, this, 0, 0, null));
		}), (go$funcType([js.Object], [], false))));
		return j;
	};
	JQuery.prototype.One = function(event, handler) { return this.go$val.One(event, handler); };
	JQuery.Ptr.prototype.Off = function(event, handler) {
		var j;
		j = this;
		j.o.off(go$externalize(event, Go$String), go$externalize((function() {
			handler();
		}), (go$funcType([], [], false))));
		return j;
	};
	JQuery.prototype.Off = function(event, handler) { return this.go$val.Off(event, handler); };
	JQuery.Ptr.prototype.AppendTo = function(destination) {
		var j;
		j = this;
		j.o.appendTo(go$externalize(destination, Go$String));
		return j;
	};
	JQuery.prototype.AppendTo = function(destination) { return this.go$val.AppendTo(destination); };
	JQuery.Ptr.prototype.Toggle = function(showOrHide) {
		var j;
		j = this;
		j.o.toggle(go$externalize(showOrHide, Go$Bool));
		return j;
	};
	JQuery.prototype.Toggle = function(showOrHide) { return this.go$val.Toggle(showOrHide); };
	JQuery.Ptr.prototype.Show = function() {
		var j;
		j = this;
		j.o.show();
		return j;
	};
	JQuery.prototype.Show = function() { return this.go$val.Show(); };
	JQuery.Ptr.prototype.Hide = function() {
		var j;
		j = this;
		j.o.hide();
		return j;
	};
	JQuery.prototype.Hide = function() { return this.go$val.Hide(); };
	JQuery.Ptr.prototype.Html = function() {
		var j;
		j = this;
		return go$internalize(j.o.html(), Go$String);
	};
	JQuery.prototype.Html = function() { return this.go$val.Html(); };
	JQuery.Ptr.prototype.SetHtml = function(html) {
		var j;
		j = this;
		j.o.html(go$externalize(html, Go$String));
		return j;
	};
	JQuery.prototype.SetHtml = function(html) { return this.go$val.SetHtml(html); };
	JQuery.Ptr.prototype.HtmlFn = function(fn) {
		var j;
		j = this;
		j.o.html(go$externalize((function(idx, txt) {
			return fn(idx, txt);
		}), (go$funcType([Go$Int, Go$String], [Go$String], false))));
		return j;
	};
	JQuery.prototype.HtmlFn = function(fn) { return this.go$val.HtmlFn(fn); };
	JQuery.Ptr.prototype.TextFn = function(fn) {
		var j;
		j = this;
		j.o.text(go$externalize((function(idx, txt) {
			return fn(idx, txt);
		}), (go$funcType([Go$Int, Go$String], [Go$String], false))));
		return j;
	};
	JQuery.prototype.TextFn = function(fn) { return this.go$val.TextFn(fn); };
	JQuery.Ptr.prototype.Find = function(selector) {
		var j, found;
		j = this;
		found = j.o.find(go$externalize(selector, Go$String));
		return new JQuery.Ptr(found);
	};
	JQuery.prototype.Find = function(selector) { return this.go$val.Find(selector); };
	JQuery.Ptr.prototype.Closest = function(selector) {
		var j, closest;
		j = this;
		closest = j.o.closest(go$externalize(selector, Go$String));
		return new JQuery.Ptr(closest);
	};
	JQuery.prototype.Closest = function(selector) { return this.go$val.Closest(selector); };
	JQuery.Ptr.prototype.End = function() {
		var j;
		j = this;
		j.o = j.o.end();
		return j;
	};
	JQuery.prototype.End = function() { return this.go$val.End(); };
	JQuery.Ptr.prototype.Add = function(selector) {
		var j;
		j = this;
		j.o = j.o.add(go$externalize(selector, Go$String));
		return j;
	};
	JQuery.prototype.Add = function(selector) { return this.go$val.Add(selector); };
	JQuery.Ptr.prototype.AddContext = function(selector, context) {
		var j;
		j = this;
		j.o = j.o.add(go$externalize(selector, Go$String), go$externalize(context, go$emptyInterface));
		return j;
	};
	JQuery.prototype.AddContext = function(selector, context) { return this.go$val.AddContext(selector, context); };
	JQuery.Ptr.prototype.AddElems = function(elements) {
		var j, obj;
		j = this;
		j.o = (obj = j.o, obj.add.apply(obj, go$externalize(elements, (go$sliceType(go$emptyInterface)))));
		return j;
	};
	JQuery.prototype.AddElems = function(elements) { return this.go$val.AddElems(elements); };
	JQuery.Ptr.prototype.AddHtml = function(html) {
		var j;
		j = this;
		j.o = j.o.add(go$externalize(html, Go$String));
		return j;
	};
	JQuery.prototype.AddHtml = function(html) { return this.go$val.AddHtml(html); };
	JQuery.Ptr.prototype.AddJquery = function(obj) {
		var j;
		j = this;
		j.o = j.o.add(go$externalize(obj, JQuery));
		return j;
	};
	JQuery.prototype.AddJquery = function(obj) { return this.go$val.AddJquery(obj); };
	JQuery.Ptr.prototype.Clone = function() {
		var j;
		j = this;
		j.o = j.o.clone();
		return j;
	};
	JQuery.prototype.Clone = function() { return this.go$val.Clone(); };
	JQuery.Ptr.prototype.CloneWithDataAndEvents = function(withDataAndEvents) {
		var j;
		j = this;
		j.o = j.o.clone(go$externalize(withDataAndEvents, Go$Bool));
		return j;
	};
	JQuery.prototype.CloneWithDataAndEvents = function(withDataAndEvents) { return this.go$val.CloneWithDataAndEvents(withDataAndEvents); };
	JQuery.Ptr.prototype.CloneDeep = function(withDataAndEvents, deepWithDataAndEvents) {
		var j;
		j = this;
		j.o = j.o.clone(go$externalize(withDataAndEvents, Go$Bool), go$externalize(deepWithDataAndEvents, Go$Bool));
		return j;
	};
	JQuery.prototype.CloneDeep = function(withDataAndEvents, deepWithDataAndEvents) { return this.go$val.CloneDeep(withDataAndEvents, deepWithDataAndEvents); };
	JQuery.Ptr.prototype.Next = function() {
		var j;
		j = this;
		j.o = j.o.next();
		return j;
	};
	JQuery.prototype.Next = function() { return this.go$val.Next(); };
	JQuery.Ptr.prototype.NextSelector = function(selector) {
		var j;
		j = this;
		j.o = j.o.next(go$externalize(selector, Go$String));
		return j;
	};
	JQuery.prototype.NextSelector = function(selector) { return this.go$val.NextSelector(selector); };
	JQuery.Ptr.prototype.Height = function() {
		var j;
		j = this;
		return go$parseInt(j.o.height()) >> 0;
	};
	JQuery.prototype.Height = function() { return this.go$val.Height(); };
	JQuery.Ptr.prototype.SetHeight = function(value) {
		var j;
		j = this;
		j.o = j.o.height(go$externalize(value, Go$String));
		return j;
	};
	JQuery.prototype.SetHeight = function(value) { return this.go$val.SetHeight(value); };
	JQuery.Ptr.prototype.ScrollLeft = function() {
		var j;
		j = this;
		return go$parseInt(j.o.scrollLeft()) >> 0;
	};
	JQuery.prototype.ScrollLeft = function() { return this.go$val.ScrollLeft(); };
	JQuery.Ptr.prototype.SetScrollLeft = function(value) {
		var j;
		j = this;
		j.o = j.o.scrollLeft(value);
		return j;
	};
	JQuery.prototype.SetScrollLeft = function(value) { return this.go$val.SetScrollLeft(value); };
	JQuery.Ptr.prototype.ScrollTop = function() {
		var j;
		j = this;
		return go$parseInt(j.o.scrollTop()) >> 0;
	};
	JQuery.prototype.ScrollTop = function() { return this.go$val.ScrollTop(); };
	JQuery.Ptr.prototype.SetScrollTop = function(value) {
		var j;
		j = this;
		j.o = j.o.scrollTop(value);
		return j;
	};
	JQuery.prototype.SetScrollTop = function(value) { return this.go$val.SetScrollTop(value); };
	JQuery.Ptr.prototype.Width = function() {
		var j;
		j = this;
		return go$parseInt(j.o.scrollTop()) >> 0;
	};
	JQuery.prototype.Width = function() { return this.go$val.Width(); };
	JQuery.Ptr.prototype.SetWidth = function(value) {
		var j;
		j = this;
		j.o = j.o.scrollTop(go$externalize(value, Go$String));
		return j;
	};
	JQuery.prototype.SetWidth = function(value) { return this.go$val.SetWidth(value); };
	JQuery.Ptr.prototype.WidthFn = function(fn) {
		var j;
		j = this;
		j.o.width(go$externalize((function(index, width) {
			return fn(index, width);
		}), (go$funcType([Go$Int, Go$String], [Go$String], false))));
		return j;
	};
	JQuery.prototype.WidthFn = function(fn) { return this.go$val.WidthFn(fn); };
	JQuery.Ptr.prototype.ClearQueue = function(queueName) {
		var j;
		j = this;
		j.o = j.o.clearQueue(go$externalize(queueName, Go$String));
		return j;
	};
	JQuery.prototype.ClearQueue = function(queueName) { return this.go$val.ClearQueue(queueName); };
	JQuery.Ptr.prototype.SetData = function(key, value) {
		var j;
		j = this;
		j.o = j.o.data(go$externalize(key, Go$String), go$externalize(value, go$emptyInterface));
		return j;
	};
	JQuery.prototype.SetData = function(key, value) { return this.go$val.SetData(key, value); };
	JQuery.Ptr.prototype.DataByKey = function(key) {
		var j;
		j = this;
		return go$internalize(j.o.data(go$externalize(key, Go$String)), go$emptyInterface);
	};
	JQuery.prototype.DataByKey = function(key) { return this.go$val.DataByKey(key); };
	JQuery.Ptr.prototype.Data = function(key) {
		var j;
		j = this;
		return go$internalize(j.o.data(go$externalize(key, Go$String)), Go$String);
	};
	JQuery.prototype.Data = function(key) { return this.go$val.Data(key); };
	JQuery.Ptr.prototype.Dequeue = function(queueName) {
		var j;
		j = this;
		j.o = j.o.dequeue(go$externalize(queueName, Go$String));
		return j;
	};
	JQuery.prototype.Dequeue = function(queueName) { return this.go$val.Dequeue(queueName); };
	JQuery.Ptr.prototype.RemoveData = function(name) {
		var j;
		j = this;
		j.o = j.o.removeData(go$externalize(name, Go$String));
		return j;
	};
	JQuery.prototype.RemoveData = function(name) { return this.go$val.RemoveData(name); };
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["errors"] = (function() {
	var go$pkg = {};
	var errorString;
	errorString = go$newType(0, "Struct", "errors.errorString", "errorString", "errors", function(s_) {
		this.go$val = this;
		this.s = s_ !== undefined ? s_ : "";
	});
	go$pkg.errorString = errorString;
	errorString.init([["s", "errors", Go$String, ""]]);
	(go$ptrType(errorString)).methods = [["Error", "", [], [Go$String], false]];
	var New = go$pkg.New = function(text) {
		return new errorString.Ptr(text);
	};
	errorString.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.s;
	};
	errorString.prototype.Error = function() { return this.go$val.Error(); };
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["sync/atomic"] = (function() {
	var go$pkg = {};
	var SwapInt32 = go$pkg.SwapInt32 = function(addr, newVal) {
		var value = addr.go$get();
		addr.go$set(newVal);
		return value;
	};
	var SwapInt64 = go$pkg.SwapInt64 = function(addr, newVal) {
		var value = addr.go$get();
		addr.go$set(newVal);
		return value;
	};
	var SwapUint32 = go$pkg.SwapUint32 = function(addr, newVal) {
		var value = addr.go$get();
		addr.go$set(newVal);
		return value;
	};
	var SwapUint64 = go$pkg.SwapUint64 = function(addr, newVal) {
		var value = addr.go$get();
		addr.go$set(newVal);
		return value;
	};
	var SwapUintptr = go$pkg.SwapUintptr = function(addr, newVal) {
		var value = addr.go$get();
		addr.go$set(newVal);
		return value;
	};
	var SwapPointer = go$pkg.SwapPointer = function(addr, newVal) {
		var value = addr.go$get();
		addr.go$set(newVal);
		return value;
	};
	var CompareAndSwapInt32 = go$pkg.CompareAndSwapInt32 = function(addr, oldVal, newVal) {
		if (addr.go$get() === oldVal) {
			addr.go$set(newVal);
			return true;
		}
		return false;
	};
	var CompareAndSwapInt64 = go$pkg.CompareAndSwapInt64 = function(addr, oldVal, newVal) {
		if (addr.go$get() === oldVal) {
			addr.go$set(newVal);
			return true;
		}
		return false;
	};
	var CompareAndSwapUint32 = go$pkg.CompareAndSwapUint32 = function(addr, oldVal, newVal) {
		if (addr.go$get() === oldVal) {
			addr.go$set(newVal);
			return true;
		}
		return false;
	};
	var CompareAndSwapUint64 = go$pkg.CompareAndSwapUint64 = function(addr, oldVal, newVal) {
		if (addr.go$get() === oldVal) {
			addr.go$set(newVal);
			return true;
		}
		return false;
	};
	var CompareAndSwapUintptr = go$pkg.CompareAndSwapUintptr = function(addr, oldVal, newVal) {
		if (addr.go$get() === oldVal) {
			addr.go$set(newVal);
			return true;
		}
		return false;
	};
	var CompareAndSwapPointer = go$pkg.CompareAndSwapPointer = function(addr, oldVal, newVal) {
		if (addr.go$get() === oldVal) {
			addr.go$set(newVal);
			return true;
		}
		return false;
	};
	var AddInt32 = go$pkg.AddInt32 = function(addr, delta) {
		var value = addr.go$get() + delta;
		addr.go$set(value);
		return value;
	};
	var AddUint32 = go$pkg.AddUint32 = function(addr, delta) {
		var value = addr.go$get() + delta;
		addr.go$set(value);
		return value;
	};
	var AddInt64 = go$pkg.AddInt64 = function(addr, delta) {
		var value = addr.go$get();
		value = new value.constructor(value.high + delta.high, value.low + delta.low);
		addr.go$set(value);
		return value;
	};
	var AddUint64 = go$pkg.AddUint64 = function(addr, delta) {
		var value = addr.go$get();
		value = new value.constructor(value.high + delta.high, value.low + delta.low);
		addr.go$set(value);
		return value;
	};
	var AddUintptr = go$pkg.AddUintptr = function(addr, delta) {
		var value = addr.go$get() + delta;
		addr.go$set(value);
		return value;
	};
	var LoadInt32 = go$pkg.LoadInt32 = function(addr) {
		return addr.go$get();
	};
	var LoadInt64 = go$pkg.LoadInt64 = function(addr) {
		return addr.go$get();
	};
	var LoadUint32 = go$pkg.LoadUint32 = function(addr) {
		return addr.go$get();
	};
	var LoadUint64 = go$pkg.LoadUint64 = function(addr) {
		return addr.go$get();
	};
	var LoadUintptr = go$pkg.LoadUintptr = function(addr) {
		return addr.go$get();
	};
	var LoadPointer = go$pkg.LoadPointer = function(addr) {
		return addr.go$get();
	};
	var StoreInt32 = go$pkg.StoreInt32 = function(addr, val) {
		addr.go$set(val);
	};
	var StoreInt64 = go$pkg.StoreInt64 = function(addr, val) {
		addr.go$set(val);
	};
	var StoreUint32 = go$pkg.StoreUint32 = function(addr, val) {
		addr.go$set(val);
	};
	var StoreUint64 = go$pkg.StoreUint64 = function(addr, val) {
		addr.go$set(val);
	};
	var StoreUintptr = go$pkg.StoreUintptr = function(addr, val) {
		addr.go$set(val);
	};
	var StorePointer = go$pkg.StorePointer = function(addr, val) {
		addr.go$set(val);
	};
	var panic64 = function() {
		throw go$panic(new Go$String("sync/atomic: broken 64-bit atomic operations (buggy QEMU)"));
	};
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["sync"] = (function() {
	var go$pkg = {};
	var atomic = go$packages["sync/atomic"];
	var Cond;
	Cond = go$newType(0, "Struct", "sync.Cond", "Cond", "sync", function(L_, sema_, waiters_, checker_) {
		this.go$val = this;
		this.L = L_ !== undefined ? L_ : null;
		this.sema = sema_ !== undefined ? sema_ : go$makeNativeArray("Uintptr", 3, function() { return 0; });
		this.waiters = waiters_ !== undefined ? waiters_ : 0;
		this.checker = checker_ !== undefined ? checker_ : 0;
	});
	go$pkg.Cond = Cond;
	var copyChecker;
	copyChecker = go$newType(4, "Uintptr", "sync.copyChecker", "copyChecker", "sync", null);
	go$pkg.copyChecker = copyChecker;
	var Mutex;
	Mutex = go$newType(0, "Struct", "sync.Mutex", "Mutex", "sync", function(state_, sema_) {
		this.go$val = this;
		this.state = state_ !== undefined ? state_ : 0;
		this.sema = sema_ !== undefined ? sema_ : 0;
	});
	go$pkg.Mutex = Mutex;
	var Locker;
	Locker = go$newType(0, "Interface", "sync.Locker", "Locker", "sync", null);
	go$pkg.Locker = Locker;
	var Once;
	Once = go$newType(0, "Struct", "sync.Once", "Once", "sync", function(m_, done_) {
		this.go$val = this;
		this.m = m_ !== undefined ? m_ : new Mutex.Ptr();
		this.done = done_ !== undefined ? done_ : 0;
	});
	go$pkg.Once = Once;
	var syncSema;
	syncSema = go$newType(0, "Array", "sync.syncSema", "syncSema", "sync", null);
	go$pkg.syncSema = syncSema;
	var RWMutex;
	RWMutex = go$newType(0, "Struct", "sync.RWMutex", "RWMutex", "sync", function(w_, writerSem_, readerSem_, readerCount_, readerWait_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : new Mutex.Ptr();
		this.writerSem = writerSem_ !== undefined ? writerSem_ : 0;
		this.readerSem = readerSem_ !== undefined ? readerSem_ : 0;
		this.readerCount = readerCount_ !== undefined ? readerCount_ : 0;
		this.readerWait = readerWait_ !== undefined ? readerWait_ : 0;
	});
	go$pkg.RWMutex = RWMutex;
	var rlocker;
	rlocker = go$newType(0, "Struct", "sync.rlocker", "rlocker", "sync", function(w_, writerSem_, readerSem_, readerCount_, readerWait_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : new Mutex.Ptr();
		this.writerSem = writerSem_ !== undefined ? writerSem_ : 0;
		this.readerSem = readerSem_ !== undefined ? readerSem_ : 0;
		this.readerCount = readerCount_ !== undefined ? readerCount_ : 0;
		this.readerWait = readerWait_ !== undefined ? readerWait_ : 0;
	});
	go$pkg.rlocker = rlocker;
	var WaitGroup;
	WaitGroup = go$newType(0, "Struct", "sync.WaitGroup", "WaitGroup", "sync", function(m_, counter_, waiters_, sema_) {
		this.go$val = this;
		this.m = m_ !== undefined ? m_ : new Mutex.Ptr();
		this.counter = counter_ !== undefined ? counter_ : 0;
		this.waiters = waiters_ !== undefined ? waiters_ : 0;
		this.sema = sema_ !== undefined ? sema_ : (go$ptrType(Go$Uint32)).nil;
	});
	go$pkg.WaitGroup = WaitGroup;
	Cond.init([["L", "", Locker, ""], ["sema", "sync", syncSema, ""], ["waiters", "sync", Go$Uint32, ""], ["checker", "sync", copyChecker, ""]]);
	(go$ptrType(Cond)).methods = [["Broadcast", "", [], [], false], ["Signal", "", [], [], false], ["Wait", "", [], [], false], ["signalImpl", "sync", [Go$Bool], [], false]];
	(go$ptrType(copyChecker)).methods = [["check", "sync", [], [], false]];
	Mutex.init([["state", "sync", Go$Int32, ""], ["sema", "sync", Go$Uint32, ""]]);
	(go$ptrType(Mutex)).methods = [["Lock", "", [], [], false], ["Unlock", "", [], [], false]];
	Locker.init([["Lock", "", (go$funcType([], [], false))], ["Unlock", "", (go$funcType([], [], false))]]);
	Once.init([["m", "sync", Mutex, ""], ["done", "sync", Go$Uint32, ""]]);
	(go$ptrType(Once)).methods = [["Do", "", [(go$funcType([], [], false))], [], false]];
	syncSema.init(Go$Uintptr, 3);
	RWMutex.init([["w", "sync", Mutex, ""], ["writerSem", "sync", Go$Uint32, ""], ["readerSem", "sync", Go$Uint32, ""], ["readerCount", "sync", Go$Int32, ""], ["readerWait", "sync", Go$Int32, ""]]);
	(go$ptrType(RWMutex)).methods = [["Lock", "", [], [], false], ["RLock", "", [], [], false], ["RLocker", "", [], [Locker], false], ["RUnlock", "", [], [], false], ["Unlock", "", [], [], false]];
	rlocker.init([["w", "sync", Mutex, ""], ["writerSem", "sync", Go$Uint32, ""], ["readerSem", "sync", Go$Uint32, ""], ["readerCount", "sync", Go$Int32, ""], ["readerWait", "sync", Go$Int32, ""]]);
	(go$ptrType(rlocker)).methods = [["Lock", "", [], [], false], ["Unlock", "", [], [], false]];
	WaitGroup.init([["m", "sync", Mutex, ""], ["counter", "sync", Go$Int32, ""], ["waiters", "sync", Go$Int32, ""], ["sema", "sync", (go$ptrType(Go$Uint32)), ""]]);
	(go$ptrType(WaitGroup)).methods = [["Add", "", [Go$Int], [], false], ["Done", "", [], [], false], ["Wait", "", [], [], false]];
	var NewCond = go$pkg.NewCond = function(l) {
		return new Cond.Ptr(l, go$makeNativeArray("Uintptr", 3, function() { return 0; }), 0, 0);
	};
	Cond.Ptr.prototype.Wait = function() {
		var c, v, v$1;
		c = this;
		(new (go$ptrType(copyChecker))(function() { return c.checker; }, function(v) { c.checker = v; })).check();
		atomic.AddUint32(new (go$ptrType(Go$Uint32))(function() { return c.waiters; }, function(v$1) { c.waiters = v$1; }), 1);
		c.L.Unlock();
		runtime_Syncsemacquire(c.sema);
		c.L.Lock();
	};
	Cond.prototype.Wait = function() { return this.go$val.Wait(); };
	Cond.Ptr.prototype.Signal = function() {
		var c;
		c = this;
		c.signalImpl(false);
	};
	Cond.prototype.Signal = function() { return this.go$val.Signal(); };
	Cond.Ptr.prototype.Broadcast = function() {
		var c;
		c = this;
		c.signalImpl(true);
	};
	Cond.prototype.Broadcast = function() { return this.go$val.Broadcast(); };
	Cond.Ptr.prototype.signalImpl = function(all) {
		var c, v, v$1, old, new$1, v$2;
		c = this;
		(new (go$ptrType(copyChecker))(function() { return c.checker; }, function(v) { c.checker = v; })).check();
		while (true) {
			old = atomic.LoadUint32(new (go$ptrType(Go$Uint32))(function() { return c.waiters; }, function(v$1) { c.waiters = v$1; }));
			if (old === 0) {
				return;
			}
			new$1 = old - 1 >>> 0;
			if (all) {
				new$1 = 0;
			}
			if (atomic.CompareAndSwapUint32(new (go$ptrType(Go$Uint32))(function() { return c.waiters; }, function(v$2) { c.waiters = v$2; }), old, new$1)) {
				runtime_Syncsemrelease(c.sema, old - new$1 >>> 0);
				return;
			}
		}
	};
	Cond.prototype.signalImpl = function(all) { return this.go$val.signalImpl(all); };
	go$ptrType(copyChecker).prototype.check = function() {};
	copyChecker.prototype.check = function() { var obj = this.go$val; return (new (go$ptrType(copyChecker))(function() { return obj; }, null)).check(); };
	Mutex.Ptr.prototype.Lock = function() {
		var m, v, awoke, old, new$1, v$1, v$2;
		m = this;
		if (atomic.CompareAndSwapInt32(new (go$ptrType(Go$Int32))(function() { return m.state; }, function(v) { m.state = v; }), 0, 1)) {
			return;
		}
		awoke = false;
		while (true) {
			old = m.state;
			new$1 = old | 1;
			if (!(((old & 1) === 0))) {
				new$1 = old + 4 >> 0;
			}
			if (awoke) {
				new$1 = new$1 & ~2;
			}
			if (atomic.CompareAndSwapInt32(new (go$ptrType(Go$Int32))(function() { return m.state; }, function(v$1) { m.state = v$1; }), old, new$1)) {
				if ((old & 1) === 0) {
					break;
				}
				runtime_Semacquire(new (go$ptrType(Go$Uint32))(function() { return m.sema; }, function(v$2) { m.sema = v$2; }));
				awoke = true;
			}
		}
	};
	Mutex.prototype.Lock = function() { return this.go$val.Lock(); };
	Mutex.Ptr.prototype.Unlock = function() {
		var m, v, new$1, old, v$1, v$2;
		m = this;
		new$1 = atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return m.state; }, function(v) { m.state = v; }), -1);
		if ((((new$1 + 1 >> 0)) & 1) === 0) {
			throw go$panic(new Go$String("sync: unlock of unlocked mutex"));
		}
		old = new$1;
		while (true) {
			if (((old >> 2 >> 0) === 0) || !(((old & 3) === 0))) {
				return;
			}
			new$1 = ((old - 4 >> 0)) | 2;
			if (atomic.CompareAndSwapInt32(new (go$ptrType(Go$Int32))(function() { return m.state; }, function(v$1) { m.state = v$1; }), old, new$1)) {
				runtime_Semrelease(new (go$ptrType(Go$Uint32))(function() { return m.sema; }, function(v$2) { m.sema = v$2; }));
				return;
			}
			old = m.state;
		}
	};
	Mutex.prototype.Unlock = function() { return this.go$val.Unlock(); };
	Once.Ptr.prototype.Do = function(f) {
		var o, v, v$1;
		var go$deferred = [];
		try {
			o = this;
			if (atomic.LoadUint32(new (go$ptrType(Go$Uint32))(function() { return o.done; }, function(v) { o.done = v; })) === 1) {
				return;
			}
			o.m.Lock();
			go$deferred.push({ recv: o.m, method: "Unlock", args: [] });
			if (o.done === 0) {
				f();
				atomic.StoreUint32(new (go$ptrType(Go$Uint32))(function() { return o.done; }, function(v$1) { o.done = v$1; }), 1);
			}
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	Once.prototype.Do = function(f) { return this.go$val.Do(f); };
	var raceAcquire = function(addr) {
	};
	var raceRelease = function(addr) {
	};
	var raceReleaseMerge = function(addr) {
	};
	var raceDisable = function() {
	};
	var raceEnable = function() {
	};
	var raceRead = function(addr) {
	};
	var raceWrite = function(addr) {
	};
	var runtime_Semacquire = function(s) {
		throw go$panic("Native function not implemented: runtime_Semacquire");
	};
	var runtime_Semrelease = function(s) {
		throw go$panic("Native function not implemented: runtime_Semrelease");
	};
	var runtime_Syncsemacquire = function(s) {
		throw go$panic("Native function not implemented: runtime_Syncsemacquire");
	};
	var runtime_Syncsemrelease = function(s, n) {
		throw go$panic("Native function not implemented: runtime_Syncsemrelease");
	};
	var runtime_Syncsemcheck = function() {};
	RWMutex.Ptr.prototype.RLock = function() {
		var rw, v, v$1;
		rw = this;
		if (atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return rw.readerCount; }, function(v) { rw.readerCount = v; }), 1) < 0) {
			runtime_Semacquire(new (go$ptrType(Go$Uint32))(function() { return rw.readerSem; }, function(v$1) { rw.readerSem = v$1; }));
		}
	};
	RWMutex.prototype.RLock = function() { return this.go$val.RLock(); };
	RWMutex.Ptr.prototype.RUnlock = function() {
		var rw, v, v$1, v$2;
		rw = this;
		if (atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return rw.readerCount; }, function(v) { rw.readerCount = v; }), -1) < 0) {
			if (atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return rw.readerWait; }, function(v$1) { rw.readerWait = v$1; }), -1) === 0) {
				runtime_Semrelease(new (go$ptrType(Go$Uint32))(function() { return rw.writerSem; }, function(v$2) { rw.writerSem = v$2; }));
			}
		}
	};
	RWMutex.prototype.RUnlock = function() { return this.go$val.RUnlock(); };
	RWMutex.Ptr.prototype.Lock = function() {
		var rw, v, r, v$1, v$2;
		rw = this;
		rw.w.Lock();
		r = atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return rw.readerCount; }, function(v) { rw.readerCount = v; }), -1073741824) + 1073741824 >> 0;
		if (!((r === 0)) && !((atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return rw.readerWait; }, function(v$1) { rw.readerWait = v$1; }), r) === 0))) {
			runtime_Semacquire(new (go$ptrType(Go$Uint32))(function() { return rw.writerSem; }, function(v$2) { rw.writerSem = v$2; }));
		}
	};
	RWMutex.prototype.Lock = function() { return this.go$val.Lock(); };
	RWMutex.Ptr.prototype.Unlock = function() {
		var rw, v, r, i, v$1;
		rw = this;
		r = atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return rw.readerCount; }, function(v) { rw.readerCount = v; }), 1073741824);
		i = 0;
		while (i < (r >> 0)) {
			runtime_Semrelease(new (go$ptrType(Go$Uint32))(function() { return rw.readerSem; }, function(v$1) { rw.readerSem = v$1; }));
			i = i + 1 >> 0;
		}
		rw.w.Unlock();
	};
	RWMutex.prototype.Unlock = function() { return this.go$val.Unlock(); };
	RWMutex.Ptr.prototype.RLocker = function() {
		var rw, _struct, _struct$1;
		rw = this;
		return (_struct = rw, new rlocker.Ptr((_struct$1 = _struct.w, new Mutex.Ptr(_struct$1.state, _struct$1.sema)), _struct.writerSem, _struct.readerSem, _struct.readerCount, _struct.readerWait));
	};
	RWMutex.prototype.RLocker = function() { return this.go$val.RLocker(); };
	rlocker.Ptr.prototype.Lock = function() {
		var r, _struct, _struct$1;
		r = this;
		(_struct = r, new RWMutex.Ptr((_struct$1 = _struct.w, new Mutex.Ptr(_struct$1.state, _struct$1.sema)), _struct.writerSem, _struct.readerSem, _struct.readerCount, _struct.readerWait)).RLock();
	};
	rlocker.prototype.Lock = function() { return this.go$val.Lock(); };
	rlocker.Ptr.prototype.Unlock = function() {
		var r, _struct, _struct$1;
		r = this;
		(_struct = r, new RWMutex.Ptr((_struct$1 = _struct.w, new Mutex.Ptr(_struct$1.state, _struct$1.sema)), _struct.writerSem, _struct.readerSem, _struct.readerCount, _struct.readerWait)).RUnlock();
	};
	rlocker.prototype.Unlock = function() { return this.go$val.Unlock(); };
	WaitGroup.Ptr.prototype.Add = function(delta) {
		var wg, v, v$1, v$2, i;
		var go$deferred = [];
		try {
			wg = this;
			v$1 = atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return wg.counter; }, function(v) { wg.counter = v; }), (delta >> 0));
			if (v$1 < 0) {
				throw go$panic(new Go$String("sync: negative WaitGroup counter"));
			}
			if (v$1 > 0 || (atomic.LoadInt32(new (go$ptrType(Go$Int32))(function() { return wg.waiters; }, function(v$2) { wg.waiters = v$2; })) === 0)) {
				return;
			}
			wg.m.Lock();
			i = 0;
			while (i < wg.waiters) {
				runtime_Semrelease(wg.sema);
				i = i + 1 >> 0;
			}
			wg.waiters = 0;
			wg.sema = (go$ptrType(Go$Uint32)).nil;
			wg.m.Unlock();
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	WaitGroup.prototype.Add = function(delta) { return this.go$val.Add(delta); };
	WaitGroup.Ptr.prototype.Done = function() {
		var wg;
		wg = this;
		wg.Add(-1);
	};
	WaitGroup.prototype.Done = function() { return this.go$val.Done(); };
	WaitGroup.Ptr.prototype.Wait = function() {
		var wg, v, v$1, w, v$2, v$3, s;
		wg = this;
		if (atomic.LoadInt32(new (go$ptrType(Go$Int32))(function() { return wg.counter; }, function(v) { wg.counter = v; })) === 0) {
			return;
		}
		wg.m.Lock();
		w = atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return wg.waiters; }, function(v$1) { wg.waiters = v$1; }), 1);
		if (atomic.LoadInt32(new (go$ptrType(Go$Int32))(function() { return wg.counter; }, function(v$2) { wg.counter = v$2; })) === 0) {
			atomic.AddInt32(new (go$ptrType(Go$Int32))(function() { return wg.waiters; }, function(v$3) { wg.waiters = v$3; }), -1);
			wg.m.Unlock();
			return;
		}
		if (go$pointerIsEqual(wg.sema, (go$ptrType(Go$Uint32)).nil)) {
			wg.sema = go$newDataPointer(0, (go$ptrType(Go$Uint32)));
		}
		s = wg.sema;
		wg.m.Unlock();
		runtime_Semacquire(s);
	};
	WaitGroup.prototype.Wait = function() { return this.go$val.Wait(); };
	go$pkg.init = function() {
		var s;
		s = go$makeNativeArray("Uintptr", 3, function() { return 0; });
		runtime_Syncsemcheck(12);
	};
	return go$pkg;
})();
go$packages["io"] = (function() {
	var go$pkg = {};
	var errors = go$packages["errors"];
	var sync = go$packages["sync"];
	var Reader;
	Reader = go$newType(0, "Interface", "io.Reader", "Reader", "io", null);
	go$pkg.Reader = Reader;
	var Writer;
	Writer = go$newType(0, "Interface", "io.Writer", "Writer", "io", null);
	go$pkg.Writer = Writer;
	var Closer;
	Closer = go$newType(0, "Interface", "io.Closer", "Closer", "io", null);
	go$pkg.Closer = Closer;
	var Seeker;
	Seeker = go$newType(0, "Interface", "io.Seeker", "Seeker", "io", null);
	go$pkg.Seeker = Seeker;
	var ReadWriter;
	ReadWriter = go$newType(0, "Interface", "io.ReadWriter", "ReadWriter", "io", null);
	go$pkg.ReadWriter = ReadWriter;
	var ReadCloser;
	ReadCloser = go$newType(0, "Interface", "io.ReadCloser", "ReadCloser", "io", null);
	go$pkg.ReadCloser = ReadCloser;
	var WriteCloser;
	WriteCloser = go$newType(0, "Interface", "io.WriteCloser", "WriteCloser", "io", null);
	go$pkg.WriteCloser = WriteCloser;
	var ReadWriteCloser;
	ReadWriteCloser = go$newType(0, "Interface", "io.ReadWriteCloser", "ReadWriteCloser", "io", null);
	go$pkg.ReadWriteCloser = ReadWriteCloser;
	var ReadSeeker;
	ReadSeeker = go$newType(0, "Interface", "io.ReadSeeker", "ReadSeeker", "io", null);
	go$pkg.ReadSeeker = ReadSeeker;
	var WriteSeeker;
	WriteSeeker = go$newType(0, "Interface", "io.WriteSeeker", "WriteSeeker", "io", null);
	go$pkg.WriteSeeker = WriteSeeker;
	var ReadWriteSeeker;
	ReadWriteSeeker = go$newType(0, "Interface", "io.ReadWriteSeeker", "ReadWriteSeeker", "io", null);
	go$pkg.ReadWriteSeeker = ReadWriteSeeker;
	var ReaderFrom;
	ReaderFrom = go$newType(0, "Interface", "io.ReaderFrom", "ReaderFrom", "io", null);
	go$pkg.ReaderFrom = ReaderFrom;
	var WriterTo;
	WriterTo = go$newType(0, "Interface", "io.WriterTo", "WriterTo", "io", null);
	go$pkg.WriterTo = WriterTo;
	var ReaderAt;
	ReaderAt = go$newType(0, "Interface", "io.ReaderAt", "ReaderAt", "io", null);
	go$pkg.ReaderAt = ReaderAt;
	var WriterAt;
	WriterAt = go$newType(0, "Interface", "io.WriterAt", "WriterAt", "io", null);
	go$pkg.WriterAt = WriterAt;
	var ByteReader;
	ByteReader = go$newType(0, "Interface", "io.ByteReader", "ByteReader", "io", null);
	go$pkg.ByteReader = ByteReader;
	var ByteScanner;
	ByteScanner = go$newType(0, "Interface", "io.ByteScanner", "ByteScanner", "io", null);
	go$pkg.ByteScanner = ByteScanner;
	var ByteWriter;
	ByteWriter = go$newType(0, "Interface", "io.ByteWriter", "ByteWriter", "io", null);
	go$pkg.ByteWriter = ByteWriter;
	var RuneReader;
	RuneReader = go$newType(0, "Interface", "io.RuneReader", "RuneReader", "io", null);
	go$pkg.RuneReader = RuneReader;
	var RuneScanner;
	RuneScanner = go$newType(0, "Interface", "io.RuneScanner", "RuneScanner", "io", null);
	go$pkg.RuneScanner = RuneScanner;
	var stringWriter;
	stringWriter = go$newType(0, "Interface", "io.stringWriter", "stringWriter", "io", null);
	go$pkg.stringWriter = stringWriter;
	var LimitedReader;
	LimitedReader = go$newType(0, "Struct", "io.LimitedReader", "LimitedReader", "io", function(R_, N_) {
		this.go$val = this;
		this.R = R_ !== undefined ? R_ : null;
		this.N = N_ !== undefined ? N_ : new Go$Int64(0, 0);
	});
	go$pkg.LimitedReader = LimitedReader;
	var SectionReader;
	SectionReader = go$newType(0, "Struct", "io.SectionReader", "SectionReader", "io", function(r_, base_, off_, limit_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.base = base_ !== undefined ? base_ : new Go$Int64(0, 0);
		this.off = off_ !== undefined ? off_ : new Go$Int64(0, 0);
		this.limit = limit_ !== undefined ? limit_ : new Go$Int64(0, 0);
	});
	go$pkg.SectionReader = SectionReader;
	var teeReader;
	teeReader = go$newType(0, "Struct", "io.teeReader", "teeReader", "io", function(r_, w_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.w = w_ !== undefined ? w_ : null;
	});
	go$pkg.teeReader = teeReader;
	var multiReader;
	multiReader = go$newType(0, "Struct", "io.multiReader", "multiReader", "io", function(readers_) {
		this.go$val = this;
		this.readers = readers_ !== undefined ? readers_ : (go$sliceType(Reader)).nil;
	});
	go$pkg.multiReader = multiReader;
	var multiWriter;
	multiWriter = go$newType(0, "Struct", "io.multiWriter", "multiWriter", "io", function(writers_) {
		this.go$val = this;
		this.writers = writers_ !== undefined ? writers_ : (go$sliceType(Writer)).nil;
	});
	go$pkg.multiWriter = multiWriter;
	var pipeResult;
	pipeResult = go$newType(0, "Struct", "io.pipeResult", "pipeResult", "io", function(n_, err_) {
		this.go$val = this;
		this.n = n_ !== undefined ? n_ : 0;
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.pipeResult = pipeResult;
	var pipe;
	pipe = go$newType(0, "Struct", "io.pipe", "pipe", "io", function(rl_, wl_, l_, data_, rwait_, wwait_, rerr_, werr_) {
		this.go$val = this;
		this.rl = rl_ !== undefined ? rl_ : new sync.Mutex.Ptr();
		this.wl = wl_ !== undefined ? wl_ : new sync.Mutex.Ptr();
		this.l = l_ !== undefined ? l_ : new sync.Mutex.Ptr();
		this.data = data_ !== undefined ? data_ : (go$sliceType(Go$Uint8)).nil;
		this.rwait = rwait_ !== undefined ? rwait_ : new sync.Cond.Ptr();
		this.wwait = wwait_ !== undefined ? wwait_ : new sync.Cond.Ptr();
		this.rerr = rerr_ !== undefined ? rerr_ : null;
		this.werr = werr_ !== undefined ? werr_ : null;
	});
	go$pkg.pipe = pipe;
	var PipeReader;
	PipeReader = go$newType(0, "Struct", "io.PipeReader", "PipeReader", "io", function(p_) {
		this.go$val = this;
		this.p = p_ !== undefined ? p_ : (go$ptrType(pipe)).nil;
	});
	go$pkg.PipeReader = PipeReader;
	var PipeWriter;
	PipeWriter = go$newType(0, "Struct", "io.PipeWriter", "PipeWriter", "io", function(p_) {
		this.go$val = this;
		this.p = p_ !== undefined ? p_ : (go$ptrType(pipe)).nil;
	});
	go$pkg.PipeWriter = PipeWriter;
	Reader.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	Writer.init([["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	Closer.init([["Close", "", (go$funcType([], [go$error], false))]]);
	Seeker.init([["Seek", "", (go$funcType([Go$Int64, Go$Int], [Go$Int64, go$error], false))]]);
	ReadWriter.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	ReadCloser.init([["Close", "", (go$funcType([], [go$error], false))], ["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	WriteCloser.init([["Close", "", (go$funcType([], [go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	ReadWriteCloser.init([["Close", "", (go$funcType([], [go$error], false))], ["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	ReadSeeker.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["Seek", "", (go$funcType([Go$Int64, Go$Int], [Go$Int64, go$error], false))]]);
	WriteSeeker.init([["Seek", "", (go$funcType([Go$Int64, Go$Int], [Go$Int64, go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	ReadWriteSeeker.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["Seek", "", (go$funcType([Go$Int64, Go$Int], [Go$Int64, go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	ReaderFrom.init([["ReadFrom", "", (go$funcType([Reader], [Go$Int64, go$error], false))]]);
	WriterTo.init([["WriteTo", "", (go$funcType([Writer], [Go$Int64, go$error], false))]]);
	ReaderAt.init([["ReadAt", "", (go$funcType([(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false))]]);
	WriterAt.init([["WriteAt", "", (go$funcType([(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false))]]);
	ByteReader.init([["ReadByte", "", (go$funcType([], [Go$Uint8, go$error], false))]]);
	ByteScanner.init([["ReadByte", "", (go$funcType([], [Go$Uint8, go$error], false))], ["UnreadByte", "", (go$funcType([], [go$error], false))]]);
	ByteWriter.init([["WriteByte", "", (go$funcType([Go$Uint8], [go$error], false))]]);
	RuneReader.init([["ReadRune", "", (go$funcType([], [Go$Int32, Go$Int, go$error], false))]]);
	RuneScanner.init([["ReadRune", "", (go$funcType([], [Go$Int32, Go$Int, go$error], false))], ["UnreadRune", "", (go$funcType([], [go$error], false))]]);
	stringWriter.init([["WriteString", "", (go$funcType([Go$String], [Go$Int, go$error], false))]]);
	LimitedReader.init([["R", "", Reader, ""], ["N", "", Go$Int64, ""]]);
	(go$ptrType(LimitedReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	SectionReader.init([["r", "io", ReaderAt, ""], ["base", "io", Go$Int64, ""], ["off", "io", Go$Int64, ""], ["limit", "io", Go$Int64, ""]]);
	(go$ptrType(SectionReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["Seek", "", [Go$Int64, Go$Int], [Go$Int64, go$error], false], ["Size", "", [], [Go$Int64], false]];
	teeReader.init([["r", "io", Reader, ""], ["w", "io", Writer, ""]]);
	(go$ptrType(teeReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	multiReader.init([["readers", "io", (go$sliceType(Reader)), ""]]);
	(go$ptrType(multiReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	multiWriter.init([["writers", "io", (go$sliceType(Writer)), ""]]);
	(go$ptrType(multiWriter)).methods = [["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	pipeResult.init([["n", "io", Go$Int, ""], ["err", "io", go$error, ""]]);
	pipe.init([["rl", "io", sync.Mutex, ""], ["wl", "io", sync.Mutex, ""], ["l", "io", sync.Mutex, ""], ["data", "io", (go$sliceType(Go$Uint8)), ""], ["rwait", "io", sync.Cond, ""], ["wwait", "io", sync.Cond, ""], ["rerr", "io", go$error, ""], ["werr", "io", go$error, ""]]);
	(go$ptrType(pipe)).methods = [["rclose", "io", [go$error], [], false], ["read", "io", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["wclose", "io", [go$error], [], false], ["write", "io", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	PipeReader.init([["p", "io", (go$ptrType(pipe)), ""]]);
	(go$ptrType(PipeReader)).methods = [["Close", "", [], [go$error], false], ["CloseWithError", "", [go$error], [go$error], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	PipeWriter.init([["p", "io", (go$ptrType(pipe)), ""]]);
	(go$ptrType(PipeWriter)).methods = [["Close", "", [], [go$error], false], ["CloseWithError", "", [go$error], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	var errWhence, errOffset, zero;
	var WriteString = go$pkg.WriteString = function(w, s) {
		var n, err, ok, _tuple, sw, _tuple$1, _tuple$2;
		n = 0;
		err = null;
		if (_tuple = (w !== null && stringWriter.implementedBy.indexOf(w.constructor) !== -1 ? [w, true] : [null, false]), sw = _tuple[0], ok = _tuple[1], ok) {
			_tuple$1 = sw.WriteString(s), n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		_tuple$2 = w.Write(new (go$sliceType(Go$Uint8))(go$stringToBytes(s))), n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	var ReadAtLeast = go$pkg.ReadAtLeast = function(r, buf, min) {
		var n, err, _tuple, nn, _tuple$1;
		n = 0;
		err = null;
		if (buf.length < min) {
			_tuple = [0, go$pkg.ErrShortBuffer], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		while (n < min && go$interfaceIsEqual(err, null)) {
			nn = 0;
			_tuple$1 = r.Read(go$subslice(buf, n)), nn = _tuple$1[0], err = _tuple$1[1];
			n = n + (nn) >> 0;
		}
		if (n >= min) {
			err = null;
		} else if (n > 0 && go$interfaceIsEqual(err, go$pkg.EOF)) {
			err = go$pkg.ErrUnexpectedEOF;
		}
		return [n, err];
	};
	var ReadFull = go$pkg.ReadFull = function(r, buf) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = ReadAtLeast(r, buf, buf.length), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var CopyN = go$pkg.CopyN = function(dst, src, n) {
		var written, err, _tuple, _tuple$1;
		written = new Go$Int64(0, 0);
		err = null;
		_tuple = Copy(dst, LimitReader(src, n)), written = _tuple[0], err = _tuple[1];
		if ((written.high === n.high && written.low === n.low)) {
			_tuple$1 = [n, null], written = _tuple$1[0], err = _tuple$1[1];
			return [written, err];
		}
		if ((written.high < n.high || (written.high === n.high && written.low < n.low)) && go$interfaceIsEqual(err, null)) {
			err = go$pkg.EOF;
		}
		return [written, err];
	};
	var Copy = go$pkg.Copy = function(dst, src) {
		var written, err, ok, _tuple, wt, _tuple$1, ok$1, _tuple$2, rt, _tuple$3, buf, _tuple$4, nr, er, _tuple$5, nw, ew, x, _tuple$6;
		written = new Go$Int64(0, 0);
		err = null;
		if (_tuple = (src !== null && WriterTo.implementedBy.indexOf(src.constructor) !== -1 ? [src, true] : [null, false]), wt = _tuple[0], ok = _tuple[1], ok) {
			_tuple$1 = wt.WriteTo(dst), written = _tuple$1[0], err = _tuple$1[1];
			return [written, err];
		}
		if (_tuple$2 = (dst !== null && ReaderFrom.implementedBy.indexOf(dst.constructor) !== -1 ? [dst, true] : [null, false]), rt = _tuple$2[0], ok$1 = _tuple$2[1], ok$1) {
			_tuple$3 = rt.ReadFrom(src), written = _tuple$3[0], err = _tuple$3[1];
			return [written, err];
		}
		buf = (go$sliceType(Go$Uint8)).make(32768, 0, function() { return 0; });
		while (true) {
			_tuple$4 = src.Read(buf), nr = _tuple$4[0], er = _tuple$4[1];
			if (nr > 0) {
				_tuple$5 = dst.Write(go$subslice(buf, 0, nr)), nw = _tuple$5[0], ew = _tuple$5[1];
				if (nw > 0) {
					written = (x = new Go$Int64(0, nw), new Go$Int64(written.high + x.high, written.low + x.low));
				}
				if (!(go$interfaceIsEqual(ew, null))) {
					err = ew;
					break;
				}
				if (!((nr === nw))) {
					err = go$pkg.ErrShortWrite;
					break;
				}
			}
			if (go$interfaceIsEqual(er, go$pkg.EOF)) {
				break;
			}
			if (!(go$interfaceIsEqual(er, null))) {
				err = er;
				break;
			}
		}
		_tuple$6 = [written, err], written = _tuple$6[0], err = _tuple$6[1];
		return [written, err];
	};
	var LimitReader = go$pkg.LimitReader = function(r, n) {
		return new LimitedReader.Ptr(r, n);
	};
	LimitedReader.Ptr.prototype.Read = function(p) {
		var n, err, l, x, _tuple, x$1, x$2, _tuple$1, x$3, x$4;
		n = 0;
		err = null;
		l = this;
		if ((x = l.N, (x.high < 0 || (x.high === 0 && x.low <= 0)))) {
			_tuple = [0, go$pkg.EOF], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if ((x$1 = new Go$Int64(0, p.length), x$2 = l.N, (x$1.high > x$2.high || (x$1.high === x$2.high && x$1.low > x$2.low)))) {
			p = go$subslice(p, 0, go$flatten64(l.N));
		}
		_tuple$1 = l.R.Read(p), n = _tuple$1[0], err = _tuple$1[1];
		l.N = (x$3 = l.N, x$4 = new Go$Int64(0, n), new Go$Int64(x$3.high - x$4.high, x$3.low - x$4.low));
		return [n, err];
	};
	LimitedReader.prototype.Read = function(p) { return this.go$val.Read(p); };
	var NewSectionReader = go$pkg.NewSectionReader = function(r, off, n) {
		return new SectionReader.Ptr(r, off, off, new Go$Int64(off.high + n.high, off.low + n.low));
	};
	SectionReader.Ptr.prototype.Read = function(p) {
		var n, err, s, x, x$1, _tuple, x$2, max, x$3, x$4, _tuple$1, x$5, x$6;
		n = 0;
		err = null;
		s = this;
		if ((x = s.off, x$1 = s.limit, (x.high > x$1.high || (x.high === x$1.high && x.low >= x$1.low)))) {
			_tuple = [0, go$pkg.EOF], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (max = (x$3 = s.limit, x$4 = s.off, new Go$Int64(x$3.high - x$4.high, x$3.low - x$4.low)), (x$2 = new Go$Int64(0, p.length), (x$2.high > max.high || (x$2.high === max.high && x$2.low > max.low)))) {
			p = go$subslice(p, 0, go$flatten64(max));
		}
		_tuple$1 = s.r.ReadAt(p, s.off), n = _tuple$1[0], err = _tuple$1[1];
		s.off = (x$5 = s.off, x$6 = new Go$Int64(0, n), new Go$Int64(x$5.high + x$6.high, x$5.low + x$6.low));
		return [n, err];
	};
	SectionReader.prototype.Read = function(p) { return this.go$val.Read(p); };
	SectionReader.Ptr.prototype.Seek = function(offset, whence) {
		var s, _ref, x, x$1, x$2, x$3, x$4;
		s = this;
		_ref = whence;
		if (_ref === 0) {
			offset = (x = s.base, new Go$Int64(offset.high + x.high, offset.low + x.low));
		} else if (_ref === 1) {
			offset = (x$1 = s.off, new Go$Int64(offset.high + x$1.high, offset.low + x$1.low));
		} else if (_ref === 2) {
			offset = (x$2 = s.limit, new Go$Int64(offset.high + x$2.high, offset.low + x$2.low));
		} else {
			return [new Go$Int64(0, 0), errWhence];
		}
		if ((x$3 = s.base, (offset.high < x$3.high || (offset.high === x$3.high && offset.low < x$3.low)))) {
			return [new Go$Int64(0, 0), errOffset];
		}
		s.off = offset;
		return [(x$4 = s.base, new Go$Int64(offset.high - x$4.high, offset.low - x$4.low)), null];
	};
	SectionReader.prototype.Seek = function(offset, whence) { return this.go$val.Seek(offset, whence); };
	SectionReader.Ptr.prototype.ReadAt = function(p, off) {
		var n, err, s, x, x$1, x$2, _tuple, x$3, x$4, max, x$5, _tuple$1, _tuple$2, _tuple$3;
		n = 0;
		err = null;
		s = this;
		if ((off.high < 0 || (off.high === 0 && off.low < 0)) || (x = (x$1 = s.limit, x$2 = s.base, new Go$Int64(x$1.high - x$2.high, x$1.low - x$2.low)), (off.high > x.high || (off.high === x.high && off.low >= x.low)))) {
			_tuple = [0, go$pkg.EOF], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		off = (x$3 = s.base, new Go$Int64(off.high + x$3.high, off.low + x$3.low));
		if (max = (x$5 = s.limit, new Go$Int64(x$5.high - off.high, x$5.low - off.low)), (x$4 = new Go$Int64(0, p.length), (x$4.high > max.high || (x$4.high === max.high && x$4.low > max.low)))) {
			p = go$subslice(p, 0, go$flatten64(max));
			_tuple$1 = s.r.ReadAt(p, off), n = _tuple$1[0], err = _tuple$1[1];
			if (go$interfaceIsEqual(err, null)) {
				err = go$pkg.EOF;
			}
			_tuple$2 = [n, err], n = _tuple$2[0], err = _tuple$2[1];
			return [n, err];
		}
		_tuple$3 = s.r.ReadAt(p, off), n = _tuple$3[0], err = _tuple$3[1];
		return [n, err];
	};
	SectionReader.prototype.ReadAt = function(p, off) { return this.go$val.ReadAt(p, off); };
	SectionReader.Ptr.prototype.Size = function() {
		var s, x, x$1;
		s = this;
		return (x = s.limit, x$1 = s.base, new Go$Int64(x.high - x$1.high, x.low - x$1.low));
	};
	SectionReader.prototype.Size = function() { return this.go$val.Size(); };
	var TeeReader = go$pkg.TeeReader = function(r, w) {
		return new teeReader.Ptr(r, w);
	};
	teeReader.Ptr.prototype.Read = function(p) {
		var n, err, t, _tuple, err$1, _tuple$1, n$1, _tuple$2;
		n = 0;
		err = null;
		t = this;
		_tuple = t.r.Read(p), n = _tuple[0], err = _tuple[1];
		if (n > 0) {
			if (_tuple$1 = t.w.Write(go$subslice(p, 0, n)), n$1 = _tuple$1[0], err$1 = _tuple$1[1], !(go$interfaceIsEqual(err$1, null))) {
				_tuple$2 = [n$1, err$1], n = _tuple$2[0], err = _tuple$2[1];
				return [n, err];
			}
		}
		return [n, err];
	};
	teeReader.prototype.Read = function(p) { return this.go$val.Read(p); };
	multiReader.Ptr.prototype.Read = function(p) {
		var n, err, mr, _tuple, _slice, _index, _tuple$1;
		n = 0;
		err = null;
		mr = this;
		while (mr.readers.length > 0) {
			_tuple = (_slice = mr.readers, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Read(p), n = _tuple[0], err = _tuple[1];
			if (n > 0 || !(go$interfaceIsEqual(err, go$pkg.EOF))) {
				if (go$interfaceIsEqual(err, go$pkg.EOF)) {
					err = null;
				}
				return [n, err];
			}
			mr.readers = go$subslice(mr.readers, 1);
		}
		_tuple$1 = [0, go$pkg.EOF], n = _tuple$1[0], err = _tuple$1[1];
		return [n, err];
	};
	multiReader.prototype.Read = function(p) { return this.go$val.Read(p); };
	var MultiReader = go$pkg.MultiReader = function(readers) {
		return new multiReader.Ptr(readers);
	};
	multiWriter.Ptr.prototype.Write = function(p) {
		var n, err, t, _ref, _i, _slice, _index, w, _tuple, _tuple$1;
		n = 0;
		err = null;
		t = this;
		_ref = t.writers;
		_i = 0;
		while (_i < _ref.length) {
			w = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			_tuple = w.Write(p), n = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [n, err];
			}
			if (!((n === p.length))) {
				err = go$pkg.ErrShortWrite;
				return [n, err];
			}
			_i++;
		}
		_tuple$1 = [p.length, null], n = _tuple$1[0], err = _tuple$1[1];
		return [n, err];
	};
	multiWriter.prototype.Write = function(p) { return this.go$val.Write(p); };
	var MultiWriter = go$pkg.MultiWriter = function(writers) {
		return new multiWriter.Ptr(writers);
	};
	pipe.Ptr.prototype.read = function(b) {
		var n, err, p, _tuple, _tuple$1;
		n = 0;
		err = null;
		var go$deferred = [];
		try {
			p = this;
			p.rl.Lock();
			go$deferred.push({ recv: p.rl, method: "Unlock", args: [] });
			p.l.Lock();
			go$deferred.push({ recv: p.l, method: "Unlock", args: [] });
			while (true) {
				if (!(go$interfaceIsEqual(p.rerr, null))) {
					_tuple = [0, go$pkg.ErrClosedPipe], n = _tuple[0], err = _tuple[1];
					return [n, err];
				}
				if (!(p.data === (go$sliceType(Go$Uint8)).nil)) {
					break;
				}
				if (!(go$interfaceIsEqual(p.werr, null))) {
					_tuple$1 = [0, p.werr], n = _tuple$1[0], err = _tuple$1[1];
					return [n, err];
				}
				p.rwait.Wait();
			}
			n = go$copySlice(b, p.data);
			p.data = go$subslice(p.data, n);
			if (p.data.length === 0) {
				p.data = (go$sliceType(Go$Uint8)).nil;
				p.wwait.Signal();
			}
			return [n, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [n, err];
		}
	};
	pipe.prototype.read = function(b) { return this.go$val.read(b); };
	pipe.Ptr.prototype.write = function(b) {
		var n, err, p;
		n = 0;
		err = null;
		var go$deferred = [];
		try {
			p = this;
			if (b === (go$sliceType(Go$Uint8)).nil) {
				b = new (go$sliceType(Go$Uint8))(zero);
			}
			p.wl.Lock();
			go$deferred.push({ recv: p.wl, method: "Unlock", args: [] });
			p.l.Lock();
			go$deferred.push({ recv: p.l, method: "Unlock", args: [] });
			if (!(go$interfaceIsEqual(p.werr, null))) {
				err = go$pkg.ErrClosedPipe;
				return [n, err];
			}
			p.data = b;
			p.rwait.Signal();
			while (true) {
				if (p.data === (go$sliceType(Go$Uint8)).nil) {
					break;
				}
				if (!(go$interfaceIsEqual(p.rerr, null))) {
					err = p.rerr;
					break;
				}
				if (!(go$interfaceIsEqual(p.werr, null))) {
					err = go$pkg.ErrClosedPipe;
				}
				p.wwait.Wait();
			}
			n = b.length - p.data.length >> 0;
			p.data = (go$sliceType(Go$Uint8)).nil;
			return [n, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [n, err];
		}
	};
	pipe.prototype.write = function(b) { return this.go$val.write(b); };
	pipe.Ptr.prototype.rclose = function(err) {
		var p;
		var go$deferred = [];
		try {
			p = this;
			if (go$interfaceIsEqual(err, null)) {
				err = go$pkg.ErrClosedPipe;
			}
			p.l.Lock();
			go$deferred.push({ recv: p.l, method: "Unlock", args: [] });
			p.rerr = err;
			p.rwait.Signal();
			p.wwait.Signal();
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	pipe.prototype.rclose = function(err) { return this.go$val.rclose(err); };
	pipe.Ptr.prototype.wclose = function(err) {
		var p;
		var go$deferred = [];
		try {
			p = this;
			if (go$interfaceIsEqual(err, null)) {
				err = go$pkg.EOF;
			}
			p.l.Lock();
			go$deferred.push({ recv: p.l, method: "Unlock", args: [] });
			p.werr = err;
			p.rwait.Signal();
			p.wwait.Signal();
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	pipe.prototype.wclose = function(err) { return this.go$val.wclose(err); };
	PipeReader.Ptr.prototype.Read = function(data) {
		var n, err, r, _tuple;
		n = 0;
		err = null;
		r = this;
		_tuple = r.p.read(data), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	PipeReader.prototype.Read = function(data) { return this.go$val.Read(data); };
	PipeReader.Ptr.prototype.Close = function() {
		var r;
		r = this;
		return r.CloseWithError(null);
	};
	PipeReader.prototype.Close = function() { return this.go$val.Close(); };
	PipeReader.Ptr.prototype.CloseWithError = function(err) {
		var r;
		r = this;
		r.p.rclose(err);
		return null;
	};
	PipeReader.prototype.CloseWithError = function(err) { return this.go$val.CloseWithError(err); };
	PipeWriter.Ptr.prototype.Write = function(data) {
		var n, err, w, _tuple;
		n = 0;
		err = null;
		w = this;
		_tuple = w.p.write(data), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	PipeWriter.prototype.Write = function(data) { return this.go$val.Write(data); };
	PipeWriter.Ptr.prototype.Close = function() {
		var w;
		w = this;
		return w.CloseWithError(null);
	};
	PipeWriter.prototype.Close = function() { return this.go$val.Close(); };
	PipeWriter.Ptr.prototype.CloseWithError = function(err) {
		var w;
		w = this;
		w.p.wclose(err);
		return null;
	};
	PipeWriter.prototype.CloseWithError = function(err) { return this.go$val.CloseWithError(err); };
	var Pipe = go$pkg.Pipe = function() {
		var p, r, w;
		p = new pipe.Ptr();
		p.rwait.L = p.l;
		p.wwait.L = p.l;
		r = new PipeReader.Ptr(p);
		w = new PipeWriter.Ptr(p);
		return [r, w];
	};
	go$pkg.init = function() {
		zero = go$makeNativeArray("Uint8", 0, function() { return 0; });
		go$pkg.ErrShortWrite = errors.New("short write");
		go$pkg.ErrShortBuffer = errors.New("short buffer");
		go$pkg.EOF = errors.New("EOF");
		go$pkg.ErrUnexpectedEOF = errors.New("unexpected EOF");
		go$pkg.ErrNoProgress = errors.New("multiple Read calls return no data or error");
		errWhence = errors.New("Seek: invalid whence");
		errOffset = errors.New("Seek: invalid offset");
		go$pkg.ErrClosedPipe = errors.New("io: read/write on closed pipe");
	};
	return go$pkg;
})();
go$packages["unicode"] = (function() {
	var go$pkg = {};
	var RangeTable;
	RangeTable = go$newType(0, "Struct", "unicode.RangeTable", "RangeTable", "unicode", function(R16_, R32_, LatinOffset_) {
		this.go$val = this;
		this.R16 = R16_ !== undefined ? R16_ : (go$sliceType(Range16)).nil;
		this.R32 = R32_ !== undefined ? R32_ : (go$sliceType(Range32)).nil;
		this.LatinOffset = LatinOffset_ !== undefined ? LatinOffset_ : 0;
	});
	go$pkg.RangeTable = RangeTable;
	var Range16;
	Range16 = go$newType(0, "Struct", "unicode.Range16", "Range16", "unicode", function(Lo_, Hi_, Stride_) {
		this.go$val = this;
		this.Lo = Lo_ !== undefined ? Lo_ : 0;
		this.Hi = Hi_ !== undefined ? Hi_ : 0;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
	});
	go$pkg.Range16 = Range16;
	var Range32;
	Range32 = go$newType(0, "Struct", "unicode.Range32", "Range32", "unicode", function(Lo_, Hi_, Stride_) {
		this.go$val = this;
		this.Lo = Lo_ !== undefined ? Lo_ : 0;
		this.Hi = Hi_ !== undefined ? Hi_ : 0;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
	});
	go$pkg.Range32 = Range32;
	var CaseRange;
	CaseRange = go$newType(0, "Struct", "unicode.CaseRange", "CaseRange", "unicode", function(Lo_, Hi_, Delta_) {
		this.go$val = this;
		this.Lo = Lo_ !== undefined ? Lo_ : 0;
		this.Hi = Hi_ !== undefined ? Hi_ : 0;
		this.Delta = Delta_ !== undefined ? Delta_ : go$makeNativeArray("Int32", 3, function() { return 0; });
	});
	go$pkg.CaseRange = CaseRange;
	var SpecialCase;
	SpecialCase = go$newType(0, "Slice", "unicode.SpecialCase", "SpecialCase", "unicode", null);
	go$pkg.SpecialCase = SpecialCase;
	var d;
	d = go$newType(0, "Array", "unicode.d", "d", "unicode", null);
	go$pkg.d = d;
	var foldPair;
	foldPair = go$newType(0, "Struct", "unicode.foldPair", "foldPair", "unicode", function(From_, To_) {
		this.go$val = this;
		this.From = From_ !== undefined ? From_ : 0;
		this.To = To_ !== undefined ? To_ : 0;
	});
	go$pkg.foldPair = foldPair;
	RangeTable.init([["R16", "", (go$sliceType(Range16)), ""], ["R32", "", (go$sliceType(Range32)), ""], ["LatinOffset", "", Go$Int, ""]]);
	Range16.init([["Lo", "", Go$Uint16, ""], ["Hi", "", Go$Uint16, ""], ["Stride", "", Go$Uint16, ""]]);
	Range32.init([["Lo", "", Go$Uint32, ""], ["Hi", "", Go$Uint32, ""], ["Stride", "", Go$Uint32, ""]]);
	CaseRange.init([["Lo", "", Go$Uint32, ""], ["Hi", "", Go$Uint32, ""], ["Delta", "", d, ""]]);
	SpecialCase.init(CaseRange);
	SpecialCase.methods = [["ToLower", "", [Go$Int32], [Go$Int32], false], ["ToTitle", "", [Go$Int32], [Go$Int32], false], ["ToUpper", "", [Go$Int32], [Go$Int32], false]];
	(go$ptrType(SpecialCase)).methods = [["ToLower", "", [Go$Int32], [Go$Int32], false], ["ToTitle", "", [Go$Int32], [Go$Int32], false], ["ToUpper", "", [Go$Int32], [Go$Int32], false]];
	d.init(Go$Int32, 3);
	foldPair.init([["From", "", Go$Uint16, ""], ["To", "", Go$Uint16, ""]]);
	var _TurkishCase, _C, _Cc, _Cf, _Co, _Cs, _L, _Ll, _Lm, _Lo, _Lt, _Lu, _M, _Mc, _Me, _Mn, _N, _Nd, _Nl, _No, _P, _Pc, _Pd, _Pe, _Pf, _Pi, _Po, _Ps, _S, _Sc, _Sk, _Sm, _So, _Z, _Zl, _Zp, _Zs, _Arabic, _Armenian, _Avestan, _Balinese, _Bamum, _Batak, _Bengali, _Bopomofo, _Brahmi, _Braille, _Buginese, _Buhid, _Canadian_Aboriginal, _Carian, _Chakma, _Cham, _Cherokee, _Common, _Coptic, _Cuneiform, _Cypriot, _Cyrillic, _Deseret, _Devanagari, _Egyptian_Hieroglyphs, _Ethiopic, _Georgian, _Glagolitic, _Gothic, _Greek, _Gujarati, _Gurmukhi, _Han, _Hangul, _Hanunoo, _Hebrew, _Hiragana, _Imperial_Aramaic, _Inherited, _Inscriptional_Pahlavi, _Inscriptional_Parthian, _Javanese, _Kaithi, _Kannada, _Katakana, _Kayah_Li, _Kharoshthi, _Khmer, _Lao, _Latin, _Lepcha, _Limbu, _Linear_B, _Lisu, _Lycian, _Lydian, _Malayalam, _Mandaic, _Meetei_Mayek, _Meroitic_Cursive, _Meroitic_Hieroglyphs, _Miao, _Mongolian, _Myanmar, _New_Tai_Lue, _Nko, _Ogham, _Ol_Chiki, _Old_Italic, _Old_Persian, _Old_South_Arabian, _Old_Turkic, _Oriya, _Osmanya, _Phags_Pa, _Phoenician, _Rejang, _Runic, _Samaritan, _Saurashtra, _Sharada, _Shavian, _Sinhala, _Sora_Sompeng, _Sundanese, _Syloti_Nagri, _Syriac, _Tagalog, _Tagbanwa, _Tai_Le, _Tai_Tham, _Tai_Viet, _Takri, _Tamil, _Telugu, _Thaana, _Thai, _Tibetan, _Tifinagh, _Ugaritic, _Vai, _Yi, _ASCII_Hex_Digit, _Bidi_Control, _Dash, _Deprecated, _Diacritic, _Extender, _Hex_Digit, _Hyphen, _IDS_Binary_Operator, _IDS_Trinary_Operator, _Ideographic, _Join_Control, _Logical_Order_Exception, _Noncharacter_Code_Point, _Other_Alphabetic, _Other_Default_Ignorable_Code_Point, _Other_Grapheme_Extend, _Other_ID_Continue, _Other_ID_Start, _Other_Lowercase, _Other_Math, _Other_Uppercase, _Pattern_Syntax, _Pattern_White_Space, _Quotation_Mark, _Radical, _STerm, _Soft_Dotted, _Terminal_Punctuation, _Unified_Ideograph, _Variation_Selector, _White_Space, _CaseRanges, properties, caseOrbit, foldCommon, foldGreek, foldInherited, foldL, foldLl, foldLt, foldLu, foldM, foldMn;
	var IsDigit = go$pkg.IsDigit = function(r) {
		if (r <= 255) {
			return 48 <= r && r <= 57;
		}
		return isExcludingLatin(go$pkg.Digit, r);
	};
	var IsGraphic = go$pkg.IsGraphic = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 144) >>> 0) === 0));
		}
		return In(r, go$pkg.GraphicRanges);
	};
	var IsPrint = go$pkg.IsPrint = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 128) >>> 0) === 0));
		}
		return In(r, go$pkg.PrintRanges);
	};
	var IsOneOf = go$pkg.IsOneOf = function(ranges, r) {
		var _ref, _i, _slice, _index, inside;
		_ref = ranges;
		_i = 0;
		while (_i < _ref.length) {
			inside = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (Is(inside, r)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	var In = go$pkg.In = function(r, ranges) {
		var _ref, _i, _slice, _index, inside;
		_ref = ranges;
		_i = 0;
		while (_i < _ref.length) {
			inside = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (Is(inside, r)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	var IsControl = go$pkg.IsControl = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 1) >>> 0) === 0));
		}
		return false;
	};
	var IsLetter = go$pkg.IsLetter = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 96) >>> 0) === 0));
		}
		return isExcludingLatin(go$pkg.Letter, r);
	};
	var IsMark = go$pkg.IsMark = function(r) {
		return isExcludingLatin(go$pkg.Mark, r);
	};
	var IsNumber = go$pkg.IsNumber = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 4) >>> 0) === 0));
		}
		return isExcludingLatin(go$pkg.Number, r);
	};
	var IsPunct = go$pkg.IsPunct = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 2) >>> 0) === 0));
		}
		return Is(go$pkg.Punct, r);
	};
	var IsSpace = go$pkg.IsSpace = function(r) {
		var _ref;
		if ((r >>> 0) <= 255) {
			_ref = r;
			if (_ref === 9 || _ref === 10 || _ref === 11 || _ref === 12 || _ref === 13 || _ref === 32 || _ref === 133 || _ref === 160) {
				return true;
			}
			return false;
		}
		return isExcludingLatin(go$pkg.White_Space, r);
	};
	var IsSymbol = go$pkg.IsSymbol = function(r) {
		if ((r >>> 0) <= 255) {
			return !((((properties[(r << 24 >>> 24)] & 8) >>> 0) === 0));
		}
		return isExcludingLatin(go$pkg.Symbol, r);
	};
	var is16 = function(ranges, r) {
		var _ref, _i, i, _slice, _index, range_, _r, lo, hi, _q, m, _slice$1, _index$1, range_$1, _r$1;
		if (ranges.length <= 18 || r <= 255) {
			_ref = ranges;
			_i = 0;
			while (_i < _ref.length) {
				i = _i;
				range_ = (_slice = ranges, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (_r = ((r - range_.Lo << 16 >>> 16)) % range_.Stride, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0;
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.length;
		while (lo < hi) {
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = (_slice$1 = ranges, _index$1 = m, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (_r$1 = ((r - range_$1.Lo << 16 >>> 16)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero")) === 0;
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	var is32 = function(ranges, r) {
		var _ref, _i, i, _slice, _index, range_, _r, lo, hi, _q, m, _slice$1, _index$1, _struct, range_$1, _r$1;
		if (ranges.length <= 18) {
			_ref = ranges;
			_i = 0;
			while (_i < _ref.length) {
				i = _i;
				range_ = (_slice = ranges, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (_r = ((r - range_.Lo >>> 0)) % range_.Stride, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0;
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.length;
		while (lo < hi) {
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = (_struct = (_slice$1 = ranges, _index$1 = m, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new Range32.Ptr(_struct.Lo, _struct.Hi, _struct.Stride));
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (_r$1 = ((r - range_$1.Lo >>> 0)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero")) === 0;
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	var Is = go$pkg.Is = function(rangeTab, r) {
		var r16, _slice, _index, r32, _slice$1, _index$1;
		r16 = rangeTab.R16;
		if (r16.length > 0 && r <= ((_slice = r16, _index = (r16.length - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Hi >> 0)) {
			return is16(r16, (r << 16 >>> 16));
		}
		r32 = rangeTab.R32;
		if (r32.length > 0 && r >= ((_slice$1 = r32, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Lo >> 0)) {
			return is32(r32, (r >>> 0));
		}
		return false;
	};
	var isExcludingLatin = function(rangeTab, r) {
		var r16, off, _slice, _index, r32, _slice$1, _index$1;
		r16 = rangeTab.R16;
		if (off = rangeTab.LatinOffset, r16.length > off && r <= ((_slice = r16, _index = (r16.length - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Hi >> 0)) {
			return is16(go$subslice(r16, off), (r << 16 >>> 16));
		}
		r32 = rangeTab.R32;
		if (r32.length > 0 && r >= ((_slice$1 = r32, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Lo >> 0)) {
			return is32(r32, (r >>> 0));
		}
		return false;
	};
	var IsUpper = go$pkg.IsUpper = function(r) {
		if ((r >>> 0) <= 255) {
			return ((properties[(r << 24 >>> 24)] & 96) >>> 0) === 32;
		}
		return isExcludingLatin(go$pkg.Upper, r);
	};
	var IsLower = go$pkg.IsLower = function(r) {
		if ((r >>> 0) <= 255) {
			return ((properties[(r << 24 >>> 24)] & 96) >>> 0) === 64;
		}
		return isExcludingLatin(go$pkg.Lower, r);
	};
	var IsTitle = go$pkg.IsTitle = function(r) {
		if (r <= 255) {
			return false;
		}
		return isExcludingLatin(go$pkg.Title, r);
	};
	var to = function(_case, r, caseRange) {
		var lo, hi, _q, m, _slice, _index, _struct, cr, delta;
		if (_case < 0 || 3 <= _case) {
			return 65533;
		}
		lo = 0;
		hi = caseRange.length;
		while (lo < hi) {
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			cr = (_struct = (_slice = caseRange, _index = m, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new CaseRange.Ptr(_struct.Lo, _struct.Hi, go$mapArray(_struct.Delta, function(entry) { return entry; })));
			if ((cr.Lo >> 0) <= r && r <= (cr.Hi >> 0)) {
				delta = cr.Delta[_case];
				if (delta > 1114111) {
					return (cr.Lo >> 0) + (((((r - (cr.Lo >> 0) >> 0)) & ~1) | ((_case & 1) >> 0))) >> 0;
				}
				return r + delta >> 0;
			}
			if (r < (cr.Lo >> 0)) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return r;
	};
	var To = go$pkg.To = function(_case, r) {
		return to(_case, r, go$pkg.CaseRanges);
	};
	var ToUpper = go$pkg.ToUpper = function(r) {
		if (r <= 127) {
			if (97 <= r && r <= 122) {
				r = r - 32 >> 0;
			}
			return r;
		}
		return To(0, r);
	};
	var ToLower = go$pkg.ToLower = function(r) {
		if (r <= 127) {
			if (65 <= r && r <= 90) {
				r = r + 32 >> 0;
			}
			return r;
		}
		return To(1, r);
	};
	var ToTitle = go$pkg.ToTitle = function(r) {
		if (r <= 127) {
			if (97 <= r && r <= 122) {
				r = r - 32 >> 0;
			}
			return r;
		}
		return To(2, r);
	};
	SpecialCase.prototype.ToUpper = function(r) {
		var special, r1;
		special = this;
		r1 = to(0, r, go$subslice(new (go$sliceType(CaseRange))(special.array), special.offset, special.offset + special.length));
		if (r1 === r) {
			r1 = ToUpper(r);
		}
		return r1;
	};
	go$ptrType(SpecialCase).prototype.ToUpper = function(r) { return this.go$get().ToUpper(r); };
	SpecialCase.prototype.ToTitle = function(r) {
		var special, r1;
		special = this;
		r1 = to(2, r, go$subslice(new (go$sliceType(CaseRange))(special.array), special.offset, special.offset + special.length));
		if (r1 === r) {
			r1 = ToTitle(r);
		}
		return r1;
	};
	go$ptrType(SpecialCase).prototype.ToTitle = function(r) { return this.go$get().ToTitle(r); };
	SpecialCase.prototype.ToLower = function(r) {
		var special, r1;
		special = this;
		r1 = to(1, r, go$subslice(new (go$sliceType(CaseRange))(special.array), special.offset, special.offset + special.length));
		if (r1 === r) {
			r1 = ToLower(r);
		}
		return r1;
	};
	go$ptrType(SpecialCase).prototype.ToLower = function(r) { return this.go$get().ToLower(r); };
	var SimpleFold = go$pkg.SimpleFold = function(r) {
		var lo, hi, _q, m, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, l;
		lo = 0;
		hi = caseOrbit.length;
		while (lo < hi) {
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			if (((_slice = caseOrbit, _index = m, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).From >> 0) < r) {
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		if (lo < caseOrbit.length && (((_slice$1 = caseOrbit, _index$1 = lo, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).From >> 0) === r)) {
			return ((_slice$2 = caseOrbit, _index$2 = lo, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).To >> 0);
		}
		if (l = ToLower(r), !((l === r))) {
			return l;
		}
		return ToUpper(r);
	};
	go$pkg.init = function() {
		var _map, _key, _map$1, _key$1, _map$2, _key$2, _map$3, _key$3, _map$4, _key$4;
		_TurkishCase = new SpecialCase([new CaseRange.Ptr(73, 73, go$toNativeArray("Int32", [0, 232, 0])), new CaseRange.Ptr(105, 105, go$toNativeArray("Int32", [199, 0, 199])), new CaseRange.Ptr(304, 304, go$toNativeArray("Int32", [0, -199, 0])), new CaseRange.Ptr(305, 305, go$toNativeArray("Int32", [-232, 0, -232]))]);
		go$pkg.TurkishCase = _TurkishCase;
		go$pkg.AzeriCase = _TurkishCase;
		_L = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(65, 90, 1), new Range16.Ptr(97, 122, 1), new Range16.Ptr(170, 181, 11), new Range16.Ptr(186, 192, 6), new Range16.Ptr(193, 214, 1), new Range16.Ptr(216, 246, 1), new Range16.Ptr(248, 705, 1), new Range16.Ptr(710, 721, 1), new Range16.Ptr(736, 740, 1), new Range16.Ptr(748, 750, 2), new Range16.Ptr(880, 884, 1), new Range16.Ptr(886, 887, 1), new Range16.Ptr(890, 893, 1), new Range16.Ptr(902, 904, 2), new Range16.Ptr(905, 906, 1), new Range16.Ptr(908, 910, 2), new Range16.Ptr(911, 929, 1), new Range16.Ptr(931, 1013, 1), new Range16.Ptr(1015, 1153, 1), new Range16.Ptr(1162, 1319, 1), new Range16.Ptr(1329, 1366, 1), new Range16.Ptr(1369, 1377, 8), new Range16.Ptr(1378, 1415, 1), new Range16.Ptr(1488, 1514, 1), new Range16.Ptr(1520, 1522, 1), new Range16.Ptr(1568, 1610, 1), new Range16.Ptr(1646, 1647, 1), new Range16.Ptr(1649, 1747, 1), new Range16.Ptr(1749, 1765, 16), new Range16.Ptr(1766, 1774, 8), new Range16.Ptr(1775, 1786, 11), new Range16.Ptr(1787, 1788, 1), new Range16.Ptr(1791, 1808, 17), new Range16.Ptr(1810, 1839, 1), new Range16.Ptr(1869, 1957, 1), new Range16.Ptr(1969, 1994, 25), new Range16.Ptr(1995, 2026, 1), new Range16.Ptr(2036, 2037, 1), new Range16.Ptr(2042, 2048, 6), new Range16.Ptr(2049, 2069, 1), new Range16.Ptr(2074, 2084, 10), new Range16.Ptr(2088, 2112, 24), new Range16.Ptr(2113, 2136, 1), new Range16.Ptr(2208, 2210, 2), new Range16.Ptr(2211, 2220, 1), new Range16.Ptr(2308, 2361, 1), new Range16.Ptr(2365, 2384, 19), new Range16.Ptr(2392, 2401, 1), new Range16.Ptr(2417, 2423, 1), new Range16.Ptr(2425, 2431, 1), new Range16.Ptr(2437, 2444, 1), new Range16.Ptr(2447, 2448, 1), new Range16.Ptr(2451, 2472, 1), new Range16.Ptr(2474, 2480, 1), new Range16.Ptr(2482, 2486, 4), new Range16.Ptr(2487, 2489, 1), new Range16.Ptr(2493, 2510, 17), new Range16.Ptr(2524, 2525, 1), new Range16.Ptr(2527, 2529, 1), new Range16.Ptr(2544, 2545, 1), new Range16.Ptr(2565, 2570, 1), new Range16.Ptr(2575, 2576, 1), new Range16.Ptr(2579, 2600, 1), new Range16.Ptr(2602, 2608, 1), new Range16.Ptr(2610, 2611, 1), new Range16.Ptr(2613, 2614, 1), new Range16.Ptr(2616, 2617, 1), new Range16.Ptr(2649, 2652, 1), new Range16.Ptr(2654, 2674, 20), new Range16.Ptr(2675, 2676, 1), new Range16.Ptr(2693, 2701, 1), new Range16.Ptr(2703, 2705, 1), new Range16.Ptr(2707, 2728, 1), new Range16.Ptr(2730, 2736, 1), new Range16.Ptr(2738, 2739, 1), new Range16.Ptr(2741, 2745, 1), new Range16.Ptr(2749, 2768, 19), new Range16.Ptr(2784, 2785, 1), new Range16.Ptr(2821, 2828, 1), new Range16.Ptr(2831, 2832, 1), new Range16.Ptr(2835, 2856, 1), new Range16.Ptr(2858, 2864, 1), new Range16.Ptr(2866, 2867, 1), new Range16.Ptr(2869, 2873, 1), new Range16.Ptr(2877, 2908, 31), new Range16.Ptr(2909, 2911, 2), new Range16.Ptr(2912, 2913, 1), new Range16.Ptr(2929, 2947, 18), new Range16.Ptr(2949, 2954, 1), new Range16.Ptr(2958, 2960, 1), new Range16.Ptr(2962, 2965, 1), new Range16.Ptr(2969, 2970, 1), new Range16.Ptr(2972, 2974, 2), new Range16.Ptr(2975, 2979, 4), new Range16.Ptr(2980, 2984, 4), new Range16.Ptr(2985, 2986, 1), new Range16.Ptr(2990, 3001, 1), new Range16.Ptr(3024, 3077, 53), new Range16.Ptr(3078, 3084, 1), new Range16.Ptr(3086, 3088, 1), new Range16.Ptr(3090, 3112, 1), new Range16.Ptr(3114, 3123, 1), new Range16.Ptr(3125, 3129, 1), new Range16.Ptr(3133, 3160, 27), new Range16.Ptr(3161, 3168, 7), new Range16.Ptr(3169, 3205, 36), new Range16.Ptr(3206, 3212, 1), new Range16.Ptr(3214, 3216, 1), new Range16.Ptr(3218, 3240, 1), new Range16.Ptr(3242, 3251, 1), new Range16.Ptr(3253, 3257, 1), new Range16.Ptr(3261, 3294, 33), new Range16.Ptr(3296, 3297, 1), new Range16.Ptr(3313, 3314, 1), new Range16.Ptr(3333, 3340, 1), new Range16.Ptr(3342, 3344, 1), new Range16.Ptr(3346, 3386, 1), new Range16.Ptr(3389, 3406, 17), new Range16.Ptr(3424, 3425, 1), new Range16.Ptr(3450, 3455, 1), new Range16.Ptr(3461, 3478, 1), new Range16.Ptr(3482, 3505, 1), new Range16.Ptr(3507, 3515, 1), new Range16.Ptr(3517, 3520, 3), new Range16.Ptr(3521, 3526, 1), new Range16.Ptr(3585, 3632, 1), new Range16.Ptr(3634, 3635, 1), new Range16.Ptr(3648, 3654, 1), new Range16.Ptr(3713, 3714, 1), new Range16.Ptr(3716, 3719, 3), new Range16.Ptr(3720, 3722, 2), new Range16.Ptr(3725, 3732, 7), new Range16.Ptr(3733, 3735, 1), new Range16.Ptr(3737, 3743, 1), new Range16.Ptr(3745, 3747, 1), new Range16.Ptr(3749, 3751, 2), new Range16.Ptr(3754, 3755, 1), new Range16.Ptr(3757, 3760, 1), new Range16.Ptr(3762, 3763, 1), new Range16.Ptr(3773, 3776, 3), new Range16.Ptr(3777, 3780, 1), new Range16.Ptr(3782, 3804, 22), new Range16.Ptr(3805, 3807, 1), new Range16.Ptr(3840, 3904, 64), new Range16.Ptr(3905, 3911, 1), new Range16.Ptr(3913, 3948, 1), new Range16.Ptr(3976, 3980, 1), new Range16.Ptr(4096, 4138, 1), new Range16.Ptr(4159, 4176, 17), new Range16.Ptr(4177, 4181, 1), new Range16.Ptr(4186, 4189, 1), new Range16.Ptr(4193, 4197, 4), new Range16.Ptr(4198, 4206, 8), new Range16.Ptr(4207, 4208, 1), new Range16.Ptr(4213, 4225, 1), new Range16.Ptr(4238, 4256, 18), new Range16.Ptr(4257, 4293, 1), new Range16.Ptr(4295, 4301, 6), new Range16.Ptr(4304, 4346, 1), new Range16.Ptr(4348, 4680, 1), new Range16.Ptr(4682, 4685, 1), new Range16.Ptr(4688, 4694, 1), new Range16.Ptr(4696, 4698, 2), new Range16.Ptr(4699, 4701, 1), new Range16.Ptr(4704, 4744, 1), new Range16.Ptr(4746, 4749, 1), new Range16.Ptr(4752, 4784, 1), new Range16.Ptr(4786, 4789, 1), new Range16.Ptr(4792, 4798, 1), new Range16.Ptr(4800, 4802, 2), new Range16.Ptr(4803, 4805, 1), new Range16.Ptr(4808, 4822, 1), new Range16.Ptr(4824, 4880, 1), new Range16.Ptr(4882, 4885, 1), new Range16.Ptr(4888, 4954, 1), new Range16.Ptr(4992, 5007, 1), new Range16.Ptr(5024, 5108, 1), new Range16.Ptr(5121, 5740, 1), new Range16.Ptr(5743, 5759, 1), new Range16.Ptr(5761, 5786, 1), new Range16.Ptr(5792, 5866, 1), new Range16.Ptr(5888, 5900, 1), new Range16.Ptr(5902, 5905, 1), new Range16.Ptr(5920, 5937, 1), new Range16.Ptr(5952, 5969, 1), new Range16.Ptr(5984, 5996, 1), new Range16.Ptr(5998, 6000, 1), new Range16.Ptr(6016, 6067, 1), new Range16.Ptr(6103, 6108, 5), new Range16.Ptr(6176, 6263, 1), new Range16.Ptr(6272, 6312, 1), new Range16.Ptr(6314, 6320, 6), new Range16.Ptr(6321, 6389, 1), new Range16.Ptr(6400, 6428, 1), new Range16.Ptr(6480, 6509, 1), new Range16.Ptr(6512, 6516, 1), new Range16.Ptr(6528, 6571, 1), new Range16.Ptr(6593, 6599, 1), new Range16.Ptr(6656, 6678, 1), new Range16.Ptr(6688, 6740, 1), new Range16.Ptr(6823, 6917, 94), new Range16.Ptr(6918, 6963, 1), new Range16.Ptr(6981, 6987, 1), new Range16.Ptr(7043, 7072, 1), new Range16.Ptr(7086, 7087, 1), new Range16.Ptr(7098, 7141, 1), new Range16.Ptr(7168, 7203, 1), new Range16.Ptr(7245, 7247, 1), new Range16.Ptr(7258, 7293, 1), new Range16.Ptr(7401, 7404, 1), new Range16.Ptr(7406, 7409, 1), new Range16.Ptr(7413, 7414, 1), new Range16.Ptr(7424, 7615, 1), new Range16.Ptr(7680, 7957, 1), new Range16.Ptr(7960, 7965, 1), new Range16.Ptr(7968, 8005, 1), new Range16.Ptr(8008, 8013, 1), new Range16.Ptr(8016, 8023, 1), new Range16.Ptr(8025, 8031, 2), new Range16.Ptr(8032, 8061, 1), new Range16.Ptr(8064, 8116, 1), new Range16.Ptr(8118, 8124, 1), new Range16.Ptr(8126, 8130, 4), new Range16.Ptr(8131, 8132, 1), new Range16.Ptr(8134, 8140, 1), new Range16.Ptr(8144, 8147, 1), new Range16.Ptr(8150, 8155, 1), new Range16.Ptr(8160, 8172, 1), new Range16.Ptr(8178, 8180, 1), new Range16.Ptr(8182, 8188, 1), new Range16.Ptr(8305, 8319, 14), new Range16.Ptr(8336, 8348, 1), new Range16.Ptr(8450, 8455, 5), new Range16.Ptr(8458, 8467, 1), new Range16.Ptr(8469, 8473, 4), new Range16.Ptr(8474, 8477, 1), new Range16.Ptr(8484, 8490, 2), new Range16.Ptr(8491, 8493, 1), new Range16.Ptr(8495, 8505, 1), new Range16.Ptr(8508, 8511, 1), new Range16.Ptr(8517, 8521, 1), new Range16.Ptr(8526, 8579, 53), new Range16.Ptr(8580, 11264, 2684), new Range16.Ptr(11265, 11310, 1), new Range16.Ptr(11312, 11358, 1), new Range16.Ptr(11360, 11492, 1), new Range16.Ptr(11499, 11502, 1), new Range16.Ptr(11506, 11507, 1), new Range16.Ptr(11520, 11557, 1), new Range16.Ptr(11559, 11565, 6), new Range16.Ptr(11568, 11623, 1), new Range16.Ptr(11631, 11648, 17), new Range16.Ptr(11649, 11670, 1), new Range16.Ptr(11680, 11686, 1), new Range16.Ptr(11688, 11694, 1), new Range16.Ptr(11696, 11702, 1), new Range16.Ptr(11704, 11710, 1), new Range16.Ptr(11712, 11718, 1), new Range16.Ptr(11720, 11726, 1), new Range16.Ptr(11728, 11734, 1), new Range16.Ptr(11736, 11742, 1), new Range16.Ptr(11823, 12293, 470), new Range16.Ptr(12294, 12337, 43), new Range16.Ptr(12338, 12341, 1), new Range16.Ptr(12347, 12348, 1), new Range16.Ptr(12353, 12438, 1), new Range16.Ptr(12445, 12447, 1), new Range16.Ptr(12449, 12538, 1), new Range16.Ptr(12540, 12543, 1), new Range16.Ptr(12549, 12589, 1), new Range16.Ptr(12593, 12686, 1), new Range16.Ptr(12704, 12730, 1), new Range16.Ptr(12784, 12799, 1), new Range16.Ptr(13312, 19893, 1), new Range16.Ptr(19968, 40908, 1), new Range16.Ptr(40960, 42124, 1), new Range16.Ptr(42192, 42237, 1), new Range16.Ptr(42240, 42508, 1), new Range16.Ptr(42512, 42527, 1), new Range16.Ptr(42538, 42539, 1), new Range16.Ptr(42560, 42606, 1), new Range16.Ptr(42623, 42647, 1), new Range16.Ptr(42656, 42725, 1), new Range16.Ptr(42775, 42783, 1), new Range16.Ptr(42786, 42888, 1), new Range16.Ptr(42891, 42894, 1), new Range16.Ptr(42896, 42899, 1), new Range16.Ptr(42912, 42922, 1), new Range16.Ptr(43000, 43009, 1), new Range16.Ptr(43011, 43013, 1), new Range16.Ptr(43015, 43018, 1), new Range16.Ptr(43020, 43042, 1), new Range16.Ptr(43072, 43123, 1), new Range16.Ptr(43138, 43187, 1), new Range16.Ptr(43250, 43255, 1), new Range16.Ptr(43259, 43274, 15), new Range16.Ptr(43275, 43301, 1), new Range16.Ptr(43312, 43334, 1), new Range16.Ptr(43360, 43388, 1), new Range16.Ptr(43396, 43442, 1), new Range16.Ptr(43471, 43520, 49), new Range16.Ptr(43521, 43560, 1), new Range16.Ptr(43584, 43586, 1), new Range16.Ptr(43588, 43595, 1), new Range16.Ptr(43616, 43638, 1), new Range16.Ptr(43642, 43648, 6), new Range16.Ptr(43649, 43695, 1), new Range16.Ptr(43697, 43701, 4), new Range16.Ptr(43702, 43705, 3), new Range16.Ptr(43706, 43709, 1), new Range16.Ptr(43712, 43714, 2), new Range16.Ptr(43739, 43741, 1), new Range16.Ptr(43744, 43754, 1), new Range16.Ptr(43762, 43764, 1), new Range16.Ptr(43777, 43782, 1), new Range16.Ptr(43785, 43790, 1), new Range16.Ptr(43793, 43798, 1), new Range16.Ptr(43808, 43814, 1), new Range16.Ptr(43816, 43822, 1), new Range16.Ptr(43968, 44002, 1), new Range16.Ptr(44032, 55203, 1), new Range16.Ptr(55216, 55238, 1), new Range16.Ptr(55243, 55291, 1), new Range16.Ptr(63744, 64109, 1), new Range16.Ptr(64112, 64217, 1), new Range16.Ptr(64256, 64262, 1), new Range16.Ptr(64275, 64279, 1), new Range16.Ptr(64285, 64287, 2), new Range16.Ptr(64288, 64296, 1), new Range16.Ptr(64298, 64310, 1), new Range16.Ptr(64312, 64316, 1), new Range16.Ptr(64318, 64320, 2), new Range16.Ptr(64321, 64323, 2), new Range16.Ptr(64324, 64326, 2), new Range16.Ptr(64327, 64433, 1), new Range16.Ptr(64467, 64829, 1), new Range16.Ptr(64848, 64911, 1), new Range16.Ptr(64914, 64967, 1), new Range16.Ptr(65008, 65019, 1), new Range16.Ptr(65136, 65140, 1), new Range16.Ptr(65142, 65276, 1), new Range16.Ptr(65313, 65338, 1), new Range16.Ptr(65345, 65370, 1), new Range16.Ptr(65382, 65470, 1), new Range16.Ptr(65474, 65479, 1), new Range16.Ptr(65482, 65487, 1), new Range16.Ptr(65490, 65495, 1), new Range16.Ptr(65498, 65500, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65536, 65547, 1), new Range32.Ptr(65549, 65574, 1), new Range32.Ptr(65576, 65594, 1), new Range32.Ptr(65596, 65597, 1), new Range32.Ptr(65599, 65613, 1), new Range32.Ptr(65616, 65629, 1), new Range32.Ptr(65664, 65786, 1), new Range32.Ptr(66176, 66204, 1), new Range32.Ptr(66208, 66256, 1), new Range32.Ptr(66304, 66334, 1), new Range32.Ptr(66352, 66368, 1), new Range32.Ptr(66370, 66377, 1), new Range32.Ptr(66432, 66461, 1), new Range32.Ptr(66464, 66499, 1), new Range32.Ptr(66504, 66511, 1), new Range32.Ptr(66560, 66717, 1), new Range32.Ptr(67584, 67589, 1), new Range32.Ptr(67592, 67594, 2), new Range32.Ptr(67595, 67637, 1), new Range32.Ptr(67639, 67640, 1), new Range32.Ptr(67644, 67647, 3), new Range32.Ptr(67648, 67669, 1), new Range32.Ptr(67840, 67861, 1), new Range32.Ptr(67872, 67897, 1), new Range32.Ptr(67968, 68023, 1), new Range32.Ptr(68030, 68031, 1), new Range32.Ptr(68096, 68112, 16), new Range32.Ptr(68113, 68115, 1), new Range32.Ptr(68117, 68119, 1), new Range32.Ptr(68121, 68147, 1), new Range32.Ptr(68192, 68220, 1), new Range32.Ptr(68352, 68405, 1), new Range32.Ptr(68416, 68437, 1), new Range32.Ptr(68448, 68466, 1), new Range32.Ptr(68608, 68680, 1), new Range32.Ptr(69635, 69687, 1), new Range32.Ptr(69763, 69807, 1), new Range32.Ptr(69840, 69864, 1), new Range32.Ptr(69891, 69926, 1), new Range32.Ptr(70019, 70066, 1), new Range32.Ptr(70081, 70084, 1), new Range32.Ptr(71296, 71338, 1), new Range32.Ptr(73728, 74606, 1), new Range32.Ptr(77824, 78894, 1), new Range32.Ptr(92160, 92728, 1), new Range32.Ptr(93952, 94020, 1), new Range32.Ptr(94032, 94099, 67), new Range32.Ptr(94100, 94111, 1), new Range32.Ptr(110592, 110593, 1), new Range32.Ptr(119808, 119892, 1), new Range32.Ptr(119894, 119964, 1), new Range32.Ptr(119966, 119967, 1), new Range32.Ptr(119970, 119973, 3), new Range32.Ptr(119974, 119977, 3), new Range32.Ptr(119978, 119980, 1), new Range32.Ptr(119982, 119993, 1), new Range32.Ptr(119995, 119997, 2), new Range32.Ptr(119998, 120003, 1), new Range32.Ptr(120005, 120069, 1), new Range32.Ptr(120071, 120074, 1), new Range32.Ptr(120077, 120084, 1), new Range32.Ptr(120086, 120092, 1), new Range32.Ptr(120094, 120121, 1), new Range32.Ptr(120123, 120126, 1), new Range32.Ptr(120128, 120132, 1), new Range32.Ptr(120134, 120138, 4), new Range32.Ptr(120139, 120144, 1), new Range32.Ptr(120146, 120485, 1), new Range32.Ptr(120488, 120512, 1), new Range32.Ptr(120514, 120538, 1), new Range32.Ptr(120540, 120570, 1), new Range32.Ptr(120572, 120596, 1), new Range32.Ptr(120598, 120628, 1), new Range32.Ptr(120630, 120654, 1), new Range32.Ptr(120656, 120686, 1), new Range32.Ptr(120688, 120712, 1), new Range32.Ptr(120714, 120744, 1), new Range32.Ptr(120746, 120770, 1), new Range32.Ptr(120772, 120779, 1), new Range32.Ptr(126464, 126467, 1), new Range32.Ptr(126469, 126495, 1), new Range32.Ptr(126497, 126498, 1), new Range32.Ptr(126500, 126503, 3), new Range32.Ptr(126505, 126514, 1), new Range32.Ptr(126516, 126519, 1), new Range32.Ptr(126521, 126523, 2), new Range32.Ptr(126530, 126535, 5), new Range32.Ptr(126537, 126541, 2), new Range32.Ptr(126542, 126543, 1), new Range32.Ptr(126545, 126546, 1), new Range32.Ptr(126548, 126551, 3), new Range32.Ptr(126553, 126561, 2), new Range32.Ptr(126562, 126564, 2), new Range32.Ptr(126567, 126570, 1), new Range32.Ptr(126572, 126578, 1), new Range32.Ptr(126580, 126583, 1), new Range32.Ptr(126585, 126588, 1), new Range32.Ptr(126590, 126592, 2), new Range32.Ptr(126593, 126601, 1), new Range32.Ptr(126603, 126619, 1), new Range32.Ptr(126625, 126627, 1), new Range32.Ptr(126629, 126633, 1), new Range32.Ptr(126635, 126651, 1), new Range32.Ptr(131072, 173782, 1), new Range32.Ptr(173824, 177972, 1), new Range32.Ptr(177984, 178205, 1), new Range32.Ptr(194560, 195101, 1)]), 6);
		go$pkg.L = _L;
		_M = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(768, 879, 1), new Range16.Ptr(1155, 1161, 1), new Range16.Ptr(1425, 1469, 1), new Range16.Ptr(1471, 1473, 2), new Range16.Ptr(1474, 1476, 2), new Range16.Ptr(1477, 1479, 2), new Range16.Ptr(1552, 1562, 1), new Range16.Ptr(1611, 1631, 1), new Range16.Ptr(1648, 1750, 102), new Range16.Ptr(1751, 1756, 1), new Range16.Ptr(1759, 1764, 1), new Range16.Ptr(1767, 1768, 1), new Range16.Ptr(1770, 1773, 1), new Range16.Ptr(1809, 1840, 31), new Range16.Ptr(1841, 1866, 1), new Range16.Ptr(1958, 1968, 1), new Range16.Ptr(2027, 2035, 1), new Range16.Ptr(2070, 2073, 1), new Range16.Ptr(2075, 2083, 1), new Range16.Ptr(2085, 2087, 1), new Range16.Ptr(2089, 2093, 1), new Range16.Ptr(2137, 2139, 1), new Range16.Ptr(2276, 2302, 1), new Range16.Ptr(2304, 2307, 1), new Range16.Ptr(2362, 2364, 1), new Range16.Ptr(2366, 2383, 1), new Range16.Ptr(2385, 2391, 1), new Range16.Ptr(2402, 2403, 1), new Range16.Ptr(2433, 2435, 1), new Range16.Ptr(2492, 2494, 2), new Range16.Ptr(2495, 2500, 1), new Range16.Ptr(2503, 2504, 1), new Range16.Ptr(2507, 2509, 1), new Range16.Ptr(2519, 2530, 11), new Range16.Ptr(2531, 2561, 30), new Range16.Ptr(2562, 2563, 1), new Range16.Ptr(2620, 2622, 2), new Range16.Ptr(2623, 2626, 1), new Range16.Ptr(2631, 2632, 1), new Range16.Ptr(2635, 2637, 1), new Range16.Ptr(2641, 2672, 31), new Range16.Ptr(2673, 2677, 4), new Range16.Ptr(2689, 2691, 1), new Range16.Ptr(2748, 2750, 2), new Range16.Ptr(2751, 2757, 1), new Range16.Ptr(2759, 2761, 1), new Range16.Ptr(2763, 2765, 1), new Range16.Ptr(2786, 2787, 1), new Range16.Ptr(2817, 2819, 1), new Range16.Ptr(2876, 2878, 2), new Range16.Ptr(2879, 2884, 1), new Range16.Ptr(2887, 2888, 1), new Range16.Ptr(2891, 2893, 1), new Range16.Ptr(2902, 2903, 1), new Range16.Ptr(2914, 2915, 1), new Range16.Ptr(2946, 3006, 60), new Range16.Ptr(3007, 3010, 1), new Range16.Ptr(3014, 3016, 1), new Range16.Ptr(3018, 3021, 1), new Range16.Ptr(3031, 3073, 42), new Range16.Ptr(3074, 3075, 1), new Range16.Ptr(3134, 3140, 1), new Range16.Ptr(3142, 3144, 1), new Range16.Ptr(3146, 3149, 1), new Range16.Ptr(3157, 3158, 1), new Range16.Ptr(3170, 3171, 1), new Range16.Ptr(3202, 3203, 1), new Range16.Ptr(3260, 3262, 2), new Range16.Ptr(3263, 3268, 1), new Range16.Ptr(3270, 3272, 1), new Range16.Ptr(3274, 3277, 1), new Range16.Ptr(3285, 3286, 1), new Range16.Ptr(3298, 3299, 1), new Range16.Ptr(3330, 3331, 1), new Range16.Ptr(3390, 3396, 1), new Range16.Ptr(3398, 3400, 1), new Range16.Ptr(3402, 3405, 1), new Range16.Ptr(3415, 3426, 11), new Range16.Ptr(3427, 3458, 31), new Range16.Ptr(3459, 3530, 71), new Range16.Ptr(3535, 3540, 1), new Range16.Ptr(3542, 3544, 2), new Range16.Ptr(3545, 3551, 1), new Range16.Ptr(3570, 3571, 1), new Range16.Ptr(3633, 3636, 3), new Range16.Ptr(3637, 3642, 1), new Range16.Ptr(3655, 3662, 1), new Range16.Ptr(3761, 3764, 3), new Range16.Ptr(3765, 3769, 1), new Range16.Ptr(3771, 3772, 1), new Range16.Ptr(3784, 3789, 1), new Range16.Ptr(3864, 3865, 1), new Range16.Ptr(3893, 3897, 2), new Range16.Ptr(3902, 3903, 1), new Range16.Ptr(3953, 3972, 1), new Range16.Ptr(3974, 3975, 1), new Range16.Ptr(3981, 3991, 1), new Range16.Ptr(3993, 4028, 1), new Range16.Ptr(4038, 4139, 101), new Range16.Ptr(4140, 4158, 1), new Range16.Ptr(4182, 4185, 1), new Range16.Ptr(4190, 4192, 1), new Range16.Ptr(4194, 4196, 1), new Range16.Ptr(4199, 4205, 1), new Range16.Ptr(4209, 4212, 1), new Range16.Ptr(4226, 4237, 1), new Range16.Ptr(4239, 4250, 11), new Range16.Ptr(4251, 4253, 1), new Range16.Ptr(4957, 4959, 1), new Range16.Ptr(5906, 5908, 1), new Range16.Ptr(5938, 5940, 1), new Range16.Ptr(5970, 5971, 1), new Range16.Ptr(6002, 6003, 1), new Range16.Ptr(6068, 6099, 1), new Range16.Ptr(6109, 6155, 46), new Range16.Ptr(6156, 6157, 1), new Range16.Ptr(6313, 6432, 119), new Range16.Ptr(6433, 6443, 1), new Range16.Ptr(6448, 6459, 1), new Range16.Ptr(6576, 6592, 1), new Range16.Ptr(6600, 6601, 1), new Range16.Ptr(6679, 6683, 1), new Range16.Ptr(6741, 6750, 1), new Range16.Ptr(6752, 6780, 1), new Range16.Ptr(6783, 6912, 129), new Range16.Ptr(6913, 6916, 1), new Range16.Ptr(6964, 6980, 1), new Range16.Ptr(7019, 7027, 1), new Range16.Ptr(7040, 7042, 1), new Range16.Ptr(7073, 7085, 1), new Range16.Ptr(7142, 7155, 1), new Range16.Ptr(7204, 7223, 1), new Range16.Ptr(7376, 7378, 1), new Range16.Ptr(7380, 7400, 1), new Range16.Ptr(7405, 7410, 5), new Range16.Ptr(7411, 7412, 1), new Range16.Ptr(7616, 7654, 1), new Range16.Ptr(7676, 7679, 1), new Range16.Ptr(8400, 8432, 1), new Range16.Ptr(11503, 11505, 1), new Range16.Ptr(11647, 11744, 97), new Range16.Ptr(11745, 11775, 1), new Range16.Ptr(12330, 12335, 1), new Range16.Ptr(12441, 12442, 1), new Range16.Ptr(42607, 42610, 1), new Range16.Ptr(42612, 42621, 1), new Range16.Ptr(42655, 42736, 81), new Range16.Ptr(42737, 43010, 273), new Range16.Ptr(43014, 43019, 5), new Range16.Ptr(43043, 43047, 1), new Range16.Ptr(43136, 43137, 1), new Range16.Ptr(43188, 43204, 1), new Range16.Ptr(43232, 43249, 1), new Range16.Ptr(43302, 43309, 1), new Range16.Ptr(43335, 43347, 1), new Range16.Ptr(43392, 43395, 1), new Range16.Ptr(43443, 43456, 1), new Range16.Ptr(43561, 43574, 1), new Range16.Ptr(43587, 43596, 9), new Range16.Ptr(43597, 43643, 46), new Range16.Ptr(43696, 43698, 2), new Range16.Ptr(43699, 43700, 1), new Range16.Ptr(43703, 43704, 1), new Range16.Ptr(43710, 43711, 1), new Range16.Ptr(43713, 43755, 42), new Range16.Ptr(43756, 43759, 1), new Range16.Ptr(43765, 43766, 1), new Range16.Ptr(44003, 44010, 1), new Range16.Ptr(44012, 44013, 1), new Range16.Ptr(64286, 65024, 738), new Range16.Ptr(65025, 65039, 1), new Range16.Ptr(65056, 65062, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66045, 68097, 2052), new Range32.Ptr(68098, 68099, 1), new Range32.Ptr(68101, 68102, 1), new Range32.Ptr(68108, 68111, 1), new Range32.Ptr(68152, 68154, 1), new Range32.Ptr(68159, 69632, 1473), new Range32.Ptr(69633, 69634, 1), new Range32.Ptr(69688, 69702, 1), new Range32.Ptr(69760, 69762, 1), new Range32.Ptr(69808, 69818, 1), new Range32.Ptr(69888, 69890, 1), new Range32.Ptr(69927, 69940, 1), new Range32.Ptr(70016, 70018, 1), new Range32.Ptr(70067, 70080, 1), new Range32.Ptr(71339, 71351, 1), new Range32.Ptr(94033, 94078, 1), new Range32.Ptr(94095, 94098, 1), new Range32.Ptr(119141, 119145, 1), new Range32.Ptr(119149, 119154, 1), new Range32.Ptr(119163, 119170, 1), new Range32.Ptr(119173, 119179, 1), new Range32.Ptr(119210, 119213, 1), new Range32.Ptr(119362, 119364, 1), new Range32.Ptr(917760, 917999, 1)]), 0);
		go$pkg.M = _M;
		_N = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(48, 57, 1), new Range16.Ptr(178, 179, 1), new Range16.Ptr(185, 188, 3), new Range16.Ptr(189, 190, 1), new Range16.Ptr(1632, 1641, 1), new Range16.Ptr(1776, 1785, 1), new Range16.Ptr(1984, 1993, 1), new Range16.Ptr(2406, 2415, 1), new Range16.Ptr(2534, 2543, 1), new Range16.Ptr(2548, 2553, 1), new Range16.Ptr(2662, 2671, 1), new Range16.Ptr(2790, 2799, 1), new Range16.Ptr(2918, 2927, 1), new Range16.Ptr(2930, 2935, 1), new Range16.Ptr(3046, 3058, 1), new Range16.Ptr(3174, 3183, 1), new Range16.Ptr(3192, 3198, 1), new Range16.Ptr(3302, 3311, 1), new Range16.Ptr(3430, 3445, 1), new Range16.Ptr(3664, 3673, 1), new Range16.Ptr(3792, 3801, 1), new Range16.Ptr(3872, 3891, 1), new Range16.Ptr(4160, 4169, 1), new Range16.Ptr(4240, 4249, 1), new Range16.Ptr(4969, 4988, 1), new Range16.Ptr(5870, 5872, 1), new Range16.Ptr(6112, 6121, 1), new Range16.Ptr(6128, 6137, 1), new Range16.Ptr(6160, 6169, 1), new Range16.Ptr(6470, 6479, 1), new Range16.Ptr(6608, 6618, 1), new Range16.Ptr(6784, 6793, 1), new Range16.Ptr(6800, 6809, 1), new Range16.Ptr(6992, 7001, 1), new Range16.Ptr(7088, 7097, 1), new Range16.Ptr(7232, 7241, 1), new Range16.Ptr(7248, 7257, 1), new Range16.Ptr(8304, 8308, 4), new Range16.Ptr(8309, 8313, 1), new Range16.Ptr(8320, 8329, 1), new Range16.Ptr(8528, 8578, 1), new Range16.Ptr(8581, 8585, 1), new Range16.Ptr(9312, 9371, 1), new Range16.Ptr(9450, 9471, 1), new Range16.Ptr(10102, 10131, 1), new Range16.Ptr(11517, 12295, 778), new Range16.Ptr(12321, 12329, 1), new Range16.Ptr(12344, 12346, 1), new Range16.Ptr(12690, 12693, 1), new Range16.Ptr(12832, 12841, 1), new Range16.Ptr(12872, 12879, 1), new Range16.Ptr(12881, 12895, 1), new Range16.Ptr(12928, 12937, 1), new Range16.Ptr(12977, 12991, 1), new Range16.Ptr(42528, 42537, 1), new Range16.Ptr(42726, 42735, 1), new Range16.Ptr(43056, 43061, 1), new Range16.Ptr(43216, 43225, 1), new Range16.Ptr(43264, 43273, 1), new Range16.Ptr(43472, 43481, 1), new Range16.Ptr(43600, 43609, 1), new Range16.Ptr(44016, 44025, 1), new Range16.Ptr(65296, 65305, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65799, 65843, 1), new Range32.Ptr(65856, 65912, 1), new Range32.Ptr(65930, 66336, 406), new Range32.Ptr(66337, 66339, 1), new Range32.Ptr(66369, 66378, 9), new Range32.Ptr(66513, 66517, 1), new Range32.Ptr(66720, 66729, 1), new Range32.Ptr(67672, 67679, 1), new Range32.Ptr(67862, 67867, 1), new Range32.Ptr(68160, 68167, 1), new Range32.Ptr(68221, 68222, 1), new Range32.Ptr(68440, 68447, 1), new Range32.Ptr(68472, 68479, 1), new Range32.Ptr(69216, 69246, 1), new Range32.Ptr(69714, 69743, 1), new Range32.Ptr(69872, 69881, 1), new Range32.Ptr(69942, 69951, 1), new Range32.Ptr(70096, 70105, 1), new Range32.Ptr(71360, 71369, 1), new Range32.Ptr(74752, 74850, 1), new Range32.Ptr(119648, 119665, 1), new Range32.Ptr(120782, 120831, 1), new Range32.Ptr(127232, 127242, 1)]), 4);
		go$pkg.N = _N;
		_P = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(33, 35, 1), new Range16.Ptr(37, 42, 1), new Range16.Ptr(44, 47, 1), new Range16.Ptr(58, 59, 1), new Range16.Ptr(63, 64, 1), new Range16.Ptr(91, 93, 1), new Range16.Ptr(95, 123, 28), new Range16.Ptr(125, 161, 36), new Range16.Ptr(167, 171, 4), new Range16.Ptr(182, 183, 1), new Range16.Ptr(187, 191, 4), new Range16.Ptr(894, 903, 9), new Range16.Ptr(1370, 1375, 1), new Range16.Ptr(1417, 1418, 1), new Range16.Ptr(1470, 1472, 2), new Range16.Ptr(1475, 1478, 3), new Range16.Ptr(1523, 1524, 1), new Range16.Ptr(1545, 1546, 1), new Range16.Ptr(1548, 1549, 1), new Range16.Ptr(1563, 1566, 3), new Range16.Ptr(1567, 1642, 75), new Range16.Ptr(1643, 1645, 1), new Range16.Ptr(1748, 1792, 44), new Range16.Ptr(1793, 1805, 1), new Range16.Ptr(2039, 2041, 1), new Range16.Ptr(2096, 2110, 1), new Range16.Ptr(2142, 2404, 262), new Range16.Ptr(2405, 2416, 11), new Range16.Ptr(2800, 3572, 772), new Range16.Ptr(3663, 3674, 11), new Range16.Ptr(3675, 3844, 169), new Range16.Ptr(3845, 3858, 1), new Range16.Ptr(3860, 3898, 38), new Range16.Ptr(3899, 3901, 1), new Range16.Ptr(3973, 4048, 75), new Range16.Ptr(4049, 4052, 1), new Range16.Ptr(4057, 4058, 1), new Range16.Ptr(4170, 4175, 1), new Range16.Ptr(4347, 4960, 613), new Range16.Ptr(4961, 4968, 1), new Range16.Ptr(5120, 5741, 621), new Range16.Ptr(5742, 5787, 45), new Range16.Ptr(5788, 5867, 79), new Range16.Ptr(5868, 5869, 1), new Range16.Ptr(5941, 5942, 1), new Range16.Ptr(6100, 6102, 1), new Range16.Ptr(6104, 6106, 1), new Range16.Ptr(6144, 6154, 1), new Range16.Ptr(6468, 6469, 1), new Range16.Ptr(6686, 6687, 1), new Range16.Ptr(6816, 6822, 1), new Range16.Ptr(6824, 6829, 1), new Range16.Ptr(7002, 7008, 1), new Range16.Ptr(7164, 7167, 1), new Range16.Ptr(7227, 7231, 1), new Range16.Ptr(7294, 7295, 1), new Range16.Ptr(7360, 7367, 1), new Range16.Ptr(7379, 8208, 829), new Range16.Ptr(8209, 8231, 1), new Range16.Ptr(8240, 8259, 1), new Range16.Ptr(8261, 8273, 1), new Range16.Ptr(8275, 8286, 1), new Range16.Ptr(8317, 8318, 1), new Range16.Ptr(8333, 8334, 1), new Range16.Ptr(9001, 9002, 1), new Range16.Ptr(10088, 10101, 1), new Range16.Ptr(10181, 10182, 1), new Range16.Ptr(10214, 10223, 1), new Range16.Ptr(10627, 10648, 1), new Range16.Ptr(10712, 10715, 1), new Range16.Ptr(10748, 10749, 1), new Range16.Ptr(11513, 11516, 1), new Range16.Ptr(11518, 11519, 1), new Range16.Ptr(11632, 11776, 144), new Range16.Ptr(11777, 11822, 1), new Range16.Ptr(11824, 11835, 1), new Range16.Ptr(12289, 12291, 1), new Range16.Ptr(12296, 12305, 1), new Range16.Ptr(12308, 12319, 1), new Range16.Ptr(12336, 12349, 13), new Range16.Ptr(12448, 12539, 91), new Range16.Ptr(42238, 42239, 1), new Range16.Ptr(42509, 42511, 1), new Range16.Ptr(42611, 42622, 11), new Range16.Ptr(42738, 42743, 1), new Range16.Ptr(43124, 43127, 1), new Range16.Ptr(43214, 43215, 1), new Range16.Ptr(43256, 43258, 1), new Range16.Ptr(43310, 43311, 1), new Range16.Ptr(43359, 43457, 98), new Range16.Ptr(43458, 43469, 1), new Range16.Ptr(43486, 43487, 1), new Range16.Ptr(43612, 43615, 1), new Range16.Ptr(43742, 43743, 1), new Range16.Ptr(43760, 43761, 1), new Range16.Ptr(44011, 64830, 20819), new Range16.Ptr(64831, 65040, 209), new Range16.Ptr(65041, 65049, 1), new Range16.Ptr(65072, 65106, 1), new Range16.Ptr(65108, 65121, 1), new Range16.Ptr(65123, 65128, 5), new Range16.Ptr(65130, 65131, 1), new Range16.Ptr(65281, 65283, 1), new Range16.Ptr(65285, 65290, 1), new Range16.Ptr(65292, 65295, 1), new Range16.Ptr(65306, 65307, 1), new Range16.Ptr(65311, 65312, 1), new Range16.Ptr(65339, 65341, 1), new Range16.Ptr(65343, 65371, 28), new Range16.Ptr(65373, 65375, 2), new Range16.Ptr(65376, 65381, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65792, 65794, 1), new Range32.Ptr(66463, 66512, 49), new Range32.Ptr(67671, 67871, 200), new Range32.Ptr(67903, 68176, 273), new Range32.Ptr(68177, 68184, 1), new Range32.Ptr(68223, 68409, 186), new Range32.Ptr(68410, 68415, 1), new Range32.Ptr(69703, 69709, 1), new Range32.Ptr(69819, 69820, 1), new Range32.Ptr(69822, 69825, 1), new Range32.Ptr(69952, 69955, 1), new Range32.Ptr(70085, 70088, 1), new Range32.Ptr(74864, 74867, 1)]), 11);
		go$pkg.P = _P;
		_S = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(36, 43, 7), new Range16.Ptr(60, 62, 1), new Range16.Ptr(94, 96, 2), new Range16.Ptr(124, 126, 2), new Range16.Ptr(162, 166, 1), new Range16.Ptr(168, 169, 1), new Range16.Ptr(172, 174, 2), new Range16.Ptr(175, 177, 1), new Range16.Ptr(180, 184, 4), new Range16.Ptr(215, 247, 32), new Range16.Ptr(706, 709, 1), new Range16.Ptr(722, 735, 1), new Range16.Ptr(741, 747, 1), new Range16.Ptr(749, 751, 2), new Range16.Ptr(752, 767, 1), new Range16.Ptr(885, 900, 15), new Range16.Ptr(901, 1014, 113), new Range16.Ptr(1154, 1423, 269), new Range16.Ptr(1542, 1544, 1), new Range16.Ptr(1547, 1550, 3), new Range16.Ptr(1551, 1758, 207), new Range16.Ptr(1769, 1789, 20), new Range16.Ptr(1790, 2038, 248), new Range16.Ptr(2546, 2547, 1), new Range16.Ptr(2554, 2555, 1), new Range16.Ptr(2801, 2928, 127), new Range16.Ptr(3059, 3066, 1), new Range16.Ptr(3199, 3449, 250), new Range16.Ptr(3647, 3841, 194), new Range16.Ptr(3842, 3843, 1), new Range16.Ptr(3859, 3861, 2), new Range16.Ptr(3862, 3863, 1), new Range16.Ptr(3866, 3871, 1), new Range16.Ptr(3892, 3896, 2), new Range16.Ptr(4030, 4037, 1), new Range16.Ptr(4039, 4044, 1), new Range16.Ptr(4046, 4047, 1), new Range16.Ptr(4053, 4056, 1), new Range16.Ptr(4254, 4255, 1), new Range16.Ptr(5008, 5017, 1), new Range16.Ptr(6107, 6464, 357), new Range16.Ptr(6622, 6655, 1), new Range16.Ptr(7009, 7018, 1), new Range16.Ptr(7028, 7036, 1), new Range16.Ptr(8125, 8127, 2), new Range16.Ptr(8128, 8129, 1), new Range16.Ptr(8141, 8143, 1), new Range16.Ptr(8157, 8159, 1), new Range16.Ptr(8173, 8175, 1), new Range16.Ptr(8189, 8190, 1), new Range16.Ptr(8260, 8274, 14), new Range16.Ptr(8314, 8316, 1), new Range16.Ptr(8330, 8332, 1), new Range16.Ptr(8352, 8378, 1), new Range16.Ptr(8448, 8449, 1), new Range16.Ptr(8451, 8454, 1), new Range16.Ptr(8456, 8457, 1), new Range16.Ptr(8468, 8470, 2), new Range16.Ptr(8471, 8472, 1), new Range16.Ptr(8478, 8483, 1), new Range16.Ptr(8485, 8489, 2), new Range16.Ptr(8494, 8506, 12), new Range16.Ptr(8507, 8512, 5), new Range16.Ptr(8513, 8516, 1), new Range16.Ptr(8522, 8525, 1), new Range16.Ptr(8527, 8592, 65), new Range16.Ptr(8593, 9000, 1), new Range16.Ptr(9003, 9203, 1), new Range16.Ptr(9216, 9254, 1), new Range16.Ptr(9280, 9290, 1), new Range16.Ptr(9372, 9449, 1), new Range16.Ptr(9472, 9983, 1), new Range16.Ptr(9985, 10087, 1), new Range16.Ptr(10132, 10180, 1), new Range16.Ptr(10183, 10213, 1), new Range16.Ptr(10224, 10626, 1), new Range16.Ptr(10649, 10711, 1), new Range16.Ptr(10716, 10747, 1), new Range16.Ptr(10750, 11084, 1), new Range16.Ptr(11088, 11097, 1), new Range16.Ptr(11493, 11498, 1), new Range16.Ptr(11904, 11929, 1), new Range16.Ptr(11931, 12019, 1), new Range16.Ptr(12032, 12245, 1), new Range16.Ptr(12272, 12283, 1), new Range16.Ptr(12292, 12306, 14), new Range16.Ptr(12307, 12320, 13), new Range16.Ptr(12342, 12343, 1), new Range16.Ptr(12350, 12351, 1), new Range16.Ptr(12443, 12444, 1), new Range16.Ptr(12688, 12689, 1), new Range16.Ptr(12694, 12703, 1), new Range16.Ptr(12736, 12771, 1), new Range16.Ptr(12800, 12830, 1), new Range16.Ptr(12842, 12871, 1), new Range16.Ptr(12880, 12896, 16), new Range16.Ptr(12897, 12927, 1), new Range16.Ptr(12938, 12976, 1), new Range16.Ptr(12992, 13054, 1), new Range16.Ptr(13056, 13311, 1), new Range16.Ptr(19904, 19967, 1), new Range16.Ptr(42128, 42182, 1), new Range16.Ptr(42752, 42774, 1), new Range16.Ptr(42784, 42785, 1), new Range16.Ptr(42889, 42890, 1), new Range16.Ptr(43048, 43051, 1), new Range16.Ptr(43062, 43065, 1), new Range16.Ptr(43639, 43641, 1), new Range16.Ptr(64297, 64434, 137), new Range16.Ptr(64435, 64449, 1), new Range16.Ptr(65020, 65021, 1), new Range16.Ptr(65122, 65124, 2), new Range16.Ptr(65125, 65126, 1), new Range16.Ptr(65129, 65284, 155), new Range16.Ptr(65291, 65308, 17), new Range16.Ptr(65309, 65310, 1), new Range16.Ptr(65342, 65344, 2), new Range16.Ptr(65372, 65374, 2), new Range16.Ptr(65504, 65510, 1), new Range16.Ptr(65512, 65518, 1), new Range16.Ptr(65532, 65533, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65847, 65855, 1), new Range32.Ptr(65913, 65929, 1), new Range32.Ptr(65936, 65947, 1), new Range32.Ptr(66000, 66044, 1), new Range32.Ptr(118784, 119029, 1), new Range32.Ptr(119040, 119078, 1), new Range32.Ptr(119081, 119140, 1), new Range32.Ptr(119146, 119148, 1), new Range32.Ptr(119171, 119172, 1), new Range32.Ptr(119180, 119209, 1), new Range32.Ptr(119214, 119261, 1), new Range32.Ptr(119296, 119361, 1), new Range32.Ptr(119365, 119552, 187), new Range32.Ptr(119553, 119638, 1), new Range32.Ptr(120513, 120539, 26), new Range32.Ptr(120571, 120597, 26), new Range32.Ptr(120629, 120655, 26), new Range32.Ptr(120687, 120713, 26), new Range32.Ptr(120745, 120771, 26), new Range32.Ptr(126704, 126705, 1), new Range32.Ptr(126976, 127019, 1), new Range32.Ptr(127024, 127123, 1), new Range32.Ptr(127136, 127150, 1), new Range32.Ptr(127153, 127166, 1), new Range32.Ptr(127169, 127183, 1), new Range32.Ptr(127185, 127199, 1), new Range32.Ptr(127248, 127278, 1), new Range32.Ptr(127280, 127339, 1), new Range32.Ptr(127344, 127386, 1), new Range32.Ptr(127462, 127490, 1), new Range32.Ptr(127504, 127546, 1), new Range32.Ptr(127552, 127560, 1), new Range32.Ptr(127568, 127569, 1), new Range32.Ptr(127744, 127776, 1), new Range32.Ptr(127792, 127797, 1), new Range32.Ptr(127799, 127868, 1), new Range32.Ptr(127872, 127891, 1), new Range32.Ptr(127904, 127940, 1), new Range32.Ptr(127942, 127946, 1), new Range32.Ptr(127968, 127984, 1), new Range32.Ptr(128000, 128062, 1), new Range32.Ptr(128064, 128066, 2), new Range32.Ptr(128067, 128247, 1), new Range32.Ptr(128249, 128252, 1), new Range32.Ptr(128256, 128317, 1), new Range32.Ptr(128320, 128323, 1), new Range32.Ptr(128336, 128359, 1), new Range32.Ptr(128507, 128576, 1), new Range32.Ptr(128581, 128591, 1), new Range32.Ptr(128640, 128709, 1), new Range32.Ptr(128768, 128883, 1)]), 10);
		go$pkg.S = _S;
		_Zs = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(32, 160, 128), new Range16.Ptr(5760, 6158, 398), new Range16.Ptr(8192, 8202, 1), new Range16.Ptr(8239, 8287, 48), new Range16.Ptr(12288, 12288, 1)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Zs = _Zs;
		go$pkg.GraphicRanges = new (go$sliceType((go$ptrType(RangeTable))))([go$pkg.L, go$pkg.M, go$pkg.N, go$pkg.P, go$pkg.S, go$pkg.Zs]);
		go$pkg.PrintRanges = new (go$sliceType((go$ptrType(RangeTable))))([go$pkg.L, go$pkg.M, go$pkg.N, go$pkg.P, go$pkg.S]);
		_Cc = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1, 31, 1), new Range16.Ptr(127, 159, 1)]), (go$sliceType(Range32)).nil, 2);
		go$pkg.Cc = _Cc;
		_Cf = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(173, 1536, 1363), new Range16.Ptr(1537, 1540, 1), new Range16.Ptr(1757, 1807, 50), new Range16.Ptr(8203, 8207, 1), new Range16.Ptr(8234, 8238, 1), new Range16.Ptr(8288, 8292, 1), new Range16.Ptr(8298, 8303, 1), new Range16.Ptr(65279, 65529, 250), new Range16.Ptr(65530, 65531, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(69821, 119155, 49334), new Range32.Ptr(119156, 119162, 1), new Range32.Ptr(917505, 917536, 31), new Range32.Ptr(917537, 917631, 1)]), 0);
		go$pkg.Cf = _Cf;
		_Co = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(57344, 63743, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(983040, 1048573, 1), new Range32.Ptr(1048576, 1114109, 1)]), 0);
		go$pkg.Co = _Co;
		_Cs = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(55296, 57343, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Cs = _Cs;
		_Nd = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(48, 57, 1), new Range16.Ptr(1632, 1641, 1), new Range16.Ptr(1776, 1785, 1), new Range16.Ptr(1984, 1993, 1), new Range16.Ptr(2406, 2415, 1), new Range16.Ptr(2534, 2543, 1), new Range16.Ptr(2662, 2671, 1), new Range16.Ptr(2790, 2799, 1), new Range16.Ptr(2918, 2927, 1), new Range16.Ptr(3046, 3055, 1), new Range16.Ptr(3174, 3183, 1), new Range16.Ptr(3302, 3311, 1), new Range16.Ptr(3430, 3439, 1), new Range16.Ptr(3664, 3673, 1), new Range16.Ptr(3792, 3801, 1), new Range16.Ptr(3872, 3881, 1), new Range16.Ptr(4160, 4169, 1), new Range16.Ptr(4240, 4249, 1), new Range16.Ptr(6112, 6121, 1), new Range16.Ptr(6160, 6169, 1), new Range16.Ptr(6470, 6479, 1), new Range16.Ptr(6608, 6617, 1), new Range16.Ptr(6784, 6793, 1), new Range16.Ptr(6800, 6809, 1), new Range16.Ptr(6992, 7001, 1), new Range16.Ptr(7088, 7097, 1), new Range16.Ptr(7232, 7241, 1), new Range16.Ptr(7248, 7257, 1), new Range16.Ptr(42528, 42537, 1), new Range16.Ptr(43216, 43225, 1), new Range16.Ptr(43264, 43273, 1), new Range16.Ptr(43472, 43481, 1), new Range16.Ptr(43600, 43609, 1), new Range16.Ptr(44016, 44025, 1), new Range16.Ptr(65296, 65305, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66720, 66729, 1), new Range32.Ptr(69734, 69743, 1), new Range32.Ptr(69872, 69881, 1), new Range32.Ptr(69942, 69951, 1), new Range32.Ptr(70096, 70105, 1), new Range32.Ptr(71360, 71369, 1), new Range32.Ptr(120782, 120831, 1)]), 1);
		go$pkg.Nd = _Nd;
		_Lm = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(688, 705, 1), new Range16.Ptr(710, 721, 1), new Range16.Ptr(736, 740, 1), new Range16.Ptr(748, 750, 2), new Range16.Ptr(884, 890, 6), new Range16.Ptr(1369, 1600, 231), new Range16.Ptr(1765, 1766, 1), new Range16.Ptr(2036, 2037, 1), new Range16.Ptr(2042, 2074, 32), new Range16.Ptr(2084, 2088, 4), new Range16.Ptr(2417, 3654, 1237), new Range16.Ptr(3782, 4348, 566), new Range16.Ptr(6103, 6211, 108), new Range16.Ptr(6823, 7288, 465), new Range16.Ptr(7289, 7293, 1), new Range16.Ptr(7468, 7530, 1), new Range16.Ptr(7544, 7579, 35), new Range16.Ptr(7580, 7615, 1), new Range16.Ptr(8305, 8319, 14), new Range16.Ptr(8336, 8348, 1), new Range16.Ptr(11388, 11389, 1), new Range16.Ptr(11631, 11823, 192), new Range16.Ptr(12293, 12337, 44), new Range16.Ptr(12338, 12341, 1), new Range16.Ptr(12347, 12445, 98), new Range16.Ptr(12446, 12540, 94), new Range16.Ptr(12541, 12542, 1), new Range16.Ptr(40981, 42232, 1251), new Range16.Ptr(42233, 42237, 1), new Range16.Ptr(42508, 42623, 115), new Range16.Ptr(42775, 42783, 1), new Range16.Ptr(42864, 42888, 24), new Range16.Ptr(43000, 43001, 1), new Range16.Ptr(43471, 43632, 161), new Range16.Ptr(43741, 43763, 22), new Range16.Ptr(43764, 65392, 21628), new Range16.Ptr(65438, 65439, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(94099, 94111, 1)]), 0);
		go$pkg.Lm = _Lm;
		_Lo = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(170, 186, 16), new Range16.Ptr(443, 448, 5), new Range16.Ptr(449, 451, 1), new Range16.Ptr(660, 1488, 828), new Range16.Ptr(1489, 1514, 1), new Range16.Ptr(1520, 1522, 1), new Range16.Ptr(1568, 1599, 1), new Range16.Ptr(1601, 1610, 1), new Range16.Ptr(1646, 1647, 1), new Range16.Ptr(1649, 1747, 1), new Range16.Ptr(1749, 1774, 25), new Range16.Ptr(1775, 1786, 11), new Range16.Ptr(1787, 1788, 1), new Range16.Ptr(1791, 1808, 17), new Range16.Ptr(1810, 1839, 1), new Range16.Ptr(1869, 1957, 1), new Range16.Ptr(1969, 1994, 25), new Range16.Ptr(1995, 2026, 1), new Range16.Ptr(2048, 2069, 1), new Range16.Ptr(2112, 2136, 1), new Range16.Ptr(2208, 2210, 2), new Range16.Ptr(2211, 2220, 1), new Range16.Ptr(2308, 2361, 1), new Range16.Ptr(2365, 2384, 19), new Range16.Ptr(2392, 2401, 1), new Range16.Ptr(2418, 2423, 1), new Range16.Ptr(2425, 2431, 1), new Range16.Ptr(2437, 2444, 1), new Range16.Ptr(2447, 2448, 1), new Range16.Ptr(2451, 2472, 1), new Range16.Ptr(2474, 2480, 1), new Range16.Ptr(2482, 2486, 4), new Range16.Ptr(2487, 2489, 1), new Range16.Ptr(2493, 2510, 17), new Range16.Ptr(2524, 2525, 1), new Range16.Ptr(2527, 2529, 1), new Range16.Ptr(2544, 2545, 1), new Range16.Ptr(2565, 2570, 1), new Range16.Ptr(2575, 2576, 1), new Range16.Ptr(2579, 2600, 1), new Range16.Ptr(2602, 2608, 1), new Range16.Ptr(2610, 2611, 1), new Range16.Ptr(2613, 2614, 1), new Range16.Ptr(2616, 2617, 1), new Range16.Ptr(2649, 2652, 1), new Range16.Ptr(2654, 2674, 20), new Range16.Ptr(2675, 2676, 1), new Range16.Ptr(2693, 2701, 1), new Range16.Ptr(2703, 2705, 1), new Range16.Ptr(2707, 2728, 1), new Range16.Ptr(2730, 2736, 1), new Range16.Ptr(2738, 2739, 1), new Range16.Ptr(2741, 2745, 1), new Range16.Ptr(2749, 2768, 19), new Range16.Ptr(2784, 2785, 1), new Range16.Ptr(2821, 2828, 1), new Range16.Ptr(2831, 2832, 1), new Range16.Ptr(2835, 2856, 1), new Range16.Ptr(2858, 2864, 1), new Range16.Ptr(2866, 2867, 1), new Range16.Ptr(2869, 2873, 1), new Range16.Ptr(2877, 2908, 31), new Range16.Ptr(2909, 2911, 2), new Range16.Ptr(2912, 2913, 1), new Range16.Ptr(2929, 2947, 18), new Range16.Ptr(2949, 2954, 1), new Range16.Ptr(2958, 2960, 1), new Range16.Ptr(2962, 2965, 1), new Range16.Ptr(2969, 2970, 1), new Range16.Ptr(2972, 2974, 2), new Range16.Ptr(2975, 2979, 4), new Range16.Ptr(2980, 2984, 4), new Range16.Ptr(2985, 2986, 1), new Range16.Ptr(2990, 3001, 1), new Range16.Ptr(3024, 3077, 53), new Range16.Ptr(3078, 3084, 1), new Range16.Ptr(3086, 3088, 1), new Range16.Ptr(3090, 3112, 1), new Range16.Ptr(3114, 3123, 1), new Range16.Ptr(3125, 3129, 1), new Range16.Ptr(3133, 3160, 27), new Range16.Ptr(3161, 3168, 7), new Range16.Ptr(3169, 3205, 36), new Range16.Ptr(3206, 3212, 1), new Range16.Ptr(3214, 3216, 1), new Range16.Ptr(3218, 3240, 1), new Range16.Ptr(3242, 3251, 1), new Range16.Ptr(3253, 3257, 1), new Range16.Ptr(3261, 3294, 33), new Range16.Ptr(3296, 3297, 1), new Range16.Ptr(3313, 3314, 1), new Range16.Ptr(3333, 3340, 1), new Range16.Ptr(3342, 3344, 1), new Range16.Ptr(3346, 3386, 1), new Range16.Ptr(3389, 3406, 17), new Range16.Ptr(3424, 3425, 1), new Range16.Ptr(3450, 3455, 1), new Range16.Ptr(3461, 3478, 1), new Range16.Ptr(3482, 3505, 1), new Range16.Ptr(3507, 3515, 1), new Range16.Ptr(3517, 3520, 3), new Range16.Ptr(3521, 3526, 1), new Range16.Ptr(3585, 3632, 1), new Range16.Ptr(3634, 3635, 1), new Range16.Ptr(3648, 3653, 1), new Range16.Ptr(3713, 3714, 1), new Range16.Ptr(3716, 3719, 3), new Range16.Ptr(3720, 3722, 2), new Range16.Ptr(3725, 3732, 7), new Range16.Ptr(3733, 3735, 1), new Range16.Ptr(3737, 3743, 1), new Range16.Ptr(3745, 3747, 1), new Range16.Ptr(3749, 3751, 2), new Range16.Ptr(3754, 3755, 1), new Range16.Ptr(3757, 3760, 1), new Range16.Ptr(3762, 3763, 1), new Range16.Ptr(3773, 3776, 3), new Range16.Ptr(3777, 3780, 1), new Range16.Ptr(3804, 3807, 1), new Range16.Ptr(3840, 3904, 64), new Range16.Ptr(3905, 3911, 1), new Range16.Ptr(3913, 3948, 1), new Range16.Ptr(3976, 3980, 1), new Range16.Ptr(4096, 4138, 1), new Range16.Ptr(4159, 4176, 17), new Range16.Ptr(4177, 4181, 1), new Range16.Ptr(4186, 4189, 1), new Range16.Ptr(4193, 4197, 4), new Range16.Ptr(4198, 4206, 8), new Range16.Ptr(4207, 4208, 1), new Range16.Ptr(4213, 4225, 1), new Range16.Ptr(4238, 4304, 66), new Range16.Ptr(4305, 4346, 1), new Range16.Ptr(4349, 4680, 1), new Range16.Ptr(4682, 4685, 1), new Range16.Ptr(4688, 4694, 1), new Range16.Ptr(4696, 4698, 2), new Range16.Ptr(4699, 4701, 1), new Range16.Ptr(4704, 4744, 1), new Range16.Ptr(4746, 4749, 1), new Range16.Ptr(4752, 4784, 1), new Range16.Ptr(4786, 4789, 1), new Range16.Ptr(4792, 4798, 1), new Range16.Ptr(4800, 4802, 2), new Range16.Ptr(4803, 4805, 1), new Range16.Ptr(4808, 4822, 1), new Range16.Ptr(4824, 4880, 1), new Range16.Ptr(4882, 4885, 1), new Range16.Ptr(4888, 4954, 1), new Range16.Ptr(4992, 5007, 1), new Range16.Ptr(5024, 5108, 1), new Range16.Ptr(5121, 5740, 1), new Range16.Ptr(5743, 5759, 1), new Range16.Ptr(5761, 5786, 1), new Range16.Ptr(5792, 5866, 1), new Range16.Ptr(5888, 5900, 1), new Range16.Ptr(5902, 5905, 1), new Range16.Ptr(5920, 5937, 1), new Range16.Ptr(5952, 5969, 1), new Range16.Ptr(5984, 5996, 1), new Range16.Ptr(5998, 6000, 1), new Range16.Ptr(6016, 6067, 1), new Range16.Ptr(6108, 6176, 68), new Range16.Ptr(6177, 6210, 1), new Range16.Ptr(6212, 6263, 1), new Range16.Ptr(6272, 6312, 1), new Range16.Ptr(6314, 6320, 6), new Range16.Ptr(6321, 6389, 1), new Range16.Ptr(6400, 6428, 1), new Range16.Ptr(6480, 6509, 1), new Range16.Ptr(6512, 6516, 1), new Range16.Ptr(6528, 6571, 1), new Range16.Ptr(6593, 6599, 1), new Range16.Ptr(6656, 6678, 1), new Range16.Ptr(6688, 6740, 1), new Range16.Ptr(6917, 6963, 1), new Range16.Ptr(6981, 6987, 1), new Range16.Ptr(7043, 7072, 1), new Range16.Ptr(7086, 7087, 1), new Range16.Ptr(7098, 7141, 1), new Range16.Ptr(7168, 7203, 1), new Range16.Ptr(7245, 7247, 1), new Range16.Ptr(7258, 7287, 1), new Range16.Ptr(7401, 7404, 1), new Range16.Ptr(7406, 7409, 1), new Range16.Ptr(7413, 7414, 1), new Range16.Ptr(8501, 8504, 1), new Range16.Ptr(11568, 11623, 1), new Range16.Ptr(11648, 11670, 1), new Range16.Ptr(11680, 11686, 1), new Range16.Ptr(11688, 11694, 1), new Range16.Ptr(11696, 11702, 1), new Range16.Ptr(11704, 11710, 1), new Range16.Ptr(11712, 11718, 1), new Range16.Ptr(11720, 11726, 1), new Range16.Ptr(11728, 11734, 1), new Range16.Ptr(11736, 11742, 1), new Range16.Ptr(12294, 12348, 54), new Range16.Ptr(12353, 12438, 1), new Range16.Ptr(12447, 12449, 2), new Range16.Ptr(12450, 12538, 1), new Range16.Ptr(12543, 12549, 6), new Range16.Ptr(12550, 12589, 1), new Range16.Ptr(12593, 12686, 1), new Range16.Ptr(12704, 12730, 1), new Range16.Ptr(12784, 12799, 1), new Range16.Ptr(13312, 19893, 1), new Range16.Ptr(19968, 40908, 1), new Range16.Ptr(40960, 40980, 1), new Range16.Ptr(40982, 42124, 1), new Range16.Ptr(42192, 42231, 1), new Range16.Ptr(42240, 42507, 1), new Range16.Ptr(42512, 42527, 1), new Range16.Ptr(42538, 42539, 1), new Range16.Ptr(42606, 42656, 50), new Range16.Ptr(42657, 42725, 1), new Range16.Ptr(43003, 43009, 1), new Range16.Ptr(43011, 43013, 1), new Range16.Ptr(43015, 43018, 1), new Range16.Ptr(43020, 43042, 1), new Range16.Ptr(43072, 43123, 1), new Range16.Ptr(43138, 43187, 1), new Range16.Ptr(43250, 43255, 1), new Range16.Ptr(43259, 43274, 15), new Range16.Ptr(43275, 43301, 1), new Range16.Ptr(43312, 43334, 1), new Range16.Ptr(43360, 43388, 1), new Range16.Ptr(43396, 43442, 1), new Range16.Ptr(43520, 43560, 1), new Range16.Ptr(43584, 43586, 1), new Range16.Ptr(43588, 43595, 1), new Range16.Ptr(43616, 43631, 1), new Range16.Ptr(43633, 43638, 1), new Range16.Ptr(43642, 43648, 6), new Range16.Ptr(43649, 43695, 1), new Range16.Ptr(43697, 43701, 4), new Range16.Ptr(43702, 43705, 3), new Range16.Ptr(43706, 43709, 1), new Range16.Ptr(43712, 43714, 2), new Range16.Ptr(43739, 43740, 1), new Range16.Ptr(43744, 43754, 1), new Range16.Ptr(43762, 43777, 15), new Range16.Ptr(43778, 43782, 1), new Range16.Ptr(43785, 43790, 1), new Range16.Ptr(43793, 43798, 1), new Range16.Ptr(43808, 43814, 1), new Range16.Ptr(43816, 43822, 1), new Range16.Ptr(43968, 44002, 1), new Range16.Ptr(44032, 55203, 1), new Range16.Ptr(55216, 55238, 1), new Range16.Ptr(55243, 55291, 1), new Range16.Ptr(63744, 64109, 1), new Range16.Ptr(64112, 64217, 1), new Range16.Ptr(64285, 64287, 2), new Range16.Ptr(64288, 64296, 1), new Range16.Ptr(64298, 64310, 1), new Range16.Ptr(64312, 64316, 1), new Range16.Ptr(64318, 64320, 2), new Range16.Ptr(64321, 64323, 2), new Range16.Ptr(64324, 64326, 2), new Range16.Ptr(64327, 64433, 1), new Range16.Ptr(64467, 64829, 1), new Range16.Ptr(64848, 64911, 1), new Range16.Ptr(64914, 64967, 1), new Range16.Ptr(65008, 65019, 1), new Range16.Ptr(65136, 65140, 1), new Range16.Ptr(65142, 65276, 1), new Range16.Ptr(65382, 65391, 1), new Range16.Ptr(65393, 65437, 1), new Range16.Ptr(65440, 65470, 1), new Range16.Ptr(65474, 65479, 1), new Range16.Ptr(65482, 65487, 1), new Range16.Ptr(65490, 65495, 1), new Range16.Ptr(65498, 65500, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65536, 65547, 1), new Range32.Ptr(65549, 65574, 1), new Range32.Ptr(65576, 65594, 1), new Range32.Ptr(65596, 65597, 1), new Range32.Ptr(65599, 65613, 1), new Range32.Ptr(65616, 65629, 1), new Range32.Ptr(65664, 65786, 1), new Range32.Ptr(66176, 66204, 1), new Range32.Ptr(66208, 66256, 1), new Range32.Ptr(66304, 66334, 1), new Range32.Ptr(66352, 66368, 1), new Range32.Ptr(66370, 66377, 1), new Range32.Ptr(66432, 66461, 1), new Range32.Ptr(66464, 66499, 1), new Range32.Ptr(66504, 66511, 1), new Range32.Ptr(66640, 66717, 1), new Range32.Ptr(67584, 67589, 1), new Range32.Ptr(67592, 67594, 2), new Range32.Ptr(67595, 67637, 1), new Range32.Ptr(67639, 67640, 1), new Range32.Ptr(67644, 67647, 3), new Range32.Ptr(67648, 67669, 1), new Range32.Ptr(67840, 67861, 1), new Range32.Ptr(67872, 67897, 1), new Range32.Ptr(67968, 68023, 1), new Range32.Ptr(68030, 68031, 1), new Range32.Ptr(68096, 68112, 16), new Range32.Ptr(68113, 68115, 1), new Range32.Ptr(68117, 68119, 1), new Range32.Ptr(68121, 68147, 1), new Range32.Ptr(68192, 68220, 1), new Range32.Ptr(68352, 68405, 1), new Range32.Ptr(68416, 68437, 1), new Range32.Ptr(68448, 68466, 1), new Range32.Ptr(68608, 68680, 1), new Range32.Ptr(69635, 69687, 1), new Range32.Ptr(69763, 69807, 1), new Range32.Ptr(69840, 69864, 1), new Range32.Ptr(69891, 69926, 1), new Range32.Ptr(70019, 70066, 1), new Range32.Ptr(70081, 70084, 1), new Range32.Ptr(71296, 71338, 1), new Range32.Ptr(73728, 74606, 1), new Range32.Ptr(77824, 78894, 1), new Range32.Ptr(92160, 92728, 1), new Range32.Ptr(93952, 94020, 1), new Range32.Ptr(94032, 110592, 16560), new Range32.Ptr(110593, 126464, 15871), new Range32.Ptr(126465, 126467, 1), new Range32.Ptr(126469, 126495, 1), new Range32.Ptr(126497, 126498, 1), new Range32.Ptr(126500, 126503, 3), new Range32.Ptr(126505, 126514, 1), new Range32.Ptr(126516, 126519, 1), new Range32.Ptr(126521, 126523, 2), new Range32.Ptr(126530, 126535, 5), new Range32.Ptr(126537, 126541, 2), new Range32.Ptr(126542, 126543, 1), new Range32.Ptr(126545, 126546, 1), new Range32.Ptr(126548, 126551, 3), new Range32.Ptr(126553, 126561, 2), new Range32.Ptr(126562, 126564, 2), new Range32.Ptr(126567, 126570, 1), new Range32.Ptr(126572, 126578, 1), new Range32.Ptr(126580, 126583, 1), new Range32.Ptr(126585, 126588, 1), new Range32.Ptr(126590, 126592, 2), new Range32.Ptr(126593, 126601, 1), new Range32.Ptr(126603, 126619, 1), new Range32.Ptr(126625, 126627, 1), new Range32.Ptr(126629, 126633, 1), new Range32.Ptr(126635, 126651, 1), new Range32.Ptr(131072, 173782, 1), new Range32.Ptr(173824, 177972, 1), new Range32.Ptr(177984, 178205, 1), new Range32.Ptr(194560, 195101, 1)]), 1);
		go$pkg.Lo = _Lo;
		_Ll = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(97, 122, 1), new Range16.Ptr(181, 223, 42), new Range16.Ptr(224, 246, 1), new Range16.Ptr(248, 255, 1), new Range16.Ptr(257, 311, 2), new Range16.Ptr(312, 328, 2), new Range16.Ptr(329, 375, 2), new Range16.Ptr(378, 382, 2), new Range16.Ptr(383, 384, 1), new Range16.Ptr(387, 389, 2), new Range16.Ptr(392, 396, 4), new Range16.Ptr(397, 402, 5), new Range16.Ptr(405, 409, 4), new Range16.Ptr(410, 411, 1), new Range16.Ptr(414, 417, 3), new Range16.Ptr(419, 421, 2), new Range16.Ptr(424, 426, 2), new Range16.Ptr(427, 429, 2), new Range16.Ptr(432, 436, 4), new Range16.Ptr(438, 441, 3), new Range16.Ptr(442, 445, 3), new Range16.Ptr(446, 447, 1), new Range16.Ptr(454, 460, 3), new Range16.Ptr(462, 476, 2), new Range16.Ptr(477, 495, 2), new Range16.Ptr(496, 499, 3), new Range16.Ptr(501, 505, 4), new Range16.Ptr(507, 563, 2), new Range16.Ptr(564, 569, 1), new Range16.Ptr(572, 575, 3), new Range16.Ptr(576, 578, 2), new Range16.Ptr(583, 591, 2), new Range16.Ptr(592, 659, 1), new Range16.Ptr(661, 687, 1), new Range16.Ptr(881, 883, 2), new Range16.Ptr(887, 891, 4), new Range16.Ptr(892, 893, 1), new Range16.Ptr(912, 940, 28), new Range16.Ptr(941, 974, 1), new Range16.Ptr(976, 977, 1), new Range16.Ptr(981, 983, 1), new Range16.Ptr(985, 1007, 2), new Range16.Ptr(1008, 1011, 1), new Range16.Ptr(1013, 1019, 3), new Range16.Ptr(1020, 1072, 52), new Range16.Ptr(1073, 1119, 1), new Range16.Ptr(1121, 1153, 2), new Range16.Ptr(1163, 1215, 2), new Range16.Ptr(1218, 1230, 2), new Range16.Ptr(1231, 1319, 2), new Range16.Ptr(1377, 1415, 1), new Range16.Ptr(7424, 7467, 1), new Range16.Ptr(7531, 7543, 1), new Range16.Ptr(7545, 7578, 1), new Range16.Ptr(7681, 7829, 2), new Range16.Ptr(7830, 7837, 1), new Range16.Ptr(7839, 7935, 2), new Range16.Ptr(7936, 7943, 1), new Range16.Ptr(7952, 7957, 1), new Range16.Ptr(7968, 7975, 1), new Range16.Ptr(7984, 7991, 1), new Range16.Ptr(8000, 8005, 1), new Range16.Ptr(8016, 8023, 1), new Range16.Ptr(8032, 8039, 1), new Range16.Ptr(8048, 8061, 1), new Range16.Ptr(8064, 8071, 1), new Range16.Ptr(8080, 8087, 1), new Range16.Ptr(8096, 8103, 1), new Range16.Ptr(8112, 8116, 1), new Range16.Ptr(8118, 8119, 1), new Range16.Ptr(8126, 8130, 4), new Range16.Ptr(8131, 8132, 1), new Range16.Ptr(8134, 8135, 1), new Range16.Ptr(8144, 8147, 1), new Range16.Ptr(8150, 8151, 1), new Range16.Ptr(8160, 8167, 1), new Range16.Ptr(8178, 8180, 1), new Range16.Ptr(8182, 8183, 1), new Range16.Ptr(8458, 8462, 4), new Range16.Ptr(8463, 8467, 4), new Range16.Ptr(8495, 8505, 5), new Range16.Ptr(8508, 8509, 1), new Range16.Ptr(8518, 8521, 1), new Range16.Ptr(8526, 8580, 54), new Range16.Ptr(11312, 11358, 1), new Range16.Ptr(11361, 11365, 4), new Range16.Ptr(11366, 11372, 2), new Range16.Ptr(11377, 11379, 2), new Range16.Ptr(11380, 11382, 2), new Range16.Ptr(11383, 11387, 1), new Range16.Ptr(11393, 11491, 2), new Range16.Ptr(11492, 11500, 8), new Range16.Ptr(11502, 11507, 5), new Range16.Ptr(11520, 11557, 1), new Range16.Ptr(11559, 11565, 6), new Range16.Ptr(42561, 42605, 2), new Range16.Ptr(42625, 42647, 2), new Range16.Ptr(42787, 42799, 2), new Range16.Ptr(42800, 42801, 1), new Range16.Ptr(42803, 42865, 2), new Range16.Ptr(42866, 42872, 1), new Range16.Ptr(42874, 42876, 2), new Range16.Ptr(42879, 42887, 2), new Range16.Ptr(42892, 42894, 2), new Range16.Ptr(42897, 42899, 2), new Range16.Ptr(42913, 42921, 2), new Range16.Ptr(43002, 64256, 21254), new Range16.Ptr(64257, 64262, 1), new Range16.Ptr(64275, 64279, 1), new Range16.Ptr(65345, 65370, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66600, 66639, 1), new Range32.Ptr(119834, 119859, 1), new Range32.Ptr(119886, 119892, 1), new Range32.Ptr(119894, 119911, 1), new Range32.Ptr(119938, 119963, 1), new Range32.Ptr(119990, 119993, 1), new Range32.Ptr(119995, 119997, 2), new Range32.Ptr(119998, 120003, 1), new Range32.Ptr(120005, 120015, 1), new Range32.Ptr(120042, 120067, 1), new Range32.Ptr(120094, 120119, 1), new Range32.Ptr(120146, 120171, 1), new Range32.Ptr(120198, 120223, 1), new Range32.Ptr(120250, 120275, 1), new Range32.Ptr(120302, 120327, 1), new Range32.Ptr(120354, 120379, 1), new Range32.Ptr(120406, 120431, 1), new Range32.Ptr(120458, 120485, 1), new Range32.Ptr(120514, 120538, 1), new Range32.Ptr(120540, 120545, 1), new Range32.Ptr(120572, 120596, 1), new Range32.Ptr(120598, 120603, 1), new Range32.Ptr(120630, 120654, 1), new Range32.Ptr(120656, 120661, 1), new Range32.Ptr(120688, 120712, 1), new Range32.Ptr(120714, 120719, 1), new Range32.Ptr(120746, 120770, 1), new Range32.Ptr(120772, 120777, 1), new Range32.Ptr(120779, 120779, 1)]), 4);
		go$pkg.Ll = _Ll;
		_Mc = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2307, 2363, 56), new Range16.Ptr(2366, 2368, 1), new Range16.Ptr(2377, 2380, 1), new Range16.Ptr(2382, 2383, 1), new Range16.Ptr(2434, 2435, 1), new Range16.Ptr(2494, 2496, 1), new Range16.Ptr(2503, 2504, 1), new Range16.Ptr(2507, 2508, 1), new Range16.Ptr(2519, 2563, 44), new Range16.Ptr(2622, 2624, 1), new Range16.Ptr(2691, 2750, 59), new Range16.Ptr(2751, 2752, 1), new Range16.Ptr(2761, 2763, 2), new Range16.Ptr(2764, 2818, 54), new Range16.Ptr(2819, 2878, 59), new Range16.Ptr(2880, 2887, 7), new Range16.Ptr(2888, 2891, 3), new Range16.Ptr(2892, 2903, 11), new Range16.Ptr(3006, 3007, 1), new Range16.Ptr(3009, 3010, 1), new Range16.Ptr(3014, 3016, 1), new Range16.Ptr(3018, 3020, 1), new Range16.Ptr(3031, 3073, 42), new Range16.Ptr(3074, 3075, 1), new Range16.Ptr(3137, 3140, 1), new Range16.Ptr(3202, 3203, 1), new Range16.Ptr(3262, 3264, 2), new Range16.Ptr(3265, 3268, 1), new Range16.Ptr(3271, 3272, 1), new Range16.Ptr(3274, 3275, 1), new Range16.Ptr(3285, 3286, 1), new Range16.Ptr(3330, 3331, 1), new Range16.Ptr(3390, 3392, 1), new Range16.Ptr(3398, 3400, 1), new Range16.Ptr(3402, 3404, 1), new Range16.Ptr(3415, 3458, 43), new Range16.Ptr(3459, 3535, 76), new Range16.Ptr(3536, 3537, 1), new Range16.Ptr(3544, 3551, 1), new Range16.Ptr(3570, 3571, 1), new Range16.Ptr(3902, 3903, 1), new Range16.Ptr(3967, 4139, 172), new Range16.Ptr(4140, 4145, 5), new Range16.Ptr(4152, 4155, 3), new Range16.Ptr(4156, 4182, 26), new Range16.Ptr(4183, 4194, 11), new Range16.Ptr(4195, 4196, 1), new Range16.Ptr(4199, 4205, 1), new Range16.Ptr(4227, 4228, 1), new Range16.Ptr(4231, 4236, 1), new Range16.Ptr(4239, 4250, 11), new Range16.Ptr(4251, 4252, 1), new Range16.Ptr(6070, 6078, 8), new Range16.Ptr(6079, 6085, 1), new Range16.Ptr(6087, 6088, 1), new Range16.Ptr(6435, 6438, 1), new Range16.Ptr(6441, 6443, 1), new Range16.Ptr(6448, 6449, 1), new Range16.Ptr(6451, 6456, 1), new Range16.Ptr(6576, 6592, 1), new Range16.Ptr(6600, 6601, 1), new Range16.Ptr(6681, 6683, 1), new Range16.Ptr(6741, 6743, 2), new Range16.Ptr(6753, 6755, 2), new Range16.Ptr(6756, 6765, 9), new Range16.Ptr(6766, 6770, 1), new Range16.Ptr(6916, 6965, 49), new Range16.Ptr(6971, 6973, 2), new Range16.Ptr(6974, 6977, 1), new Range16.Ptr(6979, 6980, 1), new Range16.Ptr(7042, 7073, 31), new Range16.Ptr(7078, 7079, 1), new Range16.Ptr(7082, 7084, 2), new Range16.Ptr(7085, 7143, 58), new Range16.Ptr(7146, 7148, 1), new Range16.Ptr(7150, 7154, 4), new Range16.Ptr(7155, 7204, 49), new Range16.Ptr(7205, 7211, 1), new Range16.Ptr(7220, 7221, 1), new Range16.Ptr(7393, 7410, 17), new Range16.Ptr(7411, 12334, 4923), new Range16.Ptr(12335, 43043, 30708), new Range16.Ptr(43044, 43047, 3), new Range16.Ptr(43136, 43137, 1), new Range16.Ptr(43188, 43203, 1), new Range16.Ptr(43346, 43347, 1), new Range16.Ptr(43395, 43444, 49), new Range16.Ptr(43445, 43450, 5), new Range16.Ptr(43451, 43453, 2), new Range16.Ptr(43454, 43456, 1), new Range16.Ptr(43567, 43568, 1), new Range16.Ptr(43571, 43572, 1), new Range16.Ptr(43597, 43643, 46), new Range16.Ptr(43755, 43758, 3), new Range16.Ptr(43759, 43765, 6), new Range16.Ptr(44003, 44004, 1), new Range16.Ptr(44006, 44007, 1), new Range16.Ptr(44009, 44010, 1), new Range16.Ptr(44012, 44012, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(69632, 69632, 1), new Range32.Ptr(69634, 69762, 128), new Range32.Ptr(69808, 69810, 1), new Range32.Ptr(69815, 69816, 1), new Range32.Ptr(69932, 70018, 86), new Range32.Ptr(70067, 70069, 1), new Range32.Ptr(70079, 70080, 1), new Range32.Ptr(71340, 71342, 2), new Range32.Ptr(71343, 71350, 7), new Range32.Ptr(94033, 94078, 1), new Range32.Ptr(119141, 119142, 1), new Range32.Ptr(119149, 119154, 1)]), 0);
		go$pkg.Mc = _Mc;
		_Me = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1160, 1161, 1), new Range16.Ptr(8413, 8416, 1), new Range16.Ptr(8418, 8420, 1), new Range16.Ptr(42608, 42610, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Me = _Me;
		_Mn = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(768, 879, 1), new Range16.Ptr(1155, 1159, 1), new Range16.Ptr(1425, 1469, 1), new Range16.Ptr(1471, 1473, 2), new Range16.Ptr(1474, 1476, 2), new Range16.Ptr(1477, 1479, 2), new Range16.Ptr(1552, 1562, 1), new Range16.Ptr(1611, 1631, 1), new Range16.Ptr(1648, 1750, 102), new Range16.Ptr(1751, 1756, 1), new Range16.Ptr(1759, 1764, 1), new Range16.Ptr(1767, 1768, 1), new Range16.Ptr(1770, 1773, 1), new Range16.Ptr(1809, 1840, 31), new Range16.Ptr(1841, 1866, 1), new Range16.Ptr(1958, 1968, 1), new Range16.Ptr(2027, 2035, 1), new Range16.Ptr(2070, 2073, 1), new Range16.Ptr(2075, 2083, 1), new Range16.Ptr(2085, 2087, 1), new Range16.Ptr(2089, 2093, 1), new Range16.Ptr(2137, 2139, 1), new Range16.Ptr(2276, 2302, 1), new Range16.Ptr(2304, 2306, 1), new Range16.Ptr(2362, 2364, 2), new Range16.Ptr(2369, 2376, 1), new Range16.Ptr(2381, 2385, 4), new Range16.Ptr(2386, 2391, 1), new Range16.Ptr(2402, 2403, 1), new Range16.Ptr(2433, 2492, 59), new Range16.Ptr(2497, 2500, 1), new Range16.Ptr(2509, 2530, 21), new Range16.Ptr(2531, 2561, 30), new Range16.Ptr(2562, 2620, 58), new Range16.Ptr(2625, 2626, 1), new Range16.Ptr(2631, 2632, 1), new Range16.Ptr(2635, 2637, 1), new Range16.Ptr(2641, 2672, 31), new Range16.Ptr(2673, 2677, 4), new Range16.Ptr(2689, 2690, 1), new Range16.Ptr(2748, 2753, 5), new Range16.Ptr(2754, 2757, 1), new Range16.Ptr(2759, 2760, 1), new Range16.Ptr(2765, 2786, 21), new Range16.Ptr(2787, 2817, 30), new Range16.Ptr(2876, 2879, 3), new Range16.Ptr(2881, 2884, 1), new Range16.Ptr(2893, 2902, 9), new Range16.Ptr(2914, 2915, 1), new Range16.Ptr(2946, 3008, 62), new Range16.Ptr(3021, 3134, 113), new Range16.Ptr(3135, 3136, 1), new Range16.Ptr(3142, 3144, 1), new Range16.Ptr(3146, 3149, 1), new Range16.Ptr(3157, 3158, 1), new Range16.Ptr(3170, 3171, 1), new Range16.Ptr(3260, 3263, 3), new Range16.Ptr(3270, 3276, 6), new Range16.Ptr(3277, 3298, 21), new Range16.Ptr(3299, 3393, 94), new Range16.Ptr(3394, 3396, 1), new Range16.Ptr(3405, 3426, 21), new Range16.Ptr(3427, 3530, 103), new Range16.Ptr(3538, 3540, 1), new Range16.Ptr(3542, 3633, 91), new Range16.Ptr(3636, 3642, 1), new Range16.Ptr(3655, 3662, 1), new Range16.Ptr(3761, 3764, 3), new Range16.Ptr(3765, 3769, 1), new Range16.Ptr(3771, 3772, 1), new Range16.Ptr(3784, 3789, 1), new Range16.Ptr(3864, 3865, 1), new Range16.Ptr(3893, 3897, 2), new Range16.Ptr(3953, 3966, 1), new Range16.Ptr(3968, 3972, 1), new Range16.Ptr(3974, 3975, 1), new Range16.Ptr(3981, 3991, 1), new Range16.Ptr(3993, 4028, 1), new Range16.Ptr(4038, 4141, 103), new Range16.Ptr(4142, 4144, 1), new Range16.Ptr(4146, 4151, 1), new Range16.Ptr(4153, 4154, 1), new Range16.Ptr(4157, 4158, 1), new Range16.Ptr(4184, 4185, 1), new Range16.Ptr(4190, 4192, 1), new Range16.Ptr(4209, 4212, 1), new Range16.Ptr(4226, 4229, 3), new Range16.Ptr(4230, 4237, 7), new Range16.Ptr(4253, 4957, 704), new Range16.Ptr(4958, 4959, 1), new Range16.Ptr(5906, 5908, 1), new Range16.Ptr(5938, 5940, 1), new Range16.Ptr(5970, 5971, 1), new Range16.Ptr(6002, 6003, 1), new Range16.Ptr(6068, 6069, 1), new Range16.Ptr(6071, 6077, 1), new Range16.Ptr(6086, 6089, 3), new Range16.Ptr(6090, 6099, 1), new Range16.Ptr(6109, 6155, 46), new Range16.Ptr(6156, 6157, 1), new Range16.Ptr(6313, 6432, 119), new Range16.Ptr(6433, 6434, 1), new Range16.Ptr(6439, 6440, 1), new Range16.Ptr(6450, 6457, 7), new Range16.Ptr(6458, 6459, 1), new Range16.Ptr(6679, 6680, 1), new Range16.Ptr(6742, 6744, 2), new Range16.Ptr(6745, 6750, 1), new Range16.Ptr(6752, 6754, 2), new Range16.Ptr(6757, 6764, 1), new Range16.Ptr(6771, 6780, 1), new Range16.Ptr(6783, 6912, 129), new Range16.Ptr(6913, 6915, 1), new Range16.Ptr(6964, 6966, 2), new Range16.Ptr(6967, 6970, 1), new Range16.Ptr(6972, 6978, 6), new Range16.Ptr(7019, 7027, 1), new Range16.Ptr(7040, 7041, 1), new Range16.Ptr(7074, 7077, 1), new Range16.Ptr(7080, 7081, 1), new Range16.Ptr(7083, 7142, 59), new Range16.Ptr(7144, 7145, 1), new Range16.Ptr(7149, 7151, 2), new Range16.Ptr(7152, 7153, 1), new Range16.Ptr(7212, 7219, 1), new Range16.Ptr(7222, 7223, 1), new Range16.Ptr(7376, 7378, 1), new Range16.Ptr(7380, 7392, 1), new Range16.Ptr(7394, 7400, 1), new Range16.Ptr(7405, 7412, 7), new Range16.Ptr(7616, 7654, 1), new Range16.Ptr(7676, 7679, 1), new Range16.Ptr(8400, 8412, 1), new Range16.Ptr(8417, 8421, 4), new Range16.Ptr(8422, 8432, 1), new Range16.Ptr(11503, 11505, 1), new Range16.Ptr(11647, 11744, 97), new Range16.Ptr(11745, 11775, 1), new Range16.Ptr(12330, 12333, 1), new Range16.Ptr(12441, 12442, 1), new Range16.Ptr(42607, 42612, 5), new Range16.Ptr(42613, 42621, 1), new Range16.Ptr(42655, 42736, 81), new Range16.Ptr(42737, 43010, 273), new Range16.Ptr(43014, 43019, 5), new Range16.Ptr(43045, 43046, 1), new Range16.Ptr(43204, 43232, 28), new Range16.Ptr(43233, 43249, 1), new Range16.Ptr(43302, 43309, 1), new Range16.Ptr(43335, 43345, 1), new Range16.Ptr(43392, 43394, 1), new Range16.Ptr(43443, 43446, 3), new Range16.Ptr(43447, 43449, 1), new Range16.Ptr(43452, 43561, 109), new Range16.Ptr(43562, 43566, 1), new Range16.Ptr(43569, 43570, 1), new Range16.Ptr(43573, 43574, 1), new Range16.Ptr(43587, 43596, 9), new Range16.Ptr(43696, 43698, 2), new Range16.Ptr(43699, 43700, 1), new Range16.Ptr(43703, 43704, 1), new Range16.Ptr(43710, 43711, 1), new Range16.Ptr(43713, 43756, 43), new Range16.Ptr(43757, 43766, 9), new Range16.Ptr(44005, 44008, 3), new Range16.Ptr(44013, 64286, 20273), new Range16.Ptr(65024, 65039, 1), new Range16.Ptr(65056, 65062, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66045, 68097, 2052), new Range32.Ptr(68098, 68099, 1), new Range32.Ptr(68101, 68102, 1), new Range32.Ptr(68108, 68111, 1), new Range32.Ptr(68152, 68154, 1), new Range32.Ptr(68159, 69633, 1474), new Range32.Ptr(69688, 69702, 1), new Range32.Ptr(69760, 69761, 1), new Range32.Ptr(69811, 69814, 1), new Range32.Ptr(69817, 69818, 1), new Range32.Ptr(69888, 69890, 1), new Range32.Ptr(69927, 69931, 1), new Range32.Ptr(69933, 69940, 1), new Range32.Ptr(70016, 70017, 1), new Range32.Ptr(70070, 70078, 1), new Range32.Ptr(71339, 71341, 2), new Range32.Ptr(71344, 71349, 1), new Range32.Ptr(71351, 94095, 22744), new Range32.Ptr(94096, 94098, 1), new Range32.Ptr(119143, 119145, 1), new Range32.Ptr(119163, 119170, 1), new Range32.Ptr(119173, 119179, 1), new Range32.Ptr(119210, 119213, 1), new Range32.Ptr(119362, 119364, 1), new Range32.Ptr(917760, 917999, 1)]), 0);
		go$pkg.Mn = _Mn;
		_Nl = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5870, 5872, 1), new Range16.Ptr(8544, 8578, 1), new Range16.Ptr(8581, 8584, 1), new Range16.Ptr(12295, 12321, 26), new Range16.Ptr(12322, 12329, 1), new Range16.Ptr(12344, 12346, 1), new Range16.Ptr(42726, 42735, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65856, 65908, 1), new Range32.Ptr(66369, 66378, 9), new Range32.Ptr(66513, 66517, 1), new Range32.Ptr(74752, 74850, 1)]), 0);
		go$pkg.Nl = _Nl;
		_No = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(178, 179, 1), new Range16.Ptr(185, 188, 3), new Range16.Ptr(189, 190, 1), new Range16.Ptr(2548, 2553, 1), new Range16.Ptr(2930, 2935, 1), new Range16.Ptr(3056, 3058, 1), new Range16.Ptr(3192, 3198, 1), new Range16.Ptr(3440, 3445, 1), new Range16.Ptr(3882, 3891, 1), new Range16.Ptr(4969, 4988, 1), new Range16.Ptr(6128, 6137, 1), new Range16.Ptr(6618, 8304, 1686), new Range16.Ptr(8308, 8313, 1), new Range16.Ptr(8320, 8329, 1), new Range16.Ptr(8528, 8543, 1), new Range16.Ptr(8585, 9312, 727), new Range16.Ptr(9313, 9371, 1), new Range16.Ptr(9450, 9471, 1), new Range16.Ptr(10102, 10131, 1), new Range16.Ptr(11517, 12690, 1173), new Range16.Ptr(12691, 12693, 1), new Range16.Ptr(12832, 12841, 1), new Range16.Ptr(12872, 12879, 1), new Range16.Ptr(12881, 12895, 1), new Range16.Ptr(12928, 12937, 1), new Range16.Ptr(12977, 12991, 1), new Range16.Ptr(43056, 43061, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65799, 65843, 1), new Range32.Ptr(65909, 65912, 1), new Range32.Ptr(65930, 66336, 406), new Range32.Ptr(66337, 66339, 1), new Range32.Ptr(67672, 67679, 1), new Range32.Ptr(67862, 67867, 1), new Range32.Ptr(68160, 68167, 1), new Range32.Ptr(68221, 68222, 1), new Range32.Ptr(68440, 68447, 1), new Range32.Ptr(68472, 68479, 1), new Range32.Ptr(69216, 69246, 1), new Range32.Ptr(69714, 69733, 1), new Range32.Ptr(119648, 119665, 1), new Range32.Ptr(127232, 127242, 1)]), 3);
		go$pkg.No = _No;
		_C = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1, 31, 1), new Range16.Ptr(127, 159, 1), new Range16.Ptr(173, 1536, 1363), new Range16.Ptr(1537, 1540, 1), new Range16.Ptr(1757, 1807, 50), new Range16.Ptr(8203, 8207, 1), new Range16.Ptr(8234, 8238, 1), new Range16.Ptr(8288, 8292, 1), new Range16.Ptr(8298, 8303, 1), new Range16.Ptr(55296, 63743, 1), new Range16.Ptr(65279, 65529, 250), new Range16.Ptr(65530, 65531, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(69821, 119155, 49334), new Range32.Ptr(119156, 119162, 1), new Range32.Ptr(917505, 917536, 31), new Range32.Ptr(917537, 917631, 1), new Range32.Ptr(983040, 1048573, 1), new Range32.Ptr(1048576, 1114109, 1)]), 2);
		go$pkg.C = _C;
		_Pc = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(95, 8255, 8160), new Range16.Ptr(8256, 8276, 20), new Range16.Ptr(65075, 65076, 1), new Range16.Ptr(65101, 65103, 1), new Range16.Ptr(65343, 65343, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Pc = _Pc;
		_Pd = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(45, 1418, 1373), new Range16.Ptr(1470, 5120, 3650), new Range16.Ptr(6150, 8208, 2058), new Range16.Ptr(8209, 8213, 1), new Range16.Ptr(11799, 11802, 3), new Range16.Ptr(11834, 11835, 1), new Range16.Ptr(12316, 12336, 20), new Range16.Ptr(12448, 65073, 52625), new Range16.Ptr(65074, 65112, 38), new Range16.Ptr(65123, 65293, 170)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Pd = _Pd;
		_Pe = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(41, 93, 52), new Range16.Ptr(125, 3899, 3774), new Range16.Ptr(3901, 5788, 1887), new Range16.Ptr(8262, 8318, 56), new Range16.Ptr(8334, 9002, 668), new Range16.Ptr(10089, 10101, 2), new Range16.Ptr(10182, 10215, 33), new Range16.Ptr(10217, 10223, 2), new Range16.Ptr(10628, 10648, 2), new Range16.Ptr(10713, 10715, 2), new Range16.Ptr(10749, 11811, 1062), new Range16.Ptr(11813, 11817, 2), new Range16.Ptr(12297, 12305, 2), new Range16.Ptr(12309, 12315, 2), new Range16.Ptr(12318, 12319, 1), new Range16.Ptr(64831, 65048, 217), new Range16.Ptr(65078, 65092, 2), new Range16.Ptr(65096, 65114, 18), new Range16.Ptr(65116, 65118, 2), new Range16.Ptr(65289, 65341, 52), new Range16.Ptr(65373, 65379, 3)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Pe = _Pe;
		_Pf = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(187, 8217, 8030), new Range16.Ptr(8221, 8250, 29), new Range16.Ptr(11779, 11781, 2), new Range16.Ptr(11786, 11789, 3), new Range16.Ptr(11805, 11809, 4)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Pf = _Pf;
		_Pi = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(171, 8216, 8045), new Range16.Ptr(8219, 8220, 1), new Range16.Ptr(8223, 8249, 26), new Range16.Ptr(11778, 11780, 2), new Range16.Ptr(11785, 11788, 3), new Range16.Ptr(11804, 11808, 4)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Pi = _Pi;
		_Po = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(33, 35, 1), new Range16.Ptr(37, 39, 1), new Range16.Ptr(42, 46, 2), new Range16.Ptr(47, 58, 11), new Range16.Ptr(59, 63, 4), new Range16.Ptr(64, 92, 28), new Range16.Ptr(161, 167, 6), new Range16.Ptr(182, 183, 1), new Range16.Ptr(191, 894, 703), new Range16.Ptr(903, 1370, 467), new Range16.Ptr(1371, 1375, 1), new Range16.Ptr(1417, 1472, 55), new Range16.Ptr(1475, 1478, 3), new Range16.Ptr(1523, 1524, 1), new Range16.Ptr(1545, 1546, 1), new Range16.Ptr(1548, 1549, 1), new Range16.Ptr(1563, 1566, 3), new Range16.Ptr(1567, 1642, 75), new Range16.Ptr(1643, 1645, 1), new Range16.Ptr(1748, 1792, 44), new Range16.Ptr(1793, 1805, 1), new Range16.Ptr(2039, 2041, 1), new Range16.Ptr(2096, 2110, 1), new Range16.Ptr(2142, 2404, 262), new Range16.Ptr(2405, 2416, 11), new Range16.Ptr(2800, 3572, 772), new Range16.Ptr(3663, 3674, 11), new Range16.Ptr(3675, 3844, 169), new Range16.Ptr(3845, 3858, 1), new Range16.Ptr(3860, 3973, 113), new Range16.Ptr(4048, 4052, 1), new Range16.Ptr(4057, 4058, 1), new Range16.Ptr(4170, 4175, 1), new Range16.Ptr(4347, 4960, 613), new Range16.Ptr(4961, 4968, 1), new Range16.Ptr(5741, 5742, 1), new Range16.Ptr(5867, 5869, 1), new Range16.Ptr(5941, 5942, 1), new Range16.Ptr(6100, 6102, 1), new Range16.Ptr(6104, 6106, 1), new Range16.Ptr(6144, 6149, 1), new Range16.Ptr(6151, 6154, 1), new Range16.Ptr(6468, 6469, 1), new Range16.Ptr(6686, 6687, 1), new Range16.Ptr(6816, 6822, 1), new Range16.Ptr(6824, 6829, 1), new Range16.Ptr(7002, 7008, 1), new Range16.Ptr(7164, 7167, 1), new Range16.Ptr(7227, 7231, 1), new Range16.Ptr(7294, 7295, 1), new Range16.Ptr(7360, 7367, 1), new Range16.Ptr(7379, 8214, 835), new Range16.Ptr(8215, 8224, 9), new Range16.Ptr(8225, 8231, 1), new Range16.Ptr(8240, 8248, 1), new Range16.Ptr(8251, 8254, 1), new Range16.Ptr(8257, 8259, 1), new Range16.Ptr(8263, 8273, 1), new Range16.Ptr(8275, 8277, 2), new Range16.Ptr(8278, 8286, 1), new Range16.Ptr(11513, 11516, 1), new Range16.Ptr(11518, 11519, 1), new Range16.Ptr(11632, 11776, 144), new Range16.Ptr(11777, 11782, 5), new Range16.Ptr(11783, 11784, 1), new Range16.Ptr(11787, 11790, 3), new Range16.Ptr(11791, 11798, 1), new Range16.Ptr(11800, 11801, 1), new Range16.Ptr(11803, 11806, 3), new Range16.Ptr(11807, 11818, 11), new Range16.Ptr(11819, 11822, 1), new Range16.Ptr(11824, 11833, 1), new Range16.Ptr(12289, 12291, 1), new Range16.Ptr(12349, 12539, 190), new Range16.Ptr(42238, 42239, 1), new Range16.Ptr(42509, 42511, 1), new Range16.Ptr(42611, 42622, 11), new Range16.Ptr(42738, 42743, 1), new Range16.Ptr(43124, 43127, 1), new Range16.Ptr(43214, 43215, 1), new Range16.Ptr(43256, 43258, 1), new Range16.Ptr(43310, 43311, 1), new Range16.Ptr(43359, 43457, 98), new Range16.Ptr(43458, 43469, 1), new Range16.Ptr(43486, 43487, 1), new Range16.Ptr(43612, 43615, 1), new Range16.Ptr(43742, 43743, 1), new Range16.Ptr(43760, 43761, 1), new Range16.Ptr(44011, 65040, 21029), new Range16.Ptr(65041, 65046, 1), new Range16.Ptr(65049, 65072, 23), new Range16.Ptr(65093, 65094, 1), new Range16.Ptr(65097, 65100, 1), new Range16.Ptr(65104, 65106, 1), new Range16.Ptr(65108, 65111, 1), new Range16.Ptr(65119, 65121, 1), new Range16.Ptr(65128, 65130, 2), new Range16.Ptr(65131, 65281, 150), new Range16.Ptr(65282, 65283, 1), new Range16.Ptr(65285, 65287, 1), new Range16.Ptr(65290, 65294, 2), new Range16.Ptr(65295, 65306, 11), new Range16.Ptr(65307, 65311, 4), new Range16.Ptr(65312, 65340, 28), new Range16.Ptr(65377, 65380, 3), new Range16.Ptr(65381, 65381, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65792, 65792, 1), new Range32.Ptr(65793, 65794, 1), new Range32.Ptr(66463, 66512, 49), new Range32.Ptr(67671, 67871, 200), new Range32.Ptr(67903, 68176, 273), new Range32.Ptr(68177, 68184, 1), new Range32.Ptr(68223, 68409, 186), new Range32.Ptr(68410, 68415, 1), new Range32.Ptr(69703, 69709, 1), new Range32.Ptr(69819, 69820, 1), new Range32.Ptr(69822, 69825, 1), new Range32.Ptr(69952, 69955, 1), new Range32.Ptr(70085, 70088, 1), new Range32.Ptr(74864, 74867, 1)]), 8);
		go$pkg.Po = _Po;
		_Ps = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(40, 91, 51), new Range16.Ptr(123, 3898, 3775), new Range16.Ptr(3900, 5787, 1887), new Range16.Ptr(8218, 8222, 4), new Range16.Ptr(8261, 8317, 56), new Range16.Ptr(8333, 9001, 668), new Range16.Ptr(10088, 10100, 2), new Range16.Ptr(10181, 10214, 33), new Range16.Ptr(10216, 10222, 2), new Range16.Ptr(10627, 10647, 2), new Range16.Ptr(10712, 10714, 2), new Range16.Ptr(10748, 11810, 1062), new Range16.Ptr(11812, 11816, 2), new Range16.Ptr(12296, 12304, 2), new Range16.Ptr(12308, 12314, 2), new Range16.Ptr(12317, 64830, 52513), new Range16.Ptr(65047, 65077, 30), new Range16.Ptr(65079, 65091, 2), new Range16.Ptr(65095, 65113, 18), new Range16.Ptr(65115, 65117, 2), new Range16.Ptr(65288, 65339, 51), new Range16.Ptr(65371, 65375, 4), new Range16.Ptr(65378, 65378, 1)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Ps = _Ps;
		_Sc = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(36, 162, 126), new Range16.Ptr(163, 165, 1), new Range16.Ptr(1423, 1547, 124), new Range16.Ptr(2546, 2547, 1), new Range16.Ptr(2555, 2801, 246), new Range16.Ptr(3065, 3647, 582), new Range16.Ptr(6107, 8352, 2245), new Range16.Ptr(8353, 8378, 1), new Range16.Ptr(43064, 65020, 21956), new Range16.Ptr(65129, 65284, 155), new Range16.Ptr(65504, 65505, 1), new Range16.Ptr(65509, 65510, 1)]), (go$sliceType(Range32)).nil, 2);
		go$pkg.Sc = _Sc;
		_Sk = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(94, 96, 2), new Range16.Ptr(168, 175, 7), new Range16.Ptr(180, 184, 4), new Range16.Ptr(706, 709, 1), new Range16.Ptr(722, 735, 1), new Range16.Ptr(741, 747, 1), new Range16.Ptr(749, 751, 2), new Range16.Ptr(752, 767, 1), new Range16.Ptr(885, 900, 15), new Range16.Ptr(901, 8125, 7224), new Range16.Ptr(8127, 8129, 1), new Range16.Ptr(8141, 8143, 1), new Range16.Ptr(8157, 8159, 1), new Range16.Ptr(8173, 8175, 1), new Range16.Ptr(8189, 8190, 1), new Range16.Ptr(12443, 12444, 1), new Range16.Ptr(42752, 42774, 1), new Range16.Ptr(42784, 42785, 1), new Range16.Ptr(42889, 42890, 1), new Range16.Ptr(64434, 64449, 1), new Range16.Ptr(65342, 65344, 2), new Range16.Ptr(65507, 65507, 1)]), (go$sliceType(Range32)).nil, 3);
		go$pkg.Sk = _Sk;
		_Sm = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43, 60, 17), new Range16.Ptr(61, 62, 1), new Range16.Ptr(124, 126, 2), new Range16.Ptr(172, 177, 5), new Range16.Ptr(215, 247, 32), new Range16.Ptr(1014, 1542, 528), new Range16.Ptr(1543, 1544, 1), new Range16.Ptr(8260, 8274, 14), new Range16.Ptr(8314, 8316, 1), new Range16.Ptr(8330, 8332, 1), new Range16.Ptr(8472, 8512, 40), new Range16.Ptr(8513, 8516, 1), new Range16.Ptr(8523, 8592, 69), new Range16.Ptr(8593, 8596, 1), new Range16.Ptr(8602, 8603, 1), new Range16.Ptr(8608, 8614, 3), new Range16.Ptr(8622, 8654, 32), new Range16.Ptr(8655, 8658, 3), new Range16.Ptr(8660, 8692, 32), new Range16.Ptr(8693, 8959, 1), new Range16.Ptr(8968, 8971, 1), new Range16.Ptr(8992, 8993, 1), new Range16.Ptr(9084, 9115, 31), new Range16.Ptr(9116, 9139, 1), new Range16.Ptr(9180, 9185, 1), new Range16.Ptr(9655, 9665, 10), new Range16.Ptr(9720, 9727, 1), new Range16.Ptr(9839, 10176, 337), new Range16.Ptr(10177, 10180, 1), new Range16.Ptr(10183, 10213, 1), new Range16.Ptr(10224, 10239, 1), new Range16.Ptr(10496, 10626, 1), new Range16.Ptr(10649, 10711, 1), new Range16.Ptr(10716, 10747, 1), new Range16.Ptr(10750, 11007, 1), new Range16.Ptr(11056, 11076, 1), new Range16.Ptr(11079, 11084, 1), new Range16.Ptr(64297, 65122, 825), new Range16.Ptr(65124, 65126, 1), new Range16.Ptr(65291, 65308, 17), new Range16.Ptr(65309, 65310, 1), new Range16.Ptr(65372, 65374, 2), new Range16.Ptr(65506, 65513, 7), new Range16.Ptr(65514, 65516, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(120513, 120539, 26), new Range32.Ptr(120571, 120597, 26), new Range32.Ptr(120629, 120655, 26), new Range32.Ptr(120687, 120713, 26), new Range32.Ptr(120745, 120771, 26), new Range32.Ptr(126704, 126705, 1)]), 5);
		go$pkg.Sm = _Sm;
		_So = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(166, 169, 3), new Range16.Ptr(174, 176, 2), new Range16.Ptr(1154, 1550, 396), new Range16.Ptr(1551, 1758, 207), new Range16.Ptr(1769, 1789, 20), new Range16.Ptr(1790, 2038, 248), new Range16.Ptr(2554, 2928, 374), new Range16.Ptr(3059, 3064, 1), new Range16.Ptr(3066, 3199, 133), new Range16.Ptr(3449, 3841, 392), new Range16.Ptr(3842, 3843, 1), new Range16.Ptr(3859, 3861, 2), new Range16.Ptr(3862, 3863, 1), new Range16.Ptr(3866, 3871, 1), new Range16.Ptr(3892, 3896, 2), new Range16.Ptr(4030, 4037, 1), new Range16.Ptr(4039, 4044, 1), new Range16.Ptr(4046, 4047, 1), new Range16.Ptr(4053, 4056, 1), new Range16.Ptr(4254, 4255, 1), new Range16.Ptr(5008, 5017, 1), new Range16.Ptr(6464, 6622, 158), new Range16.Ptr(6623, 6655, 1), new Range16.Ptr(7009, 7018, 1), new Range16.Ptr(7028, 7036, 1), new Range16.Ptr(8448, 8449, 1), new Range16.Ptr(8451, 8454, 1), new Range16.Ptr(8456, 8457, 1), new Range16.Ptr(8468, 8470, 2), new Range16.Ptr(8471, 8478, 7), new Range16.Ptr(8479, 8483, 1), new Range16.Ptr(8485, 8489, 2), new Range16.Ptr(8494, 8506, 12), new Range16.Ptr(8507, 8522, 15), new Range16.Ptr(8524, 8525, 1), new Range16.Ptr(8527, 8597, 70), new Range16.Ptr(8598, 8601, 1), new Range16.Ptr(8604, 8607, 1), new Range16.Ptr(8609, 8610, 1), new Range16.Ptr(8612, 8613, 1), new Range16.Ptr(8615, 8621, 1), new Range16.Ptr(8623, 8653, 1), new Range16.Ptr(8656, 8657, 1), new Range16.Ptr(8659, 8661, 2), new Range16.Ptr(8662, 8691, 1), new Range16.Ptr(8960, 8967, 1), new Range16.Ptr(8972, 8991, 1), new Range16.Ptr(8994, 9000, 1), new Range16.Ptr(9003, 9083, 1), new Range16.Ptr(9085, 9114, 1), new Range16.Ptr(9140, 9179, 1), new Range16.Ptr(9186, 9203, 1), new Range16.Ptr(9216, 9254, 1), new Range16.Ptr(9280, 9290, 1), new Range16.Ptr(9372, 9449, 1), new Range16.Ptr(9472, 9654, 1), new Range16.Ptr(9656, 9664, 1), new Range16.Ptr(9666, 9719, 1), new Range16.Ptr(9728, 9838, 1), new Range16.Ptr(9840, 9983, 1), new Range16.Ptr(9985, 10087, 1), new Range16.Ptr(10132, 10175, 1), new Range16.Ptr(10240, 10495, 1), new Range16.Ptr(11008, 11055, 1), new Range16.Ptr(11077, 11078, 1), new Range16.Ptr(11088, 11097, 1), new Range16.Ptr(11493, 11498, 1), new Range16.Ptr(11904, 11929, 1), new Range16.Ptr(11931, 12019, 1), new Range16.Ptr(12032, 12245, 1), new Range16.Ptr(12272, 12283, 1), new Range16.Ptr(12292, 12306, 14), new Range16.Ptr(12307, 12320, 13), new Range16.Ptr(12342, 12343, 1), new Range16.Ptr(12350, 12351, 1), new Range16.Ptr(12688, 12689, 1), new Range16.Ptr(12694, 12703, 1), new Range16.Ptr(12736, 12771, 1), new Range16.Ptr(12800, 12830, 1), new Range16.Ptr(12842, 12871, 1), new Range16.Ptr(12880, 12896, 16), new Range16.Ptr(12897, 12927, 1), new Range16.Ptr(12938, 12976, 1), new Range16.Ptr(12992, 13054, 1), new Range16.Ptr(13056, 13311, 1), new Range16.Ptr(19904, 19967, 1), new Range16.Ptr(42128, 42182, 1), new Range16.Ptr(43048, 43051, 1), new Range16.Ptr(43062, 43063, 1), new Range16.Ptr(43065, 43639, 574), new Range16.Ptr(43640, 43641, 1), new Range16.Ptr(65021, 65508, 487), new Range16.Ptr(65512, 65517, 5), new Range16.Ptr(65518, 65532, 14), new Range16.Ptr(65533, 65533, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65847, 65847, 1), new Range32.Ptr(65848, 65855, 1), new Range32.Ptr(65913, 65929, 1), new Range32.Ptr(65936, 65947, 1), new Range32.Ptr(66000, 66044, 1), new Range32.Ptr(118784, 119029, 1), new Range32.Ptr(119040, 119078, 1), new Range32.Ptr(119081, 119140, 1), new Range32.Ptr(119146, 119148, 1), new Range32.Ptr(119171, 119172, 1), new Range32.Ptr(119180, 119209, 1), new Range32.Ptr(119214, 119261, 1), new Range32.Ptr(119296, 119361, 1), new Range32.Ptr(119365, 119552, 187), new Range32.Ptr(119553, 119638, 1), new Range32.Ptr(126976, 127019, 1), new Range32.Ptr(127024, 127123, 1), new Range32.Ptr(127136, 127150, 1), new Range32.Ptr(127153, 127166, 1), new Range32.Ptr(127169, 127183, 1), new Range32.Ptr(127185, 127199, 1), new Range32.Ptr(127248, 127278, 1), new Range32.Ptr(127280, 127339, 1), new Range32.Ptr(127344, 127386, 1), new Range32.Ptr(127462, 127490, 1), new Range32.Ptr(127504, 127546, 1), new Range32.Ptr(127552, 127560, 1), new Range32.Ptr(127568, 127569, 1), new Range32.Ptr(127744, 127776, 1), new Range32.Ptr(127792, 127797, 1), new Range32.Ptr(127799, 127868, 1), new Range32.Ptr(127872, 127891, 1), new Range32.Ptr(127904, 127940, 1), new Range32.Ptr(127942, 127946, 1), new Range32.Ptr(127968, 127984, 1), new Range32.Ptr(128000, 128062, 1), new Range32.Ptr(128064, 128066, 2), new Range32.Ptr(128067, 128247, 1), new Range32.Ptr(128249, 128252, 1), new Range32.Ptr(128256, 128317, 1), new Range32.Ptr(128320, 128323, 1), new Range32.Ptr(128336, 128359, 1), new Range32.Ptr(128507, 128576, 1), new Range32.Ptr(128581, 128591, 1), new Range32.Ptr(128640, 128709, 1), new Range32.Ptr(128768, 128883, 1)]), 2);
		go$pkg.So = _So;
		_Z = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(32, 160, 128), new Range16.Ptr(5760, 6158, 398), new Range16.Ptr(8192, 8202, 1), new Range16.Ptr(8232, 8233, 1), new Range16.Ptr(8239, 8287, 48), new Range16.Ptr(12288, 12288, 1)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Z = _Z;
		_Lt = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(453, 459, 3), new Range16.Ptr(498, 8072, 7574), new Range16.Ptr(8073, 8079, 1), new Range16.Ptr(8088, 8095, 1), new Range16.Ptr(8104, 8111, 1), new Range16.Ptr(8124, 8140, 16), new Range16.Ptr(8188, 8188, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Lt = _Lt;
		_Lu = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(65, 90, 1), new Range16.Ptr(192, 214, 1), new Range16.Ptr(216, 222, 1), new Range16.Ptr(256, 310, 2), new Range16.Ptr(313, 327, 2), new Range16.Ptr(330, 376, 2), new Range16.Ptr(377, 381, 2), new Range16.Ptr(385, 386, 1), new Range16.Ptr(388, 390, 2), new Range16.Ptr(391, 393, 2), new Range16.Ptr(394, 395, 1), new Range16.Ptr(398, 401, 1), new Range16.Ptr(403, 404, 1), new Range16.Ptr(406, 408, 1), new Range16.Ptr(412, 413, 1), new Range16.Ptr(415, 416, 1), new Range16.Ptr(418, 422, 2), new Range16.Ptr(423, 425, 2), new Range16.Ptr(428, 430, 2), new Range16.Ptr(431, 433, 2), new Range16.Ptr(434, 435, 1), new Range16.Ptr(437, 439, 2), new Range16.Ptr(440, 444, 4), new Range16.Ptr(452, 461, 3), new Range16.Ptr(463, 475, 2), new Range16.Ptr(478, 494, 2), new Range16.Ptr(497, 500, 3), new Range16.Ptr(502, 504, 1), new Range16.Ptr(506, 562, 2), new Range16.Ptr(570, 571, 1), new Range16.Ptr(573, 574, 1), new Range16.Ptr(577, 579, 2), new Range16.Ptr(580, 582, 1), new Range16.Ptr(584, 590, 2), new Range16.Ptr(880, 882, 2), new Range16.Ptr(886, 902, 16), new Range16.Ptr(904, 906, 1), new Range16.Ptr(908, 910, 2), new Range16.Ptr(911, 913, 2), new Range16.Ptr(914, 929, 1), new Range16.Ptr(931, 939, 1), new Range16.Ptr(975, 978, 3), new Range16.Ptr(979, 980, 1), new Range16.Ptr(984, 1006, 2), new Range16.Ptr(1012, 1015, 3), new Range16.Ptr(1017, 1018, 1), new Range16.Ptr(1021, 1071, 1), new Range16.Ptr(1120, 1152, 2), new Range16.Ptr(1162, 1216, 2), new Range16.Ptr(1217, 1229, 2), new Range16.Ptr(1232, 1318, 2), new Range16.Ptr(1329, 1366, 1), new Range16.Ptr(4256, 4293, 1), new Range16.Ptr(4295, 4301, 6), new Range16.Ptr(7680, 7828, 2), new Range16.Ptr(7838, 7934, 2), new Range16.Ptr(7944, 7951, 1), new Range16.Ptr(7960, 7965, 1), new Range16.Ptr(7976, 7983, 1), new Range16.Ptr(7992, 7999, 1), new Range16.Ptr(8008, 8013, 1), new Range16.Ptr(8025, 8031, 2), new Range16.Ptr(8040, 8047, 1), new Range16.Ptr(8120, 8123, 1), new Range16.Ptr(8136, 8139, 1), new Range16.Ptr(8152, 8155, 1), new Range16.Ptr(8168, 8172, 1), new Range16.Ptr(8184, 8187, 1), new Range16.Ptr(8450, 8455, 5), new Range16.Ptr(8459, 8461, 1), new Range16.Ptr(8464, 8466, 1), new Range16.Ptr(8469, 8473, 4), new Range16.Ptr(8474, 8477, 1), new Range16.Ptr(8484, 8490, 2), new Range16.Ptr(8491, 8493, 1), new Range16.Ptr(8496, 8499, 1), new Range16.Ptr(8510, 8511, 1), new Range16.Ptr(8517, 8579, 62), new Range16.Ptr(11264, 11310, 1), new Range16.Ptr(11360, 11362, 2), new Range16.Ptr(11363, 11364, 1), new Range16.Ptr(11367, 11373, 2), new Range16.Ptr(11374, 11376, 1), new Range16.Ptr(11378, 11381, 3), new Range16.Ptr(11390, 11392, 1), new Range16.Ptr(11394, 11490, 2), new Range16.Ptr(11499, 11501, 2), new Range16.Ptr(11506, 42560, 31054), new Range16.Ptr(42562, 42604, 2), new Range16.Ptr(42624, 42646, 2), new Range16.Ptr(42786, 42798, 2), new Range16.Ptr(42802, 42862, 2), new Range16.Ptr(42873, 42877, 2), new Range16.Ptr(42878, 42886, 2), new Range16.Ptr(42891, 42893, 2), new Range16.Ptr(42896, 42898, 2), new Range16.Ptr(42912, 42922, 2), new Range16.Ptr(65313, 65338, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66560, 66599, 1), new Range32.Ptr(119808, 119833, 1), new Range32.Ptr(119860, 119885, 1), new Range32.Ptr(119912, 119937, 1), new Range32.Ptr(119964, 119966, 2), new Range32.Ptr(119967, 119973, 3), new Range32.Ptr(119974, 119977, 3), new Range32.Ptr(119978, 119980, 1), new Range32.Ptr(119982, 119989, 1), new Range32.Ptr(120016, 120041, 1), new Range32.Ptr(120068, 120069, 1), new Range32.Ptr(120071, 120074, 1), new Range32.Ptr(120077, 120084, 1), new Range32.Ptr(120086, 120092, 1), new Range32.Ptr(120120, 120121, 1), new Range32.Ptr(120123, 120126, 1), new Range32.Ptr(120128, 120132, 1), new Range32.Ptr(120134, 120138, 4), new Range32.Ptr(120139, 120144, 1), new Range32.Ptr(120172, 120197, 1), new Range32.Ptr(120224, 120249, 1), new Range32.Ptr(120276, 120301, 1), new Range32.Ptr(120328, 120353, 1), new Range32.Ptr(120380, 120405, 1), new Range32.Ptr(120432, 120457, 1), new Range32.Ptr(120488, 120512, 1), new Range32.Ptr(120546, 120570, 1), new Range32.Ptr(120604, 120628, 1), new Range32.Ptr(120662, 120686, 1), new Range32.Ptr(120720, 120744, 1), new Range32.Ptr(120778, 120778, 1)]), 3);
		go$pkg.Lu = _Lu;
		_Zl = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(8232, 8232, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Zl = _Zl;
		_Zp = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(8233, 8233, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Zp = _Zp;
		go$pkg.Categories = (_map = new Go$Map(), _key = "C", _map[_key] = { k: _key, v: go$pkg.C }, _key = "Cc", _map[_key] = { k: _key, v: go$pkg.Cc }, _key = "Cf", _map[_key] = { k: _key, v: go$pkg.Cf }, _key = "Co", _map[_key] = { k: _key, v: go$pkg.Co }, _key = "Cs", _map[_key] = { k: _key, v: go$pkg.Cs }, _key = "L", _map[_key] = { k: _key, v: go$pkg.L }, _key = "Ll", _map[_key] = { k: _key, v: go$pkg.Ll }, _key = "Lm", _map[_key] = { k: _key, v: go$pkg.Lm }, _key = "Lo", _map[_key] = { k: _key, v: go$pkg.Lo }, _key = "Lt", _map[_key] = { k: _key, v: go$pkg.Lt }, _key = "Lu", _map[_key] = { k: _key, v: go$pkg.Lu }, _key = "M", _map[_key] = { k: _key, v: go$pkg.M }, _key = "Mc", _map[_key] = { k: _key, v: go$pkg.Mc }, _key = "Me", _map[_key] = { k: _key, v: go$pkg.Me }, _key = "Mn", _map[_key] = { k: _key, v: go$pkg.Mn }, _key = "N", _map[_key] = { k: _key, v: go$pkg.N }, _key = "Nd", _map[_key] = { k: _key, v: go$pkg.Nd }, _key = "Nl", _map[_key] = { k: _key, v: go$pkg.Nl }, _key = "No", _map[_key] = { k: _key, v: go$pkg.No }, _key = "P", _map[_key] = { k: _key, v: go$pkg.P }, _key = "Pc", _map[_key] = { k: _key, v: go$pkg.Pc }, _key = "Pd", _map[_key] = { k: _key, v: go$pkg.Pd }, _key = "Pe", _map[_key] = { k: _key, v: go$pkg.Pe }, _key = "Pf", _map[_key] = { k: _key, v: go$pkg.Pf }, _key = "Pi", _map[_key] = { k: _key, v: go$pkg.Pi }, _key = "Po", _map[_key] = { k: _key, v: go$pkg.Po }, _key = "Ps", _map[_key] = { k: _key, v: go$pkg.Ps }, _key = "S", _map[_key] = { k: _key, v: go$pkg.S }, _key = "Sc", _map[_key] = { k: _key, v: go$pkg.Sc }, _key = "Sk", _map[_key] = { k: _key, v: go$pkg.Sk }, _key = "Sm", _map[_key] = { k: _key, v: go$pkg.Sm }, _key = "So", _map[_key] = { k: _key, v: go$pkg.So }, _key = "Z", _map[_key] = { k: _key, v: go$pkg.Z }, _key = "Zl", _map[_key] = { k: _key, v: go$pkg.Zl }, _key = "Zp", _map[_key] = { k: _key, v: go$pkg.Zp }, _key = "Zs", _map[_key] = { k: _key, v: go$pkg.Zs }, _map);
		go$pkg.Digit = _Nd;
		go$pkg.Letter = _L;
		go$pkg.Lower = _Ll;
		go$pkg.Mark = _M;
		go$pkg.Number = _N;
		go$pkg.Other = _C;
		go$pkg.Punct = _P;
		go$pkg.Space = _Z;
		go$pkg.Symbol = _S;
		go$pkg.Title = _Lt;
		go$pkg.Upper = _Lu;
		_Arabic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1536, 1540, 1), new Range16.Ptr(1542, 1547, 1), new Range16.Ptr(1549, 1562, 1), new Range16.Ptr(1566, 1566, 1), new Range16.Ptr(1568, 1599, 1), new Range16.Ptr(1601, 1610, 1), new Range16.Ptr(1622, 1631, 1), new Range16.Ptr(1642, 1647, 1), new Range16.Ptr(1649, 1756, 1), new Range16.Ptr(1758, 1791, 1), new Range16.Ptr(1872, 1919, 1), new Range16.Ptr(2208, 2208, 1), new Range16.Ptr(2210, 2220, 1), new Range16.Ptr(2276, 2302, 1), new Range16.Ptr(64336, 64449, 1), new Range16.Ptr(64467, 64829, 1), new Range16.Ptr(64848, 64911, 1), new Range16.Ptr(64914, 64967, 1), new Range16.Ptr(65008, 65020, 1), new Range16.Ptr(65136, 65140, 1), new Range16.Ptr(65142, 65276, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(69216, 69246, 1), new Range32.Ptr(126464, 126467, 1), new Range32.Ptr(126469, 126495, 1), new Range32.Ptr(126497, 126498, 1), new Range32.Ptr(126500, 126500, 1), new Range32.Ptr(126503, 126503, 1), new Range32.Ptr(126505, 126514, 1), new Range32.Ptr(126516, 126519, 1), new Range32.Ptr(126521, 126521, 1), new Range32.Ptr(126523, 126523, 1), new Range32.Ptr(126530, 126530, 1), new Range32.Ptr(126535, 126535, 1), new Range32.Ptr(126537, 126537, 1), new Range32.Ptr(126539, 126539, 1), new Range32.Ptr(126541, 126543, 1), new Range32.Ptr(126545, 126546, 1), new Range32.Ptr(126548, 126548, 1), new Range32.Ptr(126551, 126551, 1), new Range32.Ptr(126553, 126553, 1), new Range32.Ptr(126555, 126555, 1), new Range32.Ptr(126557, 126557, 1), new Range32.Ptr(126559, 126559, 1), new Range32.Ptr(126561, 126562, 1), new Range32.Ptr(126564, 126564, 1), new Range32.Ptr(126567, 126570, 1), new Range32.Ptr(126572, 126578, 1), new Range32.Ptr(126580, 126583, 1), new Range32.Ptr(126585, 126588, 1), new Range32.Ptr(126590, 126590, 1), new Range32.Ptr(126592, 126601, 1), new Range32.Ptr(126603, 126619, 1), new Range32.Ptr(126625, 126627, 1), new Range32.Ptr(126629, 126633, 1), new Range32.Ptr(126635, 126651, 1), new Range32.Ptr(126704, 126705, 1)]), 0);
		go$pkg.Arabic = _Arabic;
		_Armenian = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1329, 1366, 1), new Range16.Ptr(1369, 1375, 1), new Range16.Ptr(1377, 1415, 1), new Range16.Ptr(1418, 1418, 1), new Range16.Ptr(1423, 1423, 1), new Range16.Ptr(64275, 64279, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Armenian = _Armenian;
		_Avestan = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68352, 68405, 1), new Range32.Ptr(68409, 68415, 1)]), 0);
		go$pkg.Avestan = _Avestan;
		_Balinese = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6912, 6987, 1), new Range16.Ptr(6992, 7036, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Balinese = _Balinese;
		_Bamum = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(42656, 42743, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(92160, 92728, 1)]), 0);
		go$pkg.Bamum = _Bamum;
		_Batak = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(7104, 7155, 1), new Range16.Ptr(7164, 7167, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Batak = _Batak;
		_Bengali = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2433, 2435, 1), new Range16.Ptr(2437, 2444, 1), new Range16.Ptr(2447, 2448, 1), new Range16.Ptr(2451, 2472, 1), new Range16.Ptr(2474, 2480, 1), new Range16.Ptr(2482, 2482, 1), new Range16.Ptr(2486, 2489, 1), new Range16.Ptr(2492, 2500, 1), new Range16.Ptr(2503, 2504, 1), new Range16.Ptr(2507, 2510, 1), new Range16.Ptr(2519, 2519, 1), new Range16.Ptr(2524, 2525, 1), new Range16.Ptr(2527, 2531, 1), new Range16.Ptr(2534, 2555, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Bengali = _Bengali;
		_Bopomofo = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(746, 747, 1), new Range16.Ptr(12549, 12589, 1), new Range16.Ptr(12704, 12730, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Bopomofo = _Bopomofo;
		_Brahmi = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(69632, 69709, 1), new Range32.Ptr(69714, 69743, 1)]), 0);
		go$pkg.Brahmi = _Brahmi;
		_Braille = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(10240, 10495, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Braille = _Braille;
		_Buginese = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6656, 6683, 1), new Range16.Ptr(6686, 6687, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Buginese = _Buginese;
		_Buhid = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5952, 5971, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Buhid = _Buhid;
		_Canadian_Aboriginal = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5120, 5759, 1), new Range16.Ptr(6320, 6389, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Canadian_Aboriginal = _Canadian_Aboriginal;
		_Carian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66208, 66256, 1)]), 0);
		go$pkg.Carian = _Carian;
		_Chakma = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(69888, 69940, 1), new Range32.Ptr(69942, 69955, 1)]), 0);
		go$pkg.Chakma = _Chakma;
		_Cham = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43520, 43574, 1), new Range16.Ptr(43584, 43597, 1), new Range16.Ptr(43600, 43609, 1), new Range16.Ptr(43612, 43615, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Cham = _Cham;
		_Cherokee = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5024, 5108, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Cherokee = _Cherokee;
		_Common = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(0, 64, 1), new Range16.Ptr(91, 96, 1), new Range16.Ptr(123, 169, 1), new Range16.Ptr(171, 185, 1), new Range16.Ptr(187, 191, 1), new Range16.Ptr(215, 215, 1), new Range16.Ptr(247, 247, 1), new Range16.Ptr(697, 735, 1), new Range16.Ptr(741, 745, 1), new Range16.Ptr(748, 767, 1), new Range16.Ptr(884, 884, 1), new Range16.Ptr(894, 894, 1), new Range16.Ptr(901, 901, 1), new Range16.Ptr(903, 903, 1), new Range16.Ptr(1417, 1417, 1), new Range16.Ptr(1548, 1548, 1), new Range16.Ptr(1563, 1563, 1), new Range16.Ptr(1567, 1567, 1), new Range16.Ptr(1600, 1600, 1), new Range16.Ptr(1632, 1641, 1), new Range16.Ptr(1757, 1757, 1), new Range16.Ptr(2404, 2405, 1), new Range16.Ptr(3647, 3647, 1), new Range16.Ptr(4053, 4056, 1), new Range16.Ptr(4347, 4347, 1), new Range16.Ptr(5867, 5869, 1), new Range16.Ptr(5941, 5942, 1), new Range16.Ptr(6146, 6147, 1), new Range16.Ptr(6149, 6149, 1), new Range16.Ptr(7379, 7379, 1), new Range16.Ptr(7393, 7393, 1), new Range16.Ptr(7401, 7404, 1), new Range16.Ptr(7406, 7411, 1), new Range16.Ptr(7413, 7414, 1), new Range16.Ptr(8192, 8203, 1), new Range16.Ptr(8206, 8292, 1), new Range16.Ptr(8298, 8304, 1), new Range16.Ptr(8308, 8318, 1), new Range16.Ptr(8320, 8334, 1), new Range16.Ptr(8352, 8378, 1), new Range16.Ptr(8448, 8485, 1), new Range16.Ptr(8487, 8489, 1), new Range16.Ptr(8492, 8497, 1), new Range16.Ptr(8499, 8525, 1), new Range16.Ptr(8527, 8543, 1), new Range16.Ptr(8585, 8585, 1), new Range16.Ptr(8592, 9203, 1), new Range16.Ptr(9216, 9254, 1), new Range16.Ptr(9280, 9290, 1), new Range16.Ptr(9312, 9983, 1), new Range16.Ptr(9985, 10239, 1), new Range16.Ptr(10496, 11084, 1), new Range16.Ptr(11088, 11097, 1), new Range16.Ptr(11776, 11835, 1), new Range16.Ptr(12272, 12283, 1), new Range16.Ptr(12288, 12292, 1), new Range16.Ptr(12294, 12294, 1), new Range16.Ptr(12296, 12320, 1), new Range16.Ptr(12336, 12343, 1), new Range16.Ptr(12348, 12351, 1), new Range16.Ptr(12443, 12444, 1), new Range16.Ptr(12448, 12448, 1), new Range16.Ptr(12539, 12540, 1), new Range16.Ptr(12688, 12703, 1), new Range16.Ptr(12736, 12771, 1), new Range16.Ptr(12832, 12895, 1), new Range16.Ptr(12927, 13007, 1), new Range16.Ptr(13144, 13311, 1), new Range16.Ptr(19904, 19967, 1), new Range16.Ptr(42752, 42785, 1), new Range16.Ptr(42888, 42890, 1), new Range16.Ptr(43056, 43065, 1), new Range16.Ptr(64830, 64831, 1), new Range16.Ptr(65021, 65021, 1), new Range16.Ptr(65040, 65049, 1), new Range16.Ptr(65072, 65106, 1), new Range16.Ptr(65108, 65126, 1), new Range16.Ptr(65128, 65131, 1), new Range16.Ptr(65279, 65279, 1), new Range16.Ptr(65281, 65312, 1), new Range16.Ptr(65339, 65344, 1), new Range16.Ptr(65371, 65381, 1), new Range16.Ptr(65392, 65392, 1), new Range16.Ptr(65438, 65439, 1), new Range16.Ptr(65504, 65510, 1), new Range16.Ptr(65512, 65518, 1), new Range16.Ptr(65529, 65533, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65792, 65794, 1), new Range32.Ptr(65799, 65843, 1), new Range32.Ptr(65847, 65855, 1), new Range32.Ptr(65936, 65947, 1), new Range32.Ptr(66000, 66044, 1), new Range32.Ptr(118784, 119029, 1), new Range32.Ptr(119040, 119078, 1), new Range32.Ptr(119081, 119142, 1), new Range32.Ptr(119146, 119162, 1), new Range32.Ptr(119171, 119172, 1), new Range32.Ptr(119180, 119209, 1), new Range32.Ptr(119214, 119261, 1), new Range32.Ptr(119552, 119638, 1), new Range32.Ptr(119648, 119665, 1), new Range32.Ptr(119808, 119892, 1), new Range32.Ptr(119894, 119964, 1), new Range32.Ptr(119966, 119967, 1), new Range32.Ptr(119970, 119970, 1), new Range32.Ptr(119973, 119974, 1), new Range32.Ptr(119977, 119980, 1), new Range32.Ptr(119982, 119993, 1), new Range32.Ptr(119995, 119995, 1), new Range32.Ptr(119997, 120003, 1), new Range32.Ptr(120005, 120069, 1), new Range32.Ptr(120071, 120074, 1), new Range32.Ptr(120077, 120084, 1), new Range32.Ptr(120086, 120092, 1), new Range32.Ptr(120094, 120121, 1), new Range32.Ptr(120123, 120126, 1), new Range32.Ptr(120128, 120132, 1), new Range32.Ptr(120134, 120134, 1), new Range32.Ptr(120138, 120144, 1), new Range32.Ptr(120146, 120485, 1), new Range32.Ptr(120488, 120779, 1), new Range32.Ptr(120782, 120831, 1), new Range32.Ptr(126976, 127019, 1), new Range32.Ptr(127024, 127123, 1), new Range32.Ptr(127136, 127150, 1), new Range32.Ptr(127153, 127166, 1), new Range32.Ptr(127169, 127183, 1), new Range32.Ptr(127185, 127199, 1), new Range32.Ptr(127232, 127242, 1), new Range32.Ptr(127248, 127278, 1), new Range32.Ptr(127280, 127339, 1), new Range32.Ptr(127344, 127386, 1), new Range32.Ptr(127462, 127487, 1), new Range32.Ptr(127489, 127490, 1), new Range32.Ptr(127504, 127546, 1), new Range32.Ptr(127552, 127560, 1), new Range32.Ptr(127568, 127569, 1), new Range32.Ptr(127744, 127776, 1), new Range32.Ptr(127792, 127797, 1), new Range32.Ptr(127799, 127868, 1), new Range32.Ptr(127872, 127891, 1), new Range32.Ptr(127904, 127940, 1), new Range32.Ptr(127942, 127946, 1), new Range32.Ptr(127968, 127984, 1), new Range32.Ptr(128000, 128062, 1), new Range32.Ptr(128064, 128064, 1), new Range32.Ptr(128066, 128247, 1), new Range32.Ptr(128249, 128252, 1), new Range32.Ptr(128256, 128317, 1), new Range32.Ptr(128320, 128323, 1), new Range32.Ptr(128336, 128359, 1), new Range32.Ptr(128507, 128576, 1), new Range32.Ptr(128581, 128591, 1), new Range32.Ptr(128640, 128709, 1), new Range32.Ptr(128768, 128883, 1), new Range32.Ptr(917505, 917505, 1), new Range32.Ptr(917536, 917631, 1)]), 7);
		go$pkg.Common = _Common;
		_Coptic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(994, 1007, 1), new Range16.Ptr(11392, 11507, 1), new Range16.Ptr(11513, 11519, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Coptic = _Coptic;
		_Cuneiform = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(73728, 74606, 1), new Range32.Ptr(74752, 74850, 1), new Range32.Ptr(74864, 74867, 1)]), 0);
		go$pkg.Cuneiform = _Cuneiform;
		_Cypriot = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(67584, 67589, 1), new Range32.Ptr(67592, 67592, 1), new Range32.Ptr(67594, 67637, 1), new Range32.Ptr(67639, 67640, 1), new Range32.Ptr(67644, 67644, 1), new Range32.Ptr(67647, 67647, 1)]), 0);
		go$pkg.Cypriot = _Cypriot;
		_Cyrillic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1024, 1156, 1), new Range16.Ptr(1159, 1319, 1), new Range16.Ptr(7467, 7467, 1), new Range16.Ptr(7544, 7544, 1), new Range16.Ptr(11744, 11775, 1), new Range16.Ptr(42560, 42647, 1), new Range16.Ptr(42655, 42655, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Cyrillic = _Cyrillic;
		_Deseret = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66560, 66639, 1)]), 0);
		go$pkg.Deseret = _Deseret;
		_Devanagari = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2304, 2384, 1), new Range16.Ptr(2387, 2403, 1), new Range16.Ptr(2406, 2423, 1), new Range16.Ptr(2425, 2431, 1), new Range16.Ptr(43232, 43259, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Devanagari = _Devanagari;
		_Egyptian_Hieroglyphs = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(77824, 78894, 1)]), 0);
		go$pkg.Egyptian_Hieroglyphs = _Egyptian_Hieroglyphs;
		_Ethiopic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(4608, 4680, 1), new Range16.Ptr(4682, 4685, 1), new Range16.Ptr(4688, 4694, 1), new Range16.Ptr(4696, 4696, 1), new Range16.Ptr(4698, 4701, 1), new Range16.Ptr(4704, 4744, 1), new Range16.Ptr(4746, 4749, 1), new Range16.Ptr(4752, 4784, 1), new Range16.Ptr(4786, 4789, 1), new Range16.Ptr(4792, 4798, 1), new Range16.Ptr(4800, 4800, 1), new Range16.Ptr(4802, 4805, 1), new Range16.Ptr(4808, 4822, 1), new Range16.Ptr(4824, 4880, 1), new Range16.Ptr(4882, 4885, 1), new Range16.Ptr(4888, 4954, 1), new Range16.Ptr(4957, 4988, 1), new Range16.Ptr(4992, 5017, 1), new Range16.Ptr(11648, 11670, 1), new Range16.Ptr(11680, 11686, 1), new Range16.Ptr(11688, 11694, 1), new Range16.Ptr(11696, 11702, 1), new Range16.Ptr(11704, 11710, 1), new Range16.Ptr(11712, 11718, 1), new Range16.Ptr(11720, 11726, 1), new Range16.Ptr(11728, 11734, 1), new Range16.Ptr(11736, 11742, 1), new Range16.Ptr(43777, 43782, 1), new Range16.Ptr(43785, 43790, 1), new Range16.Ptr(43793, 43798, 1), new Range16.Ptr(43808, 43814, 1), new Range16.Ptr(43816, 43822, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Ethiopic = _Ethiopic;
		_Georgian = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(4256, 4293, 1), new Range16.Ptr(4295, 4295, 1), new Range16.Ptr(4301, 4301, 1), new Range16.Ptr(4304, 4346, 1), new Range16.Ptr(4348, 4351, 1), new Range16.Ptr(11520, 11557, 1), new Range16.Ptr(11559, 11559, 1), new Range16.Ptr(11565, 11565, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Georgian = _Georgian;
		_Glagolitic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(11264, 11310, 1), new Range16.Ptr(11312, 11358, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Glagolitic = _Glagolitic;
		_Gothic = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66352, 66378, 1)]), 0);
		go$pkg.Gothic = _Gothic;
		_Greek = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(880, 883, 1), new Range16.Ptr(885, 887, 1), new Range16.Ptr(890, 893, 1), new Range16.Ptr(900, 900, 1), new Range16.Ptr(902, 902, 1), new Range16.Ptr(904, 906, 1), new Range16.Ptr(908, 908, 1), new Range16.Ptr(910, 929, 1), new Range16.Ptr(931, 993, 1), new Range16.Ptr(1008, 1023, 1), new Range16.Ptr(7462, 7466, 1), new Range16.Ptr(7517, 7521, 1), new Range16.Ptr(7526, 7530, 1), new Range16.Ptr(7615, 7615, 1), new Range16.Ptr(7936, 7957, 1), new Range16.Ptr(7960, 7965, 1), new Range16.Ptr(7968, 8005, 1), new Range16.Ptr(8008, 8013, 1), new Range16.Ptr(8016, 8023, 1), new Range16.Ptr(8025, 8025, 1), new Range16.Ptr(8027, 8027, 1), new Range16.Ptr(8029, 8029, 1), new Range16.Ptr(8031, 8061, 1), new Range16.Ptr(8064, 8116, 1), new Range16.Ptr(8118, 8132, 1), new Range16.Ptr(8134, 8147, 1), new Range16.Ptr(8150, 8155, 1), new Range16.Ptr(8157, 8175, 1), new Range16.Ptr(8178, 8180, 1), new Range16.Ptr(8182, 8190, 1), new Range16.Ptr(8486, 8486, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(65856, 65930, 1), new Range32.Ptr(119296, 119365, 1)]), 0);
		go$pkg.Greek = _Greek;
		_Gujarati = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2689, 2691, 1), new Range16.Ptr(2693, 2701, 1), new Range16.Ptr(2703, 2705, 1), new Range16.Ptr(2707, 2728, 1), new Range16.Ptr(2730, 2736, 1), new Range16.Ptr(2738, 2739, 1), new Range16.Ptr(2741, 2745, 1), new Range16.Ptr(2748, 2757, 1), new Range16.Ptr(2759, 2761, 1), new Range16.Ptr(2763, 2765, 1), new Range16.Ptr(2768, 2768, 1), new Range16.Ptr(2784, 2787, 1), new Range16.Ptr(2790, 2801, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Gujarati = _Gujarati;
		_Gurmukhi = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2561, 2563, 1), new Range16.Ptr(2565, 2570, 1), new Range16.Ptr(2575, 2576, 1), new Range16.Ptr(2579, 2600, 1), new Range16.Ptr(2602, 2608, 1), new Range16.Ptr(2610, 2611, 1), new Range16.Ptr(2613, 2614, 1), new Range16.Ptr(2616, 2617, 1), new Range16.Ptr(2620, 2620, 1), new Range16.Ptr(2622, 2626, 1), new Range16.Ptr(2631, 2632, 1), new Range16.Ptr(2635, 2637, 1), new Range16.Ptr(2641, 2641, 1), new Range16.Ptr(2649, 2652, 1), new Range16.Ptr(2654, 2654, 1), new Range16.Ptr(2662, 2677, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Gurmukhi = _Gurmukhi;
		_Han = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(11904, 11929, 1), new Range16.Ptr(11931, 12019, 1), new Range16.Ptr(12032, 12245, 1), new Range16.Ptr(12293, 12293, 1), new Range16.Ptr(12295, 12295, 1), new Range16.Ptr(12321, 12329, 1), new Range16.Ptr(12344, 12347, 1), new Range16.Ptr(13312, 19893, 1), new Range16.Ptr(19968, 40908, 1), new Range16.Ptr(63744, 64109, 1), new Range16.Ptr(64112, 64217, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(131072, 173782, 1), new Range32.Ptr(173824, 177972, 1), new Range32.Ptr(177984, 178205, 1), new Range32.Ptr(194560, 195101, 1)]), 0);
		go$pkg.Han = _Han;
		_Hangul = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(4352, 4607, 1), new Range16.Ptr(12334, 12335, 1), new Range16.Ptr(12593, 12686, 1), new Range16.Ptr(12800, 12830, 1), new Range16.Ptr(12896, 12926, 1), new Range16.Ptr(43360, 43388, 1), new Range16.Ptr(44032, 55203, 1), new Range16.Ptr(55216, 55238, 1), new Range16.Ptr(55243, 55291, 1), new Range16.Ptr(65440, 65470, 1), new Range16.Ptr(65474, 65479, 1), new Range16.Ptr(65482, 65487, 1), new Range16.Ptr(65490, 65495, 1), new Range16.Ptr(65498, 65500, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Hangul = _Hangul;
		_Hanunoo = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5920, 5940, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Hanunoo = _Hanunoo;
		_Hebrew = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1425, 1479, 1), new Range16.Ptr(1488, 1514, 1), new Range16.Ptr(1520, 1524, 1), new Range16.Ptr(64285, 64310, 1), new Range16.Ptr(64312, 64316, 1), new Range16.Ptr(64318, 64318, 1), new Range16.Ptr(64320, 64321, 1), new Range16.Ptr(64323, 64324, 1), new Range16.Ptr(64326, 64335, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Hebrew = _Hebrew;
		_Hiragana = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(12353, 12438, 1), new Range16.Ptr(12445, 12447, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(110593, 110593, 1), new Range32.Ptr(127488, 127488, 1)]), 0);
		go$pkg.Hiragana = _Hiragana;
		_Imperial_Aramaic = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(67648, 67669, 1), new Range32.Ptr(67671, 67679, 1)]), 0);
		go$pkg.Imperial_Aramaic = _Imperial_Aramaic;
		_Inherited = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(768, 879, 1), new Range16.Ptr(1157, 1158, 1), new Range16.Ptr(1611, 1621, 1), new Range16.Ptr(1648, 1648, 1), new Range16.Ptr(2385, 2386, 1), new Range16.Ptr(7376, 7378, 1), new Range16.Ptr(7380, 7392, 1), new Range16.Ptr(7394, 7400, 1), new Range16.Ptr(7405, 7405, 1), new Range16.Ptr(7412, 7412, 1), new Range16.Ptr(7616, 7654, 1), new Range16.Ptr(7676, 7679, 1), new Range16.Ptr(8204, 8205, 1), new Range16.Ptr(8400, 8432, 1), new Range16.Ptr(12330, 12333, 1), new Range16.Ptr(12441, 12442, 1), new Range16.Ptr(65024, 65039, 1), new Range16.Ptr(65056, 65062, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66045, 66045, 1), new Range32.Ptr(119143, 119145, 1), new Range32.Ptr(119163, 119170, 1), new Range32.Ptr(119173, 119179, 1), new Range32.Ptr(119210, 119213, 1), new Range32.Ptr(917760, 917999, 1)]), 0);
		go$pkg.Inherited = _Inherited;
		_Inscriptional_Pahlavi = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68448, 68466, 1), new Range32.Ptr(68472, 68479, 1)]), 0);
		go$pkg.Inscriptional_Pahlavi = _Inscriptional_Pahlavi;
		_Inscriptional_Parthian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68416, 68437, 1), new Range32.Ptr(68440, 68447, 1)]), 0);
		go$pkg.Inscriptional_Parthian = _Inscriptional_Parthian;
		_Javanese = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43392, 43469, 1), new Range16.Ptr(43471, 43481, 1), new Range16.Ptr(43486, 43487, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Javanese = _Javanese;
		_Kaithi = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(69760, 69825, 1)]), 0);
		go$pkg.Kaithi = _Kaithi;
		_Kannada = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3202, 3203, 1), new Range16.Ptr(3205, 3212, 1), new Range16.Ptr(3214, 3216, 1), new Range16.Ptr(3218, 3240, 1), new Range16.Ptr(3242, 3251, 1), new Range16.Ptr(3253, 3257, 1), new Range16.Ptr(3260, 3268, 1), new Range16.Ptr(3270, 3272, 1), new Range16.Ptr(3274, 3277, 1), new Range16.Ptr(3285, 3286, 1), new Range16.Ptr(3294, 3294, 1), new Range16.Ptr(3296, 3299, 1), new Range16.Ptr(3302, 3311, 1), new Range16.Ptr(3313, 3314, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Kannada = _Kannada;
		_Katakana = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(12449, 12538, 1), new Range16.Ptr(12541, 12543, 1), new Range16.Ptr(12784, 12799, 1), new Range16.Ptr(13008, 13054, 1), new Range16.Ptr(13056, 13143, 1), new Range16.Ptr(65382, 65391, 1), new Range16.Ptr(65393, 65437, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(110592, 110592, 1)]), 0);
		go$pkg.Katakana = _Katakana;
		_Kayah_Li = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43264, 43311, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Kayah_Li = _Kayah_Li;
		_Kharoshthi = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68096, 68099, 1), new Range32.Ptr(68101, 68102, 1), new Range32.Ptr(68108, 68115, 1), new Range32.Ptr(68117, 68119, 1), new Range32.Ptr(68121, 68147, 1), new Range32.Ptr(68152, 68154, 1), new Range32.Ptr(68159, 68167, 1), new Range32.Ptr(68176, 68184, 1)]), 0);
		go$pkg.Kharoshthi = _Kharoshthi;
		_Khmer = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6016, 6109, 1), new Range16.Ptr(6112, 6121, 1), new Range16.Ptr(6128, 6137, 1), new Range16.Ptr(6624, 6655, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Khmer = _Khmer;
		_Lao = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3713, 3714, 1), new Range16.Ptr(3716, 3716, 1), new Range16.Ptr(3719, 3720, 1), new Range16.Ptr(3722, 3722, 1), new Range16.Ptr(3725, 3725, 1), new Range16.Ptr(3732, 3735, 1), new Range16.Ptr(3737, 3743, 1), new Range16.Ptr(3745, 3747, 1), new Range16.Ptr(3749, 3749, 1), new Range16.Ptr(3751, 3751, 1), new Range16.Ptr(3754, 3755, 1), new Range16.Ptr(3757, 3769, 1), new Range16.Ptr(3771, 3773, 1), new Range16.Ptr(3776, 3780, 1), new Range16.Ptr(3782, 3782, 1), new Range16.Ptr(3784, 3789, 1), new Range16.Ptr(3792, 3801, 1), new Range16.Ptr(3804, 3807, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Lao = _Lao;
		_Latin = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(65, 90, 1), new Range16.Ptr(97, 122, 1), new Range16.Ptr(170, 170, 1), new Range16.Ptr(186, 186, 1), new Range16.Ptr(192, 214, 1), new Range16.Ptr(216, 246, 1), new Range16.Ptr(248, 696, 1), new Range16.Ptr(736, 740, 1), new Range16.Ptr(7424, 7461, 1), new Range16.Ptr(7468, 7516, 1), new Range16.Ptr(7522, 7525, 1), new Range16.Ptr(7531, 7543, 1), new Range16.Ptr(7545, 7614, 1), new Range16.Ptr(7680, 7935, 1), new Range16.Ptr(8305, 8305, 1), new Range16.Ptr(8319, 8319, 1), new Range16.Ptr(8336, 8348, 1), new Range16.Ptr(8490, 8491, 1), new Range16.Ptr(8498, 8498, 1), new Range16.Ptr(8526, 8526, 1), new Range16.Ptr(8544, 8584, 1), new Range16.Ptr(11360, 11391, 1), new Range16.Ptr(42786, 42887, 1), new Range16.Ptr(42891, 42894, 1), new Range16.Ptr(42896, 42899, 1), new Range16.Ptr(42912, 42922, 1), new Range16.Ptr(43000, 43007, 1), new Range16.Ptr(64256, 64262, 1), new Range16.Ptr(65313, 65338, 1), new Range16.Ptr(65345, 65370, 1)]), (go$sliceType(Range32)).nil, 6);
		go$pkg.Latin = _Latin;
		_Lepcha = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(7168, 7223, 1), new Range16.Ptr(7227, 7241, 1), new Range16.Ptr(7245, 7247, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Lepcha = _Lepcha;
		_Limbu = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6400, 6428, 1), new Range16.Ptr(6432, 6443, 1), new Range16.Ptr(6448, 6459, 1), new Range16.Ptr(6464, 6464, 1), new Range16.Ptr(6468, 6479, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Limbu = _Limbu;
		_Linear_B = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(65536, 65547, 1), new Range32.Ptr(65549, 65574, 1), new Range32.Ptr(65576, 65594, 1), new Range32.Ptr(65596, 65597, 1), new Range32.Ptr(65599, 65613, 1), new Range32.Ptr(65616, 65629, 1), new Range32.Ptr(65664, 65786, 1)]), 0);
		go$pkg.Linear_B = _Linear_B;
		_Lisu = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(42192, 42239, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Lisu = _Lisu;
		_Lycian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66176, 66204, 1)]), 0);
		go$pkg.Lycian = _Lycian;
		_Lydian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(67872, 67897, 1), new Range32.Ptr(67903, 67903, 1)]), 0);
		go$pkg.Lydian = _Lydian;
		_Malayalam = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3330, 3331, 1), new Range16.Ptr(3333, 3340, 1), new Range16.Ptr(3342, 3344, 1), new Range16.Ptr(3346, 3386, 1), new Range16.Ptr(3389, 3396, 1), new Range16.Ptr(3398, 3400, 1), new Range16.Ptr(3402, 3406, 1), new Range16.Ptr(3415, 3415, 1), new Range16.Ptr(3424, 3427, 1), new Range16.Ptr(3430, 3445, 1), new Range16.Ptr(3449, 3455, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Malayalam = _Malayalam;
		_Mandaic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2112, 2139, 1), new Range16.Ptr(2142, 2142, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Mandaic = _Mandaic;
		_Meetei_Mayek = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43744, 43766, 1), new Range16.Ptr(43968, 44013, 1), new Range16.Ptr(44016, 44025, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Meetei_Mayek = _Meetei_Mayek;
		_Meroitic_Cursive = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68000, 68023, 1), new Range32.Ptr(68030, 68031, 1)]), 0);
		go$pkg.Meroitic_Cursive = _Meroitic_Cursive;
		_Meroitic_Hieroglyphs = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(67968, 67999, 1)]), 0);
		go$pkg.Meroitic_Hieroglyphs = _Meroitic_Hieroglyphs;
		_Miao = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(93952, 94020, 1), new Range32.Ptr(94032, 94078, 1), new Range32.Ptr(94095, 94111, 1)]), 0);
		go$pkg.Miao = _Miao;
		_Mongolian = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6144, 6145, 1), new Range16.Ptr(6148, 6148, 1), new Range16.Ptr(6150, 6158, 1), new Range16.Ptr(6160, 6169, 1), new Range16.Ptr(6176, 6263, 1), new Range16.Ptr(6272, 6314, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Mongolian = _Mongolian;
		_Myanmar = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(4096, 4255, 1), new Range16.Ptr(43616, 43643, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Myanmar = _Myanmar;
		_New_Tai_Lue = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6528, 6571, 1), new Range16.Ptr(6576, 6601, 1), new Range16.Ptr(6608, 6618, 1), new Range16.Ptr(6622, 6623, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.New_Tai_Lue = _New_Tai_Lue;
		_Nko = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1984, 2042, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Nko = _Nko;
		_Ogham = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5760, 5788, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Ogham = _Ogham;
		_Ol_Chiki = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(7248, 7295, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Ol_Chiki = _Ol_Chiki;
		_Old_Italic = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66304, 66334, 1), new Range32.Ptr(66336, 66339, 1)]), 0);
		go$pkg.Old_Italic = _Old_Italic;
		_Old_Persian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66464, 66499, 1), new Range32.Ptr(66504, 66517, 1)]), 0);
		go$pkg.Old_Persian = _Old_Persian;
		_Old_South_Arabian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68192, 68223, 1)]), 0);
		go$pkg.Old_South_Arabian = _Old_South_Arabian;
		_Old_Turkic = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(68608, 68680, 1)]), 0);
		go$pkg.Old_Turkic = _Old_Turkic;
		_Oriya = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2817, 2819, 1), new Range16.Ptr(2821, 2828, 1), new Range16.Ptr(2831, 2832, 1), new Range16.Ptr(2835, 2856, 1), new Range16.Ptr(2858, 2864, 1), new Range16.Ptr(2866, 2867, 1), new Range16.Ptr(2869, 2873, 1), new Range16.Ptr(2876, 2884, 1), new Range16.Ptr(2887, 2888, 1), new Range16.Ptr(2891, 2893, 1), new Range16.Ptr(2902, 2903, 1), new Range16.Ptr(2908, 2909, 1), new Range16.Ptr(2911, 2915, 1), new Range16.Ptr(2918, 2935, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Oriya = _Oriya;
		_Osmanya = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66688, 66717, 1), new Range32.Ptr(66720, 66729, 1)]), 0);
		go$pkg.Osmanya = _Osmanya;
		_Phags_Pa = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43072, 43127, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Phags_Pa = _Phags_Pa;
		_Phoenician = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(67840, 67867, 1), new Range32.Ptr(67871, 67871, 1)]), 0);
		go$pkg.Phoenician = _Phoenician;
		_Rejang = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43312, 43347, 1), new Range16.Ptr(43359, 43359, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Rejang = _Rejang;
		_Runic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5792, 5866, 1), new Range16.Ptr(5870, 5872, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Runic = _Runic;
		_Samaritan = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2048, 2093, 1), new Range16.Ptr(2096, 2110, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Samaritan = _Samaritan;
		_Saurashtra = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43136, 43204, 1), new Range16.Ptr(43214, 43225, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Saurashtra = _Saurashtra;
		_Sharada = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(70016, 70088, 1), new Range32.Ptr(70096, 70105, 1)]), 0);
		go$pkg.Sharada = _Sharada;
		_Shavian = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66640, 66687, 1)]), 0);
		go$pkg.Shavian = _Shavian;
		_Sinhala = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3458, 3459, 1), new Range16.Ptr(3461, 3478, 1), new Range16.Ptr(3482, 3505, 1), new Range16.Ptr(3507, 3515, 1), new Range16.Ptr(3517, 3517, 1), new Range16.Ptr(3520, 3526, 1), new Range16.Ptr(3530, 3530, 1), new Range16.Ptr(3535, 3540, 1), new Range16.Ptr(3542, 3542, 1), new Range16.Ptr(3544, 3551, 1), new Range16.Ptr(3570, 3572, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Sinhala = _Sinhala;
		_Sora_Sompeng = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(69840, 69864, 1), new Range32.Ptr(69872, 69881, 1)]), 0);
		go$pkg.Sora_Sompeng = _Sora_Sompeng;
		_Sundanese = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(7040, 7103, 1), new Range16.Ptr(7360, 7367, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Sundanese = _Sundanese;
		_Syloti_Nagri = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43008, 43051, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Syloti_Nagri = _Syloti_Nagri;
		_Syriac = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1792, 1805, 1), new Range16.Ptr(1807, 1866, 1), new Range16.Ptr(1869, 1871, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Syriac = _Syriac;
		_Tagalog = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5888, 5900, 1), new Range16.Ptr(5902, 5908, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tagalog = _Tagalog;
		_Tagbanwa = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(5984, 5996, 1), new Range16.Ptr(5998, 6000, 1), new Range16.Ptr(6002, 6003, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tagbanwa = _Tagbanwa;
		_Tai_Le = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6480, 6509, 1), new Range16.Ptr(6512, 6516, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tai_Le = _Tai_Le;
		_Tai_Tham = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6688, 6750, 1), new Range16.Ptr(6752, 6780, 1), new Range16.Ptr(6783, 6793, 1), new Range16.Ptr(6800, 6809, 1), new Range16.Ptr(6816, 6829, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tai_Tham = _Tai_Tham;
		_Tai_Viet = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(43648, 43714, 1), new Range16.Ptr(43739, 43743, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tai_Viet = _Tai_Viet;
		_Takri = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(71296, 71351, 1), new Range32.Ptr(71360, 71369, 1)]), 0);
		go$pkg.Takri = _Takri;
		_Tamil = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2946, 2947, 1), new Range16.Ptr(2949, 2954, 1), new Range16.Ptr(2958, 2960, 1), new Range16.Ptr(2962, 2965, 1), new Range16.Ptr(2969, 2970, 1), new Range16.Ptr(2972, 2972, 1), new Range16.Ptr(2974, 2975, 1), new Range16.Ptr(2979, 2980, 1), new Range16.Ptr(2984, 2986, 1), new Range16.Ptr(2990, 3001, 1), new Range16.Ptr(3006, 3010, 1), new Range16.Ptr(3014, 3016, 1), new Range16.Ptr(3018, 3021, 1), new Range16.Ptr(3024, 3024, 1), new Range16.Ptr(3031, 3031, 1), new Range16.Ptr(3046, 3066, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tamil = _Tamil;
		_Telugu = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3073, 3075, 1), new Range16.Ptr(3077, 3084, 1), new Range16.Ptr(3086, 3088, 1), new Range16.Ptr(3090, 3112, 1), new Range16.Ptr(3114, 3123, 1), new Range16.Ptr(3125, 3129, 1), new Range16.Ptr(3133, 3140, 1), new Range16.Ptr(3142, 3144, 1), new Range16.Ptr(3146, 3149, 1), new Range16.Ptr(3157, 3158, 1), new Range16.Ptr(3160, 3161, 1), new Range16.Ptr(3168, 3171, 1), new Range16.Ptr(3174, 3183, 1), new Range16.Ptr(3192, 3199, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Telugu = _Telugu;
		_Thaana = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(1920, 1969, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Thaana = _Thaana;
		_Thai = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3585, 3642, 1), new Range16.Ptr(3648, 3675, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Thai = _Thai;
		_Tibetan = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3840, 3911, 1), new Range16.Ptr(3913, 3948, 1), new Range16.Ptr(3953, 3991, 1), new Range16.Ptr(3993, 4028, 1), new Range16.Ptr(4030, 4044, 1), new Range16.Ptr(4046, 4052, 1), new Range16.Ptr(4057, 4058, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tibetan = _Tibetan;
		_Tifinagh = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(11568, 11623, 1), new Range16.Ptr(11631, 11632, 1), new Range16.Ptr(11647, 11647, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Tifinagh = _Tifinagh;
		_Ugaritic = new RangeTable.Ptr(new (go$sliceType(Range16))([]), new (go$sliceType(Range32))([new Range32.Ptr(66432, 66461, 1), new Range32.Ptr(66463, 66463, 1)]), 0);
		go$pkg.Ugaritic = _Ugaritic;
		_Vai = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(42240, 42539, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Vai = _Vai;
		_Yi = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(40960, 42124, 1), new Range16.Ptr(42128, 42182, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Yi = _Yi;
		go$pkg.Scripts = (_map$1 = new Go$Map(), _key$1 = "Arabic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Arabic }, _key$1 = "Armenian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Armenian }, _key$1 = "Avestan", _map$1[_key$1] = { k: _key$1, v: go$pkg.Avestan }, _key$1 = "Balinese", _map$1[_key$1] = { k: _key$1, v: go$pkg.Balinese }, _key$1 = "Bamum", _map$1[_key$1] = { k: _key$1, v: go$pkg.Bamum }, _key$1 = "Batak", _map$1[_key$1] = { k: _key$1, v: go$pkg.Batak }, _key$1 = "Bengali", _map$1[_key$1] = { k: _key$1, v: go$pkg.Bengali }, _key$1 = "Bopomofo", _map$1[_key$1] = { k: _key$1, v: go$pkg.Bopomofo }, _key$1 = "Brahmi", _map$1[_key$1] = { k: _key$1, v: go$pkg.Brahmi }, _key$1 = "Braille", _map$1[_key$1] = { k: _key$1, v: go$pkg.Braille }, _key$1 = "Buginese", _map$1[_key$1] = { k: _key$1, v: go$pkg.Buginese }, _key$1 = "Buhid", _map$1[_key$1] = { k: _key$1, v: go$pkg.Buhid }, _key$1 = "Canadian_Aboriginal", _map$1[_key$1] = { k: _key$1, v: go$pkg.Canadian_Aboriginal }, _key$1 = "Carian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Carian }, _key$1 = "Chakma", _map$1[_key$1] = { k: _key$1, v: go$pkg.Chakma }, _key$1 = "Cham", _map$1[_key$1] = { k: _key$1, v: go$pkg.Cham }, _key$1 = "Cherokee", _map$1[_key$1] = { k: _key$1, v: go$pkg.Cherokee }, _key$1 = "Common", _map$1[_key$1] = { k: _key$1, v: go$pkg.Common }, _key$1 = "Coptic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Coptic }, _key$1 = "Cuneiform", _map$1[_key$1] = { k: _key$1, v: go$pkg.Cuneiform }, _key$1 = "Cypriot", _map$1[_key$1] = { k: _key$1, v: go$pkg.Cypriot }, _key$1 = "Cyrillic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Cyrillic }, _key$1 = "Deseret", _map$1[_key$1] = { k: _key$1, v: go$pkg.Deseret }, _key$1 = "Devanagari", _map$1[_key$1] = { k: _key$1, v: go$pkg.Devanagari }, _key$1 = "Egyptian_Hieroglyphs", _map$1[_key$1] = { k: _key$1, v: go$pkg.Egyptian_Hieroglyphs }, _key$1 = "Ethiopic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Ethiopic }, _key$1 = "Georgian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Georgian }, _key$1 = "Glagolitic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Glagolitic }, _key$1 = "Gothic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Gothic }, _key$1 = "Greek", _map$1[_key$1] = { k: _key$1, v: go$pkg.Greek }, _key$1 = "Gujarati", _map$1[_key$1] = { k: _key$1, v: go$pkg.Gujarati }, _key$1 = "Gurmukhi", _map$1[_key$1] = { k: _key$1, v: go$pkg.Gurmukhi }, _key$1 = "Han", _map$1[_key$1] = { k: _key$1, v: go$pkg.Han }, _key$1 = "Hangul", _map$1[_key$1] = { k: _key$1, v: go$pkg.Hangul }, _key$1 = "Hanunoo", _map$1[_key$1] = { k: _key$1, v: go$pkg.Hanunoo }, _key$1 = "Hebrew", _map$1[_key$1] = { k: _key$1, v: go$pkg.Hebrew }, _key$1 = "Hiragana", _map$1[_key$1] = { k: _key$1, v: go$pkg.Hiragana }, _key$1 = "Imperial_Aramaic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Imperial_Aramaic }, _key$1 = "Inherited", _map$1[_key$1] = { k: _key$1, v: go$pkg.Inherited }, _key$1 = "Inscriptional_Pahlavi", _map$1[_key$1] = { k: _key$1, v: go$pkg.Inscriptional_Pahlavi }, _key$1 = "Inscriptional_Parthian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Inscriptional_Parthian }, _key$1 = "Javanese", _map$1[_key$1] = { k: _key$1, v: go$pkg.Javanese }, _key$1 = "Kaithi", _map$1[_key$1] = { k: _key$1, v: go$pkg.Kaithi }, _key$1 = "Kannada", _map$1[_key$1] = { k: _key$1, v: go$pkg.Kannada }, _key$1 = "Katakana", _map$1[_key$1] = { k: _key$1, v: go$pkg.Katakana }, _key$1 = "Kayah_Li", _map$1[_key$1] = { k: _key$1, v: go$pkg.Kayah_Li }, _key$1 = "Kharoshthi", _map$1[_key$1] = { k: _key$1, v: go$pkg.Kharoshthi }, _key$1 = "Khmer", _map$1[_key$1] = { k: _key$1, v: go$pkg.Khmer }, _key$1 = "Lao", _map$1[_key$1] = { k: _key$1, v: go$pkg.Lao }, _key$1 = "Latin", _map$1[_key$1] = { k: _key$1, v: go$pkg.Latin }, _key$1 = "Lepcha", _map$1[_key$1] = { k: _key$1, v: go$pkg.Lepcha }, _key$1 = "Limbu", _map$1[_key$1] = { k: _key$1, v: go$pkg.Limbu }, _key$1 = "Linear_B", _map$1[_key$1] = { k: _key$1, v: go$pkg.Linear_B }, _key$1 = "Lisu", _map$1[_key$1] = { k: _key$1, v: go$pkg.Lisu }, _key$1 = "Lycian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Lycian }, _key$1 = "Lydian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Lydian }, _key$1 = "Malayalam", _map$1[_key$1] = { k: _key$1, v: go$pkg.Malayalam }, _key$1 = "Mandaic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Mandaic }, _key$1 = "Meetei_Mayek", _map$1[_key$1] = { k: _key$1, v: go$pkg.Meetei_Mayek }, _key$1 = "Meroitic_Cursive", _map$1[_key$1] = { k: _key$1, v: go$pkg.Meroitic_Cursive }, _key$1 = "Meroitic_Hieroglyphs", _map$1[_key$1] = { k: _key$1, v: go$pkg.Meroitic_Hieroglyphs }, _key$1 = "Miao", _map$1[_key$1] = { k: _key$1, v: go$pkg.Miao }, _key$1 = "Mongolian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Mongolian }, _key$1 = "Myanmar", _map$1[_key$1] = { k: _key$1, v: go$pkg.Myanmar }, _key$1 = "New_Tai_Lue", _map$1[_key$1] = { k: _key$1, v: go$pkg.New_Tai_Lue }, _key$1 = "Nko", _map$1[_key$1] = { k: _key$1, v: go$pkg.Nko }, _key$1 = "Ogham", _map$1[_key$1] = { k: _key$1, v: go$pkg.Ogham }, _key$1 = "Ol_Chiki", _map$1[_key$1] = { k: _key$1, v: go$pkg.Ol_Chiki }, _key$1 = "Old_Italic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Old_Italic }, _key$1 = "Old_Persian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Old_Persian }, _key$1 = "Old_South_Arabian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Old_South_Arabian }, _key$1 = "Old_Turkic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Old_Turkic }, _key$1 = "Oriya", _map$1[_key$1] = { k: _key$1, v: go$pkg.Oriya }, _key$1 = "Osmanya", _map$1[_key$1] = { k: _key$1, v: go$pkg.Osmanya }, _key$1 = "Phags_Pa", _map$1[_key$1] = { k: _key$1, v: go$pkg.Phags_Pa }, _key$1 = "Phoenician", _map$1[_key$1] = { k: _key$1, v: go$pkg.Phoenician }, _key$1 = "Rejang", _map$1[_key$1] = { k: _key$1, v: go$pkg.Rejang }, _key$1 = "Runic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Runic }, _key$1 = "Samaritan", _map$1[_key$1] = { k: _key$1, v: go$pkg.Samaritan }, _key$1 = "Saurashtra", _map$1[_key$1] = { k: _key$1, v: go$pkg.Saurashtra }, _key$1 = "Sharada", _map$1[_key$1] = { k: _key$1, v: go$pkg.Sharada }, _key$1 = "Shavian", _map$1[_key$1] = { k: _key$1, v: go$pkg.Shavian }, _key$1 = "Sinhala", _map$1[_key$1] = { k: _key$1, v: go$pkg.Sinhala }, _key$1 = "Sora_Sompeng", _map$1[_key$1] = { k: _key$1, v: go$pkg.Sora_Sompeng }, _key$1 = "Sundanese", _map$1[_key$1] = { k: _key$1, v: go$pkg.Sundanese }, _key$1 = "Syloti_Nagri", _map$1[_key$1] = { k: _key$1, v: go$pkg.Syloti_Nagri }, _key$1 = "Syriac", _map$1[_key$1] = { k: _key$1, v: go$pkg.Syriac }, _key$1 = "Tagalog", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tagalog }, _key$1 = "Tagbanwa", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tagbanwa }, _key$1 = "Tai_Le", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tai_Le }, _key$1 = "Tai_Tham", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tai_Tham }, _key$1 = "Tai_Viet", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tai_Viet }, _key$1 = "Takri", _map$1[_key$1] = { k: _key$1, v: go$pkg.Takri }, _key$1 = "Tamil", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tamil }, _key$1 = "Telugu", _map$1[_key$1] = { k: _key$1, v: go$pkg.Telugu }, _key$1 = "Thaana", _map$1[_key$1] = { k: _key$1, v: go$pkg.Thaana }, _key$1 = "Thai", _map$1[_key$1] = { k: _key$1, v: go$pkg.Thai }, _key$1 = "Tibetan", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tibetan }, _key$1 = "Tifinagh", _map$1[_key$1] = { k: _key$1, v: go$pkg.Tifinagh }, _key$1 = "Ugaritic", _map$1[_key$1] = { k: _key$1, v: go$pkg.Ugaritic }, _key$1 = "Vai", _map$1[_key$1] = { k: _key$1, v: go$pkg.Vai }, _key$1 = "Yi", _map$1[_key$1] = { k: _key$1, v: go$pkg.Yi }, _map$1);
		_ASCII_Hex_Digit = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(48, 57, 1), new Range16.Ptr(65, 70, 1), new Range16.Ptr(97, 102, 1)]), (go$sliceType(Range32)).nil, 3);
		go$pkg.ASCII_Hex_Digit = _ASCII_Hex_Digit;
		_Bidi_Control = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(8206, 8207, 1), new Range16.Ptr(8234, 8238, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Bidi_Control = _Bidi_Control;
		_Dash = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(45, 45, 1), new Range16.Ptr(1418, 1418, 1), new Range16.Ptr(1470, 1470, 1), new Range16.Ptr(5120, 5120, 1), new Range16.Ptr(6150, 6150, 1), new Range16.Ptr(8208, 8213, 1), new Range16.Ptr(8275, 8275, 1), new Range16.Ptr(8315, 8315, 1), new Range16.Ptr(8331, 8331, 1), new Range16.Ptr(8722, 8722, 1), new Range16.Ptr(11799, 11799, 1), new Range16.Ptr(11802, 11802, 1), new Range16.Ptr(11834, 11835, 1), new Range16.Ptr(12316, 12316, 1), new Range16.Ptr(12336, 12336, 1), new Range16.Ptr(12448, 12448, 1), new Range16.Ptr(65073, 65074, 1), new Range16.Ptr(65112, 65112, 1), new Range16.Ptr(65123, 65123, 1), new Range16.Ptr(65293, 65293, 1)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Dash = _Dash;
		_Deprecated = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(329, 329, 1), new Range16.Ptr(1651, 1651, 1), new Range16.Ptr(3959, 3959, 1), new Range16.Ptr(3961, 3961, 1), new Range16.Ptr(6051, 6052, 1), new Range16.Ptr(8298, 8303, 1), new Range16.Ptr(9001, 9002, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(917505, 917505, 1), new Range32.Ptr(917536, 917631, 1)]), 0);
		go$pkg.Deprecated = _Deprecated;
		_Diacritic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(94, 94, 1), new Range16.Ptr(96, 96, 1), new Range16.Ptr(168, 168, 1), new Range16.Ptr(175, 175, 1), new Range16.Ptr(180, 180, 1), new Range16.Ptr(183, 184, 1), new Range16.Ptr(688, 846, 1), new Range16.Ptr(848, 855, 1), new Range16.Ptr(861, 866, 1), new Range16.Ptr(884, 885, 1), new Range16.Ptr(890, 890, 1), new Range16.Ptr(900, 901, 1), new Range16.Ptr(1155, 1159, 1), new Range16.Ptr(1369, 1369, 1), new Range16.Ptr(1425, 1441, 1), new Range16.Ptr(1443, 1469, 1), new Range16.Ptr(1471, 1471, 1), new Range16.Ptr(1473, 1474, 1), new Range16.Ptr(1476, 1476, 1), new Range16.Ptr(1611, 1618, 1), new Range16.Ptr(1623, 1624, 1), new Range16.Ptr(1759, 1760, 1), new Range16.Ptr(1765, 1766, 1), new Range16.Ptr(1770, 1772, 1), new Range16.Ptr(1840, 1866, 1), new Range16.Ptr(1958, 1968, 1), new Range16.Ptr(2027, 2037, 1), new Range16.Ptr(2072, 2073, 1), new Range16.Ptr(2276, 2302, 1), new Range16.Ptr(2364, 2364, 1), new Range16.Ptr(2381, 2381, 1), new Range16.Ptr(2385, 2388, 1), new Range16.Ptr(2417, 2417, 1), new Range16.Ptr(2492, 2492, 1), new Range16.Ptr(2509, 2509, 1), new Range16.Ptr(2620, 2620, 1), new Range16.Ptr(2637, 2637, 1), new Range16.Ptr(2748, 2748, 1), new Range16.Ptr(2765, 2765, 1), new Range16.Ptr(2876, 2876, 1), new Range16.Ptr(2893, 2893, 1), new Range16.Ptr(3021, 3021, 1), new Range16.Ptr(3149, 3149, 1), new Range16.Ptr(3260, 3260, 1), new Range16.Ptr(3277, 3277, 1), new Range16.Ptr(3405, 3405, 1), new Range16.Ptr(3530, 3530, 1), new Range16.Ptr(3655, 3660, 1), new Range16.Ptr(3662, 3662, 1), new Range16.Ptr(3784, 3788, 1), new Range16.Ptr(3864, 3865, 1), new Range16.Ptr(3893, 3893, 1), new Range16.Ptr(3895, 3895, 1), new Range16.Ptr(3897, 3897, 1), new Range16.Ptr(3902, 3903, 1), new Range16.Ptr(3970, 3972, 1), new Range16.Ptr(3974, 3975, 1), new Range16.Ptr(4038, 4038, 1), new Range16.Ptr(4151, 4151, 1), new Range16.Ptr(4153, 4154, 1), new Range16.Ptr(4231, 4237, 1), new Range16.Ptr(4239, 4239, 1), new Range16.Ptr(4250, 4251, 1), new Range16.Ptr(6089, 6099, 1), new Range16.Ptr(6109, 6109, 1), new Range16.Ptr(6457, 6459, 1), new Range16.Ptr(6773, 6780, 1), new Range16.Ptr(6783, 6783, 1), new Range16.Ptr(6964, 6964, 1), new Range16.Ptr(6980, 6980, 1), new Range16.Ptr(7019, 7027, 1), new Range16.Ptr(7082, 7083, 1), new Range16.Ptr(7222, 7223, 1), new Range16.Ptr(7288, 7293, 1), new Range16.Ptr(7376, 7400, 1), new Range16.Ptr(7405, 7405, 1), new Range16.Ptr(7412, 7412, 1), new Range16.Ptr(7468, 7530, 1), new Range16.Ptr(7620, 7631, 1), new Range16.Ptr(7677, 7679, 1), new Range16.Ptr(8125, 8125, 1), new Range16.Ptr(8127, 8129, 1), new Range16.Ptr(8141, 8143, 1), new Range16.Ptr(8157, 8159, 1), new Range16.Ptr(8173, 8175, 1), new Range16.Ptr(8189, 8190, 1), new Range16.Ptr(11503, 11505, 1), new Range16.Ptr(11823, 11823, 1), new Range16.Ptr(12330, 12335, 1), new Range16.Ptr(12441, 12444, 1), new Range16.Ptr(12540, 12540, 1), new Range16.Ptr(42607, 42607, 1), new Range16.Ptr(42620, 42621, 1), new Range16.Ptr(42623, 42623, 1), new Range16.Ptr(42736, 42737, 1), new Range16.Ptr(42775, 42785, 1), new Range16.Ptr(42888, 42888, 1), new Range16.Ptr(43000, 43001, 1), new Range16.Ptr(43204, 43204, 1), new Range16.Ptr(43232, 43249, 1), new Range16.Ptr(43307, 43310, 1), new Range16.Ptr(43347, 43347, 1), new Range16.Ptr(43443, 43443, 1), new Range16.Ptr(43456, 43456, 1), new Range16.Ptr(43643, 43643, 1), new Range16.Ptr(43711, 43714, 1), new Range16.Ptr(43766, 43766, 1), new Range16.Ptr(44012, 44013, 1), new Range16.Ptr(64286, 64286, 1), new Range16.Ptr(65056, 65062, 1), new Range16.Ptr(65342, 65342, 1), new Range16.Ptr(65344, 65344, 1), new Range16.Ptr(65392, 65392, 1), new Range16.Ptr(65438, 65439, 1), new Range16.Ptr(65507, 65507, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(69817, 69818, 1), new Range32.Ptr(69939, 69940, 1), new Range32.Ptr(70080, 70080, 1), new Range32.Ptr(71350, 71351, 1), new Range32.Ptr(94095, 94111, 1), new Range32.Ptr(119143, 119145, 1), new Range32.Ptr(119149, 119154, 1), new Range32.Ptr(119163, 119170, 1), new Range32.Ptr(119173, 119179, 1), new Range32.Ptr(119210, 119213, 1)]), 6);
		go$pkg.Diacritic = _Diacritic;
		_Extender = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(183, 183, 1), new Range16.Ptr(720, 721, 1), new Range16.Ptr(1600, 1600, 1), new Range16.Ptr(2042, 2042, 1), new Range16.Ptr(3654, 3654, 1), new Range16.Ptr(3782, 3782, 1), new Range16.Ptr(6154, 6154, 1), new Range16.Ptr(6211, 6211, 1), new Range16.Ptr(6823, 6823, 1), new Range16.Ptr(7222, 7222, 1), new Range16.Ptr(7291, 7291, 1), new Range16.Ptr(12293, 12293, 1), new Range16.Ptr(12337, 12341, 1), new Range16.Ptr(12445, 12446, 1), new Range16.Ptr(12540, 12542, 1), new Range16.Ptr(40981, 40981, 1), new Range16.Ptr(42508, 42508, 1), new Range16.Ptr(43471, 43471, 1), new Range16.Ptr(43632, 43632, 1), new Range16.Ptr(43741, 43741, 1), new Range16.Ptr(43763, 43764, 1), new Range16.Ptr(65392, 65392, 1)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Extender = _Extender;
		_Hex_Digit = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(48, 57, 1), new Range16.Ptr(65, 70, 1), new Range16.Ptr(97, 102, 1), new Range16.Ptr(65296, 65305, 1), new Range16.Ptr(65313, 65318, 1), new Range16.Ptr(65345, 65350, 1)]), (go$sliceType(Range32)).nil, 3);
		go$pkg.Hex_Digit = _Hex_Digit;
		_Hyphen = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(45, 45, 1), new Range16.Ptr(173, 173, 1), new Range16.Ptr(1418, 1418, 1), new Range16.Ptr(6150, 6150, 1), new Range16.Ptr(8208, 8209, 1), new Range16.Ptr(11799, 11799, 1), new Range16.Ptr(12539, 12539, 1), new Range16.Ptr(65123, 65123, 1), new Range16.Ptr(65293, 65293, 1), new Range16.Ptr(65381, 65381, 1)]), (go$sliceType(Range32)).nil, 2);
		go$pkg.Hyphen = _Hyphen;
		_IDS_Binary_Operator = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(12272, 12273, 1), new Range16.Ptr(12276, 12283, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.IDS_Binary_Operator = _IDS_Binary_Operator;
		_IDS_Trinary_Operator = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(12274, 12275, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.IDS_Trinary_Operator = _IDS_Trinary_Operator;
		_Ideographic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(12294, 12295, 1), new Range16.Ptr(12321, 12329, 1), new Range16.Ptr(12344, 12346, 1), new Range16.Ptr(13312, 19893, 1), new Range16.Ptr(19968, 40908, 1), new Range16.Ptr(63744, 64109, 1), new Range16.Ptr(64112, 64217, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(131072, 173782, 1), new Range32.Ptr(173824, 177972, 1), new Range32.Ptr(177984, 178205, 1), new Range32.Ptr(194560, 195101, 1)]), 0);
		go$pkg.Ideographic = _Ideographic;
		_Join_Control = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(8204, 8205, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Join_Control = _Join_Control;
		_Logical_Order_Exception = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(3648, 3652, 1), new Range16.Ptr(3776, 3780, 1), new Range16.Ptr(43701, 43702, 1), new Range16.Ptr(43705, 43705, 1), new Range16.Ptr(43707, 43708, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Logical_Order_Exception = _Logical_Order_Exception;
		_Noncharacter_Code_Point = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(64976, 65007, 1), new Range16.Ptr(65534, 65535, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(131070, 131071, 1), new Range32.Ptr(196606, 196607, 1), new Range32.Ptr(262142, 262143, 1), new Range32.Ptr(327678, 327679, 1), new Range32.Ptr(393214, 393215, 1), new Range32.Ptr(458750, 458751, 1), new Range32.Ptr(524286, 524287, 1), new Range32.Ptr(589822, 589823, 1), new Range32.Ptr(655358, 655359, 1), new Range32.Ptr(720894, 720895, 1), new Range32.Ptr(786430, 786431, 1), new Range32.Ptr(851966, 851967, 1), new Range32.Ptr(917502, 917503, 1), new Range32.Ptr(983038, 983039, 1), new Range32.Ptr(1048574, 1048575, 1), new Range32.Ptr(1114110, 1114111, 1)]), 0);
		go$pkg.Noncharacter_Code_Point = _Noncharacter_Code_Point;
		_Other_Alphabetic = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(837, 837, 1), new Range16.Ptr(1456, 1469, 1), new Range16.Ptr(1471, 1471, 1), new Range16.Ptr(1473, 1474, 1), new Range16.Ptr(1476, 1477, 1), new Range16.Ptr(1479, 1479, 1), new Range16.Ptr(1552, 1562, 1), new Range16.Ptr(1611, 1623, 1), new Range16.Ptr(1625, 1631, 1), new Range16.Ptr(1648, 1648, 1), new Range16.Ptr(1750, 1756, 1), new Range16.Ptr(1761, 1764, 1), new Range16.Ptr(1767, 1768, 1), new Range16.Ptr(1773, 1773, 1), new Range16.Ptr(1809, 1809, 1), new Range16.Ptr(1840, 1855, 1), new Range16.Ptr(1958, 1968, 1), new Range16.Ptr(2070, 2071, 1), new Range16.Ptr(2075, 2083, 1), new Range16.Ptr(2085, 2087, 1), new Range16.Ptr(2089, 2092, 1), new Range16.Ptr(2276, 2281, 1), new Range16.Ptr(2288, 2302, 1), new Range16.Ptr(2304, 2307, 1), new Range16.Ptr(2362, 2363, 1), new Range16.Ptr(2366, 2380, 1), new Range16.Ptr(2382, 2383, 1), new Range16.Ptr(2389, 2391, 1), new Range16.Ptr(2402, 2403, 1), new Range16.Ptr(2433, 2435, 1), new Range16.Ptr(2494, 2500, 1), new Range16.Ptr(2503, 2504, 1), new Range16.Ptr(2507, 2508, 1), new Range16.Ptr(2519, 2519, 1), new Range16.Ptr(2530, 2531, 1), new Range16.Ptr(2561, 2563, 1), new Range16.Ptr(2622, 2626, 1), new Range16.Ptr(2631, 2632, 1), new Range16.Ptr(2635, 2636, 1), new Range16.Ptr(2641, 2641, 1), new Range16.Ptr(2672, 2673, 1), new Range16.Ptr(2677, 2677, 1), new Range16.Ptr(2689, 2691, 1), new Range16.Ptr(2750, 2757, 1), new Range16.Ptr(2759, 2761, 1), new Range16.Ptr(2763, 2764, 1), new Range16.Ptr(2786, 2787, 1), new Range16.Ptr(2817, 2819, 1), new Range16.Ptr(2878, 2884, 1), new Range16.Ptr(2887, 2888, 1), new Range16.Ptr(2891, 2892, 1), new Range16.Ptr(2902, 2903, 1), new Range16.Ptr(2914, 2915, 1), new Range16.Ptr(2946, 2946, 1), new Range16.Ptr(3006, 3010, 1), new Range16.Ptr(3014, 3016, 1), new Range16.Ptr(3018, 3020, 1), new Range16.Ptr(3031, 3031, 1), new Range16.Ptr(3073, 3075, 1), new Range16.Ptr(3134, 3140, 1), new Range16.Ptr(3142, 3144, 1), new Range16.Ptr(3146, 3148, 1), new Range16.Ptr(3157, 3158, 1), new Range16.Ptr(3170, 3171, 1), new Range16.Ptr(3202, 3203, 1), new Range16.Ptr(3262, 3268, 1), new Range16.Ptr(3270, 3272, 1), new Range16.Ptr(3274, 3276, 1), new Range16.Ptr(3285, 3286, 1), new Range16.Ptr(3298, 3299, 1), new Range16.Ptr(3330, 3331, 1), new Range16.Ptr(3390, 3396, 1), new Range16.Ptr(3398, 3400, 1), new Range16.Ptr(3402, 3404, 1), new Range16.Ptr(3415, 3415, 1), new Range16.Ptr(3426, 3427, 1), new Range16.Ptr(3458, 3459, 1), new Range16.Ptr(3535, 3540, 1), new Range16.Ptr(3542, 3542, 1), new Range16.Ptr(3544, 3551, 1), new Range16.Ptr(3570, 3571, 1), new Range16.Ptr(3633, 3633, 1), new Range16.Ptr(3636, 3642, 1), new Range16.Ptr(3661, 3661, 1), new Range16.Ptr(3761, 3761, 1), new Range16.Ptr(3764, 3769, 1), new Range16.Ptr(3771, 3772, 1), new Range16.Ptr(3789, 3789, 1), new Range16.Ptr(3953, 3969, 1), new Range16.Ptr(3981, 3991, 1), new Range16.Ptr(3993, 4028, 1), new Range16.Ptr(4139, 4150, 1), new Range16.Ptr(4152, 4152, 1), new Range16.Ptr(4155, 4158, 1), new Range16.Ptr(4182, 4185, 1), new Range16.Ptr(4190, 4192, 1), new Range16.Ptr(4194, 4194, 1), new Range16.Ptr(4199, 4200, 1), new Range16.Ptr(4209, 4212, 1), new Range16.Ptr(4226, 4230, 1), new Range16.Ptr(4252, 4253, 1), new Range16.Ptr(4959, 4959, 1), new Range16.Ptr(5906, 5907, 1), new Range16.Ptr(5938, 5939, 1), new Range16.Ptr(5970, 5971, 1), new Range16.Ptr(6002, 6003, 1), new Range16.Ptr(6070, 6088, 1), new Range16.Ptr(6313, 6313, 1), new Range16.Ptr(6432, 6443, 1), new Range16.Ptr(6448, 6456, 1), new Range16.Ptr(6576, 6592, 1), new Range16.Ptr(6600, 6601, 1), new Range16.Ptr(6679, 6683, 1), new Range16.Ptr(6741, 6750, 1), new Range16.Ptr(6753, 6772, 1), new Range16.Ptr(6912, 6916, 1), new Range16.Ptr(6965, 6979, 1), new Range16.Ptr(7040, 7042, 1), new Range16.Ptr(7073, 7081, 1), new Range16.Ptr(7084, 7085, 1), new Range16.Ptr(7143, 7153, 1), new Range16.Ptr(7204, 7221, 1), new Range16.Ptr(7410, 7411, 1), new Range16.Ptr(9398, 9449, 1), new Range16.Ptr(11744, 11775, 1), new Range16.Ptr(42612, 42619, 1), new Range16.Ptr(42655, 42655, 1), new Range16.Ptr(43043, 43047, 1), new Range16.Ptr(43136, 43137, 1), new Range16.Ptr(43188, 43203, 1), new Range16.Ptr(43302, 43306, 1), new Range16.Ptr(43335, 43346, 1), new Range16.Ptr(43392, 43395, 1), new Range16.Ptr(43444, 43455, 1), new Range16.Ptr(43561, 43574, 1), new Range16.Ptr(43587, 43587, 1), new Range16.Ptr(43596, 43597, 1), new Range16.Ptr(43696, 43696, 1), new Range16.Ptr(43698, 43700, 1), new Range16.Ptr(43703, 43704, 1), new Range16.Ptr(43710, 43710, 1), new Range16.Ptr(43755, 43759, 1), new Range16.Ptr(43765, 43765, 1), new Range16.Ptr(44003, 44010, 1), new Range16.Ptr(64286, 64286, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(68097, 68099, 1), new Range32.Ptr(68101, 68102, 1), new Range32.Ptr(68108, 68111, 1), new Range32.Ptr(69632, 69634, 1), new Range32.Ptr(69688, 69701, 1), new Range32.Ptr(69762, 69762, 1), new Range32.Ptr(69808, 69816, 1), new Range32.Ptr(69888, 69890, 1), new Range32.Ptr(69927, 69938, 1), new Range32.Ptr(70016, 70018, 1), new Range32.Ptr(70067, 70079, 1), new Range32.Ptr(71339, 71349, 1), new Range32.Ptr(94033, 94078, 1)]), 0);
		go$pkg.Other_Alphabetic = _Other_Alphabetic;
		_Other_Default_Ignorable_Code_Point = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(847, 847, 1), new Range16.Ptr(4447, 4448, 1), new Range16.Ptr(6068, 6069, 1), new Range16.Ptr(8293, 8297, 1), new Range16.Ptr(12644, 12644, 1), new Range16.Ptr(65440, 65440, 1), new Range16.Ptr(65520, 65528, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(917504, 917504, 1), new Range32.Ptr(917506, 917535, 1), new Range32.Ptr(917632, 917759, 1), new Range32.Ptr(918000, 921599, 1)]), 0);
		go$pkg.Other_Default_Ignorable_Code_Point = _Other_Default_Ignorable_Code_Point;
		_Other_Grapheme_Extend = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(2494, 2494, 1), new Range16.Ptr(2519, 2519, 1), new Range16.Ptr(2878, 2878, 1), new Range16.Ptr(2903, 2903, 1), new Range16.Ptr(3006, 3006, 1), new Range16.Ptr(3031, 3031, 1), new Range16.Ptr(3266, 3266, 1), new Range16.Ptr(3285, 3286, 1), new Range16.Ptr(3390, 3390, 1), new Range16.Ptr(3415, 3415, 1), new Range16.Ptr(3535, 3535, 1), new Range16.Ptr(3551, 3551, 1), new Range16.Ptr(8204, 8205, 1), new Range16.Ptr(12334, 12335, 1), new Range16.Ptr(65438, 65439, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(119141, 119141, 1), new Range32.Ptr(119150, 119154, 1)]), 0);
		go$pkg.Other_Grapheme_Extend = _Other_Grapheme_Extend;
		_Other_ID_Continue = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(183, 183, 1), new Range16.Ptr(903, 903, 1), new Range16.Ptr(4969, 4977, 1), new Range16.Ptr(6618, 6618, 1)]), (go$sliceType(Range32)).nil, 1);
		go$pkg.Other_ID_Continue = _Other_ID_Continue;
		_Other_ID_Start = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(8472, 8472, 1), new Range16.Ptr(8494, 8494, 1), new Range16.Ptr(12443, 12444, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Other_ID_Start = _Other_ID_Start;
		_Other_Lowercase = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(170, 170, 1), new Range16.Ptr(186, 186, 1), new Range16.Ptr(688, 696, 1), new Range16.Ptr(704, 705, 1), new Range16.Ptr(736, 740, 1), new Range16.Ptr(837, 837, 1), new Range16.Ptr(890, 890, 1), new Range16.Ptr(7468, 7530, 1), new Range16.Ptr(7544, 7544, 1), new Range16.Ptr(7579, 7615, 1), new Range16.Ptr(8305, 8305, 1), new Range16.Ptr(8319, 8319, 1), new Range16.Ptr(8336, 8348, 1), new Range16.Ptr(8560, 8575, 1), new Range16.Ptr(9424, 9449, 1), new Range16.Ptr(11388, 11389, 1), new Range16.Ptr(42864, 42864, 1), new Range16.Ptr(43000, 43001, 1)]), (go$sliceType(Range32)).nil, 2);
		go$pkg.Other_Lowercase = _Other_Lowercase;
		_Other_Math = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(94, 94, 1), new Range16.Ptr(976, 978, 1), new Range16.Ptr(981, 981, 1), new Range16.Ptr(1008, 1009, 1), new Range16.Ptr(1012, 1013, 1), new Range16.Ptr(8214, 8214, 1), new Range16.Ptr(8242, 8244, 1), new Range16.Ptr(8256, 8256, 1), new Range16.Ptr(8289, 8292, 1), new Range16.Ptr(8317, 8318, 1), new Range16.Ptr(8333, 8334, 1), new Range16.Ptr(8400, 8412, 1), new Range16.Ptr(8417, 8417, 1), new Range16.Ptr(8421, 8422, 1), new Range16.Ptr(8427, 8431, 1), new Range16.Ptr(8450, 8450, 1), new Range16.Ptr(8455, 8455, 1), new Range16.Ptr(8458, 8467, 1), new Range16.Ptr(8469, 8469, 1), new Range16.Ptr(8473, 8477, 1), new Range16.Ptr(8484, 8484, 1), new Range16.Ptr(8488, 8489, 1), new Range16.Ptr(8492, 8493, 1), new Range16.Ptr(8495, 8497, 1), new Range16.Ptr(8499, 8504, 1), new Range16.Ptr(8508, 8511, 1), new Range16.Ptr(8517, 8521, 1), new Range16.Ptr(8597, 8601, 1), new Range16.Ptr(8604, 8607, 1), new Range16.Ptr(8609, 8610, 1), new Range16.Ptr(8612, 8613, 1), new Range16.Ptr(8615, 8615, 1), new Range16.Ptr(8617, 8621, 1), new Range16.Ptr(8624, 8625, 1), new Range16.Ptr(8630, 8631, 1), new Range16.Ptr(8636, 8653, 1), new Range16.Ptr(8656, 8657, 1), new Range16.Ptr(8659, 8659, 1), new Range16.Ptr(8661, 8667, 1), new Range16.Ptr(8669, 8669, 1), new Range16.Ptr(8676, 8677, 1), new Range16.Ptr(9140, 9141, 1), new Range16.Ptr(9143, 9143, 1), new Range16.Ptr(9168, 9168, 1), new Range16.Ptr(9186, 9186, 1), new Range16.Ptr(9632, 9633, 1), new Range16.Ptr(9646, 9654, 1), new Range16.Ptr(9660, 9664, 1), new Range16.Ptr(9670, 9671, 1), new Range16.Ptr(9674, 9675, 1), new Range16.Ptr(9679, 9683, 1), new Range16.Ptr(9698, 9698, 1), new Range16.Ptr(9700, 9700, 1), new Range16.Ptr(9703, 9708, 1), new Range16.Ptr(9733, 9734, 1), new Range16.Ptr(9792, 9792, 1), new Range16.Ptr(9794, 9794, 1), new Range16.Ptr(9824, 9827, 1), new Range16.Ptr(9837, 9838, 1), new Range16.Ptr(10181, 10182, 1), new Range16.Ptr(10214, 10223, 1), new Range16.Ptr(10627, 10648, 1), new Range16.Ptr(10712, 10715, 1), new Range16.Ptr(10748, 10749, 1), new Range16.Ptr(65121, 65121, 1), new Range16.Ptr(65123, 65123, 1), new Range16.Ptr(65128, 65128, 1), new Range16.Ptr(65340, 65340, 1), new Range16.Ptr(65342, 65342, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(119808, 119892, 1), new Range32.Ptr(119894, 119964, 1), new Range32.Ptr(119966, 119967, 1), new Range32.Ptr(119970, 119970, 1), new Range32.Ptr(119973, 119974, 1), new Range32.Ptr(119977, 119980, 1), new Range32.Ptr(119982, 119993, 1), new Range32.Ptr(119995, 119995, 1), new Range32.Ptr(119997, 120003, 1), new Range32.Ptr(120005, 120069, 1), new Range32.Ptr(120071, 120074, 1), new Range32.Ptr(120077, 120084, 1), new Range32.Ptr(120086, 120092, 1), new Range32.Ptr(120094, 120121, 1), new Range32.Ptr(120123, 120126, 1), new Range32.Ptr(120128, 120132, 1), new Range32.Ptr(120134, 120134, 1), new Range32.Ptr(120138, 120144, 1), new Range32.Ptr(120146, 120485, 1), new Range32.Ptr(120488, 120512, 1), new Range32.Ptr(120514, 120538, 1), new Range32.Ptr(120540, 120570, 1), new Range32.Ptr(120572, 120596, 1), new Range32.Ptr(120598, 120628, 1), new Range32.Ptr(120630, 120654, 1), new Range32.Ptr(120656, 120686, 1), new Range32.Ptr(120688, 120712, 1), new Range32.Ptr(120714, 120744, 1), new Range32.Ptr(120746, 120770, 1), new Range32.Ptr(120772, 120779, 1), new Range32.Ptr(120782, 120831, 1), new Range32.Ptr(126464, 126467, 1), new Range32.Ptr(126469, 126495, 1), new Range32.Ptr(126497, 126498, 1), new Range32.Ptr(126500, 126500, 1), new Range32.Ptr(126503, 126503, 1), new Range32.Ptr(126505, 126514, 1), new Range32.Ptr(126516, 126519, 1), new Range32.Ptr(126521, 126521, 1), new Range32.Ptr(126523, 126523, 1), new Range32.Ptr(126530, 126530, 1), new Range32.Ptr(126535, 126535, 1), new Range32.Ptr(126537, 126537, 1), new Range32.Ptr(126539, 126539, 1), new Range32.Ptr(126541, 126543, 1), new Range32.Ptr(126545, 126546, 1), new Range32.Ptr(126548, 126548, 1), new Range32.Ptr(126551, 126551, 1), new Range32.Ptr(126553, 126553, 1), new Range32.Ptr(126555, 126555, 1), new Range32.Ptr(126557, 126557, 1), new Range32.Ptr(126559, 126559, 1), new Range32.Ptr(126561, 126562, 1), new Range32.Ptr(126564, 126564, 1), new Range32.Ptr(126567, 126570, 1), new Range32.Ptr(126572, 126578, 1), new Range32.Ptr(126580, 126583, 1), new Range32.Ptr(126585, 126588, 1), new Range32.Ptr(126590, 126590, 1), new Range32.Ptr(126592, 126601, 1), new Range32.Ptr(126603, 126619, 1), new Range32.Ptr(126625, 126627, 1), new Range32.Ptr(126629, 126633, 1), new Range32.Ptr(126635, 126651, 1)]), 1);
		go$pkg.Other_Math = _Other_Math;
		_Other_Uppercase = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(8544, 8559, 1), new Range16.Ptr(9398, 9423, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Other_Uppercase = _Other_Uppercase;
		_Pattern_Syntax = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(33, 47, 1), new Range16.Ptr(58, 64, 1), new Range16.Ptr(91, 94, 1), new Range16.Ptr(96, 96, 1), new Range16.Ptr(123, 126, 1), new Range16.Ptr(161, 167, 1), new Range16.Ptr(169, 169, 1), new Range16.Ptr(171, 172, 1), new Range16.Ptr(174, 174, 1), new Range16.Ptr(176, 177, 1), new Range16.Ptr(182, 182, 1), new Range16.Ptr(187, 187, 1), new Range16.Ptr(191, 191, 1), new Range16.Ptr(215, 215, 1), new Range16.Ptr(247, 247, 1), new Range16.Ptr(8208, 8231, 1), new Range16.Ptr(8240, 8254, 1), new Range16.Ptr(8257, 8275, 1), new Range16.Ptr(8277, 8286, 1), new Range16.Ptr(8592, 9311, 1), new Range16.Ptr(9472, 10101, 1), new Range16.Ptr(10132, 11263, 1), new Range16.Ptr(11776, 11903, 1), new Range16.Ptr(12289, 12291, 1), new Range16.Ptr(12296, 12320, 1), new Range16.Ptr(12336, 12336, 1), new Range16.Ptr(64830, 64831, 1), new Range16.Ptr(65093, 65094, 1)]), (go$sliceType(Range32)).nil, 15);
		go$pkg.Pattern_Syntax = _Pattern_Syntax;
		_Pattern_White_Space = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(9, 13, 1), new Range16.Ptr(32, 32, 1), new Range16.Ptr(133, 133, 1), new Range16.Ptr(8206, 8207, 1), new Range16.Ptr(8232, 8233, 1)]), (go$sliceType(Range32)).nil, 3);
		go$pkg.Pattern_White_Space = _Pattern_White_Space;
		_Quotation_Mark = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(34, 34, 1), new Range16.Ptr(39, 39, 1), new Range16.Ptr(171, 171, 1), new Range16.Ptr(187, 187, 1), new Range16.Ptr(8216, 8223, 1), new Range16.Ptr(8249, 8250, 1), new Range16.Ptr(12300, 12303, 1), new Range16.Ptr(12317, 12319, 1), new Range16.Ptr(65089, 65092, 1), new Range16.Ptr(65282, 65282, 1), new Range16.Ptr(65287, 65287, 1), new Range16.Ptr(65378, 65379, 1)]), (go$sliceType(Range32)).nil, 4);
		go$pkg.Quotation_Mark = _Quotation_Mark;
		_Radical = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(11904, 11929, 1), new Range16.Ptr(11931, 12019, 1), new Range16.Ptr(12032, 12245, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.Radical = _Radical;
		_STerm = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(33, 33, 1), new Range16.Ptr(46, 46, 1), new Range16.Ptr(63, 63, 1), new Range16.Ptr(1372, 1372, 1), new Range16.Ptr(1374, 1374, 1), new Range16.Ptr(1417, 1417, 1), new Range16.Ptr(1567, 1567, 1), new Range16.Ptr(1748, 1748, 1), new Range16.Ptr(1792, 1794, 1), new Range16.Ptr(2041, 2041, 1), new Range16.Ptr(2404, 2405, 1), new Range16.Ptr(4170, 4171, 1), new Range16.Ptr(4962, 4962, 1), new Range16.Ptr(4967, 4968, 1), new Range16.Ptr(5742, 5742, 1), new Range16.Ptr(5941, 5942, 1), new Range16.Ptr(6147, 6147, 1), new Range16.Ptr(6153, 6153, 1), new Range16.Ptr(6468, 6469, 1), new Range16.Ptr(6824, 6827, 1), new Range16.Ptr(7002, 7003, 1), new Range16.Ptr(7006, 7007, 1), new Range16.Ptr(7227, 7228, 1), new Range16.Ptr(7294, 7295, 1), new Range16.Ptr(8252, 8253, 1), new Range16.Ptr(8263, 8265, 1), new Range16.Ptr(11822, 11822, 1), new Range16.Ptr(12290, 12290, 1), new Range16.Ptr(42239, 42239, 1), new Range16.Ptr(42510, 42511, 1), new Range16.Ptr(42739, 42739, 1), new Range16.Ptr(42743, 42743, 1), new Range16.Ptr(43126, 43127, 1), new Range16.Ptr(43214, 43215, 1), new Range16.Ptr(43311, 43311, 1), new Range16.Ptr(43464, 43465, 1), new Range16.Ptr(43613, 43615, 1), new Range16.Ptr(43760, 43761, 1), new Range16.Ptr(44011, 44011, 1), new Range16.Ptr(65106, 65106, 1), new Range16.Ptr(65110, 65111, 1), new Range16.Ptr(65281, 65281, 1), new Range16.Ptr(65294, 65294, 1), new Range16.Ptr(65311, 65311, 1), new Range16.Ptr(65377, 65377, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(68182, 68183, 1), new Range32.Ptr(69703, 69704, 1), new Range32.Ptr(69822, 69825, 1), new Range32.Ptr(69953, 69955, 1), new Range32.Ptr(70085, 70086, 1)]), 3);
		go$pkg.STerm = _STerm;
		_Soft_Dotted = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(105, 106, 1), new Range16.Ptr(303, 303, 1), new Range16.Ptr(585, 585, 1), new Range16.Ptr(616, 616, 1), new Range16.Ptr(669, 669, 1), new Range16.Ptr(690, 690, 1), new Range16.Ptr(1011, 1011, 1), new Range16.Ptr(1110, 1110, 1), new Range16.Ptr(1112, 1112, 1), new Range16.Ptr(7522, 7522, 1), new Range16.Ptr(7574, 7574, 1), new Range16.Ptr(7588, 7588, 1), new Range16.Ptr(7592, 7592, 1), new Range16.Ptr(7725, 7725, 1), new Range16.Ptr(7883, 7883, 1), new Range16.Ptr(8305, 8305, 1), new Range16.Ptr(8520, 8521, 1), new Range16.Ptr(11388, 11388, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(119842, 119843, 1), new Range32.Ptr(119894, 119895, 1), new Range32.Ptr(119946, 119947, 1), new Range32.Ptr(119998, 119999, 1), new Range32.Ptr(120050, 120051, 1), new Range32.Ptr(120102, 120103, 1), new Range32.Ptr(120154, 120155, 1), new Range32.Ptr(120206, 120207, 1), new Range32.Ptr(120258, 120259, 1), new Range32.Ptr(120310, 120311, 1), new Range32.Ptr(120362, 120363, 1), new Range32.Ptr(120414, 120415, 1), new Range32.Ptr(120466, 120467, 1)]), 1);
		go$pkg.Soft_Dotted = _Soft_Dotted;
		_Terminal_Punctuation = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(33, 33, 1), new Range16.Ptr(44, 44, 1), new Range16.Ptr(46, 46, 1), new Range16.Ptr(58, 59, 1), new Range16.Ptr(63, 63, 1), new Range16.Ptr(894, 894, 1), new Range16.Ptr(903, 903, 1), new Range16.Ptr(1417, 1417, 1), new Range16.Ptr(1475, 1475, 1), new Range16.Ptr(1548, 1548, 1), new Range16.Ptr(1563, 1563, 1), new Range16.Ptr(1567, 1567, 1), new Range16.Ptr(1748, 1748, 1), new Range16.Ptr(1792, 1802, 1), new Range16.Ptr(1804, 1804, 1), new Range16.Ptr(2040, 2041, 1), new Range16.Ptr(2096, 2110, 1), new Range16.Ptr(2142, 2142, 1), new Range16.Ptr(2404, 2405, 1), new Range16.Ptr(3674, 3675, 1), new Range16.Ptr(3848, 3848, 1), new Range16.Ptr(3853, 3858, 1), new Range16.Ptr(4170, 4171, 1), new Range16.Ptr(4961, 4968, 1), new Range16.Ptr(5741, 5742, 1), new Range16.Ptr(5867, 5869, 1), new Range16.Ptr(6100, 6102, 1), new Range16.Ptr(6106, 6106, 1), new Range16.Ptr(6146, 6149, 1), new Range16.Ptr(6152, 6153, 1), new Range16.Ptr(6468, 6469, 1), new Range16.Ptr(6824, 6827, 1), new Range16.Ptr(7002, 7003, 1), new Range16.Ptr(7005, 7007, 1), new Range16.Ptr(7227, 7231, 1), new Range16.Ptr(7294, 7295, 1), new Range16.Ptr(8252, 8253, 1), new Range16.Ptr(8263, 8265, 1), new Range16.Ptr(11822, 11822, 1), new Range16.Ptr(12289, 12290, 1), new Range16.Ptr(42238, 42239, 1), new Range16.Ptr(42509, 42511, 1), new Range16.Ptr(42739, 42743, 1), new Range16.Ptr(43126, 43127, 1), new Range16.Ptr(43214, 43215, 1), new Range16.Ptr(43311, 43311, 1), new Range16.Ptr(43463, 43465, 1), new Range16.Ptr(43613, 43615, 1), new Range16.Ptr(43743, 43743, 1), new Range16.Ptr(43760, 43761, 1), new Range16.Ptr(44011, 44011, 1), new Range16.Ptr(65104, 65106, 1), new Range16.Ptr(65108, 65111, 1), new Range16.Ptr(65281, 65281, 1), new Range16.Ptr(65292, 65292, 1), new Range16.Ptr(65294, 65294, 1), new Range16.Ptr(65306, 65307, 1), new Range16.Ptr(65311, 65311, 1), new Range16.Ptr(65377, 65377, 1), new Range16.Ptr(65380, 65380, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66463, 66463, 1), new Range32.Ptr(66512, 66512, 1), new Range32.Ptr(67671, 67671, 1), new Range32.Ptr(67871, 67871, 1), new Range32.Ptr(68410, 68415, 1), new Range32.Ptr(69703, 69709, 1), new Range32.Ptr(69822, 69825, 1), new Range32.Ptr(69953, 69955, 1), new Range32.Ptr(70085, 70086, 1), new Range32.Ptr(74864, 74867, 1)]), 5);
		go$pkg.Terminal_Punctuation = _Terminal_Punctuation;
		_Unified_Ideograph = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(13312, 19893, 1), new Range16.Ptr(19968, 40908, 1), new Range16.Ptr(64014, 64015, 1), new Range16.Ptr(64017, 64017, 1), new Range16.Ptr(64019, 64020, 1), new Range16.Ptr(64031, 64031, 1), new Range16.Ptr(64033, 64033, 1), new Range16.Ptr(64035, 64036, 1), new Range16.Ptr(64039, 64041, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(131072, 173782, 1), new Range32.Ptr(173824, 177972, 1), new Range32.Ptr(177984, 178205, 1)]), 0);
		go$pkg.Unified_Ideograph = _Unified_Ideograph;
		_Variation_Selector = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(6155, 6157, 1), new Range16.Ptr(65024, 65039, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(917760, 917999, 1)]), 0);
		go$pkg.Variation_Selector = _Variation_Selector;
		_White_Space = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(9, 13, 1), new Range16.Ptr(32, 32, 1), new Range16.Ptr(133, 133, 1), new Range16.Ptr(160, 160, 1), new Range16.Ptr(5760, 5760, 1), new Range16.Ptr(6158, 6158, 1), new Range16.Ptr(8192, 8202, 1), new Range16.Ptr(8232, 8233, 1), new Range16.Ptr(8239, 8239, 1), new Range16.Ptr(8287, 8287, 1), new Range16.Ptr(12288, 12288, 1)]), (go$sliceType(Range32)).nil, 4);
		go$pkg.White_Space = _White_Space;
		go$pkg.Properties = (_map$2 = new Go$Map(), _key$2 = "ASCII_Hex_Digit", _map$2[_key$2] = { k: _key$2, v: go$pkg.ASCII_Hex_Digit }, _key$2 = "Bidi_Control", _map$2[_key$2] = { k: _key$2, v: go$pkg.Bidi_Control }, _key$2 = "Dash", _map$2[_key$2] = { k: _key$2, v: go$pkg.Dash }, _key$2 = "Deprecated", _map$2[_key$2] = { k: _key$2, v: go$pkg.Deprecated }, _key$2 = "Diacritic", _map$2[_key$2] = { k: _key$2, v: go$pkg.Diacritic }, _key$2 = "Extender", _map$2[_key$2] = { k: _key$2, v: go$pkg.Extender }, _key$2 = "Hex_Digit", _map$2[_key$2] = { k: _key$2, v: go$pkg.Hex_Digit }, _key$2 = "Hyphen", _map$2[_key$2] = { k: _key$2, v: go$pkg.Hyphen }, _key$2 = "IDS_Binary_Operator", _map$2[_key$2] = { k: _key$2, v: go$pkg.IDS_Binary_Operator }, _key$2 = "IDS_Trinary_Operator", _map$2[_key$2] = { k: _key$2, v: go$pkg.IDS_Trinary_Operator }, _key$2 = "Ideographic", _map$2[_key$2] = { k: _key$2, v: go$pkg.Ideographic }, _key$2 = "Join_Control", _map$2[_key$2] = { k: _key$2, v: go$pkg.Join_Control }, _key$2 = "Logical_Order_Exception", _map$2[_key$2] = { k: _key$2, v: go$pkg.Logical_Order_Exception }, _key$2 = "Noncharacter_Code_Point", _map$2[_key$2] = { k: _key$2, v: go$pkg.Noncharacter_Code_Point }, _key$2 = "Other_Alphabetic", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_Alphabetic }, _key$2 = "Other_Default_Ignorable_Code_Point", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_Default_Ignorable_Code_Point }, _key$2 = "Other_Grapheme_Extend", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_Grapheme_Extend }, _key$2 = "Other_ID_Continue", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_ID_Continue }, _key$2 = "Other_ID_Start", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_ID_Start }, _key$2 = "Other_Lowercase", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_Lowercase }, _key$2 = "Other_Math", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_Math }, _key$2 = "Other_Uppercase", _map$2[_key$2] = { k: _key$2, v: go$pkg.Other_Uppercase }, _key$2 = "Pattern_Syntax", _map$2[_key$2] = { k: _key$2, v: go$pkg.Pattern_Syntax }, _key$2 = "Pattern_White_Space", _map$2[_key$2] = { k: _key$2, v: go$pkg.Pattern_White_Space }, _key$2 = "Quotation_Mark", _map$2[_key$2] = { k: _key$2, v: go$pkg.Quotation_Mark }, _key$2 = "Radical", _map$2[_key$2] = { k: _key$2, v: go$pkg.Radical }, _key$2 = "STerm", _map$2[_key$2] = { k: _key$2, v: go$pkg.STerm }, _key$2 = "Soft_Dotted", _map$2[_key$2] = { k: _key$2, v: go$pkg.Soft_Dotted }, _key$2 = "Terminal_Punctuation", _map$2[_key$2] = { k: _key$2, v: go$pkg.Terminal_Punctuation }, _key$2 = "Unified_Ideograph", _map$2[_key$2] = { k: _key$2, v: go$pkg.Unified_Ideograph }, _key$2 = "Variation_Selector", _map$2[_key$2] = { k: _key$2, v: go$pkg.Variation_Selector }, _key$2 = "White_Space", _map$2[_key$2] = { k: _key$2, v: go$pkg.White_Space }, _map$2);
		_CaseRanges = new (go$sliceType(CaseRange))([new CaseRange.Ptr(65, 90, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(97, 122, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(181, 181, go$toNativeArray("Int32", [743, 0, 743])), new CaseRange.Ptr(192, 214, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(216, 222, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(224, 246, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(248, 254, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(255, 255, go$toNativeArray("Int32", [121, 0, 121])), new CaseRange.Ptr(256, 303, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(304, 304, go$toNativeArray("Int32", [0, -199, 0])), new CaseRange.Ptr(305, 305, go$toNativeArray("Int32", [-232, 0, -232])), new CaseRange.Ptr(306, 311, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(313, 328, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(330, 375, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(376, 376, go$toNativeArray("Int32", [0, -121, 0])), new CaseRange.Ptr(377, 382, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(383, 383, go$toNativeArray("Int32", [-300, 0, -300])), new CaseRange.Ptr(384, 384, go$toNativeArray("Int32", [195, 0, 195])), new CaseRange.Ptr(385, 385, go$toNativeArray("Int32", [0, 210, 0])), new CaseRange.Ptr(386, 389, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(390, 390, go$toNativeArray("Int32", [0, 206, 0])), new CaseRange.Ptr(391, 392, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(393, 394, go$toNativeArray("Int32", [0, 205, 0])), new CaseRange.Ptr(395, 396, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(398, 398, go$toNativeArray("Int32", [0, 79, 0])), new CaseRange.Ptr(399, 399, go$toNativeArray("Int32", [0, 202, 0])), new CaseRange.Ptr(400, 400, go$toNativeArray("Int32", [0, 203, 0])), new CaseRange.Ptr(401, 402, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(403, 403, go$toNativeArray("Int32", [0, 205, 0])), new CaseRange.Ptr(404, 404, go$toNativeArray("Int32", [0, 207, 0])), new CaseRange.Ptr(405, 405, go$toNativeArray("Int32", [97, 0, 97])), new CaseRange.Ptr(406, 406, go$toNativeArray("Int32", [0, 211, 0])), new CaseRange.Ptr(407, 407, go$toNativeArray("Int32", [0, 209, 0])), new CaseRange.Ptr(408, 409, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(410, 410, go$toNativeArray("Int32", [163, 0, 163])), new CaseRange.Ptr(412, 412, go$toNativeArray("Int32", [0, 211, 0])), new CaseRange.Ptr(413, 413, go$toNativeArray("Int32", [0, 213, 0])), new CaseRange.Ptr(414, 414, go$toNativeArray("Int32", [130, 0, 130])), new CaseRange.Ptr(415, 415, go$toNativeArray("Int32", [0, 214, 0])), new CaseRange.Ptr(416, 421, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(422, 422, go$toNativeArray("Int32", [0, 218, 0])), new CaseRange.Ptr(423, 424, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(425, 425, go$toNativeArray("Int32", [0, 218, 0])), new CaseRange.Ptr(428, 429, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(430, 430, go$toNativeArray("Int32", [0, 218, 0])), new CaseRange.Ptr(431, 432, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(433, 434, go$toNativeArray("Int32", [0, 217, 0])), new CaseRange.Ptr(435, 438, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(439, 439, go$toNativeArray("Int32", [0, 219, 0])), new CaseRange.Ptr(440, 441, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(444, 445, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(447, 447, go$toNativeArray("Int32", [56, 0, 56])), new CaseRange.Ptr(452, 452, go$toNativeArray("Int32", [0, 2, 1])), new CaseRange.Ptr(453, 453, go$toNativeArray("Int32", [-1, 1, 0])), new CaseRange.Ptr(454, 454, go$toNativeArray("Int32", [-2, 0, -1])), new CaseRange.Ptr(455, 455, go$toNativeArray("Int32", [0, 2, 1])), new CaseRange.Ptr(456, 456, go$toNativeArray("Int32", [-1, 1, 0])), new CaseRange.Ptr(457, 457, go$toNativeArray("Int32", [-2, 0, -1])), new CaseRange.Ptr(458, 458, go$toNativeArray("Int32", [0, 2, 1])), new CaseRange.Ptr(459, 459, go$toNativeArray("Int32", [-1, 1, 0])), new CaseRange.Ptr(460, 460, go$toNativeArray("Int32", [-2, 0, -1])), new CaseRange.Ptr(461, 476, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(477, 477, go$toNativeArray("Int32", [-79, 0, -79])), new CaseRange.Ptr(478, 495, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(497, 497, go$toNativeArray("Int32", [0, 2, 1])), new CaseRange.Ptr(498, 498, go$toNativeArray("Int32", [-1, 1, 0])), new CaseRange.Ptr(499, 499, go$toNativeArray("Int32", [-2, 0, -1])), new CaseRange.Ptr(500, 501, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(502, 502, go$toNativeArray("Int32", [0, -97, 0])), new CaseRange.Ptr(503, 503, go$toNativeArray("Int32", [0, -56, 0])), new CaseRange.Ptr(504, 543, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(544, 544, go$toNativeArray("Int32", [0, -130, 0])), new CaseRange.Ptr(546, 563, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(570, 570, go$toNativeArray("Int32", [0, 10795, 0])), new CaseRange.Ptr(571, 572, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(573, 573, go$toNativeArray("Int32", [0, -163, 0])), new CaseRange.Ptr(574, 574, go$toNativeArray("Int32", [0, 10792, 0])), new CaseRange.Ptr(575, 576, go$toNativeArray("Int32", [10815, 0, 10815])), new CaseRange.Ptr(577, 578, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(579, 579, go$toNativeArray("Int32", [0, -195, 0])), new CaseRange.Ptr(580, 580, go$toNativeArray("Int32", [0, 69, 0])), new CaseRange.Ptr(581, 581, go$toNativeArray("Int32", [0, 71, 0])), new CaseRange.Ptr(582, 591, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(592, 592, go$toNativeArray("Int32", [10783, 0, 10783])), new CaseRange.Ptr(593, 593, go$toNativeArray("Int32", [10780, 0, 10780])), new CaseRange.Ptr(594, 594, go$toNativeArray("Int32", [10782, 0, 10782])), new CaseRange.Ptr(595, 595, go$toNativeArray("Int32", [-210, 0, -210])), new CaseRange.Ptr(596, 596, go$toNativeArray("Int32", [-206, 0, -206])), new CaseRange.Ptr(598, 599, go$toNativeArray("Int32", [-205, 0, -205])), new CaseRange.Ptr(601, 601, go$toNativeArray("Int32", [-202, 0, -202])), new CaseRange.Ptr(603, 603, go$toNativeArray("Int32", [-203, 0, -203])), new CaseRange.Ptr(608, 608, go$toNativeArray("Int32", [-205, 0, -205])), new CaseRange.Ptr(611, 611, go$toNativeArray("Int32", [-207, 0, -207])), new CaseRange.Ptr(613, 613, go$toNativeArray("Int32", [42280, 0, 42280])), new CaseRange.Ptr(614, 614, go$toNativeArray("Int32", [42308, 0, 42308])), new CaseRange.Ptr(616, 616, go$toNativeArray("Int32", [-209, 0, -209])), new CaseRange.Ptr(617, 617, go$toNativeArray("Int32", [-211, 0, -211])), new CaseRange.Ptr(619, 619, go$toNativeArray("Int32", [10743, 0, 10743])), new CaseRange.Ptr(623, 623, go$toNativeArray("Int32", [-211, 0, -211])), new CaseRange.Ptr(625, 625, go$toNativeArray("Int32", [10749, 0, 10749])), new CaseRange.Ptr(626, 626, go$toNativeArray("Int32", [-213, 0, -213])), new CaseRange.Ptr(629, 629, go$toNativeArray("Int32", [-214, 0, -214])), new CaseRange.Ptr(637, 637, go$toNativeArray("Int32", [10727, 0, 10727])), new CaseRange.Ptr(640, 640, go$toNativeArray("Int32", [-218, 0, -218])), new CaseRange.Ptr(643, 643, go$toNativeArray("Int32", [-218, 0, -218])), new CaseRange.Ptr(648, 648, go$toNativeArray("Int32", [-218, 0, -218])), new CaseRange.Ptr(649, 649, go$toNativeArray("Int32", [-69, 0, -69])), new CaseRange.Ptr(650, 651, go$toNativeArray("Int32", [-217, 0, -217])), new CaseRange.Ptr(652, 652, go$toNativeArray("Int32", [-71, 0, -71])), new CaseRange.Ptr(658, 658, go$toNativeArray("Int32", [-219, 0, -219])), new CaseRange.Ptr(837, 837, go$toNativeArray("Int32", [84, 0, 84])), new CaseRange.Ptr(880, 883, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(886, 887, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(891, 893, go$toNativeArray("Int32", [130, 0, 130])), new CaseRange.Ptr(902, 902, go$toNativeArray("Int32", [0, 38, 0])), new CaseRange.Ptr(904, 906, go$toNativeArray("Int32", [0, 37, 0])), new CaseRange.Ptr(908, 908, go$toNativeArray("Int32", [0, 64, 0])), new CaseRange.Ptr(910, 911, go$toNativeArray("Int32", [0, 63, 0])), new CaseRange.Ptr(913, 929, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(931, 939, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(940, 940, go$toNativeArray("Int32", [-38, 0, -38])), new CaseRange.Ptr(941, 943, go$toNativeArray("Int32", [-37, 0, -37])), new CaseRange.Ptr(945, 961, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(962, 962, go$toNativeArray("Int32", [-31, 0, -31])), new CaseRange.Ptr(963, 971, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(972, 972, go$toNativeArray("Int32", [-64, 0, -64])), new CaseRange.Ptr(973, 974, go$toNativeArray("Int32", [-63, 0, -63])), new CaseRange.Ptr(975, 975, go$toNativeArray("Int32", [0, 8, 0])), new CaseRange.Ptr(976, 976, go$toNativeArray("Int32", [-62, 0, -62])), new CaseRange.Ptr(977, 977, go$toNativeArray("Int32", [-57, 0, -57])), new CaseRange.Ptr(981, 981, go$toNativeArray("Int32", [-47, 0, -47])), new CaseRange.Ptr(982, 982, go$toNativeArray("Int32", [-54, 0, -54])), new CaseRange.Ptr(983, 983, go$toNativeArray("Int32", [-8, 0, -8])), new CaseRange.Ptr(984, 1007, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1008, 1008, go$toNativeArray("Int32", [-86, 0, -86])), new CaseRange.Ptr(1009, 1009, go$toNativeArray("Int32", [-80, 0, -80])), new CaseRange.Ptr(1010, 1010, go$toNativeArray("Int32", [7, 0, 7])), new CaseRange.Ptr(1012, 1012, go$toNativeArray("Int32", [0, -60, 0])), new CaseRange.Ptr(1013, 1013, go$toNativeArray("Int32", [-96, 0, -96])), new CaseRange.Ptr(1015, 1016, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1017, 1017, go$toNativeArray("Int32", [0, -7, 0])), new CaseRange.Ptr(1018, 1019, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1021, 1023, go$toNativeArray("Int32", [0, -130, 0])), new CaseRange.Ptr(1024, 1039, go$toNativeArray("Int32", [0, 80, 0])), new CaseRange.Ptr(1040, 1071, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(1072, 1103, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(1104, 1119, go$toNativeArray("Int32", [-80, 0, -80])), new CaseRange.Ptr(1120, 1153, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1162, 1215, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1216, 1216, go$toNativeArray("Int32", [0, 15, 0])), new CaseRange.Ptr(1217, 1230, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1231, 1231, go$toNativeArray("Int32", [-15, 0, -15])), new CaseRange.Ptr(1232, 1319, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(1329, 1366, go$toNativeArray("Int32", [0, 48, 0])), new CaseRange.Ptr(1377, 1414, go$toNativeArray("Int32", [-48, 0, -48])), new CaseRange.Ptr(4256, 4293, go$toNativeArray("Int32", [0, 7264, 0])), new CaseRange.Ptr(4295, 4295, go$toNativeArray("Int32", [0, 7264, 0])), new CaseRange.Ptr(4301, 4301, go$toNativeArray("Int32", [0, 7264, 0])), new CaseRange.Ptr(7545, 7545, go$toNativeArray("Int32", [35332, 0, 35332])), new CaseRange.Ptr(7549, 7549, go$toNativeArray("Int32", [3814, 0, 3814])), new CaseRange.Ptr(7680, 7829, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(7835, 7835, go$toNativeArray("Int32", [-59, 0, -59])), new CaseRange.Ptr(7838, 7838, go$toNativeArray("Int32", [0, -7615, 0])), new CaseRange.Ptr(7840, 7935, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(7936, 7943, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(7944, 7951, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(7952, 7957, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(7960, 7965, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(7968, 7975, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(7976, 7983, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(7984, 7991, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(7992, 7999, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8000, 8005, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8008, 8013, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8017, 8017, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8019, 8019, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8021, 8021, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8023, 8023, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8025, 8025, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8027, 8027, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8029, 8029, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8031, 8031, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8032, 8039, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8040, 8047, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8048, 8049, go$toNativeArray("Int32", [74, 0, 74])), new CaseRange.Ptr(8050, 8053, go$toNativeArray("Int32", [86, 0, 86])), new CaseRange.Ptr(8054, 8055, go$toNativeArray("Int32", [100, 0, 100])), new CaseRange.Ptr(8056, 8057, go$toNativeArray("Int32", [128, 0, 128])), new CaseRange.Ptr(8058, 8059, go$toNativeArray("Int32", [112, 0, 112])), new CaseRange.Ptr(8060, 8061, go$toNativeArray("Int32", [126, 0, 126])), new CaseRange.Ptr(8064, 8071, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8072, 8079, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8080, 8087, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8088, 8095, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8096, 8103, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8104, 8111, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8112, 8113, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8115, 8115, go$toNativeArray("Int32", [9, 0, 9])), new CaseRange.Ptr(8120, 8121, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8122, 8123, go$toNativeArray("Int32", [0, -74, 0])), new CaseRange.Ptr(8124, 8124, go$toNativeArray("Int32", [0, -9, 0])), new CaseRange.Ptr(8126, 8126, go$toNativeArray("Int32", [-7205, 0, -7205])), new CaseRange.Ptr(8131, 8131, go$toNativeArray("Int32", [9, 0, 9])), new CaseRange.Ptr(8136, 8139, go$toNativeArray("Int32", [0, -86, 0])), new CaseRange.Ptr(8140, 8140, go$toNativeArray("Int32", [0, -9, 0])), new CaseRange.Ptr(8144, 8145, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8152, 8153, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8154, 8155, go$toNativeArray("Int32", [0, -100, 0])), new CaseRange.Ptr(8160, 8161, go$toNativeArray("Int32", [8, 0, 8])), new CaseRange.Ptr(8165, 8165, go$toNativeArray("Int32", [7, 0, 7])), new CaseRange.Ptr(8168, 8169, go$toNativeArray("Int32", [0, -8, 0])), new CaseRange.Ptr(8170, 8171, go$toNativeArray("Int32", [0, -112, 0])), new CaseRange.Ptr(8172, 8172, go$toNativeArray("Int32", [0, -7, 0])), new CaseRange.Ptr(8179, 8179, go$toNativeArray("Int32", [9, 0, 9])), new CaseRange.Ptr(8184, 8185, go$toNativeArray("Int32", [0, -128, 0])), new CaseRange.Ptr(8186, 8187, go$toNativeArray("Int32", [0, -126, 0])), new CaseRange.Ptr(8188, 8188, go$toNativeArray("Int32", [0, -9, 0])), new CaseRange.Ptr(8486, 8486, go$toNativeArray("Int32", [0, -7517, 0])), new CaseRange.Ptr(8490, 8490, go$toNativeArray("Int32", [0, -8383, 0])), new CaseRange.Ptr(8491, 8491, go$toNativeArray("Int32", [0, -8262, 0])), new CaseRange.Ptr(8498, 8498, go$toNativeArray("Int32", [0, 28, 0])), new CaseRange.Ptr(8526, 8526, go$toNativeArray("Int32", [-28, 0, -28])), new CaseRange.Ptr(8544, 8559, go$toNativeArray("Int32", [0, 16, 0])), new CaseRange.Ptr(8560, 8575, go$toNativeArray("Int32", [-16, 0, -16])), new CaseRange.Ptr(8579, 8580, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(9398, 9423, go$toNativeArray("Int32", [0, 26, 0])), new CaseRange.Ptr(9424, 9449, go$toNativeArray("Int32", [-26, 0, -26])), new CaseRange.Ptr(11264, 11310, go$toNativeArray("Int32", [0, 48, 0])), new CaseRange.Ptr(11312, 11358, go$toNativeArray("Int32", [-48, 0, -48])), new CaseRange.Ptr(11360, 11361, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11362, 11362, go$toNativeArray("Int32", [0, -10743, 0])), new CaseRange.Ptr(11363, 11363, go$toNativeArray("Int32", [0, -3814, 0])), new CaseRange.Ptr(11364, 11364, go$toNativeArray("Int32", [0, -10727, 0])), new CaseRange.Ptr(11365, 11365, go$toNativeArray("Int32", [-10795, 0, -10795])), new CaseRange.Ptr(11366, 11366, go$toNativeArray("Int32", [-10792, 0, -10792])), new CaseRange.Ptr(11367, 11372, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11373, 11373, go$toNativeArray("Int32", [0, -10780, 0])), new CaseRange.Ptr(11374, 11374, go$toNativeArray("Int32", [0, -10749, 0])), new CaseRange.Ptr(11375, 11375, go$toNativeArray("Int32", [0, -10783, 0])), new CaseRange.Ptr(11376, 11376, go$toNativeArray("Int32", [0, -10782, 0])), new CaseRange.Ptr(11378, 11379, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11381, 11382, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11390, 11391, go$toNativeArray("Int32", [0, -10815, 0])), new CaseRange.Ptr(11392, 11491, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11499, 11502, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11506, 11507, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(11520, 11557, go$toNativeArray("Int32", [-7264, 0, -7264])), new CaseRange.Ptr(11559, 11559, go$toNativeArray("Int32", [-7264, 0, -7264])), new CaseRange.Ptr(11565, 11565, go$toNativeArray("Int32", [-7264, 0, -7264])), new CaseRange.Ptr(42560, 42605, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42624, 42647, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42786, 42799, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42802, 42863, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42873, 42876, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42877, 42877, go$toNativeArray("Int32", [0, -35332, 0])), new CaseRange.Ptr(42878, 42887, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42891, 42892, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42893, 42893, go$toNativeArray("Int32", [0, -42280, 0])), new CaseRange.Ptr(42896, 42899, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42912, 42921, go$toNativeArray("Int32", [1114112, 1114112, 1114112])), new CaseRange.Ptr(42922, 42922, go$toNativeArray("Int32", [0, -42308, 0])), new CaseRange.Ptr(65313, 65338, go$toNativeArray("Int32", [0, 32, 0])), new CaseRange.Ptr(65345, 65370, go$toNativeArray("Int32", [-32, 0, -32])), new CaseRange.Ptr(66560, 66599, go$toNativeArray("Int32", [0, 40, 0])), new CaseRange.Ptr(66600, 66639, go$toNativeArray("Int32", [-40, 0, -40]))]);
		go$pkg.CaseRanges = _CaseRanges;
		properties = go$toNativeArray("Uint8", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 144, 130, 130, 130, 136, 130, 130, 130, 130, 130, 130, 136, 130, 130, 130, 130, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 130, 130, 136, 136, 136, 130, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 130, 130, 130, 136, 130, 136, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 130, 136, 130, 136, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 130, 136, 136, 136, 136, 136, 130, 136, 136, 224, 130, 136, 0, 136, 136, 136, 136, 132, 132, 136, 192, 130, 130, 136, 132, 224, 130, 132, 132, 132, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 136, 160, 160, 160, 160, 160, 160, 160, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 136, 192, 192, 192, 192, 192, 192, 192, 192]);
		caseOrbit = new (go$sliceType(foldPair))([new foldPair.Ptr(75, 107), new foldPair.Ptr(83, 115), new foldPair.Ptr(107, 8490), new foldPair.Ptr(115, 383), new foldPair.Ptr(181, 924), new foldPair.Ptr(197, 229), new foldPair.Ptr(223, 7838), new foldPair.Ptr(229, 8491), new foldPair.Ptr(304, 304), new foldPair.Ptr(305, 305), new foldPair.Ptr(383, 83), new foldPair.Ptr(452, 453), new foldPair.Ptr(453, 454), new foldPair.Ptr(454, 452), new foldPair.Ptr(455, 456), new foldPair.Ptr(456, 457), new foldPair.Ptr(457, 455), new foldPair.Ptr(458, 459), new foldPair.Ptr(459, 460), new foldPair.Ptr(460, 458), new foldPair.Ptr(497, 498), new foldPair.Ptr(498, 499), new foldPair.Ptr(499, 497), new foldPair.Ptr(837, 921), new foldPair.Ptr(914, 946), new foldPair.Ptr(917, 949), new foldPair.Ptr(920, 952), new foldPair.Ptr(921, 953), new foldPair.Ptr(922, 954), new foldPair.Ptr(924, 956), new foldPair.Ptr(928, 960), new foldPair.Ptr(929, 961), new foldPair.Ptr(931, 962), new foldPair.Ptr(934, 966), new foldPair.Ptr(937, 969), new foldPair.Ptr(946, 976), new foldPair.Ptr(949, 1013), new foldPair.Ptr(952, 977), new foldPair.Ptr(953, 8126), new foldPair.Ptr(954, 1008), new foldPair.Ptr(956, 181), new foldPair.Ptr(960, 982), new foldPair.Ptr(961, 1009), new foldPair.Ptr(962, 963), new foldPair.Ptr(963, 931), new foldPair.Ptr(966, 981), new foldPair.Ptr(969, 8486), new foldPair.Ptr(976, 914), new foldPair.Ptr(977, 1012), new foldPair.Ptr(981, 934), new foldPair.Ptr(982, 928), new foldPair.Ptr(1008, 922), new foldPair.Ptr(1009, 929), new foldPair.Ptr(1012, 920), new foldPair.Ptr(1013, 917), new foldPair.Ptr(7776, 7777), new foldPair.Ptr(7777, 7835), new foldPair.Ptr(7835, 7776), new foldPair.Ptr(7838, 223), new foldPair.Ptr(8126, 837), new foldPair.Ptr(8486, 937), new foldPair.Ptr(8490, 75), new foldPair.Ptr(8491, 197)]);
		foldCommon = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(924, 956, 32)]), (go$sliceType(Range32)).nil, 0);
		foldGreek = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(181, 837, 656)]), (go$sliceType(Range32)).nil, 0);
		foldInherited = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(921, 953, 32), new Range16.Ptr(8126, 8126, 1)]), (go$sliceType(Range32)).nil, 0);
		foldL = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(837, 837, 1)]), (go$sliceType(Range32)).nil, 0);
		foldLl = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(65, 90, 1), new Range16.Ptr(192, 214, 1), new Range16.Ptr(216, 222, 1), new Range16.Ptr(256, 302, 2), new Range16.Ptr(306, 310, 2), new Range16.Ptr(313, 327, 2), new Range16.Ptr(330, 376, 2), new Range16.Ptr(377, 381, 2), new Range16.Ptr(385, 386, 1), new Range16.Ptr(388, 390, 2), new Range16.Ptr(391, 393, 2), new Range16.Ptr(394, 395, 1), new Range16.Ptr(398, 401, 1), new Range16.Ptr(403, 404, 1), new Range16.Ptr(406, 408, 1), new Range16.Ptr(412, 413, 1), new Range16.Ptr(415, 416, 1), new Range16.Ptr(418, 422, 2), new Range16.Ptr(423, 425, 2), new Range16.Ptr(428, 430, 2), new Range16.Ptr(431, 433, 2), new Range16.Ptr(434, 435, 1), new Range16.Ptr(437, 439, 2), new Range16.Ptr(440, 444, 4), new Range16.Ptr(452, 453, 1), new Range16.Ptr(455, 456, 1), new Range16.Ptr(458, 459, 1), new Range16.Ptr(461, 475, 2), new Range16.Ptr(478, 494, 2), new Range16.Ptr(497, 498, 1), new Range16.Ptr(500, 502, 2), new Range16.Ptr(503, 504, 1), new Range16.Ptr(506, 562, 2), new Range16.Ptr(570, 571, 1), new Range16.Ptr(573, 574, 1), new Range16.Ptr(577, 579, 2), new Range16.Ptr(580, 582, 1), new Range16.Ptr(584, 590, 2), new Range16.Ptr(837, 880, 43), new Range16.Ptr(882, 886, 4), new Range16.Ptr(902, 904, 2), new Range16.Ptr(905, 906, 1), new Range16.Ptr(908, 910, 2), new Range16.Ptr(911, 913, 2), new Range16.Ptr(914, 929, 1), new Range16.Ptr(931, 939, 1), new Range16.Ptr(975, 984, 9), new Range16.Ptr(986, 1006, 2), new Range16.Ptr(1012, 1015, 3), new Range16.Ptr(1017, 1018, 1), new Range16.Ptr(1021, 1071, 1), new Range16.Ptr(1120, 1152, 2), new Range16.Ptr(1162, 1216, 2), new Range16.Ptr(1217, 1229, 2), new Range16.Ptr(1232, 1318, 2), new Range16.Ptr(1329, 1366, 1), new Range16.Ptr(4256, 4293, 1), new Range16.Ptr(4295, 4301, 6), new Range16.Ptr(7680, 7828, 2), new Range16.Ptr(7838, 7934, 2), new Range16.Ptr(7944, 7951, 1), new Range16.Ptr(7960, 7965, 1), new Range16.Ptr(7976, 7983, 1), new Range16.Ptr(7992, 7999, 1), new Range16.Ptr(8008, 8013, 1), new Range16.Ptr(8025, 8031, 2), new Range16.Ptr(8040, 8047, 1), new Range16.Ptr(8072, 8079, 1), new Range16.Ptr(8088, 8095, 1), new Range16.Ptr(8104, 8111, 1), new Range16.Ptr(8120, 8124, 1), new Range16.Ptr(8136, 8140, 1), new Range16.Ptr(8152, 8155, 1), new Range16.Ptr(8168, 8172, 1), new Range16.Ptr(8184, 8188, 1), new Range16.Ptr(8486, 8490, 4), new Range16.Ptr(8491, 8498, 7), new Range16.Ptr(8579, 11264, 2685), new Range16.Ptr(11265, 11310, 1), new Range16.Ptr(11360, 11362, 2), new Range16.Ptr(11363, 11364, 1), new Range16.Ptr(11367, 11373, 2), new Range16.Ptr(11374, 11376, 1), new Range16.Ptr(11378, 11381, 3), new Range16.Ptr(11390, 11392, 1), new Range16.Ptr(11394, 11490, 2), new Range16.Ptr(11499, 11501, 2), new Range16.Ptr(11506, 42560, 31054), new Range16.Ptr(42562, 42604, 2), new Range16.Ptr(42624, 42646, 2), new Range16.Ptr(42786, 42798, 2), new Range16.Ptr(42802, 42862, 2), new Range16.Ptr(42873, 42877, 2), new Range16.Ptr(42878, 42886, 2), new Range16.Ptr(42891, 42893, 2), new Range16.Ptr(42896, 42898, 2), new Range16.Ptr(42912, 42922, 2), new Range16.Ptr(65313, 65338, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66560, 66599, 1)]), 3);
		foldLt = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(452, 454, 2), new Range16.Ptr(455, 457, 2), new Range16.Ptr(458, 460, 2), new Range16.Ptr(497, 499, 2), new Range16.Ptr(8064, 8071, 1), new Range16.Ptr(8080, 8087, 1), new Range16.Ptr(8096, 8103, 1), new Range16.Ptr(8115, 8131, 16), new Range16.Ptr(8179, 8179, 1)]), (go$sliceType(Range32)).nil, 0);
		foldLu = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(97, 122, 1), new Range16.Ptr(181, 223, 42), new Range16.Ptr(224, 246, 1), new Range16.Ptr(248, 255, 1), new Range16.Ptr(257, 303, 2), new Range16.Ptr(307, 311, 2), new Range16.Ptr(314, 328, 2), new Range16.Ptr(331, 375, 2), new Range16.Ptr(378, 382, 2), new Range16.Ptr(383, 384, 1), new Range16.Ptr(387, 389, 2), new Range16.Ptr(392, 396, 4), new Range16.Ptr(402, 405, 3), new Range16.Ptr(409, 410, 1), new Range16.Ptr(414, 417, 3), new Range16.Ptr(419, 421, 2), new Range16.Ptr(424, 429, 5), new Range16.Ptr(432, 436, 4), new Range16.Ptr(438, 441, 3), new Range16.Ptr(445, 447, 2), new Range16.Ptr(453, 454, 1), new Range16.Ptr(456, 457, 1), new Range16.Ptr(459, 460, 1), new Range16.Ptr(462, 476, 2), new Range16.Ptr(477, 495, 2), new Range16.Ptr(498, 499, 1), new Range16.Ptr(501, 505, 4), new Range16.Ptr(507, 543, 2), new Range16.Ptr(547, 563, 2), new Range16.Ptr(572, 575, 3), new Range16.Ptr(576, 578, 2), new Range16.Ptr(583, 591, 2), new Range16.Ptr(592, 596, 1), new Range16.Ptr(598, 599, 1), new Range16.Ptr(601, 603, 2), new Range16.Ptr(608, 611, 3), new Range16.Ptr(613, 614, 1), new Range16.Ptr(616, 617, 1), new Range16.Ptr(619, 623, 4), new Range16.Ptr(625, 626, 1), new Range16.Ptr(629, 637, 8), new Range16.Ptr(640, 643, 3), new Range16.Ptr(648, 652, 1), new Range16.Ptr(658, 837, 179), new Range16.Ptr(881, 883, 2), new Range16.Ptr(887, 891, 4), new Range16.Ptr(892, 893, 1), new Range16.Ptr(940, 943, 1), new Range16.Ptr(945, 974, 1), new Range16.Ptr(976, 977, 1), new Range16.Ptr(981, 983, 1), new Range16.Ptr(985, 1007, 2), new Range16.Ptr(1008, 1010, 1), new Range16.Ptr(1013, 1019, 3), new Range16.Ptr(1072, 1119, 1), new Range16.Ptr(1121, 1153, 2), new Range16.Ptr(1163, 1215, 2), new Range16.Ptr(1218, 1230, 2), new Range16.Ptr(1231, 1319, 2), new Range16.Ptr(1377, 1414, 1), new Range16.Ptr(7545, 7549, 4), new Range16.Ptr(7681, 7829, 2), new Range16.Ptr(7835, 7841, 6), new Range16.Ptr(7843, 7935, 2), new Range16.Ptr(7936, 7943, 1), new Range16.Ptr(7952, 7957, 1), new Range16.Ptr(7968, 7975, 1), new Range16.Ptr(7984, 7991, 1), new Range16.Ptr(8000, 8005, 1), new Range16.Ptr(8017, 8023, 2), new Range16.Ptr(8032, 8039, 1), new Range16.Ptr(8048, 8061, 1), new Range16.Ptr(8112, 8113, 1), new Range16.Ptr(8126, 8144, 18), new Range16.Ptr(8145, 8160, 15), new Range16.Ptr(8161, 8165, 4), new Range16.Ptr(8526, 8580, 54), new Range16.Ptr(11312, 11358, 1), new Range16.Ptr(11361, 11365, 4), new Range16.Ptr(11366, 11372, 2), new Range16.Ptr(11379, 11382, 3), new Range16.Ptr(11393, 11491, 2), new Range16.Ptr(11500, 11502, 2), new Range16.Ptr(11507, 11520, 13), new Range16.Ptr(11521, 11557, 1), new Range16.Ptr(11559, 11565, 6), new Range16.Ptr(42561, 42605, 2), new Range16.Ptr(42625, 42647, 2), new Range16.Ptr(42787, 42799, 2), new Range16.Ptr(42803, 42863, 2), new Range16.Ptr(42874, 42876, 2), new Range16.Ptr(42879, 42887, 2), new Range16.Ptr(42892, 42897, 5), new Range16.Ptr(42899, 42913, 14), new Range16.Ptr(42915, 42921, 2), new Range16.Ptr(65345, 65370, 1)]), new (go$sliceType(Range32))([new Range32.Ptr(66600, 66639, 1)]), 4);
		foldM = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(921, 953, 32), new Range16.Ptr(8126, 8126, 1)]), (go$sliceType(Range32)).nil, 0);
		foldMn = new RangeTable.Ptr(new (go$sliceType(Range16))([new Range16.Ptr(921, 953, 32), new Range16.Ptr(8126, 8126, 1)]), (go$sliceType(Range32)).nil, 0);
		go$pkg.FoldCategory = (_map$3 = new Go$Map(), _key$3 = "Common", _map$3[_key$3] = { k: _key$3, v: foldCommon }, _key$3 = "Greek", _map$3[_key$3] = { k: _key$3, v: foldGreek }, _key$3 = "Inherited", _map$3[_key$3] = { k: _key$3, v: foldInherited }, _key$3 = "L", _map$3[_key$3] = { k: _key$3, v: foldL }, _key$3 = "Ll", _map$3[_key$3] = { k: _key$3, v: foldLl }, _key$3 = "Lt", _map$3[_key$3] = { k: _key$3, v: foldLt }, _key$3 = "Lu", _map$3[_key$3] = { k: _key$3, v: foldLu }, _key$3 = "M", _map$3[_key$3] = { k: _key$3, v: foldM }, _key$3 = "Mn", _map$3[_key$3] = { k: _key$3, v: foldMn }, _map$3);
		go$pkg.FoldScript = (_map$4 = new Go$Map(), _map$4);
	};
	return go$pkg;
})();
go$packages["unicode/utf8"] = (function() {
	var go$pkg = {};
	var decodeRuneInternal = function(p) {
		var r, size, short$1, n, _tuple, _slice, _index, c0, _tuple$1, _tuple$2, _tuple$3, _slice$1, _index$1, c1, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _slice$2, _index$2, c2, _tuple$8, _tuple$9, _tuple$10, _tuple$11, _tuple$12, _slice$3, _index$3, c3, _tuple$13, _tuple$14, _tuple$15, _tuple$16;
		r = 0;
		size = 0;
		short$1 = false;
		n = p.length;
		if (n < 1) {
			_tuple = [65533, 0, true], r = _tuple[0], size = _tuple[1], short$1 = _tuple[2];
			return [r, size, short$1];
		}
		c0 = (_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		if (c0 < 128) {
			_tuple$1 = [(c0 >> 0), 1, false], r = _tuple$1[0], size = _tuple$1[1], short$1 = _tuple$1[2];
			return [r, size, short$1];
		}
		if (c0 < 192) {
			_tuple$2 = [65533, 1, false], r = _tuple$2[0], size = _tuple$2[1], short$1 = _tuple$2[2];
			return [r, size, short$1];
		}
		if (n < 2) {
			_tuple$3 = [65533, 1, true], r = _tuple$3[0], size = _tuple$3[1], short$1 = _tuple$3[2];
			return [r, size, short$1];
		}
		c1 = (_slice$1 = p, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
		if (c1 < 128 || 192 <= c1) {
			_tuple$4 = [65533, 1, false], r = _tuple$4[0], size = _tuple$4[1], short$1 = _tuple$4[2];
			return [r, size, short$1];
		}
		if (c0 < 224) {
			r = ((((c0 & 31) >>> 0) >> 0) << 6 >> 0) | (((c1 & 63) >>> 0) >> 0);
			if (r <= 127) {
				_tuple$5 = [65533, 1, false], r = _tuple$5[0], size = _tuple$5[1], short$1 = _tuple$5[2];
				return [r, size, short$1];
			}
			_tuple$6 = [r, 2, false], r = _tuple$6[0], size = _tuple$6[1], short$1 = _tuple$6[2];
			return [r, size, short$1];
		}
		if (n < 3) {
			_tuple$7 = [65533, 1, true], r = _tuple$7[0], size = _tuple$7[1], short$1 = _tuple$7[2];
			return [r, size, short$1];
		}
		c2 = (_slice$2 = p, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
		if (c2 < 128 || 192 <= c2) {
			_tuple$8 = [65533, 1, false], r = _tuple$8[0], size = _tuple$8[1], short$1 = _tuple$8[2];
			return [r, size, short$1];
		}
		if (c0 < 240) {
			r = (((((c0 & 15) >>> 0) >> 0) << 12 >> 0) | ((((c1 & 63) >>> 0) >> 0) << 6 >> 0)) | (((c2 & 63) >>> 0) >> 0);
			if (r <= 2047) {
				_tuple$9 = [65533, 1, false], r = _tuple$9[0], size = _tuple$9[1], short$1 = _tuple$9[2];
				return [r, size, short$1];
			}
			if (55296 <= r && r <= 57343) {
				_tuple$10 = [65533, 1, false], r = _tuple$10[0], size = _tuple$10[1], short$1 = _tuple$10[2];
				return [r, size, short$1];
			}
			_tuple$11 = [r, 3, false], r = _tuple$11[0], size = _tuple$11[1], short$1 = _tuple$11[2];
			return [r, size, short$1];
		}
		if (n < 4) {
			_tuple$12 = [65533, 1, true], r = _tuple$12[0], size = _tuple$12[1], short$1 = _tuple$12[2];
			return [r, size, short$1];
		}
		c3 = (_slice$3 = p, _index$3 = 3, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
		if (c3 < 128 || 192 <= c3) {
			_tuple$13 = [65533, 1, false], r = _tuple$13[0], size = _tuple$13[1], short$1 = _tuple$13[2];
			return [r, size, short$1];
		}
		if (c0 < 248) {
			r = ((((((c0 & 7) >>> 0) >> 0) << 18 >> 0) | ((((c1 & 63) >>> 0) >> 0) << 12 >> 0)) | ((((c2 & 63) >>> 0) >> 0) << 6 >> 0)) | (((c3 & 63) >>> 0) >> 0);
			if (r <= 65535 || 1114111 < r) {
				_tuple$14 = [65533, 1, false], r = _tuple$14[0], size = _tuple$14[1], short$1 = _tuple$14[2];
				return [r, size, short$1];
			}
			_tuple$15 = [r, 4, false], r = _tuple$15[0], size = _tuple$15[1], short$1 = _tuple$15[2];
			return [r, size, short$1];
		}
		_tuple$16 = [65533, 1, false], r = _tuple$16[0], size = _tuple$16[1], short$1 = _tuple$16[2];
		return [r, size, short$1];
	};
	var decodeRuneInStringInternal = function(s) {
		var r, size, short$1, n, _tuple, c0, _tuple$1, _tuple$2, _tuple$3, c1, _tuple$4, _tuple$5, _tuple$6, _tuple$7, c2, _tuple$8, _tuple$9, _tuple$10, _tuple$11, _tuple$12, c3, _tuple$13, _tuple$14, _tuple$15, _tuple$16;
		r = 0;
		size = 0;
		short$1 = false;
		n = s.length;
		if (n < 1) {
			_tuple = [65533, 0, true], r = _tuple[0], size = _tuple[1], short$1 = _tuple[2];
			return [r, size, short$1];
		}
		c0 = s.charCodeAt(0);
		if (c0 < 128) {
			_tuple$1 = [(c0 >> 0), 1, false], r = _tuple$1[0], size = _tuple$1[1], short$1 = _tuple$1[2];
			return [r, size, short$1];
		}
		if (c0 < 192) {
			_tuple$2 = [65533, 1, false], r = _tuple$2[0], size = _tuple$2[1], short$1 = _tuple$2[2];
			return [r, size, short$1];
		}
		if (n < 2) {
			_tuple$3 = [65533, 1, true], r = _tuple$3[0], size = _tuple$3[1], short$1 = _tuple$3[2];
			return [r, size, short$1];
		}
		c1 = s.charCodeAt(1);
		if (c1 < 128 || 192 <= c1) {
			_tuple$4 = [65533, 1, false], r = _tuple$4[0], size = _tuple$4[1], short$1 = _tuple$4[2];
			return [r, size, short$1];
		}
		if (c0 < 224) {
			r = ((((c0 & 31) >>> 0) >> 0) << 6 >> 0) | (((c1 & 63) >>> 0) >> 0);
			if (r <= 127) {
				_tuple$5 = [65533, 1, false], r = _tuple$5[0], size = _tuple$5[1], short$1 = _tuple$5[2];
				return [r, size, short$1];
			}
			_tuple$6 = [r, 2, false], r = _tuple$6[0], size = _tuple$6[1], short$1 = _tuple$6[2];
			return [r, size, short$1];
		}
		if (n < 3) {
			_tuple$7 = [65533, 1, true], r = _tuple$7[0], size = _tuple$7[1], short$1 = _tuple$7[2];
			return [r, size, short$1];
		}
		c2 = s.charCodeAt(2);
		if (c2 < 128 || 192 <= c2) {
			_tuple$8 = [65533, 1, false], r = _tuple$8[0], size = _tuple$8[1], short$1 = _tuple$8[2];
			return [r, size, short$1];
		}
		if (c0 < 240) {
			r = (((((c0 & 15) >>> 0) >> 0) << 12 >> 0) | ((((c1 & 63) >>> 0) >> 0) << 6 >> 0)) | (((c2 & 63) >>> 0) >> 0);
			if (r <= 2047) {
				_tuple$9 = [65533, 1, false], r = _tuple$9[0], size = _tuple$9[1], short$1 = _tuple$9[2];
				return [r, size, short$1];
			}
			if (55296 <= r && r <= 57343) {
				_tuple$10 = [65533, 1, false], r = _tuple$10[0], size = _tuple$10[1], short$1 = _tuple$10[2];
				return [r, size, short$1];
			}
			_tuple$11 = [r, 3, false], r = _tuple$11[0], size = _tuple$11[1], short$1 = _tuple$11[2];
			return [r, size, short$1];
		}
		if (n < 4) {
			_tuple$12 = [65533, 1, true], r = _tuple$12[0], size = _tuple$12[1], short$1 = _tuple$12[2];
			return [r, size, short$1];
		}
		c3 = s.charCodeAt(3);
		if (c3 < 128 || 192 <= c3) {
			_tuple$13 = [65533, 1, false], r = _tuple$13[0], size = _tuple$13[1], short$1 = _tuple$13[2];
			return [r, size, short$1];
		}
		if (c0 < 248) {
			r = ((((((c0 & 7) >>> 0) >> 0) << 18 >> 0) | ((((c1 & 63) >>> 0) >> 0) << 12 >> 0)) | ((((c2 & 63) >>> 0) >> 0) << 6 >> 0)) | (((c3 & 63) >>> 0) >> 0);
			if (r <= 65535 || 1114111 < r) {
				_tuple$14 = [65533, 1, false], r = _tuple$14[0], size = _tuple$14[1], short$1 = _tuple$14[2];
				return [r, size, short$1];
			}
			_tuple$15 = [r, 4, false], r = _tuple$15[0], size = _tuple$15[1], short$1 = _tuple$15[2];
			return [r, size, short$1];
		}
		_tuple$16 = [65533, 1, false], r = _tuple$16[0], size = _tuple$16[1], short$1 = _tuple$16[2];
		return [r, size, short$1];
	};
	var FullRune = go$pkg.FullRune = function(p) {
		var _tuple, short$1;
		_tuple = decodeRuneInternal(p), short$1 = _tuple[2];
		return !short$1;
	};
	var FullRuneInString = go$pkg.FullRuneInString = function(s) {
		var _tuple, short$1;
		_tuple = decodeRuneInStringInternal(s), short$1 = _tuple[2];
		return !short$1;
	};
	var DecodeRune = go$pkg.DecodeRune = function(p) {
		var r, size, _tuple;
		r = 0;
		size = 0;
		_tuple = decodeRuneInternal(p), r = _tuple[0], size = _tuple[1];
		return [r, size];
	};
	var DecodeRuneInString = go$pkg.DecodeRuneInString = function(s) {
		var r, size, _tuple;
		r = 0;
		size = 0;
		_tuple = decodeRuneInStringInternal(s), r = _tuple[0], size = _tuple[1];
		return [r, size];
	};
	var DecodeLastRune = go$pkg.DecodeLastRune = function(p) {
		var r, size, end, _tuple, start, _slice, _index, _tuple$1, lim, _slice$1, _index$1, _tuple$2, _tuple$3, _tuple$4;
		r = 0;
		size = 0;
		end = p.length;
		if (end === 0) {
			_tuple = [65533, 0], r = _tuple[0], size = _tuple[1];
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((_slice = p, _index = start, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0);
		if (r < 128) {
			_tuple$1 = [r, 1], r = _tuple$1[0], size = _tuple$1[1];
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - 1 >> 0;
		while (start >= lim) {
			if (RuneStart((_slice$1 = p, _index$1 = start, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")))) {
				break;
			}
			start = start - 1 >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple$2 = DecodeRune(go$subslice(p, start, end)), r = _tuple$2[0], size = _tuple$2[1];
		if (!(((start + size >> 0) === end))) {
			_tuple$3 = [65533, 1], r = _tuple$3[0], size = _tuple$3[1];
			return [r, size];
		}
		_tuple$4 = [r, size], r = _tuple$4[0], size = _tuple$4[1];
		return [r, size];
	};
	var DecodeLastRuneInString = go$pkg.DecodeLastRuneInString = function(s) {
		var r, size, end, _tuple, start, _tuple$1, lim, _tuple$2, _tuple$3, _tuple$4;
		r = 0;
		size = 0;
		end = s.length;
		if (end === 0) {
			_tuple = [65533, 0], r = _tuple[0], size = _tuple[1];
			return [r, size];
		}
		start = end - 1 >> 0;
		r = (s.charCodeAt(start) >> 0);
		if (r < 128) {
			_tuple$1 = [r, 1], r = _tuple$1[0], size = _tuple$1[1];
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - 1 >> 0;
		while (start >= lim) {
			if (RuneStart(s.charCodeAt(start))) {
				break;
			}
			start = start - 1 >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple$2 = DecodeRuneInString(s.substring(start, end)), r = _tuple$2[0], size = _tuple$2[1];
		if (!(((start + size >> 0) === end))) {
			_tuple$3 = [65533, 1], r = _tuple$3[0], size = _tuple$3[1];
			return [r, size];
		}
		_tuple$4 = [r, size], r = _tuple$4[0], size = _tuple$4[1];
		return [r, size];
	};
	var RuneLen = go$pkg.RuneLen = function(r) {
		if (r < 0) {
			return -1;
		} else if (r <= 127) {
			return 1;
		} else if (r <= 2047) {
			return 2;
		} else if (55296 <= r && r <= 57343) {
			return -1;
		} else if (r <= 65535) {
			return 3;
		} else if (r <= 1114111) {
			return 4;
		}
		return -1;
	};
	var EncodeRune = go$pkg.EncodeRune = function(p, r) {
		var _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9;
		if ((r >>> 0) <= 127) {
			_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (r << 24 >>> 24)) : go$throwRuntimeError("index out of range");
			return 1;
		}
		if ((r >>> 0) <= 2047) {
			_slice$1 = p, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (192 | ((r >> 6 >> 0) << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
			_slice$2 = p, _index$2 = 1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = (128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0) : go$throwRuntimeError("index out of range");
			return 2;
		}
		if ((r >>> 0) > 1114111) {
			r = 65533;
		}
		if (55296 <= r && r <= 57343) {
			r = 65533;
		}
		if ((r >>> 0) <= 65535) {
			_slice$3 = p, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (224 | ((r >> 12 >> 0) << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
			_slice$4 = p, _index$4 = 1, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = (128 | ((((r >> 6 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0) : go$throwRuntimeError("index out of range");
			_slice$5 = p, _index$5 = 2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0) : go$throwRuntimeError("index out of range");
			return 3;
		}
		_slice$6 = p, _index$6 = 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = (240 | ((r >> 18 >> 0) << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
		_slice$7 = p, _index$7 = 1, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = (128 | ((((r >> 12 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0) : go$throwRuntimeError("index out of range");
		_slice$8 = p, _index$8 = 2, (_index$8 >= 0 && _index$8 < _slice$8.length) ? (_slice$8.array[_slice$8.offset + _index$8] = (128 | ((((r >> 6 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0) : go$throwRuntimeError("index out of range");
		_slice$9 = p, _index$9 = 3, (_index$9 >= 0 && _index$9 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$9] = (128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0) : go$throwRuntimeError("index out of range");
		return 4;
	};
	var RuneCount = go$pkg.RuneCount = function(p) {
		var i, n, _slice, _index, _tuple, size;
		i = 0;
		n = 0;
		n = 0;
		while (i < p.length) {
			if ((_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < 128) {
				i = i + 1 >> 0;
			} else {
				_tuple = DecodeRune(go$subslice(p, i)), size = _tuple[1];
				i = i + (size) >> 0;
			}
			n = n + 1 >> 0;
		}
		return n;
	};
	var RuneCountInString = go$pkg.RuneCountInString = function(s) {
		var n, _ref, _i, _rune;
		n = 0;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			n = n + 1 >> 0;
			_i += _rune[1];
		}
		return n;
	};
	var RuneStart = go$pkg.RuneStart = function(b) {
		return !((((b & 192) >>> 0) === 128));
	};
	var Valid = go$pkg.Valid = function(p) {
		var i, _slice, _index, _tuple, size;
		i = 0;
		while (i < p.length) {
			if ((_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < 128) {
				i = i + 1 >> 0;
			} else {
				_tuple = DecodeRune(go$subslice(p, i)), size = _tuple[1];
				if (size === 1) {
					return false;
				}
				i = i + (size) >> 0;
			}
		}
		return true;
	};
	var ValidString = go$pkg.ValidString = function(s) {
		var _ref, _i, _rune, r, i, _tuple, size;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			r = _rune[0];
			i = _i;
			if (r === 65533) {
				_tuple = DecodeRuneInString(s.substring(i)), size = _tuple[1];
				if (size === 1) {
					return false;
				}
			}
			_i += _rune[1];
		}
		return true;
	};
	var ValidRune = go$pkg.ValidRune = function(r) {
		if (r < 0) {
			return false;
		} else if (55296 <= r && r <= 57343) {
			return false;
		} else if (r > 1114111) {
			return false;
		}
		return true;
	};
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["bytes"] = (function() {
	var go$pkg = {};
	var errors = go$packages["errors"];
	var io = go$packages["io"];
	var utf8 = go$packages["unicode/utf8"];
	var unicode = go$packages["unicode"];
	var Buffer;
	Buffer = go$newType(0, "Struct", "bytes.Buffer", "Buffer", "bytes", function(buf_, off_, runeBytes_, bootstrap_, lastRead_) {
		this.go$val = this;
		this.buf = buf_ !== undefined ? buf_ : (go$sliceType(Go$Uint8)).nil;
		this.off = off_ !== undefined ? off_ : 0;
		this.runeBytes = runeBytes_ !== undefined ? runeBytes_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
		this.bootstrap = bootstrap_ !== undefined ? bootstrap_ : go$makeNativeArray("Uint8", 64, function() { return 0; });
		this.lastRead = lastRead_ !== undefined ? lastRead_ : 0;
	});
	go$pkg.Buffer = Buffer;
	var readOp;
	readOp = go$newType(4, "Int", "bytes.readOp", "readOp", "bytes", null);
	go$pkg.readOp = readOp;
	var Reader;
	Reader = go$newType(0, "Struct", "bytes.Reader", "Reader", "bytes", function(s_, i_, prevRune_) {
		this.go$val = this;
		this.s = s_ !== undefined ? s_ : (go$sliceType(Go$Uint8)).nil;
		this.i = i_ !== undefined ? i_ : 0;
		this.prevRune = prevRune_ !== undefined ? prevRune_ : 0;
	});
	go$pkg.Reader = Reader;
	Buffer.init([["buf", "bytes", (go$sliceType(Go$Uint8)), ""], ["off", "bytes", Go$Int, ""], ["runeBytes", "bytes", (go$arrayType(Go$Uint8, 4)), ""], ["bootstrap", "bytes", (go$arrayType(Go$Uint8, 64)), ""], ["lastRead", "bytes", readOp, ""]]);
	(go$ptrType(Buffer)).methods = [["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Grow", "", [Go$Int], [], false], ["Len", "", [], [Go$Int], false], ["Next", "", [Go$Int], [(go$sliceType(Go$Uint8))], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadByte", "", [], [Go$Uint8, go$error], false], ["ReadBytes", "", [Go$Uint8], [(go$sliceType(Go$Uint8)), go$error], false], ["ReadFrom", "", [io.Reader], [Go$Int64, go$error], false], ["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["ReadString", "", [Go$Uint8], [Go$String, go$error], false], ["Reset", "", [], [], false], ["String", "", [], [Go$String], false], ["Truncate", "", [Go$Int], [], false], ["UnreadByte", "", [], [go$error], false], ["UnreadRune", "", [], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["WriteByte", "", [Go$Uint8], [go$error], false], ["WriteRune", "", [Go$Int32], [Go$Int, go$error], false], ["WriteString", "", [Go$String], [Go$Int, go$error], false], ["WriteTo", "", [io.Writer], [Go$Int64, go$error], false], ["grow", "bytes", [Go$Int], [Go$Int], false], ["readSlice", "bytes", [Go$Uint8], [(go$sliceType(Go$Uint8)), go$error], false]];
	Reader.init([["s", "bytes", (go$sliceType(Go$Uint8)), ""], ["i", "bytes", Go$Int, ""], ["prevRune", "bytes", Go$Int, ""]]);
	(go$ptrType(Reader)).methods = [["Len", "", [], [Go$Int], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["ReadByte", "", [], [Go$Uint8, go$error], false], ["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["Seek", "", [Go$Int64, Go$Int], [Go$Int64, go$error], false], ["UnreadByte", "", [], [go$error], false], ["UnreadRune", "", [], [go$error], false], ["WriteTo", "", [io.Writer], [Go$Int64, go$error], false]];
	Buffer.Ptr.prototype.Bytes = function() {
		var b;
		b = this;
		return go$subslice(b.buf, b.off);
	};
	Buffer.prototype.Bytes = function() { return this.go$val.Bytes(); };
	Buffer.Ptr.prototype.String = function() {
		var b;
		b = this;
		if (b === (go$ptrType(Buffer)).nil) {
			return "<nil>";
		}
		return go$bytesToString(go$subslice(b.buf, b.off));
	};
	Buffer.prototype.String = function() { return this.go$val.String(); };
	Buffer.Ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.length - b.off >> 0;
	};
	Buffer.prototype.Len = function() { return this.go$val.Len(); };
	Buffer.Ptr.prototype.Truncate = function(n) {
		var b;
		b = this;
		b.lastRead = 0;
		if (n < 0 || n > b.Len()) {
			throw go$panic(new Go$String("bytes.Buffer: truncation out of range"));
		} else if (n === 0) {
			b.off = 0;
		}
		b.buf = go$subslice(b.buf, 0, (b.off + n >> 0));
	};
	Buffer.prototype.Truncate = function(n) { return this.go$val.Truncate(n); };
	Buffer.Ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.Truncate(0);
	};
	Buffer.prototype.Reset = function() { return this.go$val.Reset(); };
	Buffer.Ptr.prototype.grow = function(n) {
		var b, m, buf, _q, x, x$1;
		b = this;
		m = b.Len();
		if ((m === 0) && !((b.off === 0))) {
			b.Truncate(0);
		}
		if ((b.buf.length + n >> 0) > b.buf.capacity) {
			buf = (go$sliceType(Go$Uint8)).nil;
			if (b.buf === (go$sliceType(Go$Uint8)).nil && n <= 64) {
				buf = go$subslice(new (go$sliceType(Go$Uint8))(b.bootstrap), 0);
			} else if ((m + n >> 0) <= (_q = b.buf.capacity / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"))) {
				go$copySlice(b.buf, go$subslice(b.buf, b.off));
				buf = go$subslice(b.buf, 0, m);
			} else {
				buf = makeSlice((x = 2, x$1 = b.buf.capacity, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) + n >> 0);
				go$copySlice(buf, go$subslice(b.buf, b.off));
			}
			b.buf = buf;
			b.off = 0;
		}
		b.buf = go$subslice(b.buf, 0, ((b.off + m >> 0) + n >> 0));
		return b.off + m >> 0;
	};
	Buffer.prototype.grow = function(n) { return this.go$val.grow(n); };
	Buffer.Ptr.prototype.Grow = function(n) {
		var b, m;
		b = this;
		if (n < 0) {
			throw go$panic(new Go$String("bytes.Buffer.Grow: negative count"));
		}
		m = b.grow(n);
		b.buf = go$subslice(b.buf, 0, m);
	};
	Buffer.prototype.Grow = function(n) { return this.go$val.Grow(n); };
	Buffer.Ptr.prototype.Write = function(p) {
		var n, err, b, m, _tuple;
		n = 0;
		err = null;
		b = this;
		b.lastRead = 0;
		m = b.grow(p.length);
		_tuple = [go$copySlice(go$subslice(b.buf, m), p), null], n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	Buffer.prototype.Write = function(p) { return this.go$val.Write(p); };
	Buffer.Ptr.prototype.WriteString = function(s) {
		var n, err, b, m, _tuple;
		n = 0;
		err = null;
		b = this;
		b.lastRead = 0;
		m = b.grow(s.length);
		_tuple = [go$copyString(go$subslice(b.buf, m), s), null], n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	Buffer.prototype.WriteString = function(s) { return this.go$val.WriteString(s); };
	Buffer.Ptr.prototype.ReadFrom = function(r) {
		var n, err, b, free, newBuf, x, x$1, _tuple, m, e, x$2, _tuple$1, _tuple$2;
		n = new Go$Int64(0, 0);
		err = null;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.length) {
			b.Truncate(0);
		}
		while (true) {
			if (free = b.buf.capacity - b.buf.length >> 0, free < 512) {
				newBuf = b.buf;
				if ((b.off + free >> 0) < 512) {
					newBuf = makeSlice((x = 2, x$1 = b.buf.capacity, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) + 512 >> 0);
				}
				go$copySlice(newBuf, go$subslice(b.buf, b.off));
				b.buf = go$subslice(newBuf, 0, (b.buf.length - b.off >> 0));
				b.off = 0;
			}
			_tuple = r.Read(go$subslice(b.buf, b.buf.length, b.buf.capacity)), m = _tuple[0], e = _tuple[1];
			b.buf = go$subslice(b.buf, 0, (b.buf.length + m >> 0));
			n = (x$2 = new Go$Int64(0, m), new Go$Int64(n.high + x$2.high, n.low + x$2.low));
			if (go$interfaceIsEqual(e, io.EOF)) {
				break;
			}
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$1 = [n, e], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
		}
		_tuple$2 = [n, null], n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	Buffer.prototype.ReadFrom = function(r) { return this.go$val.ReadFrom(r); };
	var makeSlice = function(n) {
		var go$deferred = [];
		try {
			go$deferred.push({ fun: (function() {
				if (!(go$interfaceIsEqual(go$recover(), null))) {
					throw go$panic(go$pkg.ErrTooLarge);
				}
			}), args: [] });
			return (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
		} catch(go$err) {
			go$pushErr(go$err);
			return (go$sliceType(Go$Uint8)).nil;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	Buffer.Ptr.prototype.WriteTo = function(w) {
		var n, err, b, nBytes, _tuple, m, e, _tuple$1, _tuple$2;
		n = new Go$Int64(0, 0);
		err = null;
		b = this;
		b.lastRead = 0;
		if (b.off < b.buf.length) {
			nBytes = b.Len();
			_tuple = w.Write(go$subslice(b.buf, b.off)), m = _tuple[0], e = _tuple[1];
			if (m > nBytes) {
				throw go$panic(new Go$String("bytes.Buffer.WriteTo: invalid Write count"));
			}
			b.off = b.off + (m) >> 0;
			n = new Go$Int64(0, m);
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$1 = [n, e], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
			if (!((m === nBytes))) {
				_tuple$2 = [n, io.ErrShortWrite], n = _tuple$2[0], err = _tuple$2[1];
				return [n, err];
			}
		}
		b.Truncate(0);
		return [n, err];
	};
	Buffer.prototype.WriteTo = function(w) { return this.go$val.WriteTo(w); };
	Buffer.Ptr.prototype.WriteByte = function(c) {
		var b, m, _slice, _index;
		b = this;
		b.lastRead = 0;
		m = b.grow(1);
		_slice = b.buf, _index = m, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c) : go$throwRuntimeError("index out of range");
		return null;
	};
	Buffer.prototype.WriteByte = function(c) { return this.go$val.WriteByte(c); };
	Buffer.Ptr.prototype.WriteRune = function(r) {
		var n, err, b, _tuple, _tuple$1;
		n = 0;
		err = null;
		b = this;
		if (r < 128) {
			b.WriteByte((r << 24 >>> 24));
			_tuple = [1, null], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		n = utf8.EncodeRune(go$subslice(new (go$sliceType(Go$Uint8))(b.runeBytes), 0), r);
		b.Write(go$subslice(new (go$sliceType(Go$Uint8))(b.runeBytes), 0, n));
		_tuple$1 = [n, null], n = _tuple$1[0], err = _tuple$1[1];
		return [n, err];
	};
	Buffer.prototype.WriteRune = function(r) { return this.go$val.WriteRune(r); };
	Buffer.Ptr.prototype.Read = function(p) {
		var n, err, b, _tuple;
		n = 0;
		err = null;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.length) {
			b.Truncate(0);
			if (p.length === 0) {
				return [n, err];
			}
			_tuple = [0, io.EOF], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		n = go$copySlice(p, go$subslice(b.buf, b.off));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = 2;
		}
		return [n, err];
	};
	Buffer.prototype.Read = function(p) { return this.go$val.Read(p); };
	Buffer.Ptr.prototype.Next = function(n) {
		var b, m, data;
		b = this;
		b.lastRead = 0;
		m = b.Len();
		if (n > m) {
			n = m;
		}
		data = go$subslice(b.buf, b.off, (b.off + n >> 0));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = 2;
		}
		return data;
	};
	Buffer.prototype.Next = function(n) { return this.go$val.Next(n); };
	Buffer.Ptr.prototype.ReadByte = function() {
		var c, err, b, _tuple, _slice, _index, _tuple$1;
		c = 0;
		err = null;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.length) {
			b.Truncate(0);
			_tuple = [0, io.EOF], c = _tuple[0], err = _tuple[1];
			return [c, err];
		}
		c = (_slice = b.buf, _index = b.off, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		b.off = b.off + 1 >> 0;
		b.lastRead = 2;
		_tuple$1 = [c, null], c = _tuple$1[0], err = _tuple$1[1];
		return [c, err];
	};
	Buffer.prototype.ReadByte = function() { return this.go$val.ReadByte(); };
	Buffer.Ptr.prototype.ReadRune = function() {
		var r, size, err, b, _tuple, _slice, _index, c, _tuple$1, _tuple$2, n, _tuple$3;
		r = 0;
		size = 0;
		err = null;
		b = this;
		b.lastRead = 0;
		if (b.off >= b.buf.length) {
			b.Truncate(0);
			_tuple = [0, 0, io.EOF], r = _tuple[0], size = _tuple[1], err = _tuple[2];
			return [r, size, err];
		}
		b.lastRead = 1;
		c = (_slice = b.buf, _index = b.off, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		if (c < 128) {
			b.off = b.off + 1 >> 0;
			_tuple$1 = [(c >> 0), 1, null], r = _tuple$1[0], size = _tuple$1[1], err = _tuple$1[2];
			return [r, size, err];
		}
		_tuple$2 = utf8.DecodeRune(go$subslice(b.buf, b.off)), r = _tuple$2[0], n = _tuple$2[1];
		b.off = b.off + (n) >> 0;
		_tuple$3 = [r, n, null], r = _tuple$3[0], size = _tuple$3[1], err = _tuple$3[2];
		return [r, size, err];
	};
	Buffer.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	Buffer.Ptr.prototype.UnreadRune = function() {
		var b, _tuple, n;
		b = this;
		if (!((b.lastRead === 1))) {
			return errors.New("bytes.Buffer: UnreadRune: previous operation was not ReadRune");
		}
		b.lastRead = 0;
		if (b.off > 0) {
			_tuple = utf8.DecodeLastRune(go$subslice(b.buf, 0, b.off)), n = _tuple[1];
			b.off = b.off - (n) >> 0;
		}
		return null;
	};
	Buffer.prototype.UnreadRune = function() { return this.go$val.UnreadRune(); };
	Buffer.Ptr.prototype.UnreadByte = function() {
		var b;
		b = this;
		if (!((b.lastRead === 1)) && !((b.lastRead === 2))) {
			return errors.New("bytes.Buffer: UnreadByte: previous operation was not a read");
		}
		b.lastRead = 0;
		if (b.off > 0) {
			b.off = b.off - 1 >> 0;
		}
		return null;
	};
	Buffer.prototype.UnreadByte = function() { return this.go$val.UnreadByte(); };
	Buffer.Ptr.prototype.ReadBytes = function(delim) {
		var line, err, b, _tuple, slice;
		line = (go$sliceType(Go$Uint8)).nil;
		err = null;
		b = this;
		_tuple = b.readSlice(delim), slice = _tuple[0], err = _tuple[1];
		line = go$appendSlice(line, slice);
		return [line, err];
	};
	Buffer.prototype.ReadBytes = function(delim) { return this.go$val.ReadBytes(delim); };
	Buffer.Ptr.prototype.readSlice = function(delim) {
		var line, err, b, i, end, _tuple;
		line = (go$sliceType(Go$Uint8)).nil;
		err = null;
		b = this;
		i = IndexByte(go$subslice(b.buf, b.off), delim);
		end = (b.off + i >> 0) + 1 >> 0;
		if (i < 0) {
			end = b.buf.length;
			err = io.EOF;
		}
		line = go$subslice(b.buf, b.off, end);
		b.off = end;
		b.lastRead = 2;
		_tuple = [line, err], line = _tuple[0], err = _tuple[1];
		return [line, err];
	};
	Buffer.prototype.readSlice = function(delim) { return this.go$val.readSlice(delim); };
	Buffer.Ptr.prototype.ReadString = function(delim) {
		var line, err, b, _tuple, slice, _tuple$1;
		line = "";
		err = null;
		b = this;
		_tuple = b.readSlice(delim), slice = _tuple[0], err = _tuple[1];
		_tuple$1 = [go$bytesToString(slice), err], line = _tuple$1[0], err = _tuple$1[1];
		return [line, err];
	};
	Buffer.prototype.ReadString = function(delim) { return this.go$val.ReadString(delim); };
	var NewBuffer = go$pkg.NewBuffer = function(buf) {
		return new Buffer.Ptr(buf, 0, go$makeNativeArray("Uint8", 4, function() { return 0; }), go$makeNativeArray("Uint8", 64, function() { return 0; }), 0);
	};
	var NewBufferString = go$pkg.NewBufferString = function(s) {
		return new Buffer.Ptr(new (go$sliceType(Go$Uint8))(go$stringToBytes(s)), 0, go$makeNativeArray("Uint8", 4, function() { return 0; }), go$makeNativeArray("Uint8", 64, function() { return 0; }), 0);
	};
	var equalPortable = function(a, b) {
		var _ref, _i, _slice, _index, c, i, _slice$1, _index$1;
		if (!((a.length === b.length))) {
			return false;
		}
		_ref = a;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (!((c === (_slice$1 = b, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	var explode = function(s, n) {
		var a, size, na, _slice, _index, _tuple, _slice$1, _index$1;
		if (n <= 0) {
			n = s.length;
		}
		a = (go$sliceType((go$sliceType(Go$Uint8)))).make(n, 0, function() { return (go$sliceType(Go$Uint8)).nil; });
		size = 0;
		na = 0;
		while (s.length > 0) {
			if ((na + 1 >> 0) >= n) {
				_slice = a, _index = na, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = s) : go$throwRuntimeError("index out of range");
				na = na + 1 >> 0;
				break;
			}
			_tuple = utf8.DecodeRune(s), size = _tuple[1];
			_slice$1 = a, _index$1 = na, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = go$subslice(s, 0, size)) : go$throwRuntimeError("index out of range");
			s = go$subslice(s, size);
			na = na + 1 >> 0;
		}
		return go$subslice(a, 0, na);
	};
	var Count = go$pkg.Count = function(s, sep) {
		var n, count, _slice, _index, c, i, t, _slice$1, _index$1, o;
		n = sep.length;
		if (n === 0) {
			return utf8.RuneCount(s) + 1 >> 0;
		}
		if (n > s.length) {
			return 0;
		}
		count = 0;
		c = (_slice = sep, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		i = 0;
		t = go$subslice(s, 0, ((s.length - n >> 0) + 1 >> 0));
		while (i < t.length) {
			if (!(((_slice$1 = t, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === c))) {
				o = IndexByte(go$subslice(t, i), c);
				if (o < 0) {
					break;
				}
				i = i + (o) >> 0;
			}
			if ((n === 1) || Equal(go$subslice(s, i, (i + n >> 0)), sep)) {
				count = count + 1 >> 0;
				i = i + (n) >> 0;
				continue;
			}
			i = i + 1 >> 0;
		}
		return count;
	};
	var Contains = go$pkg.Contains = function(b, subslice) {
		return !((Index(b, subslice) === -1));
	};
	var Index = go$pkg.Index = function(s, sep) {
		var n, _slice, _index, c, i, t, _slice$1, _index$1, o;
		n = sep.length;
		if (n === 0) {
			return 0;
		}
		if (n > s.length) {
			return -1;
		}
		c = (_slice = sep, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		if (n === 1) {
			return IndexByte(s, c);
		}
		i = 0;
		t = go$subslice(s, 0, ((s.length - n >> 0) + 1 >> 0));
		while (i < t.length) {
			if (!(((_slice$1 = t, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === c))) {
				o = IndexByte(go$subslice(t, i), c);
				if (o < 0) {
					break;
				}
				i = i + (o) >> 0;
			}
			if (Equal(go$subslice(s, i, (i + n >> 0)), sep)) {
				return i;
			}
			i = i + 1 >> 0;
		}
		return -1;
	};
	var indexBytePortable = function(s, c) {
		var _ref, _i, _slice, _index, b, i;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	var LastIndex = go$pkg.LastIndex = function(s, sep) {
		var n, _slice, _index, c, i, _slice$1, _index$1;
		n = sep.length;
		if (n === 0) {
			return s.length;
		}
		c = (_slice = sep, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		i = s.length - n >> 0;
		while (i >= 0) {
			if (((_slice$1 = s, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === c) && ((n === 1) || Equal(go$subslice(s, i, (i + n >> 0)), sep))) {
				return i;
			}
			i = i - 1 >> 0;
		}
		return -1;
	};
	var IndexRune = go$pkg.IndexRune = function(s, r) {
		var i, _tuple, r1, size;
		i = 0;
		while (i < s.length) {
			_tuple = utf8.DecodeRune(go$subslice(s, i)), r1 = _tuple[0], size = _tuple[1];
			if (r === r1) {
				return i;
			}
			i = i + (size) >> 0;
		}
		return -1;
	};
	var IndexAny = go$pkg.IndexAny = function(s, chars) {
		var r, width, i, _slice, _index, _tuple, _ref, _i, _rune, ch;
		if (chars.length > 0) {
			r = 0;
			width = 0;
			i = 0;
			while (i < s.length) {
				r = ((_slice = s, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0);
				if (r < 128) {
					width = 1;
				} else {
					_tuple = utf8.DecodeRune(go$subslice(s, i)), r = _tuple[0], width = _tuple[1];
				}
				_ref = chars;
				_i = 0;
				while (_i < _ref.length) {
					_rune = go$decodeRune(_ref, _i);
					ch = _rune[0];
					if (r === ch) {
						return i;
					}
					_i += _rune[1];
				}
				i = i + (width) >> 0;
			}
		}
		return -1;
	};
	var LastIndexAny = go$pkg.LastIndexAny = function(s, chars) {
		var i, _tuple, r, size, _ref, _i, _rune, ch;
		if (chars.length > 0) {
			i = s.length;
			while (i > 0) {
				_tuple = utf8.DecodeLastRune(go$subslice(s, 0, i)), r = _tuple[0], size = _tuple[1];
				i = i - (size) >> 0;
				_ref = chars;
				_i = 0;
				while (_i < _ref.length) {
					_rune = go$decodeRune(_ref, _i);
					ch = _rune[0];
					if (r === ch) {
						return i;
					}
					_i += _rune[1];
				}
			}
		}
		return -1;
	};
	var genSplit = function(s, sep, sepSave, n) {
		var _slice, _index, c, start, a, na, i, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		if (n === 0) {
			return (go$sliceType((go$sliceType(Go$Uint8)))).nil;
		}
		if (sep.length === 0) {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		c = (_slice = sep, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		start = 0;
		a = (go$sliceType((go$sliceType(Go$Uint8)))).make(n, 0, function() { return (go$sliceType(Go$Uint8)).nil; });
		na = 0;
		i = 0;
		while ((i + sep.length >> 0) <= s.length && (na + 1 >> 0) < n) {
			if (((_slice$1 = s, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === c) && ((sep.length === 1) || Equal(go$subslice(s, i, (i + sep.length >> 0)), sep))) {
				_slice$2 = a, _index$2 = na, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = go$subslice(s, start, (i + sepSave >> 0))) : go$throwRuntimeError("index out of range");
				na = na + 1 >> 0;
				start = i + sep.length >> 0;
				i = i + ((sep.length - 1 >> 0)) >> 0;
			}
			i = i + 1 >> 0;
		}
		_slice$3 = a, _index$3 = na, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = go$subslice(s, start)) : go$throwRuntimeError("index out of range");
		return go$subslice(a, 0, (na + 1 >> 0));
	};
	var SplitN = go$pkg.SplitN = function(s, sep, n) {
		return genSplit(s, sep, 0, n);
	};
	var SplitAfterN = go$pkg.SplitAfterN = function(s, sep, n) {
		return genSplit(s, sep, sep.length, n);
	};
	var Split = go$pkg.Split = function(s, sep) {
		return genSplit(s, sep, 0, -1);
	};
	var SplitAfter = go$pkg.SplitAfter = function(s, sep) {
		return genSplit(s, sep, sep.length, -1);
	};
	var Fields = go$pkg.Fields = function(s) {
		return FieldsFunc(s, unicode.IsSpace);
	};
	var FieldsFunc = go$pkg.FieldsFunc = function(s, f) {
		var n, inField, i, _tuple, r, size, wasInField, a, na, fieldStart, i$1, _tuple$1, r$1, size$1, _slice, _index;
		n = 0;
		inField = false;
		i = 0;
		while (i < s.length) {
			_tuple = utf8.DecodeRune(go$subslice(s, i)), r = _tuple[0], size = _tuple[1];
			wasInField = inField;
			inField = !f(r);
			if (inField && !wasInField) {
				n = n + 1 >> 0;
			}
			i = i + (size) >> 0;
		}
		a = (go$sliceType((go$sliceType(Go$Uint8)))).make(n, 0, function() { return (go$sliceType(Go$Uint8)).nil; });
		na = 0;
		fieldStart = -1;
		i$1 = 0;
		while (i$1 <= s.length && na < n) {
			_tuple$1 = utf8.DecodeRune(go$subslice(s, i$1)), r$1 = _tuple$1[0], size$1 = _tuple$1[1];
			if (fieldStart < 0 && size$1 > 0 && !f(r$1)) {
				fieldStart = i$1;
				i$1 = i$1 + (size$1) >> 0;
				continue;
			}
			if (fieldStart >= 0 && ((size$1 === 0) || f(r$1))) {
				_slice = a, _index = na, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = go$subslice(s, fieldStart, i$1)) : go$throwRuntimeError("index out of range");
				na = na + 1 >> 0;
				fieldStart = -1;
			}
			if (size$1 === 0) {
				break;
			}
			i$1 = i$1 + (size$1) >> 0;
		}
		return go$subslice(a, 0, na);
	};
	var Join = go$pkg.Join = function(s, sep) {
		var _slice, _index, x, x$1, n, _ref, _i, _slice$1, _index$1, v, b, _slice$2, _index$2, bp, _ref$1, _i$1, _slice$3, _index$3, v$1;
		if (s.length === 0) {
			return new (go$sliceType(Go$Uint8))([]);
		}
		if (s.length === 1) {
			return go$appendSlice((go$sliceType(Go$Uint8)).nil, (_slice = s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
		}
		n = (x = sep.length, x$1 = (s.length - 1 >> 0), (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice$1 = _ref, _index$1 = _i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			n = n + (v.length) >> 0;
			_i++;
		}
		b = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
		bp = go$copySlice(b, (_slice$2 = s, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")));
		_ref$1 = go$subslice(s, 1);
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			v$1 = (_slice$3 = _ref$1, _index$3 = _i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			bp = bp + (go$copySlice(go$subslice(b, bp), sep)) >> 0;
			bp = bp + (go$copySlice(go$subslice(b, bp), v$1)) >> 0;
			_i$1++;
		}
		return b;
	};
	var HasPrefix = go$pkg.HasPrefix = function(s, prefix) {
		return s.length >= prefix.length && Equal(go$subslice(s, 0, prefix.length), prefix);
	};
	var HasSuffix = go$pkg.HasSuffix = function(s, suffix) {
		return s.length >= suffix.length && Equal(go$subslice(s, (s.length - suffix.length >> 0)), suffix);
	};
	var Map = go$pkg.Map = function(mapping, s) {
		var maxbytes, nbytes, b, i, wid, _slice, _index, r, _tuple, x, nb;
		maxbytes = s.length;
		nbytes = 0;
		b = (go$sliceType(Go$Uint8)).make(maxbytes, 0, function() { return 0; });
		i = 0;
		while (i < s.length) {
			wid = 1;
			r = ((_slice = s, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0);
			if (r >= 128) {
				_tuple = utf8.DecodeRune(go$subslice(s, i)), r = _tuple[0], wid = _tuple[1];
			}
			r = mapping(r);
			if (r >= 0) {
				if ((nbytes + utf8.RuneLen(r) >> 0) > maxbytes) {
					maxbytes = (x = 2, (((maxbytes >>> 16 << 16) * x >> 0) + (maxbytes << 16 >>> 16) * x) >> 0) + 4 >> 0;
					nb = (go$sliceType(Go$Uint8)).make(maxbytes, 0, function() { return 0; });
					go$copySlice(nb, go$subslice(b, 0, nbytes));
					b = nb;
				}
				nbytes = nbytes + (utf8.EncodeRune(go$subslice(b, nbytes, maxbytes), r)) >> 0;
			}
			i = i + (wid) >> 0;
		}
		return go$subslice(b, 0, nbytes);
	};
	var Repeat = go$pkg.Repeat = function(b, count) {
		var x, nb, bp, i;
		nb = (go$sliceType(Go$Uint8)).make((x = b.length, (((x >>> 16 << 16) * count >> 0) + (x << 16 >>> 16) * count) >> 0), 0, function() { return 0; });
		bp = 0;
		i = 0;
		while (i < count) {
			bp = bp + (go$copySlice(go$subslice(nb, bp), b)) >> 0;
			i = i + 1 >> 0;
		}
		return nb;
	};
	var ToUpper = go$pkg.ToUpper = function(s) {
		return Map(unicode.ToUpper, s);
	};
	var ToLower = go$pkg.ToLower = function(s) {
		return Map(unicode.ToLower, s);
	};
	var ToTitle = go$pkg.ToTitle = function(s) {
		return Map(unicode.ToTitle, s);
	};
	var ToUpperSpecial = go$pkg.ToUpperSpecial = function(_case, s) {
		return Map((function(r) {
			return _case.ToUpper(r);
		}), s);
	};
	var ToLowerSpecial = go$pkg.ToLowerSpecial = function(_case, s) {
		return Map((function(r) {
			return _case.ToLower(r);
		}), s);
	};
	var ToTitleSpecial = go$pkg.ToTitleSpecial = function(_case, s) {
		return Map((function(r) {
			return _case.ToTitle(r);
		}), s);
	};
	var isSeparator = function(r) {
		if (r <= 127) {
			if (48 <= r && r <= 57) {
				return false;
			} else if (97 <= r && r <= 122) {
				return false;
			} else if (65 <= r && r <= 90) {
				return false;
			} else if (r === 95) {
				return false;
			}
			return true;
		}
		if (unicode.IsLetter(r) || unicode.IsDigit(r)) {
			return false;
		}
		return unicode.IsSpace(r);
	};
	var Title = go$pkg.Title = function(s) {
		var prev;
		prev = 32;
		return Map((function(r) {
			if (isSeparator(prev)) {
				prev = r;
				return unicode.ToTitle(r);
			}
			prev = r;
			return r;
		}), s);
	};
	var TrimLeftFunc = go$pkg.TrimLeftFunc = function(s, f) {
		var i;
		i = indexFunc(s, f, false);
		if (i === -1) {
			return (go$sliceType(Go$Uint8)).nil;
		}
		return go$subslice(s, i);
	};
	var TrimRightFunc = go$pkg.TrimRightFunc = function(s, f) {
		var i, _slice, _index, _tuple, wid;
		i = lastIndexFunc(s, f, false);
		if (i >= 0 && (_slice = s, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >= 128) {
			_tuple = utf8.DecodeRune(go$subslice(s, i)), wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + 1 >> 0;
		}
		return go$subslice(s, 0, i);
	};
	var TrimFunc = go$pkg.TrimFunc = function(s, f) {
		return TrimRightFunc(TrimLeftFunc(s, f), f);
	};
	var TrimPrefix = go$pkg.TrimPrefix = function(s, prefix) {
		if (HasPrefix(s, prefix)) {
			return go$subslice(s, prefix.length);
		}
		return s;
	};
	var TrimSuffix = go$pkg.TrimSuffix = function(s, suffix) {
		if (HasSuffix(s, suffix)) {
			return go$subslice(s, 0, (s.length - suffix.length >> 0));
		}
		return s;
	};
	var IndexFunc = go$pkg.IndexFunc = function(s, f) {
		return indexFunc(s, f, true);
	};
	var LastIndexFunc = go$pkg.LastIndexFunc = function(s, f) {
		return lastIndexFunc(s, f, true);
	};
	var indexFunc = function(s, f, truth) {
		var start, wid, _slice, _index, r, _tuple;
		start = 0;
		while (start < s.length) {
			wid = 1;
			r = ((_slice = s, _index = start, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0);
			if (r >= 128) {
				_tuple = utf8.DecodeRune(go$subslice(s, start)), r = _tuple[0], wid = _tuple[1];
			}
			if (f(r) === truth) {
				return start;
			}
			start = start + (wid) >> 0;
		}
		return -1;
	};
	var lastIndexFunc = function(s, f, truth) {
		var i, _slice, _index, _tuple, r, size, _tuple$1;
		i = s.length;
		while (i > 0) {
			_tuple = [((_slice = s, _index = (i - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0), 1], r = _tuple[0], size = _tuple[1];
			if (r >= 128) {
				_tuple$1 = utf8.DecodeLastRune(go$subslice(s, 0, i)), r = _tuple$1[0], size = _tuple$1[1];
			}
			i = i - (size) >> 0;
			if (f(r) === truth) {
				return i;
			}
		}
		return -1;
	};
	var makeCutsetFunc = function(cutset) {
		return (function(r) {
			var _ref, _i, _rune, c;
			_ref = cutset;
			_i = 0;
			while (_i < _ref.length) {
				_rune = go$decodeRune(_ref, _i);
				c = _rune[0];
				if (c === r) {
					return true;
				}
				_i += _rune[1];
			}
			return false;
		});
	};
	var Trim = go$pkg.Trim = function(s, cutset) {
		return TrimFunc(s, makeCutsetFunc(cutset));
	};
	var TrimLeft = go$pkg.TrimLeft = function(s, cutset) {
		return TrimLeftFunc(s, makeCutsetFunc(cutset));
	};
	var TrimRight = go$pkg.TrimRight = function(s, cutset) {
		return TrimRightFunc(s, makeCutsetFunc(cutset));
	};
	var TrimSpace = go$pkg.TrimSpace = function(s) {
		return TrimFunc(s, unicode.IsSpace);
	};
	var Runes = go$pkg.Runes = function(s) {
		var t, i, _tuple, r, l, _slice, _index;
		t = (go$sliceType(Go$Int32)).make(utf8.RuneCount(s), 0, function() { return 0; });
		i = 0;
		while (s.length > 0) {
			_tuple = utf8.DecodeRune(s), r = _tuple[0], l = _tuple[1];
			_slice = t, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = r) : go$throwRuntimeError("index out of range");
			i = i + 1 >> 0;
			s = go$subslice(s, l);
		}
		return t;
	};
	var Replace = go$pkg.Replace = function(s, old, new$1, n) {
		var m, x, t, w, start, i, j, _tuple, wid;
		m = 0;
		if (!((n === 0))) {
			m = Count(s, old);
		}
		if (m === 0) {
			return go$appendSlice((go$sliceType(Go$Uint8)).nil, s);
		}
		if (n < 0 || m < n) {
			n = m;
		}
		t = (go$sliceType(Go$Uint8)).make(s.length + (x = (new$1.length - old.length >> 0), (((n >>> 16 << 16) * x >> 0) + (n << 16 >>> 16) * x) >> 0) >> 0, 0, function() { return 0; });
		w = 0;
		start = 0;
		i = 0;
		while (i < n) {
			j = start;
			if (old.length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRune(go$subslice(s, start)), wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index(go$subslice(s, start), old)) >> 0;
			}
			w = w + (go$copySlice(go$subslice(t, w), go$subslice(s, start, j))) >> 0;
			w = w + (go$copySlice(go$subslice(t, w), new$1)) >> 0;
			start = j + old.length >> 0;
			i = i + 1 >> 0;
		}
		w = w + (go$copySlice(go$subslice(t, w), go$subslice(s, start))) >> 0;
		return go$subslice(t, 0, w);
	};
	var EqualFold = go$pkg.EqualFold = function(s, t) {
		var _tuple, sr, tr, _slice, _index, _slice$1, _index$1, _tuple$1, _tuple$2, r, size, _tuple$3, _slice$2, _index$2, _slice$3, _index$3, _tuple$4, _tuple$5, r$1, size$1, _tuple$6, _tuple$7, r$2;
		while (!((s.length === 0)) && !((t.length === 0))) {
			_tuple = [0, 0], sr = _tuple[0], tr = _tuple[1];
			if ((_slice = s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < 128) {
				_tuple$1 = [((_slice$1 = s, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >> 0), go$subslice(s, 1)], sr = _tuple$1[0], s = _tuple$1[1];
			} else {
				_tuple$2 = utf8.DecodeRune(s), r = _tuple$2[0], size = _tuple$2[1];
				_tuple$3 = [r, go$subslice(s, size)], sr = _tuple$3[0], s = _tuple$3[1];
			}
			if ((_slice$2 = t, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) < 128) {
				_tuple$4 = [((_slice$3 = t, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) >> 0), go$subslice(t, 1)], tr = _tuple$4[0], t = _tuple$4[1];
			} else {
				_tuple$5 = utf8.DecodeRune(t), r$1 = _tuple$5[0], size$1 = _tuple$5[1];
				_tuple$6 = [r$1, go$subslice(t, size$1)], tr = _tuple$6[0], t = _tuple$6[1];
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tuple$7 = [sr, tr], tr = _tuple$7[0], sr = _tuple$7[1];
			}
			if (tr < 128 && 65 <= sr && sr <= 90) {
				if (tr === ((sr + 97 >> 0) - 65 >> 0)) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (!((r$2 === sr)) && r$2 < tr) {
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s.length === t.length;
	};
	var IndexByte = go$pkg.IndexByte = function(s, c) {
			var i;
			for (i = 0; i < s.length; i++) {
				if (s.array[s.offset + i] === c) {
					return i;
				}
			}
			return -1;
		};
	var Equal = go$pkg.Equal = function(a, b) {
			if (a.length !== b.length) {
				return false;
			}
			var i;
			for (i = 0; i < a.length; i++) {
				if (a.array[a.offset + i] !== b.array[b.offset + i]) {
					return false;
				}
			}
			return true;
		};
	var Compare = go$pkg.Compare = function(a, b) {
			var l = Math.min(a.length, b.length), i;
			for (i = 0; i < a.length; i++) {
				var va = a.array[a.offset + i];
				var vb = b.array[b.offset + i];
				if (va < vb) {
					return -1;
				}
				if (va > vb) {
					return 1;
				}
			}
			if (a.length < b.length) {
				return -1;
			}
			if (a.length > b.length) {
				return 1;
			}
			return 0;
		};
	Reader.Ptr.prototype.Len = function() {
		var r;
		r = this;
		if (r.i >= r.s.length) {
			return 0;
		}
		return r.s.length - r.i >> 0;
	};
	Reader.prototype.Len = function() { return this.go$val.Len(); };
	Reader.Ptr.prototype.Read = function(b) {
		var n, err, r, _tuple, _tuple$1;
		n = 0;
		err = null;
		r = this;
		if (b.length === 0) {
			_tuple = [0, null], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (r.i >= r.s.length) {
			_tuple$1 = [0, io.EOF], n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		n = go$copySlice(b, go$subslice(r.s, r.i));
		r.i = r.i + (n) >> 0;
		r.prevRune = -1;
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.go$val.Read(b); };
	Reader.Ptr.prototype.ReadAt = function(b, off) {
		var n, err, r, _tuple, x, _tuple$1;
		n = 0;
		err = null;
		r = this;
		if ((off.high < 0 || (off.high === 0 && off.low < 0))) {
			_tuple = [0, errors.New("bytes: invalid offset")], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if ((x = new Go$Int64(0, r.s.length), (off.high > x.high || (off.high === x.high && off.low >= x.low)))) {
			_tuple$1 = [0, io.EOF], n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		n = go$copySlice(b, go$subslice(r.s, ((off.low + ((off.high >> 31) * 4294967296)) >> 0)));
		if (n < b.length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.go$val.ReadAt(b, off); };
	Reader.Ptr.prototype.ReadByte = function() {
		var b, err, r, _tuple, _slice, _index;
		b = 0;
		err = null;
		r = this;
		if (r.i >= r.s.length) {
			_tuple = [0, io.EOF], b = _tuple[0], err = _tuple[1];
			return [b, err];
		}
		b = (_slice = r.s, _index = r.i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		r.i = r.i + 1 >> 0;
		r.prevRune = -1;
		return [b, err];
	};
	Reader.prototype.ReadByte = function() { return this.go$val.ReadByte(); };
	Reader.Ptr.prototype.UnreadByte = function() {
		var r;
		r = this;
		if (r.i <= 0) {
			return errors.New("bytes.Reader: at beginning of slice");
		}
		r.i = r.i - 1 >> 0;
		r.prevRune = -1;
		return null;
	};
	Reader.prototype.UnreadByte = function() { return this.go$val.UnreadByte(); };
	Reader.Ptr.prototype.ReadRune = function() {
		var ch, size, err, r, _tuple, c, _slice, _index, _tuple$1, _tuple$2;
		ch = 0;
		size = 0;
		err = null;
		r = this;
		if (r.i >= r.s.length) {
			_tuple = [0, 0, io.EOF], ch = _tuple[0], size = _tuple[1], err = _tuple[2];
			return [ch, size, err];
		}
		r.prevRune = r.i;
		if (c = (_slice = r.s, _index = r.i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), c < 128) {
			r.i = r.i + 1 >> 0;
			_tuple$1 = [(c >> 0), 1, null], ch = _tuple$1[0], size = _tuple$1[1], err = _tuple$1[2];
			return [ch, size, err];
		}
		_tuple$2 = utf8.DecodeRune(go$subslice(r.s, r.i)), ch = _tuple$2[0], size = _tuple$2[1];
		r.i = r.i + (size) >> 0;
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	Reader.Ptr.prototype.UnreadRune = function() {
		var r;
		r = this;
		if (r.prevRune < 0) {
			return errors.New("bytes.Reader: previous operation was not ReadRune");
		}
		r.i = r.prevRune;
		r.prevRune = -1;
		return null;
	};
	Reader.prototype.UnreadRune = function() { return this.go$val.UnreadRune(); };
	Reader.Ptr.prototype.Seek = function(offset, whence) {
		var r, abs, _ref, x, x$1;
		r = this;
		abs = new Go$Int64(0, 0);
		_ref = whence;
		if (_ref === 0) {
			abs = offset;
		} else if (_ref === 1) {
			abs = (x = new Go$Int64(0, r.i), new Go$Int64(x.high + offset.high, x.low + offset.low));
		} else if (_ref === 2) {
			abs = (x$1 = new Go$Int64(0, r.s.length), new Go$Int64(x$1.high + offset.high, x$1.low + offset.low));
		} else {
			return [new Go$Int64(0, 0), errors.New("bytes: invalid whence")];
		}
		if ((abs.high < 0 || (abs.high === 0 && abs.low < 0))) {
			return [new Go$Int64(0, 0), errors.New("bytes: negative position")];
		}
		if ((abs.high > 0 || (abs.high === 0 && abs.low >= 2147483648))) {
			return [new Go$Int64(0, 0), errors.New("bytes: position out of range")];
		}
		r.i = ((abs.low + ((abs.high >> 31) * 4294967296)) >> 0);
		return [abs, null];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.go$val.Seek(offset, whence); };
	Reader.Ptr.prototype.WriteTo = function(w) {
		var n, err, r, _tuple, b, _tuple$1, m;
		n = new Go$Int64(0, 0);
		err = null;
		r = this;
		r.prevRune = -1;
		if (r.i >= r.s.length) {
			_tuple = [new Go$Int64(0, 0), null], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		b = go$subslice(r.s, r.i);
		_tuple$1 = w.Write(b), m = _tuple$1[0], err = _tuple$1[1];
		if (m > b.length) {
			throw go$panic(new Go$String("bytes.Reader.WriteTo: invalid Write count"));
		}
		r.i = r.i + (m) >> 0;
		n = new Go$Int64(0, m);
		if (!((m === b.length)) && go$interfaceIsEqual(err, null)) {
			err = io.ErrShortWrite;
		}
		return [n, err];
	};
	Reader.prototype.WriteTo = function(w) { return this.go$val.WriteTo(w); };
	var NewReader = go$pkg.NewReader = function(b) {
		return new Reader.Ptr(b, 0, -1);
	};
	go$pkg.init = function() {
		go$pkg.ErrTooLarge = errors.New("bytes.Buffer: too large");
	};
	return go$pkg;
})();
go$packages["encoding"] = (function() {
	var go$pkg = {};
	var BinaryMarshaler;
	BinaryMarshaler = go$newType(0, "Interface", "encoding.BinaryMarshaler", "BinaryMarshaler", "encoding", null);
	go$pkg.BinaryMarshaler = BinaryMarshaler;
	var BinaryUnmarshaler;
	BinaryUnmarshaler = go$newType(0, "Interface", "encoding.BinaryUnmarshaler", "BinaryUnmarshaler", "encoding", null);
	go$pkg.BinaryUnmarshaler = BinaryUnmarshaler;
	var TextMarshaler;
	TextMarshaler = go$newType(0, "Interface", "encoding.TextMarshaler", "TextMarshaler", "encoding", null);
	go$pkg.TextMarshaler = TextMarshaler;
	var TextUnmarshaler;
	TextUnmarshaler = go$newType(0, "Interface", "encoding.TextUnmarshaler", "TextUnmarshaler", "encoding", null);
	go$pkg.TextUnmarshaler = TextUnmarshaler;
	BinaryMarshaler.init([["MarshalBinary", "", (go$funcType([], [(go$sliceType(Go$Uint8)), go$error], false))]]);
	BinaryUnmarshaler.init([["UnmarshalBinary", "", (go$funcType([(go$sliceType(Go$Uint8))], [go$error], false))]]);
	TextMarshaler.init([["MarshalText", "", (go$funcType([], [(go$sliceType(Go$Uint8)), go$error], false))]]);
	TextUnmarshaler.init([["UnmarshalText", "", (go$funcType([(go$sliceType(Go$Uint8))], [go$error], false))]]);
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["math"] = (function() {
	var go$pkg = {};
	var _gamP, _gamQ, _gamS, p0R8, p0S8, p0R5, p0S5, p0R3, p0S3, p0R2, p0S2, q0R8, q0S8, q0R5, q0S5, q0R3, q0S3, q0R2, q0S2, p1R8, p1S8, p1R5, p1S5, p1R3, p1S3, p1R2, p1S2, q1R8, q1S8, q1R5, q1S5, q1R3, q1S3, q1R2, q1S2, _lgamA, _lgamR, _lgamS, _lgamT, _lgamU, _lgamV, _lgamW, pow10tab, _sin, _cos, _tanP, _tanQ, tanhP, tanhQ;
	var Abs = go$pkg.Abs = Math.abs;
	var abs = function(x) {
		if (x < 0) {
			return -x;
		} else if (x === 0) {
			return 0;
		}
		return x;
	};
	var Acosh = go$pkg.Acosh = function(x) {
		var t;
		if (x < 1 || IsNaN(x)) {
			return NaN();
		} else if (x === 1) {
			return 0;
		} else if (x >= 2.68435456e+08) {
			return Log(x) + 0.6931471805599453;
		} else if (x > 2) {
			return Log(2 * x - 1 / (x + Sqrt(x * x - 1)));
		}
		t = x - 1;
		return Log1p(t + Sqrt(2 * t + t * t));
	};
	var Asin = go$pkg.Asin = Math.asin;
	var asin = function(x) {
		var sign, temp;
		if (x === 0) {
			return x;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		if (x > 1) {
			return NaN();
		}
		temp = Sqrt(1 - x * x);
		if (x > 0.7) {
			temp = 1.5707963267948966 - satan(temp / x);
		} else {
			temp = satan(x / temp);
		}
		if (sign) {
			temp = -temp;
		}
		return temp;
	};
	var Acos = go$pkg.Acos = Math.acos;
	var acos = function(x) {
		return 1.5707963267948966 - Asin(x);
	};
	var Asinh = go$pkg.Asinh = function(x) {
		var sign, temp;
		if (IsNaN(x) || IsInf(x, 0)) {
			return x;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		temp = 0;
		if (x > 2.68435456e+08) {
			temp = Log(x) + 0.6931471805599453;
		} else if (x > 2) {
			temp = Log(2 * x + 1 / (Sqrt(x * x + 1) + x));
		} else if (x < 3.725290298461914e-09) {
			temp = x;
		} else {
			temp = Log1p(x + x * x / (1 + Sqrt(1 + x * x)));
		}
		if (sign) {
			temp = -temp;
		}
		return temp;
	};
	var xatan = function(x) {
		var z;
		z = x * x;
		z = z * ((((-0.8750608600031904 * z + -16.157537187333652) * z + -75.00855792314705) * z + -122.88666844901361) * z + -64.85021904942025) / (((((z + 24.858464901423062) * z + 165.02700983169885) * z + 432.88106049129027) * z + 485.3903996359137) * z + 194.5506571482614);
		z = x * z + x;
		return z;
	};
	var satan = function(x) {
		if (x <= 0.66) {
			return xatan(x);
		}
		if (x > 2.414213562373095) {
			return 1.5707963267948966 - xatan(1 / x) + 6.123233995736766e-17;
		}
		return 0.7853981633974483 + xatan((x - 1) / (x + 1)) + 3.061616997868383e-17;
	};
	var Atan = go$pkg.Atan = Math.atan;
	var atan = function(x) {
		if (x === 0) {
			return x;
		}
		if (x > 0) {
			return satan(x);
		}
		return -satan(-x);
	};
	var Atan2 = go$pkg.Atan2 = Math.atan2;
	var atan2 = function(y, x) {
		var q;
		if (IsNaN(y) || IsNaN(x)) {
			return NaN();
		} else if (y === 0) {
			if (x >= 0 && !Signbit(x)) {
				return Copysign(0, y);
			}
			return Copysign(3.141592653589793, y);
		} else if (x === 0) {
			return Copysign(1.5707963267948966, y);
		} else if (IsInf(x, 0)) {
			if (IsInf(x, 1)) {
				if (IsInf(y, 0)) {
					return Copysign(0.7853981633974483, y);
				} else {
					return Copysign(0, y);
				}
			}
			if (IsInf(y, 0)) {
				return Copysign(2.356194490192345, y);
			} else {
				return Copysign(3.141592653589793, y);
			}
		} else if (IsInf(y, 0)) {
			return Copysign(1.5707963267948966, y);
		}
		q = Atan(y / x);
		if (x < 0) {
			if (q <= 0) {
				return q + 3.141592653589793;
			}
			return q - 3.141592653589793;
		}
		return q;
	};
	var Atanh = go$pkg.Atanh = function(x) {
		var sign, temp;
		if (x < -1 || x > 1 || IsNaN(x)) {
			return NaN();
		} else if (x === 1) {
			return Inf(1);
		} else if (x === -1) {
			return Inf(-1);
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		temp = 0;
		if (x < 3.725290298461914e-09) {
			temp = x;
		} else if (x < 0.5) {
			temp = x + x;
			temp = 0.5 * Log1p(temp + temp * x / (1 - x));
		} else {
			temp = 0.5 * Log1p((x + x) / (1 - x));
		}
		if (sign) {
			temp = -temp;
		}
		return temp;
	};
	var Inf = go$pkg.Inf = function(sign) { return sign >= 0 ? 1/0 : -1/0; };
	var NaN = go$pkg.NaN = function() { return 0/0; };
	var IsNaN = go$pkg.IsNaN = function(f) { return f !== f; };
	var IsInf = go$pkg.IsInf = function(f, sign) { if (f === -1/0) { return sign <= 0; } if (f === 1/0) { return sign >= 0; } return false; };
	var normalize = function(x) {
		var y, exp$1, _tuple, _tuple$1;
		y = 0;
		exp$1 = 0;
		if (Abs(x) < 2.2250738585072014e-308) {
			_tuple = [x * 4.503599627370496e+15, -52], y = _tuple[0], exp$1 = _tuple[1];
			return [y, exp$1];
		}
		_tuple$1 = [x, 0], y = _tuple$1[0], exp$1 = _tuple$1[1];
		return [y, exp$1];
	};
	var Cbrt = go$pkg.Cbrt = function(x) {
		var sign, _tuple, f, e, _r, m, _ref, _q, y, s, t;
		if ((x === 0) || IsNaN(x) || IsInf(x, 0)) {
			return x;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		_tuple = Frexp(x), f = _tuple[0], e = _tuple[1];
		m = (_r = e % 3, _r === _r ? _r : go$throwRuntimeError("integer divide by zero"));
		if (m > 0) {
			m = m - 3 >> 0;
			e = e - (m) >> 0;
		}
		_ref = m;
		if (_ref === 0) {
			f = 0.1662848358 * f + 1.096040958 - 0.4105032829 / (0.5649335816 + f);
		} else if (_ref === -1) {
			f = f * 0.5;
			f = 0.2639607233 * f + 0.8699282849 - 0.1629083358 / (0.2824667908 + f);
		} else {
			f = f * 0.25;
			f = 0.4190115298 * f + 0.6904625373 - 0.0646502159 / (0.1412333954 + f);
		}
		y = Ldexp(f, (_q = e / 3, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")));
		s = y * y * y;
		t = s + x;
		y = y * ((t + x) / (s + t));
		s = (y * y * y - x) / x;
		y = y - (y * ((0.1728395061728395 * s - 0.2222222222222222) * s + 0.3333333333333333) * s);
		if (sign) {
			y = -y;
		}
		return y;
	};
	var Copysign = go$pkg.Copysign = function(x, y) { return (x < 0 || 1/x === 1/-0) !== (y < 0 || 1/y === 1/-0) ? -x : x; };
	var Dim = go$pkg.Dim = function(x, y) { return Math.max(x - y, 0); };
	var dim = function(x, y) {
		return max(x - y, 0);
	};
	var Max = go$pkg.Max = function(x, y) { return (x === 1/0 || y === 1/0) ? 1/0 : Math.max(x, y); };
	var max = function(x, y) {
		if (IsInf(x, 1) || IsInf(y, 1)) {
			return Inf(1);
		} else if (IsNaN(x) || IsNaN(y)) {
			return NaN();
		} else if ((x === 0) && (x === y)) {
			if (Signbit(x)) {
				return y;
			}
			return x;
		}
		if (x > y) {
			return x;
		}
		return y;
	};
	var Min = go$pkg.Min = function(x, y) { return (x === -1/0 || y === -1/0) ? -1/0 : Math.min(x, y); };
	var min = function(x, y) {
		if (IsInf(x, -1) || IsInf(y, -1)) {
			return Inf(-1);
		} else if (IsNaN(x) || IsNaN(y)) {
			return NaN();
		} else if ((x === 0) && (x === y)) {
			if (Signbit(x)) {
				return x;
			}
			return y;
		}
		if (x < y) {
			return x;
		}
		return y;
	};
	var Erf = go$pkg.Erf = function(x) {
		var sign, temp, z, r, s, y, s$1, P, Q, s$2, _tuple, R, S, x$1, z$1, r$1;
		if (IsNaN(x)) {
			return NaN();
		} else if (IsInf(x, 1)) {
			return 1;
		} else if (IsInf(x, -1)) {
			return -1;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		if (x < 0.84375) {
			temp = 0;
			if (x < 3.725290298461914e-09) {
				if (x < 2.848094538889218e-306) {
					temp = 0.125 * (8 * x + 1.0270333367641007 * x);
				} else {
					temp = x + 0.1283791670955126 * x;
				}
			} else {
				z = x * x;
				r = 0.12837916709551256 + z * (-0.3250421072470015 + z * (-0.02848174957559851 + z * (-0.005770270296489442 + z * -2.3763016656650163e-05)));
				s = 1 + z * (0.39791722395915535 + z * (0.0650222499887673 + z * (0.005081306281875766 + z * (0.00013249473800432164 + z * -3.960228278775368e-06))));
				y = r / s;
				temp = x + x * y;
			}
			if (sign) {
				return -temp;
			}
			return temp;
		}
		if (x < 1.25) {
			s$1 = x - 1;
			P = -0.0023621185607526594 + s$1 * (0.41485611868374833 + s$1 * (-0.3722078760357013 + s$1 * (0.31834661990116175 + s$1 * (-0.11089469428239668 + s$1 * (0.035478304325618236 + s$1 * -0.002166375594868791)))));
			Q = 1 + s$1 * (0.10642088040084423 + s$1 * (0.540397917702171 + s$1 * (0.07182865441419627 + s$1 * (0.12617121980876164 + s$1 * (0.01363708391202905 + s$1 * 0.011984499846799107)))));
			if (sign) {
				return -0.8450629115104675 - P / Q;
			}
			return 0.8450629115104675 + P / Q;
		}
		if (x >= 6) {
			if (sign) {
				return -1;
			}
			return 1;
		}
		s$2 = 1 / (x * x);
		_tuple = [0, 0], R = _tuple[0], S = _tuple[1];
		if (x < 2.857142857142857) {
			R = -0.009864944034847148 + s$2 * (-0.6938585727071818 + s$2 * (-10.558626225323291 + s$2 * (-62.375332450326006 + s$2 * (-162.39666946257347 + s$2 * (-184.60509290671104 + s$2 * (-81.2874355063066 + s$2 * -9.814329344169145))))));
			S = 1 + s$2 * (19.651271667439257 + s$2 * (137.65775414351904 + s$2 * (434.56587747522923 + s$2 * (645.3872717332679 + s$2 * (429.00814002756783 + s$2 * (108.63500554177944 + s$2 * (6.570249770319282 + s$2 * -0.0604244152148581)))))));
		} else {
			R = -0.0098649429247001 + s$2 * (-0.799283237680523 + s$2 * (-17.757954917754752 + s$2 * (-160.63638485582192 + s$2 * (-637.5664433683896 + s$2 * (-1025.0951316110772 + s$2 * -483.5191916086514)))));
			S = 1 + s$2 * (30.33806074348246 + s$2 * (325.7925129965739 + s$2 * (1536.729586084437 + s$2 * (3199.8582195085955 + s$2 * (2553.0504064331644 + s$2 * (474.52854120695537 + s$2 * -22.44095244658582))))));
		}
		z$1 = Float64frombits((x$1 = Float64bits(x), new Go$Uint64(x$1.high & 4294967295, (x$1.low & 0) >>> 0)));
		r$1 = Exp(-z$1 * z$1 - 0.5625) * Exp((z$1 - x) * (z$1 + x) + R / S);
		if (sign) {
			return r$1 / x - 1;
		}
		return 1 - r$1 / x;
	};
	var Erfc = go$pkg.Erfc = function(x) {
		var sign, temp, z, r, s, y, s$1, P, Q, s$2, _tuple, R, S, x$1, z$1, r$1;
		if (IsNaN(x)) {
			return NaN();
		} else if (IsInf(x, 1)) {
			return 0;
		} else if (IsInf(x, -1)) {
			return 2;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		if (x < 0.84375) {
			temp = 0;
			if (x < 1.3877787807814457e-17) {
				temp = x;
			} else {
				z = x * x;
				r = 0.12837916709551256 + z * (-0.3250421072470015 + z * (-0.02848174957559851 + z * (-0.005770270296489442 + z * -2.3763016656650163e-05)));
				s = 1 + z * (0.39791722395915535 + z * (0.0650222499887673 + z * (0.005081306281875766 + z * (0.00013249473800432164 + z * -3.960228278775368e-06))));
				y = r / s;
				if (x < 0.25) {
					temp = x + x * y;
				} else {
					temp = 0.5 + (x * y + (x - 0.5));
				}
			}
			if (sign) {
				return 1 + temp;
			}
			return 1 - temp;
		}
		if (x < 1.25) {
			s$1 = x - 1;
			P = -0.0023621185607526594 + s$1 * (0.41485611868374833 + s$1 * (-0.3722078760357013 + s$1 * (0.31834661990116175 + s$1 * (-0.11089469428239668 + s$1 * (0.035478304325618236 + s$1 * -0.002166375594868791)))));
			Q = 1 + s$1 * (0.10642088040084423 + s$1 * (0.540397917702171 + s$1 * (0.07182865441419627 + s$1 * (0.12617121980876164 + s$1 * (0.01363708391202905 + s$1 * 0.011984499846799107)))));
			if (sign) {
				return 1.8450629115104675 + P / Q;
			}
			return 0.15493708848953247 - P / Q;
		}
		if (x < 28) {
			s$2 = 1 / (x * x);
			_tuple = [0, 0], R = _tuple[0], S = _tuple[1];
			if (x < 2.857142857142857) {
				R = -0.009864944034847148 + s$2 * (-0.6938585727071818 + s$2 * (-10.558626225323291 + s$2 * (-62.375332450326006 + s$2 * (-162.39666946257347 + s$2 * (-184.60509290671104 + s$2 * (-81.2874355063066 + s$2 * -9.814329344169145))))));
				S = 1 + s$2 * (19.651271667439257 + s$2 * (137.65775414351904 + s$2 * (434.56587747522923 + s$2 * (645.3872717332679 + s$2 * (429.00814002756783 + s$2 * (108.63500554177944 + s$2 * (6.570249770319282 + s$2 * -0.0604244152148581)))))));
			} else {
				if (sign && x > 6) {
					return 2;
				}
				R = -0.0098649429247001 + s$2 * (-0.799283237680523 + s$2 * (-17.757954917754752 + s$2 * (-160.63638485582192 + s$2 * (-637.5664433683896 + s$2 * (-1025.0951316110772 + s$2 * -483.5191916086514)))));
				S = 1 + s$2 * (30.33806074348246 + s$2 * (325.7925129965739 + s$2 * (1536.729586084437 + s$2 * (3199.8582195085955 + s$2 * (2553.0504064331644 + s$2 * (474.52854120695537 + s$2 * -22.44095244658582))))));
			}
			z$1 = Float64frombits((x$1 = Float64bits(x), new Go$Uint64(x$1.high & 4294967295, (x$1.low & 0) >>> 0)));
			r$1 = Exp(-z$1 * z$1 - 0.5625) * Exp((z$1 - x) * (z$1 + x) + R / S);
			if (sign) {
				return 2 - r$1 / x;
			}
			return r$1 / x;
		}
		if (sign) {
			return 2;
		}
		return 0;
	};
	var Exp = go$pkg.Exp = Math.exp;
	var exp = function(x) {
		var k, hi, lo;
		if (IsNaN(x) || IsInf(x, 1)) {
			return x;
		} else if (IsInf(x, -1)) {
			return 0;
		} else if (x > 709.782712893384) {
			return Inf(1);
		} else if (x < -745.1332191019411) {
			return 0;
		} else if (-3.725290298461914e-09 < x && x < 3.725290298461914e-09) {
			return 1 + x;
		}
		k = 0;
		if (x < 0) {
			k = (1.4426950408889634 * x - 0.5 >> 0);
		} else if (x > 0) {
			k = (1.4426950408889634 * x + 0.5 >> 0);
		}
		hi = x - k * 0.6931471803691238;
		lo = k * 1.9082149292705877e-10;
		return expmulti(hi, lo, k);
	};
	var Exp2 = go$pkg.Exp2 = function(x) { return Math.pow(2, x); };
	var exp2 = function(x) {
		var k, t, hi, lo;
		if (IsNaN(x) || IsInf(x, 1)) {
			return x;
		} else if (IsInf(x, -1)) {
			return 0;
		} else if (x > 1023.9999999999999) {
			return Inf(1);
		} else if (x < -1074) {
			return 0;
		}
		k = 0;
		if (x > 0) {
			k = (x + 0.5 >> 0);
		} else if (x < 0) {
			k = (x - 0.5 >> 0);
		}
		t = x - k;
		hi = t * 0.6931471803691238;
		lo = -t * 1.9082149292705877e-10;
		return expmulti(hi, lo, k);
	};
	var expmulti = function(hi, lo, k) {
		var r, t, c, y;
		r = hi - lo;
		t = r * r;
		c = r - t * (0.16666666666666602 + t * (-0.0027777777777015593 + t * (6.613756321437934e-05 + t * (-1.6533902205465252e-06 + t * 4.1381367970572385e-08))));
		y = 1 - ((lo - (r * c) / (2 - c)) - hi);
		return Ldexp(y, k);
	};
	var Expm1 = go$pkg.Expm1 = function(x) { return expm1(x); };
	var expm1 = function(x) {
		var absx, sign, c, k, _tuple, hi, lo, t, hfx, hxs, r1, t$1, e, y, x$1, x$2, x$3, t$2, y$1, x$4, x$5, t$3, y$2, x$6, x$7;
		if (IsInf(x, 1) || IsNaN(x)) {
			return x;
		} else if (IsInf(x, -1)) {
			return -1;
		}
		absx = x;
		sign = false;
		if (x < 0) {
			absx = -absx;
			sign = true;
		}
		if (absx >= 38.816242111356935) {
			if (absx >= 709.782712893384) {
				return Inf(1);
			}
			if (sign) {
				return -1;
			}
		}
		c = 0;
		k = 0;
		if (absx > 0.34657359027997264) {
			_tuple = [0, 0], hi = _tuple[0], lo = _tuple[1];
			if (absx < 1.0397207708399179) {
				if (!sign) {
					hi = x - 0.6931471803691238;
					lo = 1.9082149292705877e-10;
					k = 1;
				} else {
					hi = x + 0.6931471803691238;
					lo = -1.9082149292705877e-10;
					k = -1;
				}
			} else {
				if (!sign) {
					k = (1.4426950408889634 * x + 0.5 >> 0);
				} else {
					k = (1.4426950408889634 * x - 0.5 >> 0);
				}
				t = k;
				hi = x - t * 0.6931471803691238;
				lo = t * 1.9082149292705877e-10;
			}
			x = hi - lo;
			c = (hi - x) - lo;
		} else if (absx < 5.551115123125783e-17) {
			return x;
		} else {
			k = 0;
		}
		hfx = 0.5 * x;
		hxs = x * hfx;
		r1 = 1 + hxs * (-0.03333333333333313 + hxs * (0.0015873015872548146 + hxs * (-7.93650757867488e-05 + hxs * (4.008217827329362e-06 + hxs * -2.0109921818362437e-07))));
		t$1 = 3 - r1 * hfx;
		e = hxs * ((r1 - t$1) / (6 - x * t$1));
		if (!((k === 0))) {
			e = x * (e - c) - c;
			e = e - (hxs);
			if (k === -1) {
				return 0.5 * (x - e) - 0.5;
			} else if (k === 1) {
				if (x < -0.25) {
					return -2 * (e - (x + 0.5));
				}
				return 1 + 2 * (x - e);
			} else if (k <= -2 || k > 56) {
				y = 1 - (e - x);
				y = Float64frombits((x$1 = Float64bits(y), x$2 = go$shiftLeft64(new Go$Uint64(0, k), 52), new Go$Uint64(x$1.high + x$2.high, x$1.low + x$2.low)));
				return y - 1;
			}
			if (k < 20) {
				t$2 = Float64frombits((x$3 = go$shiftRightUint64(new Go$Uint64(2097152, 0), (k >>> 0)), new Go$Uint64(1072693248 - x$3.high, 0 - x$3.low)));
				y$1 = t$2 - (e - x);
				y$1 = Float64frombits((x$4 = Float64bits(y$1), x$5 = go$shiftLeft64(new Go$Uint64(0, k), 52), new Go$Uint64(x$4.high + x$5.high, x$4.low + x$5.low)));
				return y$1;
			}
			t$3 = Float64frombits(new Go$Uint64(0, (((1023 - k >> 0)) << 52 >> 0)));
			y$2 = x - (e + t$3);
			y$2 = y$2 + 1;
			y$2 = Float64frombits((x$6 = Float64bits(y$2), x$7 = go$shiftLeft64(new Go$Uint64(0, k), 52), new Go$Uint64(x$6.high + x$7.high, x$6.low + x$7.low)));
			return y$2;
		}
		return x - (x * e - hxs);
	};
	var Floor = go$pkg.Floor = Math.floor;
	var floor = function(x) {
		var _tuple, d, fract, _tuple$1, d$1;
		if ((x === 0) || IsNaN(x) || IsInf(x, 0)) {
			return x;
		}
		if (x < 0) {
			_tuple = Modf(-x), d = _tuple[0], fract = _tuple[1];
			if (!((fract === 0))) {
				d = d + 1;
			}
			return -d;
		}
		_tuple$1 = Modf(x), d$1 = _tuple$1[0];
		return d$1;
	};
	var Ceil = go$pkg.Ceil = Math.ceil;
	var ceil = function(x) {
		return -Floor(-x);
	};
	var Trunc = go$pkg.Trunc = function(x) { return (x === 1/0 || x === -1/0 || x !== x || 1/x === 1/-0) ? x : x >> 0; };
	var trunc = function(x) {
		var _tuple, d;
		if ((x === 0) || IsNaN(x) || IsInf(x, 0)) {
			return x;
		}
		_tuple = Modf(x), d = _tuple[0];
		return d;
	};
	var Frexp = go$pkg.Frexp = function(f) { return frexp(f); };
	var frexp = function(f) {
		var frac, exp$1, _tuple, _tuple$1, _tuple$2, x, x$1;
		frac = 0;
		exp$1 = 0;
		if (f === 0) {
			_tuple = [f, 0], frac = _tuple[0], exp$1 = _tuple[1];
			return [frac, exp$1];
		} else if (IsInf(f, 0) || IsNaN(f)) {
			_tuple$1 = [f, 0], frac = _tuple$1[0], exp$1 = _tuple$1[1];
			return [frac, exp$1];
		}
		_tuple$2 = normalize(f), f = _tuple$2[0], exp$1 = _tuple$2[1];
		x = Float64bits(f);
		exp$1 = exp$1 + (((((x$1 = go$shiftRightUint64(x, 52), new Go$Uint64(x$1.high & 0, (x$1.low & 2047) >>> 0)).low >> 0) - 1023 >> 0) + 1 >> 0)) >> 0;
		x = new Go$Uint64(x.high &~ 2146435072, (x.low &~ 0) >>> 0);
		x = new Go$Uint64(x.high | 1071644672, (x.low | 0) >>> 0);
		frac = Float64frombits(x);
		return [frac, exp$1];
	};
	var stirling = function(x) {
		var w, y, v;
		w = 1 / x;
		w = 1 + w * ((((_gamS[0] * w + _gamS[1]) * w + _gamS[2]) * w + _gamS[3]) * w + _gamS[4]);
		y = Exp(x);
		if (x > 143.01608) {
			v = Pow(x, 0.5 * x - 0.25);
			y = v * (v / y);
		} else {
			y = Pow(x, x - 0.5) / y;
		}
		y = 2.5066282746310007 * y * w;
		return y;
	};
	var Gamma = go$pkg.Gamma = function(x) {
		var q, p, signgam, ip, z, z$1;
		if (isNegInt(x) || IsInf(x, -1) || IsNaN(x)) {
			return NaN();
		} else if (x === 0) {
			if (Signbit(x)) {
				return Inf(-1);
			}
			return Inf(1);
		} else if (x < -170.5674972726612 || x > 171.61447887182297) {
			return Inf(1);
		}
		q = Abs(x);
		p = Floor(q);
		if (q > 33) {
			if (x >= 0) {
				return stirling(x);
			}
			signgam = 1;
			if (ip = (p >> 0), (ip & 1) === 0) {
				signgam = -1;
			}
			z = q - p;
			if (z > 0.5) {
				p = p + 1;
				z = q - p;
			}
			z = q * Sin(3.141592653589793 * z);
			if (z === 0) {
				return Inf(signgam);
			}
			z = 3.141592653589793 / (Abs(z) * stirling(q));
			return signgam * z;
		}
		z$1 = 1;
		while (x >= 3) {
			x = x - 1;
			z$1 = z$1 * x;
		}
		while (x < 0) {
			if (x > -1e-09) {
				go$notSupported("goto");
			}
			z$1 = z$1 / x;
			x = x + 1;
		}
		while (x < 2) {
			if (x < 1e-09) {
				go$notSupported("goto");
			}
			z$1 = z$1 / x;
			x = x + 1;
		}
		if (x === 2) {
			return z$1;
		}
		x = x - 2;
		p = (((((x * _gamP[0] + _gamP[1]) * x + _gamP[2]) * x + _gamP[3]) * x + _gamP[4]) * x + _gamP[5]) * x + _gamP[6];
		q = ((((((x * _gamQ[0] + _gamQ[1]) * x + _gamQ[2]) * x + _gamQ[3]) * x + _gamQ[4]) * x + _gamQ[5]) * x + _gamQ[6]) * x + _gamQ[7];
		return z$1 * p / q;
		small: switch (0) { default: if (x === 0) {
			return Inf(1);
		} }
		return z$1 / ((1 + 0.5772156649015329 * x) * x);
	};
	var isNegInt = function(x) {
		var _tuple, xf;
		if (x < 0) {
			_tuple = Modf(x), xf = _tuple[1];
			return xf === 0;
		}
		return false;
	};
	var Hypot = go$pkg.Hypot = function(p, q) { return hypot(p, q); };
	var hypot = function(p, q) {
		var _tuple;
		if (IsInf(p, 0) || IsInf(q, 0)) {
			return Inf(1);
		} else if (IsNaN(p) || IsNaN(q)) {
			return NaN();
		}
		if (p < 0) {
			p = -p;
		}
		if (q < 0) {
			q = -q;
		}
		if (p < q) {
			_tuple = [q, p], p = _tuple[0], q = _tuple[1];
		}
		if (p === 0) {
			return 0;
		}
		q = q / p;
		return p * Sqrt(1 + q * q);
	};
	var J0 = go$pkg.J0 = function(x) {
		var _tuple, s, c, ss, cc, z, z$1, u, v, z$2, r, s$1, u$1;
		if (IsNaN(x)) {
			return x;
		} else if (IsInf(x, 0)) {
			return 0;
		} else if (x === 0) {
			return 1;
		}
		if (x < 0) {
			x = -x;
		}
		if (x >= 2) {
			_tuple = Sincos(x), s = _tuple[0], c = _tuple[1];
			ss = s - c;
			cc = s + c;
			if (x < 8.988465674311579e+307) {
				z = -Cos(x + x);
				if (s * c < 0) {
					cc = z / ss;
				} else {
					ss = z / cc;
				}
			}
			z$1 = 0;
			if (x > 6.80564733841877e+38) {
				z$1 = 0.5641895835477563 * cc / Sqrt(x);
			} else {
				u = pzero(x);
				v = qzero(x);
				z$1 = 0.5641895835477563 * (u * cc - v * ss) / Sqrt(x);
			}
			return z$1;
		}
		if (x < 0.0001220703125) {
			if (x < 7.450580596923828e-09) {
				return 1;
			}
			return 1 - 0.25 * x * x;
		}
		z$2 = x * x;
		r = z$2 * (0.015624999999999995 + z$2 * (-0.00018997929423885472 + z$2 * (1.8295404953270067e-06 + z$2 * -4.618326885321032e-09)));
		s$1 = 1 + z$2 * (0.015619102946489001 + z$2 * (0.00011692678466333745 + z$2 * (5.135465502073181e-07 + z$2 * 1.1661400333379e-09)));
		if (x < 1) {
			return 1 + z$2 * (-0.25 + (r / s$1));
		}
		u$1 = 0.5 * x;
		return (1 + u$1) * (1 - u$1) + z$2 * (r / s$1);
	};
	var Y0 = go$pkg.Y0 = function(x) {
		var _tuple, s, c, ss, cc, z, z$1, u, v, z$2, u$1, v$1;
		if (x < 0 || IsNaN(x)) {
			return NaN();
		} else if (IsInf(x, 1)) {
			return 0;
		} else if (x === 0) {
			return Inf(-1);
		}
		if (x >= 2) {
			_tuple = Sincos(x), s = _tuple[0], c = _tuple[1];
			ss = s - c;
			cc = s + c;
			if (x < 8.988465674311579e+307) {
				z = -Cos(x + x);
				if (s * c < 0) {
					cc = z / ss;
				} else {
					ss = z / cc;
				}
			}
			z$1 = 0;
			if (x > 6.80564733841877e+38) {
				z$1 = 0.5641895835477563 * ss / Sqrt(x);
			} else {
				u = pzero(x);
				v = qzero(x);
				z$1 = 0.5641895835477563 * (u * ss + v * cc) / Sqrt(x);
			}
			return z$1;
		}
		if (x <= 7.450580596923828e-09) {
			return -0.07380429510868723 + 0.6366197723675814 * Log(x);
		}
		z$2 = x * x;
		u$1 = -0.07380429510868723 + z$2 * (0.17666645250918112 + z$2 * (-0.01381856719455969 + z$2 * (0.00034745343209368365 + z$2 * (-3.8140705372436416e-06 + z$2 * (1.9559013703502292e-08 + z$2 * -3.982051941321034e-11)))));
		v$1 = 1 + z$2 * (0.01273048348341237 + z$2 * (7.600686273503533e-05 + z$2 * (2.591508518404578e-07 + z$2 * 4.4111031133267547e-10)));
		return u$1 / v$1 + 0.6366197723675814 * J0(x) * Log(x);
	};
	var pzero = function(x) {
		var p, q, z, r, s;
		p = go$makeNativeArray("Float64", 6, function() { return 0; });
		q = go$makeNativeArray("Float64", 5, function() { return 0; });
		if (x >= 8) {
			p = go$mapArray(p0R8, function(entry) { return entry; });
			q = go$mapArray(p0S8, function(entry) { return entry; });
		} else if (x >= 4.5454) {
			p = go$mapArray(p0R5, function(entry) { return entry; });
			q = go$mapArray(p0S5, function(entry) { return entry; });
		} else if (x >= 2.8571) {
			p = go$mapArray(p0R3, function(entry) { return entry; });
			q = go$mapArray(p0S3, function(entry) { return entry; });
		} else if (x >= 2) {
			p = go$mapArray(p0R2, function(entry) { return entry; });
			q = go$mapArray(p0S2, function(entry) { return entry; });
		}
		z = 1 / (x * x);
		r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
		s = 1 + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
		return 1 + r / s;
	};
	var qzero = function(x) {
		var _tuple, p, q, z, r, s;
		_tuple = [go$makeNativeArray("Float64", 6, function() { return 0; }), go$makeNativeArray("Float64", 6, function() { return 0; })], p = _tuple[0], q = _tuple[1];
		if (x >= 8) {
			p = go$mapArray(q0R8, function(entry) { return entry; });
			q = go$mapArray(q0S8, function(entry) { return entry; });
		} else if (x >= 4.5454) {
			p = go$mapArray(q0R5, function(entry) { return entry; });
			q = go$mapArray(q0S5, function(entry) { return entry; });
		} else if (x >= 2.8571) {
			p = go$mapArray(q0R3, function(entry) { return entry; });
			q = go$mapArray(q0S3, function(entry) { return entry; });
		} else if (x >= 2) {
			p = go$mapArray(q0R2, function(entry) { return entry; });
			q = go$mapArray(q0S2, function(entry) { return entry; });
		}
		z = 1 / (x * x);
		r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
		s = 1 + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
		return (-0.125 + r / s) / x;
	};
	var J1 = go$pkg.J1 = function(x) {
		var sign, _tuple, s, c, ss, cc, z, z$1, u, v, z$2, r, s$1;
		if (IsNaN(x)) {
			return x;
		} else if (IsInf(x, 0) || (x === 0)) {
			return 0;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		if (x >= 2) {
			_tuple = Sincos(x), s = _tuple[0], c = _tuple[1];
			ss = -s - c;
			cc = s - c;
			if (x < 8.988465674311579e+307) {
				z = Cos(x + x);
				if (s * c > 0) {
					cc = z / ss;
				} else {
					ss = z / cc;
				}
			}
			z$1 = 0;
			if (x > 6.80564733841877e+38) {
				z$1 = 0.5641895835477563 * cc / Sqrt(x);
			} else {
				u = pone(x);
				v = qone(x);
				z$1 = 0.5641895835477563 * (u * cc - v * ss) / Sqrt(x);
			}
			if (sign) {
				return -z$1;
			}
			return z$1;
		}
		if (x < 7.450580596923828e-09) {
			return 0.5 * x;
		}
		z$2 = x * x;
		r = z$2 * (-0.0625 + z$2 * (0.001407056669551897 + z$2 * (-1.599556310840356e-05 + z$2 * 4.9672799960958445e-08)));
		s$1 = 1 + z$2 * (0.019153759953836346 + z$2 * (0.00018594678558863092 + z$2 * (1.1771846404262368e-06 + z$2 * (5.0463625707621704e-09 + z$2 * 1.2354227442613791e-11))));
		r = r * (x);
		z$2 = 0.5 * x + r / s$1;
		if (sign) {
			return -z$2;
		}
		return z$2;
	};
	var Y1 = go$pkg.Y1 = function(x) {
		var _tuple, s, c, ss, cc, z, z$1, u, v, z$2, u$1, v$1;
		if (x < 0 || IsNaN(x)) {
			return NaN();
		} else if (IsInf(x, 1)) {
			return 0;
		} else if (x === 0) {
			return Inf(-1);
		}
		if (x >= 2) {
			_tuple = Sincos(x), s = _tuple[0], c = _tuple[1];
			ss = -s - c;
			cc = s - c;
			if (x < 8.988465674311579e+307) {
				z = Cos(x + x);
				if (s * c > 0) {
					cc = z / ss;
				} else {
					ss = z / cc;
				}
			}
			z$1 = 0;
			if (x > 6.80564733841877e+38) {
				z$1 = 0.5641895835477563 * ss / Sqrt(x);
			} else {
				u = pone(x);
				v = qone(x);
				z$1 = 0.5641895835477563 * (u * ss + v * cc) / Sqrt(x);
			}
			return z$1;
		}
		if (x <= 5.551115123125783e-17) {
			return -0.6366197723675814 / x;
		}
		z$2 = x * x;
		u$1 = -0.19605709064623894 + z$2 * (0.05044387166398113 + z$2 * (-0.0019125689587576355 + z$2 * (2.352526005616105e-05 + z$2 * -9.190991580398789e-08)));
		v$1 = 1 + z$2 * (0.01991673182366499 + z$2 * (0.00020255258102513517 + z$2 * (1.3560880109751623e-06 + z$2 * (6.227414523646215e-09 + z$2 * 1.6655924620799208e-11))));
		return x * (u$1 / v$1) + 0.6366197723675814 * (J1(x) * Log(x) - 1 / x);
	};
	var pone = function(x) {
		var p, q, z, r, s;
		p = go$makeNativeArray("Float64", 6, function() { return 0; });
		q = go$makeNativeArray("Float64", 5, function() { return 0; });
		if (x >= 8) {
			p = go$mapArray(p1R8, function(entry) { return entry; });
			q = go$mapArray(p1S8, function(entry) { return entry; });
		} else if (x >= 4.5454) {
			p = go$mapArray(p1R5, function(entry) { return entry; });
			q = go$mapArray(p1S5, function(entry) { return entry; });
		} else if (x >= 2.8571) {
			p = go$mapArray(p1R3, function(entry) { return entry; });
			q = go$mapArray(p1S3, function(entry) { return entry; });
		} else if (x >= 2) {
			p = go$mapArray(p1R2, function(entry) { return entry; });
			q = go$mapArray(p1S2, function(entry) { return entry; });
		}
		z = 1 / (x * x);
		r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
		s = 1 + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
		return 1 + r / s;
	};
	var qone = function(x) {
		var _tuple, p, q, z, r, s;
		_tuple = [go$makeNativeArray("Float64", 6, function() { return 0; }), go$makeNativeArray("Float64", 6, function() { return 0; })], p = _tuple[0], q = _tuple[1];
		if (x >= 8) {
			p = go$mapArray(q1R8, function(entry) { return entry; });
			q = go$mapArray(q1S8, function(entry) { return entry; });
		} else if (x >= 4.5454) {
			p = go$mapArray(q1R5, function(entry) { return entry; });
			q = go$mapArray(q1S5, function(entry) { return entry; });
		} else if (x >= 2.8571) {
			p = go$mapArray(q1R3, function(entry) { return entry; });
			q = go$mapArray(q1S3, function(entry) { return entry; });
		} else if (x >= 2) {
			p = go$mapArray(q1R2, function(entry) { return entry; });
			q = go$mapArray(q1S2, function(entry) { return entry; });
		}
		z = 1 / (x * x);
		r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
		s = 1 + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
		return (0.375 + r / s) / x;
	};
	var Jn = go$pkg.Jn = function(n, x) {
		var _tuple, sign, b, temp, _ref, _tuple$1, i, a, _tuple$2, temp$1, a$1, i$1, w, h, q0, z, q1, k, _tuple$3, m, t, x$1, x$2, i$2, a$2, tmp, v, i$3, di, _tuple$4, i$4, di$1, _tuple$5;
		if (IsNaN(x)) {
			return x;
		} else if (IsInf(x, 0)) {
			return 0;
		}
		if (n === 0) {
			return J0(x);
		}
		if (x === 0) {
			return 0;
		}
		if (n < 0) {
			_tuple = [-n, -x], n = _tuple[0], x = _tuple[1];
		}
		if (n === 1) {
			return J1(x);
		}
		sign = false;
		if (x < 0) {
			x = -x;
			if ((n & 1) === 1) {
				sign = true;
			}
		}
		b = 0;
		if (n <= x) {
			if (x >= 8.148143905337944e+90) {
				temp = 0;
				_ref = n & 3;
				if (_ref === 0) {
					temp = Cos(x) + Sin(x);
				} else if (_ref === 1) {
					temp = -Cos(x) + Sin(x);
				} else if (_ref === 2) {
					temp = -Cos(x) - Sin(x);
				} else if (_ref === 3) {
					temp = Cos(x) - Sin(x);
				}
				b = 0.5641895835477563 * temp / Sqrt(x);
			} else {
				b = J1(x);
				_tuple$1 = [1, J0(x)], i = _tuple$1[0], a = _tuple$1[1];
				while (i < n) {
					_tuple$2 = [b, b * ((i + i >> 0) / x) - a], a = _tuple$2[0], b = _tuple$2[1];
					i = i + 1 >> 0;
				}
			}
		} else {
			if (x < 1.862645149230957e-09) {
				if (n > 33) {
					b = 0;
				} else {
					temp$1 = x * 0.5;
					b = temp$1;
					a$1 = 1;
					i$1 = 2;
					while (i$1 <= n) {
						a$1 = a$1 * (i$1);
						b = b * (temp$1);
						i$1 = i$1 + 1 >> 0;
					}
					b = b / (a$1);
				}
			} else {
				w = (n + n >> 0) / x;
				h = 2 / x;
				q0 = w;
				z = w + h;
				q1 = w * z - 1;
				k = 1;
				while (q1 < 1e+09) {
					k = k + 1 >> 0;
					z = z + (h);
					_tuple$3 = [q1, z * q1 - q0], q0 = _tuple$3[0], q1 = _tuple$3[1];
				}
				m = n + n >> 0;
				t = 0;
				i$2 = (x$1 = 2, x$2 = (n + k >> 0), (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0);
				while (i$2 >= m) {
					t = 1 / (i$2 / x - t);
					i$2 = i$2 - 2 >> 0;
				}
				a$2 = t;
				b = 1;
				tmp = n;
				v = 2 / x;
				tmp = tmp * Log(Abs(v * tmp));
				if (tmp < 709.782712893384) {
					i$3 = n - 1 >> 0;
					while (i$3 > 0) {
						di = (i$3 + i$3 >> 0);
						_tuple$4 = [b, b * di / x - a$2], a$2 = _tuple$4[0], b = _tuple$4[1];
						di = di - 2;
						i$3 = i$3 - 1 >> 0;
					}
				} else {
					i$4 = n - 1 >> 0;
					while (i$4 > 0) {
						di$1 = (i$4 + i$4 >> 0);
						_tuple$5 = [b, b * di$1 / x - a$2], a$2 = _tuple$5[0], b = _tuple$5[1];
						di$1 = di$1 - 2;
						if (b > 1e+100) {
							a$2 = a$2 / (b);
							t = t / (b);
							b = 1;
						}
						i$4 = i$4 - 1 >> 0;
					}
				}
				b = t * J0(x) / b;
			}
		}
		if (sign) {
			return -b;
		}
		return b;
	};
	var Yn = go$pkg.Yn = function(n, x) {
		var sign, b, temp, _ref, a, i, _tuple;
		if (x < 0 || IsNaN(x)) {
			return NaN();
		} else if (IsInf(x, 1)) {
			return 0;
		}
		if (n === 0) {
			return Y0(x);
		}
		if (x === 0) {
			if (n < 0 && ((n & 1) === 1)) {
				return Inf(1);
			}
			return Inf(-1);
		}
		sign = false;
		if (n < 0) {
			n = -n;
			if ((n & 1) === 1) {
				sign = true;
			}
		}
		if (n === 1) {
			if (sign) {
				return -Y1(x);
			}
			return Y1(x);
		}
		b = 0;
		if (x >= 8.148143905337944e+90) {
			temp = 0;
			_ref = n & 3;
			if (_ref === 0) {
				temp = Sin(x) - Cos(x);
			} else if (_ref === 1) {
				temp = -Sin(x) - Cos(x);
			} else if (_ref === 2) {
				temp = -Sin(x) + Cos(x);
			} else if (_ref === 3) {
				temp = Sin(x) + Cos(x);
			}
			b = 0.5641895835477563 * temp / Sqrt(x);
		} else {
			a = Y0(x);
			b = Y1(x);
			i = 1;
			while (i < n && !IsInf(b, -1)) {
				_tuple = [b, ((i + i >> 0) / x) * b - a], a = _tuple[0], b = _tuple[1];
				i = i + 1 >> 0;
			}
		}
		if (sign) {
			return -b;
		}
		return b;
	};
	var Ldexp = go$pkg.Ldexp = function(frac, exp) {
			if (frac === 0) { return frac; }
			if (exp >= 1024) { return frac * Math.pow(2, 1023) * Math.pow(2, exp - 1023); }
			if (exp <= -1024) { return frac * Math.pow(2, -1023) * Math.pow(2, exp + 1023); }
			return frac * Math.pow(2, exp);
		};
	var ldexp = function(frac, exp$1) {
		var _tuple, e, x, m, x$1;
		if (frac === 0) {
			return frac;
		} else if (IsInf(frac, 0) || IsNaN(frac)) {
			return frac;
		}
		_tuple = normalize(frac), frac = _tuple[0], e = _tuple[1];
		exp$1 = exp$1 + (e) >> 0;
		x = Float64bits(frac);
		exp$1 = exp$1 + ((((go$shiftRightUint64(x, 52).low >> 0) & 2047) - 1023 >> 0)) >> 0;
		if (exp$1 < -1074) {
			return Copysign(0, frac);
		}
		if (exp$1 > 1023) {
			if (frac < 0) {
				return Inf(-1);
			}
			return Inf(1);
		}
		m = 1;
		if (exp$1 < -1022) {
			exp$1 = exp$1 + 52 >> 0;
			m = 2.220446049250313e-16;
		}
		x = new Go$Uint64(x.high &~ 2146435072, (x.low &~ 0) >>> 0);
		x = (x$1 = go$shiftLeft64(new Go$Uint64(0, (exp$1 + 1023 >> 0)), 52), new Go$Uint64(x.high | x$1.high, (x.low | x$1.low) >>> 0));
		return m * Float64frombits(x);
	};
	var Lgamma = go$pkg.Lgamma = function(x) {
		var lgamma, sign, neg, nadj, t, y, i, _ref, z, p1, p2, p, z$1, w, p1$1, p2$1, p3, p$1, p1$2, p2$2, i$1, y$1, p$2, q, z$2, _ref$1, t$1, z$3, y$2, w$1;
		lgamma = 0;
		sign = 0;
		sign = 1;
		if (IsNaN(x)) {
			lgamma = x;
			return [lgamma, sign];
		} else if (IsInf(x, 0)) {
			lgamma = x;
			return [lgamma, sign];
		} else if (x === 0) {
			lgamma = Inf(1);
			return [lgamma, sign];
		}
		neg = false;
		if (x < 0) {
			x = -x;
			neg = true;
		}
		if (x < 8.470329472543003e-22) {
			if (neg) {
				sign = -1;
			}
			lgamma = -Log(x);
			return [lgamma, sign];
		}
		nadj = 0;
		if (neg) {
			if (x >= 4.503599627370496e+15) {
				lgamma = Inf(1);
				return [lgamma, sign];
			}
			t = sinPi(x);
			if (t === 0) {
				lgamma = Inf(1);
				return [lgamma, sign];
			}
			nadj = Log(3.141592653589793 / Abs(t * x));
			if (t < 0) {
				sign = -1;
			}
		}
		if ((x === 1) || (x === 2)) {
			lgamma = 0;
			return [lgamma, sign];
		} else if (x < 2) {
			y = 0;
			i = 0;
			if (x <= 0.9) {
				lgamma = -Log(x);
				if (x >= 0.7316321449683623) {
					y = 1 - x;
					i = 0;
				} else if (x >= 0.19163214496836226) {
					y = x - 0.46163214496836225;
					i = 1;
				} else {
					y = x;
					i = 2;
				}
			} else {
				lgamma = 0;
				if (x >= 1.7316321449683623) {
					y = 2 - x;
					i = 0;
				} else if (x >= 1.1916321449683622) {
					y = x - 1.4616321449683622;
					i = 1;
				} else {
					y = x - 1;
					i = 2;
				}
			}
			_ref = i;
			if (_ref === 0) {
				z = y * y;
				p1 = _lgamA[0] + z * (_lgamA[2] + z * (_lgamA[4] + z * (_lgamA[6] + z * (_lgamA[8] + z * _lgamA[10]))));
				p2 = z * (_lgamA[1] + z * (_lgamA[3] + z * (_lgamA[5] + z * (_lgamA[7] + z * (_lgamA[9] + z * _lgamA[11])))));
				p = y * p1 + p2;
				lgamma = lgamma + ((p - 0.5 * y));
			} else if (_ref === 1) {
				z$1 = y * y;
				w = z$1 * y;
				p1$1 = _lgamT[0] + w * (_lgamT[3] + w * (_lgamT[6] + w * (_lgamT[9] + w * _lgamT[12])));
				p2$1 = _lgamT[1] + w * (_lgamT[4] + w * (_lgamT[7] + w * (_lgamT[10] + w * _lgamT[13])));
				p3 = _lgamT[2] + w * (_lgamT[5] + w * (_lgamT[8] + w * (_lgamT[11] + w * _lgamT[14])));
				p$1 = z$1 * p1$1 - (-3.638676997039505e-18 - w * (p2$1 + y * p3));
				lgamma = lgamma + ((-0.12148629053584961 + p$1));
			} else if (_ref === 2) {
				p1$2 = y * (_lgamU[0] + y * (_lgamU[1] + y * (_lgamU[2] + y * (_lgamU[3] + y * (_lgamU[4] + y * _lgamU[5])))));
				p2$2 = 1 + y * (_lgamV[1] + y * (_lgamV[2] + y * (_lgamV[3] + y * (_lgamV[4] + y * _lgamV[5]))));
				lgamma = lgamma + ((-0.5 * y + p1$2 / p2$2));
			}
		} else if (x < 8) {
			i$1 = (x >> 0);
			y$1 = x - i$1;
			p$2 = y$1 * (_lgamS[0] + y$1 * (_lgamS[1] + y$1 * (_lgamS[2] + y$1 * (_lgamS[3] + y$1 * (_lgamS[4] + y$1 * (_lgamS[5] + y$1 * _lgamS[6]))))));
			q = 1 + y$1 * (_lgamR[1] + y$1 * (_lgamR[2] + y$1 * (_lgamR[3] + y$1 * (_lgamR[4] + y$1 * (_lgamR[5] + y$1 * _lgamR[6])))));
			lgamma = 0.5 * y$1 + p$2 / q;
			z$2 = 1;
			_ref$1 = i$1;
			if (_ref$1 === 7) {
				z$2 = z$2 * ((y$1 + 6));
				z$2 = z$2 * ((y$1 + 5));
				z$2 = z$2 * ((y$1 + 4));
				z$2 = z$2 * ((y$1 + 3));
				z$2 = z$2 * ((y$1 + 2));
				lgamma = lgamma + (Log(z$2));
			} else if (_ref$1 === 6) {
				z$2 = z$2 * ((y$1 + 5));
				z$2 = z$2 * ((y$1 + 4));
				z$2 = z$2 * ((y$1 + 3));
				z$2 = z$2 * ((y$1 + 2));
				lgamma = lgamma + (Log(z$2));
			} else if (_ref$1 === 5) {
				z$2 = z$2 * ((y$1 + 4));
				z$2 = z$2 * ((y$1 + 3));
				z$2 = z$2 * ((y$1 + 2));
				lgamma = lgamma + (Log(z$2));
			} else if (_ref$1 === 4) {
				z$2 = z$2 * ((y$1 + 3));
				z$2 = z$2 * ((y$1 + 2));
				lgamma = lgamma + (Log(z$2));
			} else if (_ref$1 === 3) {
				z$2 = z$2 * ((y$1 + 2));
				lgamma = lgamma + (Log(z$2));
			}
		} else if (x < 2.8823037615171174e+17) {
			t$1 = Log(x);
			z$3 = 1 / x;
			y$2 = z$3 * z$3;
			w$1 = _lgamW[0] + z$3 * (_lgamW[1] + y$2 * (_lgamW[2] + y$2 * (_lgamW[3] + y$2 * (_lgamW[4] + y$2 * (_lgamW[5] + y$2 * _lgamW[6])))));
			lgamma = (x - 0.5) * (t$1 - 1) + w$1;
		} else {
			lgamma = x * (Log(x) - 1);
		}
		if (neg) {
			lgamma = nadj - lgamma;
		}
		return [lgamma, sign];
	};
	var sinPi = function(x) {
		var z, n, x$1, _ref;
		if (x < 0.25) {
			return -Sin(3.141592653589793 * x);
		}
		z = Floor(x);
		n = 0;
		if (!((z === x))) {
			x = Mod(x, 2);
			n = (x * 4 >> 0);
		} else {
			if (x >= 9.007199254740992e+15) {
				x = 0;
				n = 0;
			} else {
				if (x < 4.503599627370496e+15) {
					z = x + 4.503599627370496e+15;
				}
				n = ((x$1 = Float64bits(z), new Go$Uint64(0 & x$1.high, (1 & x$1.low) >>> 0)).low >> 0);
				x = n;
				n = n << 2 >> 0;
			}
		}
		_ref = n;
		if (_ref === 0) {
			x = Sin(3.141592653589793 * x);
		} else if (_ref === 1 || _ref === 2) {
			x = Cos(3.141592653589793 * (0.5 - x));
		} else if (_ref === 3 || _ref === 4) {
			x = Sin(3.141592653589793 * (1 - x));
		} else if (_ref === 5 || _ref === 6) {
			x = -Cos(3.141592653589793 * (x - 1.5));
		} else {
			x = Sin(3.141592653589793 * (x - 2));
		}
		return -x;
	};
	var Log = go$pkg.Log = Math.log;
	var log = function(x) {
		var _tuple, f1, ki, f, k, s, s2, s4, t1, t2, R, hfsq;
		if (IsNaN(x) || IsInf(x, 1)) {
			return x;
		} else if (x < 0) {
			return NaN();
		} else if (x === 0) {
			return Inf(-1);
		}
		_tuple = Frexp(x), f1 = _tuple[0], ki = _tuple[1];
		if (f1 < 0.7071067811865476) {
			f1 = f1 * 2;
			ki = ki - 1 >> 0;
		}
		f = f1 - 1;
		k = ki;
		s = f / (2 + f);
		s2 = s * s;
		s4 = s2 * s2;
		t1 = s2 * (0.6666666666666735 + s4 * (0.2857142874366239 + s4 * (0.1818357216161805 + s4 * 0.14798198605116586)));
		t2 = s4 * (0.3999999999940942 + s4 * (0.22222198432149784 + s4 * 0.15313837699209373));
		R = t1 + t2;
		hfsq = 0.5 * f * f;
		return k * 0.6931471803691238 - ((hfsq - (s * (hfsq + R) + k * 1.9082149292705877e-10)) - f);
	};
	var Log10 = go$pkg.Log10 = function(x) { return log10(x); };
	var log10 = function(x) {
		return Log(x) * 0.4342944819032518;
	};
	var Log2 = go$pkg.Log2 = function(x) { return log2(x); };
	var log2 = function(x) {
		var _tuple, frac, exp$1;
		_tuple = Frexp(x), frac = _tuple[0], exp$1 = _tuple[1];
		return Log(frac) * 1.4426950408889634 + exp$1;
	};
	var Log1p = go$pkg.Log1p = function(x) { return log1p(x); };
	var log1p = function(x) {
		var absx, f, iu, k, c, u, x$1, x$2, hfsq, _tuple, s, R, z;
		if (x < -1 || IsNaN(x)) {
			return NaN();
		} else if (x === -1) {
			return Inf(-1);
		} else if (IsInf(x, 1)) {
			return Inf(1);
		}
		absx = x;
		if (absx < 0) {
			absx = -absx;
		}
		f = 0;
		iu = new Go$Uint64(0, 0);
		k = 1;
		if (absx < 0.41421356237309503) {
			if (absx < 1.862645149230957e-09) {
				if (absx < 5.551115123125783e-17) {
					return x;
				}
				return x - x * x * 0.5;
			}
			if (x > -0.2928932188134525) {
				k = 0;
				f = x;
				iu = new Go$Uint64(0, 1);
			}
		}
		c = 0;
		if (!((k === 0))) {
			u = 0;
			if (absx < 9.007199254740992e+15) {
				u = 1 + x;
				iu = Float64bits(u);
				k = ((x$1 = go$shiftRightUint64(iu, 52), new Go$Uint64(x$1.high - 0, x$1.low - 1023)).low >> 0);
				if (k > 0) {
					c = 1 - (u - x);
				} else {
					c = x - (u - 1);
					c = c / (u);
				}
			} else {
				u = x;
				iu = Float64bits(u);
				k = ((x$2 = go$shiftRightUint64(iu, 52), new Go$Uint64(x$2.high - 0, x$2.low - 1023)).low >> 0);
				c = 0;
			}
			iu = new Go$Uint64(iu.high & 1048575, (iu.low & 4294967295) >>> 0);
			if ((iu.high < 434334 || (iu.high === 434334 && iu.low < 1719614413))) {
				u = Float64frombits(new Go$Uint64(iu.high | 1072693248, (iu.low | 0) >>> 0));
			} else {
				k = k + 1 >> 0;
				u = Float64frombits(new Go$Uint64(iu.high | 1071644672, (iu.low | 0) >>> 0));
				iu = go$shiftRightUint64((new Go$Uint64(1048576 - iu.high, 0 - iu.low)), 2);
			}
			f = u - 1;
		}
		hfsq = 0.5 * f * f;
		_tuple = [0, 0, 0], s = _tuple[0], R = _tuple[1], z = _tuple[2];
		if ((iu.high === 0 && iu.low === 0)) {
			if (f === 0) {
				if (k === 0) {
					return 0;
				} else {
					c = c + (k * 1.9082149292705877e-10);
					return k * 0.6931471803691238 + c;
				}
			}
			R = hfsq * (1 - 0.6666666666666666 * f);
			if (k === 0) {
				return f - R;
			}
			return k * 0.6931471803691238 - ((R - (k * 1.9082149292705877e-10 + c)) - f);
		}
		s = f / (2 + f);
		z = s * s;
		R = z * (0.6666666666666735 + z * (0.3999999999940942 + z * (0.2857142874366239 + z * (0.22222198432149784 + z * (0.1818357216161805 + z * (0.15313837699209373 + z * 0.14798198605116586))))));
		if (k === 0) {
			return f - (hfsq - s * (hfsq + R));
		}
		return k * 0.6931471803691238 - ((hfsq - (s * (hfsq + R) + (k * 1.9082149292705877e-10 + c))) - f);
	};
	var Logb = go$pkg.Logb = function(x) {
		if (x === 0) {
			return Inf(-1);
		} else if (IsInf(x, 0)) {
			return Inf(1);
		} else if (IsNaN(x)) {
			return x;
		}
		return ilogb(x);
	};
	var Ilogb = go$pkg.Ilogb = function(x) {
		if (x === 0) {
			return -2147483648;
		} else if (IsNaN(x)) {
			return 2147483647;
		} else if (IsInf(x, 0)) {
			return 2147483647;
		}
		return ilogb(x);
	};
	var ilogb = function(x) {
		var _tuple, exp$1, x$1;
		_tuple = normalize(x), x = _tuple[0], exp$1 = _tuple[1];
		return (((x$1 = go$shiftRightUint64(Float64bits(x), 52), new Go$Uint64(x$1.high & 0, (x$1.low & 2047) >>> 0)).low >> 0) - 1023 >> 0) + exp$1 >> 0;
	};
	var Mod = go$pkg.Mod = function(x, y) { return x % y; };
	var mod = function(x, y) {
		var _tuple, yfr, yexp, sign, r, _tuple$1, rfr, rexp;
		if ((y === 0) || IsInf(x, 0) || IsNaN(x) || IsNaN(y)) {
			return NaN();
		}
		if (y < 0) {
			y = -y;
		}
		_tuple = Frexp(y), yfr = _tuple[0], yexp = _tuple[1];
		sign = false;
		r = x;
		if (x < 0) {
			r = -x;
			sign = true;
		}
		while (r >= y) {
			_tuple$1 = Frexp(r), rfr = _tuple$1[0], rexp = _tuple$1[1];
			if (rfr < yfr) {
				rexp = rexp - 1 >> 0;
			}
			r = r - Ldexp(y, rexp - yexp >> 0);
		}
		if (sign) {
			r = -r;
		}
		return r;
	};
	var Modf = go$pkg.Modf = function(f) { if (f === -1/0 || f === 1/0) { return [f, 0/0]; } var frac = f % 1; return [f - frac, frac]; };
	var modf = function(f) {
		var int$1, frac, _tuple, _tuple$1, _tuple$2, x, e, x$1, x$2;
		int$1 = 0;
		frac = 0;
		if (f < 1) {
			if (f < 0) {
				_tuple = Modf(-f), int$1 = _tuple[0], frac = _tuple[1];
				_tuple$1 = [-int$1, -frac], int$1 = _tuple$1[0], frac = _tuple$1[1];
				return [int$1, frac];
			}
			_tuple$2 = [0, f], int$1 = _tuple$2[0], frac = _tuple$2[1];
			return [int$1, frac];
		}
		x = Float64bits(f);
		e = (((go$shiftRightUint64(x, 52).low >>> 0) & 2047) >>> 0) - 1023 >>> 0;
		if (e < 52) {
			x = (x$1 = (x$2 = go$shiftLeft64(new Go$Uint64(0, 1), ((52 - e >>> 0))), new Go$Uint64(x$2.high - 0, x$2.low - 1)), new Go$Uint64(x.high &~ x$1.high, (x.low &~ x$1.low) >>> 0));
		}
		int$1 = Float64frombits(x);
		frac = f - int$1;
		return [int$1, frac];
	};
	var Nextafter = go$pkg.Nextafter = function(x, y) {
		var r, x$1, x$2;
		r = 0;
		if (IsNaN(x) || IsNaN(y)) {
			r = NaN();
		} else if (x === y) {
			r = x;
		} else if (x === 0) {
			r = Copysign(Float64frombits(new Go$Uint64(0, 1)), y);
		} else if ((y > x) === (x > 0)) {
			r = Float64frombits((x$1 = Float64bits(x), new Go$Uint64(x$1.high + 0, x$1.low + 1)));
		} else {
			r = Float64frombits((x$2 = Float64bits(x), new Go$Uint64(x$2.high - 0, x$2.low - 1)));
		}
		return r;
	};
	var isOddInt = function(x) {
		var _tuple, xi, xf, x$1, x$2;
		_tuple = Modf(x), xi = _tuple[0], xf = _tuple[1];
		return (xf === 0) && (x$1 = (x$2 = new Go$Int64(0, xi), new Go$Int64(x$2.high & 0, (x$2.low & 1) >>> 0)), (x$1.high === 0 && x$1.low === 1));
	};
	var Pow = go$pkg.Pow = function(x, y) { return ((x === 1) || (x === -1 && (y === -1/0 || y === 1/0))) ? 1 : Math.pow(x, y); };
	var Pow10 = go$pkg.Pow10 = function(e) {
		var _q, m;
		if (e <= -325) {
			return 0;
		} else if (e > 309) {
			return Inf(1);
		}
		if (e < 0) {
			return 1 / Pow10(-e);
		}
		if (e < 70) {
			return pow10tab[e];
		}
		m = (_q = e / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		return Pow10(m) * Pow10(e - m >> 0);
	};
	var Remainder = go$pkg.Remainder = function(x, y) { return remainder(x, y); };
	var remainder = function(x, y) {
		var sign, yHalf;
		if (IsNaN(x) || IsNaN(y) || IsInf(x, 0) || (y === 0)) {
			return NaN();
		} else if (IsInf(y, 0)) {
			return x;
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		if (y < 0) {
			y = -y;
		}
		if (x === y) {
			return 0;
		}
		if (y <= 8.988465674311579e+307) {
			x = Mod(x, y + y);
		}
		if (y < 4.450147717014403e-308) {
			if (x + x > y) {
				x = x - (y);
				if (x + x >= y) {
					x = x - (y);
				}
			}
		} else {
			yHalf = 0.5 * y;
			if (x > yHalf) {
				x = x - (y);
				if (x >= yHalf) {
					x = x - (y);
				}
			}
		}
		if (sign) {
			x = -x;
		}
		return x;
	};
	var Signbit = go$pkg.Signbit = function(x) { return x < 0 || 1/x === 1/-0; };
	var Cos = go$pkg.Cos = Math.cos;
	var cos = function(x) {
		var sign, j, y, x$1, z, zz;
		if (IsNaN(x) || IsInf(x, 0)) {
			return NaN();
		}
		sign = false;
		if (x < 0) {
			x = -x;
		}
		j = new Go$Int64(0, x * 1.2732395447351625);
		y = go$flatten64(j);
		if ((x$1 = new Go$Int64(j.high & 0, (j.low & 1) >>> 0), (x$1.high === 0 && x$1.low === 1))) {
			j = new Go$Int64(j.high + 0, j.low + 1);
			y = y + 1;
		}
		j = new Go$Int64(j.high & 0, (j.low & 7) >>> 0);
		if ((j.high > 0 || (j.high === 0 && j.low > 3))) {
			j = new Go$Int64(j.high - 0, j.low - 4);
			sign = !sign;
		}
		if ((j.high > 0 || (j.high === 0 && j.low > 1))) {
			sign = !sign;
		}
		z = ((x - y * 0.7853981256484985) - y * 3.774894707930798e-08) - y * 2.6951514290790595e-15;
		zz = z * z;
		if ((j.high === 0 && j.low === 1) || (j.high === 0 && j.low === 2)) {
			y = z + z * zz * ((((((_sin[0] * zz) + _sin[1]) * zz + _sin[2]) * zz + _sin[3]) * zz + _sin[4]) * zz + _sin[5]);
		} else {
			y = 1 - 0.5 * zz + zz * zz * ((((((_cos[0] * zz) + _cos[1]) * zz + _cos[2]) * zz + _cos[3]) * zz + _cos[4]) * zz + _cos[5]);
		}
		if (sign) {
			y = -y;
		}
		return y;
	};
	var Sin = go$pkg.Sin = Math.sin;
	var sin = function(x) {
		var sign, j, y, x$1, z, zz;
		if ((x === 0) || IsNaN(x)) {
			return x;
		} else if (IsInf(x, 0)) {
			return NaN();
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		j = new Go$Int64(0, x * 1.2732395447351625);
		y = go$flatten64(j);
		if ((x$1 = new Go$Int64(j.high & 0, (j.low & 1) >>> 0), (x$1.high === 0 && x$1.low === 1))) {
			j = new Go$Int64(j.high + 0, j.low + 1);
			y = y + 1;
		}
		j = new Go$Int64(j.high & 0, (j.low & 7) >>> 0);
		if ((j.high > 0 || (j.high === 0 && j.low > 3))) {
			sign = !sign;
			j = new Go$Int64(j.high - 0, j.low - 4);
		}
		z = ((x - y * 0.7853981256484985) - y * 3.774894707930798e-08) - y * 2.6951514290790595e-15;
		zz = z * z;
		if ((j.high === 0 && j.low === 1) || (j.high === 0 && j.low === 2)) {
			y = 1 - 0.5 * zz + zz * zz * ((((((_cos[0] * zz) + _cos[1]) * zz + _cos[2]) * zz + _cos[3]) * zz + _cos[4]) * zz + _cos[5]);
		} else {
			y = z + z * zz * ((((((_sin[0] * zz) + _sin[1]) * zz + _sin[2]) * zz + _sin[3]) * zz + _sin[4]) * zz + _sin[5]);
		}
		if (sign) {
			y = -y;
		}
		return y;
	};
	var Sincos = go$pkg.Sincos = function(x) { return [Math.sin(x), Math.cos(x)]; };
	var sincos = function(x) {
		var sin$1, cos$1, _tuple, _tuple$1, _tuple$2, sinSign, cosSign, j, y, x$1, _tuple$3, z, zz, _tuple$4;
		sin$1 = 0;
		cos$1 = 0;
		if (x === 0) {
			_tuple = [x, 1], sin$1 = _tuple[0], cos$1 = _tuple[1];
			return [sin$1, cos$1];
		} else if (IsNaN(x) || IsInf(x, 0)) {
			_tuple$1 = [NaN(), NaN()], sin$1 = _tuple$1[0], cos$1 = _tuple$1[1];
			return [sin$1, cos$1];
		}
		_tuple$2 = [false, false], sinSign = _tuple$2[0], cosSign = _tuple$2[1];
		if (x < 0) {
			x = -x;
			sinSign = true;
		}
		j = new Go$Int64(0, x * 1.2732395447351625);
		y = go$flatten64(j);
		if ((x$1 = new Go$Int64(j.high & 0, (j.low & 1) >>> 0), (x$1.high === 0 && x$1.low === 1))) {
			j = new Go$Int64(j.high + 0, j.low + 1);
			y = y + 1;
		}
		j = new Go$Int64(j.high & 0, (j.low & 7) >>> 0);
		if ((j.high > 0 || (j.high === 0 && j.low > 3))) {
			j = new Go$Int64(j.high - 0, j.low - 4);
			_tuple$3 = [!sinSign, !cosSign], sinSign = _tuple$3[0], cosSign = _tuple$3[1];
		}
		if ((j.high > 0 || (j.high === 0 && j.low > 1))) {
			cosSign = !cosSign;
		}
		z = ((x - y * 0.7853981256484985) - y * 3.774894707930798e-08) - y * 2.6951514290790595e-15;
		zz = z * z;
		cos$1 = 1 - 0.5 * zz + zz * zz * ((((((_cos[0] * zz) + _cos[1]) * zz + _cos[2]) * zz + _cos[3]) * zz + _cos[4]) * zz + _cos[5]);
		sin$1 = z + z * zz * ((((((_sin[0] * zz) + _sin[1]) * zz + _sin[2]) * zz + _sin[3]) * zz + _sin[4]) * zz + _sin[5]);
		if ((j.high === 0 && j.low === 1) || (j.high === 0 && j.low === 2)) {
			_tuple$4 = [cos$1, sin$1], sin$1 = _tuple$4[0], cos$1 = _tuple$4[1];
		}
		if (cosSign) {
			cos$1 = -cos$1;
		}
		if (sinSign) {
			sin$1 = -sin$1;
		}
		return [sin$1, cos$1];
	};
	var Sinh = go$pkg.Sinh = function(x) {
		var sign, temp, _ref, sq;
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		temp = 0;
		_ref = true;
		if (_ref === x > 21) {
			temp = Exp(x) / 2;
		} else if (_ref === x > 0.5) {
			temp = (Exp(x) - Exp(-x)) / 2;
		} else {
			sq = x * x;
			temp = (((-26.30563213397497 * sq + -2894.211355989564) * sq + -89912.72022039509) * sq + -630767.3640497717) * x;
			temp = temp / (((sq + -173.6789535582337) * sq + 15215.17378790019) * sq + -630767.3640497717);
		}
		if (sign) {
			temp = -temp;
		}
		return temp;
	};
	var Cosh = go$pkg.Cosh = function(x) {
		if (x < 0) {
			x = -x;
		}
		if (x > 21) {
			return Exp(x) / 2;
		}
		return (Exp(x) + Exp(-x)) / 2;
	};
	var Sqrt = go$pkg.Sqrt = Math.sqrt;
	var sqrt = function(x) {
		var ix, x$1, exp$1, x$2, _tuple, q, s, r, t, x$3, x$4, x$5, x$6, x$7;
		if ((x === 0) || IsNaN(x) || IsInf(x, 1)) {
			return x;
		} else if (x < 0) {
			return NaN();
		}
		ix = Float64bits(x);
		exp$1 = ((x$1 = go$shiftRightUint64(ix, 52), new Go$Uint64(x$1.high & 0, (x$1.low & 2047) >>> 0)).low >> 0);
		if (exp$1 === 0) {
			while ((x$2 = go$shiftLeft64(new Go$Uint64(ix.high & 0, (ix.low & 1) >>> 0), 52), (x$2.high === 0 && x$2.low === 0))) {
				ix = go$shiftLeft64(ix, 1);
				exp$1 = exp$1 - 1 >> 0;
			}
			exp$1 = exp$1 + 1 >> 0;
		}
		exp$1 = exp$1 - 1023 >> 0;
		ix = new Go$Uint64(ix.high &~ 2146435072, (ix.low &~ 0) >>> 0);
		ix = new Go$Uint64(ix.high | 1048576, (ix.low | 0) >>> 0);
		if ((exp$1 & 1) === 1) {
			ix = go$shiftLeft64(ix, 1);
		}
		exp$1 = exp$1 >> 1 >> 0;
		ix = go$shiftLeft64(ix, 1);
		_tuple = [new Go$Uint64(0, 0), new Go$Uint64(0, 0)], q = _tuple[0], s = _tuple[1];
		r = new Go$Uint64(2097152, 0);
		while (!((r.high === 0 && r.low === 0))) {
			t = new Go$Uint64(s.high + r.high, s.low + r.low);
			if ((t.high < ix.high || (t.high === ix.high && t.low <= ix.low))) {
				s = new Go$Uint64(t.high + r.high, t.low + r.low);
				ix = (x$3 = t, new Go$Uint64(ix.high - x$3.high, ix.low - x$3.low));
				q = (x$4 = r, new Go$Uint64(q.high + x$4.high, q.low + x$4.low));
			}
			ix = go$shiftLeft64(ix, 1);
			r = go$shiftRightUint64(r, 1);
		}
		if (!((ix.high === 0 && ix.low === 0))) {
			q = (x$5 = new Go$Uint64(q.high & 0, (q.low & 1) >>> 0), new Go$Uint64(q.high + x$5.high, q.low + x$5.low));
		}
		ix = (x$6 = go$shiftRightUint64(q, 1), x$7 = go$shiftLeft64(new Go$Uint64(0, ((exp$1 - 1 >> 0) + 1023 >> 0)), 52), new Go$Uint64(x$6.high + x$7.high, x$6.low + x$7.low));
		return Float64frombits(ix);
	};
	var sqrtC = function(f, r) {
		r.go$set(sqrt(f));
	};
	var Tan = go$pkg.Tan = Math.tan;
	var tan = function(x) {
		var sign, j, y, x$1, z, zz, x$2;
		if ((x === 0) || IsNaN(x)) {
			return x;
		} else if (IsInf(x, 0)) {
			return NaN();
		}
		sign = false;
		if (x < 0) {
			x = -x;
			sign = true;
		}
		j = new Go$Int64(0, x * 1.2732395447351625);
		y = go$flatten64(j);
		if ((x$1 = new Go$Int64(j.high & 0, (j.low & 1) >>> 0), (x$1.high === 0 && x$1.low === 1))) {
			j = new Go$Int64(j.high + 0, j.low + 1);
			y = y + 1;
		}
		z = ((x - y * 0.7853981256484985) - y * 3.774894707930798e-08) - y * 2.6951514290790595e-15;
		zz = z * z;
		if (zz > 1e-14) {
			y = z + z * (zz * (((_tanP[0] * zz) + _tanP[1]) * zz + _tanP[2]) / ((((zz + _tanQ[1]) * zz + _tanQ[2]) * zz + _tanQ[3]) * zz + _tanQ[4]));
		} else {
			y = z;
		}
		if ((x$2 = new Go$Int64(j.high & 0, (j.low & 2) >>> 0), (x$2.high === 0 && x$2.low === 2))) {
			y = -1 / y;
		}
		if (sign) {
			y = -y;
		}
		return y;
	};
	var Tanh = go$pkg.Tanh = function(x) {
		var z, s, s$1;
		z = Abs(x);
		if (z > 44.014845965556525) {
			if (x < 0) {
				return -1;
			}
			return 1;
		} else if (z >= 0.625) {
			s = Exp(2 * z);
			z = 1 - 2 / (s + 1);
			if (x < 0) {
				z = -z;
			}
		} else {
			if (x === 0) {
				return x;
			}
			s$1 = x * x;
			z = x + x * s$1 * ((tanhP[0] * s$1 + tanhP[1]) * s$1 + tanhP[2]) / (((s$1 + tanhQ[0]) * s$1 + tanhQ[1]) * s$1 + tanhQ[2]);
		}
		return z;
	};
	var Float32bits = go$pkg.Float32bits = go$float32bits;
	var Float32frombits = go$pkg.Float32frombits = function(b) {
			var s, e, m;
			s = 1;
			if (!(((b & 2147483648) >>> 0) === 0)) {
				s = -1;
			}
			e = (((((b >>> 23) >>> 0)) & 255) >>> 0);
			m = ((b & 8388607) >>> 0);
			if (e === 255) {
				if (m === 0) {
					return s / 0;
				}
				return 0/0;
			}
			if (!(e === 0)) {
				m = (m + (8388608) >>> 0);
			}
			if (e === 0) {
				e = 1;
			}
			return Ldexp(m, e - 127 - 23) * s;
		};
	var Float64bits = go$pkg.Float64bits = function(f) {
			var s, e, x, y, x$1, y$1, x$2, y$2;
			if (f === 0) {
				if (f === 0 && 1 / f === 1 / -0) {
					return new Go$Uint64(2147483648, 0);
				}
				return new Go$Uint64(0, 0);
			}
			if (!(f === f)) {
				return new Go$Uint64(2146959360, 1);
			}
			s = new Go$Uint64(0, 0);
			if (f < 0) {
				s = new Go$Uint64(2147483648, 0);
				f = -f;
			}
			e = 1075;
			while (f >= 9.007199254740992e+15) {
				f = f / (2);
				if (e === 2047) {
					break;
				}
				e = (e + (1) >>> 0);
			}
			while (f < 4.503599627370496e+15) {
				e = (e - (1) >>> 0);
				if (e === 0) {
					break;
				}
				f = f * (2);
			}
			return (x$2 = (x = s, y = go$shiftLeft64(new Go$Uint64(0, e), 52), new Go$Uint64(x.high | y.high, (x.low | y.low) >>> 0)), y$2 = ((x$1 = new Go$Uint64(0, f), y$1 = new Go$Uint64(1048576, 0), new Go$Uint64(x$1.high &~ y$1.high, (x$1.low &~ y$1.low) >>> 0))), new Go$Uint64(x$2.high | y$2.high, (x$2.low | y$2.low) >>> 0));
		};
	var Float64frombits = go$pkg.Float64frombits = function(b) {
			var s, x, y, x$1, y$1, x$2, y$2, e, x$3, y$3, m, x$4, y$4, x$5, y$5, x$6, y$6, x$7, y$7, x$8, y$8;
			s = 1;
			if (!((x$1 = (x = b, y = new Go$Uint64(2147483648, 0), new Go$Uint64(x.high & y.high, (x.low & y.low) >>> 0)), y$1 = new Go$Uint64(0, 0), x$1.high === y$1.high && x$1.low === y$1.low))) {
				s = -1;
			}
			e = (x$2 = (go$shiftRightUint64(b, 52)), y$2 = new Go$Uint64(0, 2047), new Go$Uint64(x$2.high & y$2.high, (x$2.low & y$2.low) >>> 0));
			m = (x$3 = b, y$3 = new Go$Uint64(1048575, 4294967295), new Go$Uint64(x$3.high & y$3.high, (x$3.low & y$3.low) >>> 0));
			if ((x$4 = e, y$4 = new Go$Uint64(0, 2047), x$4.high === y$4.high && x$4.low === y$4.low)) {
				if ((x$5 = m, y$5 = new Go$Uint64(0, 0), x$5.high === y$5.high && x$5.low === y$5.low)) {
					return s / 0;
				}
				return 0/0;
			}
			if (!((x$6 = e, y$6 = new Go$Uint64(0, 0), x$6.high === y$6.high && x$6.low === y$6.low))) {
				m = (x$7 = m, y$7 = (new Go$Uint64(1048576, 0)), new Go$Uint64(x$7.high + y$7.high, x$7.low + y$7.low));
			}
			if ((x$8 = e, y$8 = new Go$Uint64(0, 0), x$8.high === y$8.high && x$8.low === y$8.low)) {
				e = new Go$Uint64(0, 1);
			}
			return Ldexp((m.high * 4294967296 + m.low), e.low - 1023 - 52) * s;
		};
	go$pkg.init = function() {
		pow10tab = go$makeNativeArray("Float64", 70, function() { return 0; });
		var i, _q, m;
		_gamP = go$toNativeArray("Float64", [0.00016011952247675185, 0.0011913514700658638, 0.010421379756176158, 0.04763678004571372, 0.20744822764843598, 0.4942148268014971, 1]);
		_gamQ = go$toNativeArray("Float64", [-2.3158187332412014e-05, 0.0005396055804933034, -0.004456419138517973, 0.011813978522206043, 0.035823639860549865, -0.23459179571824335, 0.0714304917030273, 1]);
		_gamS = go$toNativeArray("Float64", [0.0007873113957930937, -0.00022954996161337813, -0.0026813261780578124, 0.0034722222160545866, 0.08333333333334822]);
		p0R8 = go$toNativeArray("Float64", [0, -0.07031249999999004, -8.081670412753498, -257.06310567970485, -2485.216410094288, -5253.043804907295]);
		p0S8 = go$toNativeArray("Float64", [116.53436461966818, 3833.7447536412183, 40597.857264847255, 116752.97256437592, 47627.728414673096]);
		p0R5 = go$toNativeArray("Float64", [-1.141254646918945e-11, -0.07031249408735993, -4.159610644705878, -67.67476522651673, -331.23129964917297, -346.4333883656049]);
		p0S5 = go$toNativeArray("Float64", [60.753938269230034, 1051.2523059570458, 5978.970943338558, 9625.445143577745, 2406.058159229391]);
		p0R3 = go$toNativeArray("Float64", [-2.547046017719519e-09, -0.07031196163814817, -2.409032215495296, -21.96597747348831, -58.07917047017376, -31.44794705948885]);
		p0S3 = go$toNativeArray("Float64", [35.85603380552097, 361.51398305030386, 1193.6078379211153, 1127.9967985690741, 173.58093081333575]);
		p0R2 = go$toNativeArray("Float64", [-8.875343330325264e-08, -0.07030309954836247, -1.4507384678095299, -7.635696138235278, -11.193166886035675, -3.2336457935133534]);
		p0S2 = go$toNativeArray("Float64", [22.22029975320888, 136.2067942182152, 270.4702786580835, 153.87539420832033, 14.65761769482562]);
		q0R8 = go$toNativeArray("Float64", [0, 0.0732421874999935, 11.76820646822527, 557.6733802564019, 8859.197207564686, 37014.62677768878]);
		q0S8 = go$toNativeArray("Float64", [163.77602689568982, 8098.344946564498, 142538.29141912048, 803309.2571195144, 840501.5798190605, -343899.2935378666]);
		q0R5 = go$toNativeArray("Float64", [1.8408596359451553e-11, 0.07324217666126848, 5.8356350896205695, 135.11157728644983, 1027.243765961641, 1989.9778586460538]);
		q0S5 = go$toNativeArray("Float64", [82.77661022365378, 2077.81416421393, 18847.28877857181, 56751.11228949473, 35976.75384251145, -5354.342756019448]);
		q0R3 = go$toNativeArray("Float64", [4.377410140897386e-09, 0.07324111800429114, 3.344231375161707, 42.621844074541265, 170.8080913405656, 166.73394869665117]);
		q0S3 = go$toNativeArray("Float64", [48.75887297245872, 709.689221056606, 3704.1482262011136, 6460.425167525689, 2516.3336892036896, -149.2474518361564]);
		q0R2 = go$toNativeArray("Float64", [1.5044444488698327e-07, 0.07322342659630793, 1.99819174093816, 14.495602934788574, 31.666231750478154, 16.252707571092927]);
		q0S2 = go$toNativeArray("Float64", [30.36558483552192, 269.34811860804984, 844.7837575953201, 882.9358451124886, 212.66638851179883, -5.3109549388266695]);
		p1R8 = go$toNativeArray("Float64", [0, 0.11718749999998865, 13.239480659307358, 412.05185430737856, 3874.7453891396053, 7914.479540318917]);
		p1S8 = go$toNativeArray("Float64", [114.20737037567841, 3650.9308342085346, 36956.206026903346, 97602.79359349508, 30804.27206278888]);
		p1R5 = go$toNativeArray("Float64", [1.3199051955624352e-11, 0.1171874931906141, 6.802751278684329, 108.30818299018911, 517.6361395331998, 528.7152013633375]);
		p1S5 = go$toNativeArray("Float64", [59.28059872211313, 991.4014187336144, 5353.26695291488, 7844.690317495512, 1504.0468881036106]);
		p1R3 = go$toNativeArray("Float64", [3.025039161373736e-09, 0.11718686556725359, 3.9329775003331564, 35.11940355916369, 91.05501107507813, 48.55906851973649]);
		p1S3 = go$toNativeArray("Float64", [34.79130950012515, 336.76245874782575, 1046.8713997577513, 890.8113463982564, 103.78793243963928]);
		p1R2 = go$toNativeArray("Float64", [1.0771083010687374e-07, 0.11717621946268335, 2.368514966676088, 12.242610914826123, 17.693971127168773, 5.073523125888185]);
		p1S2 = go$toNativeArray("Float64", [21.43648593638214, 125.29022716840275, 232.2764690571628, 117.6793732871471, 8.364638933716183]);
		q1R8 = go$toNativeArray("Float64", [0, -0.10253906249999271, -16.271753454459, -759.6017225139501, -11849.806670242959, -48438.512428575035]);
		q1S8 = go$toNativeArray("Float64", [161.3953697007229, 7825.385999233485, 133875.33628724958, 719657.7236832409, 666601.2326177764, -294490.26430383464]);
		q1R5 = go$toNativeArray("Float64", [-2.089799311417641e-11, -0.10253905024137543, -8.05644828123936, -183.66960747488838, -1373.1937606550816, -2612.4444045321566]);
		q1S5 = go$toNativeArray("Float64", [81.27655013843358, 1991.7987346048596, 17468.48519249089, 49851.42709103523, 27948.075163891812, -4719.183547951285]);
		q1R3 = go$toNativeArray("Float64", [-5.078312264617666e-09, -0.10253782982083709, -4.610115811394734, -57.847221656278364, -228.2445407376317, -219.21012847890933]);
		q1S3 = go$toNativeArray("Float64", [47.66515503237295, 673.8651126766997, 3380.1528667952634, 5547.729097207228, 1903.119193388108, -135.20119144430734]);
		q1R2 = go$toNativeArray("Float64", [-1.7838172751095887e-07, -0.10251704260798555, -2.7522056827818746, -19.663616264370372, -42.32531333728305, -21.371921170370406]);
		q1S2 = go$toNativeArray("Float64", [29.533362906052385, 252.98154998219053, 757.5028348686454, 739.3932053204672, 155.94900333666612, -4.959498988226282]);
		_lgamA = go$toNativeArray("Float64", [0.07721566490153287, 0.3224670334241136, 0.06735230105312927, 0.020580808432516733, 0.007385550860814029, 0.0028905138367341563, 0.0011927076318336207, 0.0005100697921535113, 0.00022086279071390839, 0.00010801156724758394, 2.5214456545125733e-05, 4.4864094961891516e-05]);
		_lgamR = go$toNativeArray("Float64", [1, 1.3920053346762105, 0.7219355475671381, 0.17193386563280308, 0.01864591917156529, 0.0007779424963818936, 7.326684307446256e-06]);
		_lgamS = go$toNativeArray("Float64", [-0.07721566490153287, 0.21498241596060885, 0.325778796408931, 0.14635047265246445, 0.02664227030336386, 0.0018402845140733772, 3.194753265841009e-05]);
		_lgamT = go$toNativeArray("Float64", [0.48383612272381005, -0.1475877229945939, 0.06462494023913339, -0.032788541075985965, 0.01797067508118204, -0.010314224129834144, 0.006100538702462913, -0.0036845201678113826, 0.0022596478090061247, -0.0014034646998923284, 0.000881081882437654, -0.0005385953053567405, 0.00031563207090362595, -0.00031275416837512086, 0.0003355291926355191]);
		_lgamU = go$toNativeArray("Float64", [-0.07721566490153287, 0.6328270640250934, 1.4549225013723477, 0.9777175279633727, 0.22896372806469245, 0.013381091853678766]);
		_lgamV = go$toNativeArray("Float64", [1, 2.4559779371304113, 2.128489763798934, 0.7692851504566728, 0.10422264559336913, 0.003217092422824239]);
		_lgamW = go$toNativeArray("Float64", [0.4189385332046727, 0.08333333333333297, -0.0027777777772877554, 0.0007936505586430196, -0.00059518755745034, 0.0008363399189962821, -0.0016309293409657527]);
		_sin = go$toNativeArray("Float64", [1.5896230157654656e-10, -2.5050747762857807e-08, 2.7557313621385722e-06, -0.0001984126982958954, 0.008333333333322118, -0.1666666666666663]);
		_cos = go$toNativeArray("Float64", [-1.1358536521387682e-11, 2.087570084197473e-09, -2.755731417929674e-07, 2.4801587288851704e-05, -0.0013888888888873056, 0.041666666666666595]);
		_tanP = go$toNativeArray("Float64", [-13093.693918138379, 1.1535166483858742e+06, -1.7956525197648488e+07]);
		_tanQ = go$toNativeArray("Float64", [1, 13681.296347069296, -1.3208923444021097e+06, 2.500838018233579e+07, -5.3869575592945464e+07]);
		tanhP = go$toNativeArray("Float64", [-0.9643991794250523, -99.28772310019185, -1614.6876844170845]);
		tanhQ = go$toNativeArray("Float64", [112.81167849163293, 2235.4883906010045, 4844.063053251255]);
		pow10tab[0] = 1;
		pow10tab[1] = 10;
		i = 2;
		while (i < 70) {
			m = (_q = i / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
			pow10tab[i] = pow10tab[m] * pow10tab[(i - m >> 0)];
			i = i + 1 >> 0;
		}
	};
	return go$pkg;
})();
go$packages["strconv"] = (function() {
	var go$pkg = {};
	var math = go$packages["math"];
	var errors = go$packages["errors"];
	var utf8 = go$packages["unicode/utf8"];
	var NumError;
	NumError = go$newType(0, "Struct", "strconv.NumError", "NumError", "strconv", function(Func_, Num_, Err_) {
		this.go$val = this;
		this.Func = Func_ !== undefined ? Func_ : "";
		this.Num = Num_ !== undefined ? Num_ : "";
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.NumError = NumError;
	var decimal;
	decimal = go$newType(0, "Struct", "strconv.decimal", "decimal", "strconv", function(d_, nd_, dp_, neg_, trunc_) {
		this.go$val = this;
		this.d = d_ !== undefined ? d_ : go$makeNativeArray("Uint8", 800, function() { return 0; });
		this.nd = nd_ !== undefined ? nd_ : 0;
		this.dp = dp_ !== undefined ? dp_ : 0;
		this.neg = neg_ !== undefined ? neg_ : false;
		this.trunc = trunc_ !== undefined ? trunc_ : false;
	});
	go$pkg.decimal = decimal;
	var leftCheat;
	leftCheat = go$newType(0, "Struct", "strconv.leftCheat", "leftCheat", "strconv", function(delta_, cutoff_) {
		this.go$val = this;
		this.delta = delta_ !== undefined ? delta_ : 0;
		this.cutoff = cutoff_ !== undefined ? cutoff_ : "";
	});
	go$pkg.leftCheat = leftCheat;
	var extFloat;
	extFloat = go$newType(0, "Struct", "strconv.extFloat", "extFloat", "strconv", function(mant_, exp_, neg_) {
		this.go$val = this;
		this.mant = mant_ !== undefined ? mant_ : new Go$Uint64(0, 0);
		this.exp = exp_ !== undefined ? exp_ : 0;
		this.neg = neg_ !== undefined ? neg_ : false;
	});
	go$pkg.extFloat = extFloat;
	var floatInfo;
	floatInfo = go$newType(0, "Struct", "strconv.floatInfo", "floatInfo", "strconv", function(mantbits_, expbits_, bias_) {
		this.go$val = this;
		this.mantbits = mantbits_ !== undefined ? mantbits_ : 0;
		this.expbits = expbits_ !== undefined ? expbits_ : 0;
		this.bias = bias_ !== undefined ? bias_ : 0;
	});
	go$pkg.floatInfo = floatInfo;
	var decimalSlice;
	decimalSlice = go$newType(0, "Struct", "strconv.decimalSlice", "decimalSlice", "strconv", function(d_, nd_, dp_, neg_) {
		this.go$val = this;
		this.d = d_ !== undefined ? d_ : (go$sliceType(Go$Uint8)).nil;
		this.nd = nd_ !== undefined ? nd_ : 0;
		this.dp = dp_ !== undefined ? dp_ : 0;
		this.neg = neg_ !== undefined ? neg_ : false;
	});
	go$pkg.decimalSlice = decimalSlice;
	NumError.init([["Func", "", Go$String, ""], ["Num", "", Go$String, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(NumError)).methods = [["Error", "", [], [Go$String], false]];
	decimal.init([["d", "strconv", (go$arrayType(Go$Uint8, 800)), ""], ["nd", "strconv", Go$Int, ""], ["dp", "strconv", Go$Int, ""], ["neg", "strconv", Go$Bool, ""], ["trunc", "strconv", Go$Bool, ""]]);
	(go$ptrType(decimal)).methods = [["Assign", "", [Go$Uint64], [], false], ["Round", "", [Go$Int], [], false], ["RoundDown", "", [Go$Int], [], false], ["RoundUp", "", [Go$Int], [], false], ["RoundedInteger", "", [], [Go$Uint64], false], ["Shift", "", [Go$Int], [], false], ["String", "", [], [Go$String], false], ["atof32int", "strconv", [], [Go$Float32], false], ["floatBits", "strconv", [(go$ptrType(floatInfo))], [Go$Uint64, Go$Bool], false], ["set", "strconv", [Go$String], [Go$Bool], false]];
	leftCheat.init([["delta", "strconv", Go$Int, ""], ["cutoff", "strconv", Go$String, ""]]);
	extFloat.init([["mant", "strconv", Go$Uint64, ""], ["exp", "strconv", Go$Int, ""], ["neg", "strconv", Go$Bool, ""]]);
	(go$ptrType(extFloat)).methods = [["AssignComputeBounds", "", [Go$Uint64, Go$Int, Go$Bool, (go$ptrType(floatInfo))], [extFloat, extFloat], false], ["AssignDecimal", "", [Go$Uint64, Go$Int, Go$Bool, Go$Bool, (go$ptrType(floatInfo))], [Go$Bool], false], ["FixedDecimal", "", [(go$ptrType(decimalSlice)), Go$Int], [Go$Bool], false], ["Multiply", "", [extFloat], [], false], ["Normalize", "", [], [Go$Uint], false], ["ShortestDecimal", "", [(go$ptrType(decimalSlice)), (go$ptrType(extFloat)), (go$ptrType(extFloat))], [Go$Bool], false], ["floatBits", "strconv", [(go$ptrType(floatInfo))], [Go$Uint64, Go$Bool], false], ["frexp10", "strconv", [], [Go$Int, Go$Int], false]];
	floatInfo.init([["mantbits", "strconv", Go$Uint, ""], ["expbits", "strconv", Go$Uint, ""], ["bias", "strconv", Go$Int, ""]]);
	decimalSlice.init([["d", "strconv", (go$sliceType(Go$Uint8)), ""], ["nd", "strconv", Go$Int, ""], ["dp", "strconv", Go$Int, ""], ["neg", "strconv", Go$Bool, ""]]);
	var optimize, powtab, float64pow10, float32pow10, leftcheats, smallPowersOfTen, powersOfTen, uint64pow10, float32info, float64info, isPrint16, isNotPrint16, isPrint32, isNotPrint32, shifts;
	var ParseBool = go$pkg.ParseBool = function(str) {
		var value, err, _ref, _tuple, _tuple$1, _tuple$2;
		value = false;
		err = null;
		_ref = str;
		if (_ref === "1" || _ref === "t" || _ref === "T" || _ref === "true" || _ref === "TRUE" || _ref === "True") {
			_tuple = [true, null], value = _tuple[0], err = _tuple[1];
			return [value, err];
		} else if (_ref === "0" || _ref === "f" || _ref === "F" || _ref === "false" || _ref === "FALSE" || _ref === "False") {
			_tuple$1 = [false, null], value = _tuple$1[0], err = _tuple$1[1];
			return [value, err];
		}
		_tuple$2 = [false, syntaxError("ParseBool", str)], value = _tuple$2[0], err = _tuple$2[1];
		return [value, err];
	};
	var FormatBool = go$pkg.FormatBool = function(b) {
		if (b) {
			return "true";
		}
		return "false";
	};
	var AppendBool = go$pkg.AppendBool = function(dst, b) {
		if (b) {
			return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes("true")));
		}
		return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes("false")));
	};
	var equalIgnoreCase = function(s1, s2) {
		var i, c1, c2;
		if (!((s1.length === s2.length))) {
			return false;
		}
		i = 0;
		while (i < s1.length) {
			c1 = s1.charCodeAt(i);
			if (65 <= c1 && c1 <= 90) {
				c1 = c1 + 32 << 24 >>> 24;
			}
			c2 = s2.charCodeAt(i);
			if (65 <= c2 && c2 <= 90) {
				c2 = c2 + 32 << 24 >>> 24;
			}
			if (!((c1 === c2))) {
				return false;
			}
			i = i + 1 >> 0;
		}
		return true;
	};
	var special = function(s) {
		var f, ok, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3;
		f = 0;
		ok = false;
		if (s.length === 0) {
			return [f, ok];
		}
		_ref = s.charCodeAt(0);
		if (_ref === 43) {
			if (equalIgnoreCase(s, "+inf") || equalIgnoreCase(s, "+infinity")) {
				_tuple = [math.Inf(1), true], f = _tuple[0], ok = _tuple[1];
				return [f, ok];
			}
		} else if (_ref === 45) {
			if (equalIgnoreCase(s, "-inf") || equalIgnoreCase(s, "-infinity")) {
				_tuple$1 = [math.Inf(-1), true], f = _tuple$1[0], ok = _tuple$1[1];
				return [f, ok];
			}
		} else if (_ref === 110 || _ref === 78) {
			if (equalIgnoreCase(s, "nan")) {
				_tuple$2 = [math.NaN(), true], f = _tuple$2[0], ok = _tuple$2[1];
				return [f, ok];
			}
		} else if (_ref === 105 || _ref === 73) {
			if (equalIgnoreCase(s, "inf") || equalIgnoreCase(s, "infinity")) {
				_tuple$3 = [math.Inf(1), true], f = _tuple$3[0], ok = _tuple$3[1];
				return [f, ok];
			}
		} else {
			return [f, ok];
		}
		return [f, ok];
	};
	decimal.Ptr.prototype.set = function(s) {
		var ok, b, i, sawdot, sawdigits, esign, e, x;
		ok = false;
		b = this;
		i = 0;
		b.neg = false;
		b.trunc = false;
		if (i >= s.length) {
			return ok;
		}
		if (s.charCodeAt(i) === 43) {
			i = i + 1 >> 0;
		} else if (s.charCodeAt(i) === 45) {
			b.neg = true;
			i = i + 1 >> 0;
		}
		sawdot = false;
		sawdigits = false;
		while (i < s.length) {
			if (s.charCodeAt(i) === 46) {
				if (sawdot) {
					return ok;
				}
				sawdot = true;
				b.dp = b.nd;
				i = i + 1 >> 0;
				continue;
			} else if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {
				sawdigits = true;
				if ((s.charCodeAt(i) === 48) && (b.nd === 0)) {
					b.dp = b.dp - 1 >> 0;
					i = i + 1 >> 0;
					continue;
				}
				if (b.nd < 800) {
					b.d[b.nd] = s.charCodeAt(i);
					b.nd = b.nd + 1 >> 0;
				} else if (!((s.charCodeAt(i) === 48))) {
					b.trunc = true;
				}
				i = i + 1 >> 0;
				continue;
			}
			break;
		}
		if (!sawdigits) {
			return ok;
		}
		if (!sawdot) {
			b.dp = b.nd;
		}
		if (i < s.length && ((s.charCodeAt(i) === 101) || (s.charCodeAt(i) === 69))) {
			i = i + 1 >> 0;
			if (i >= s.length) {
				return ok;
			}
			esign = 1;
			if (s.charCodeAt(i) === 43) {
				i = i + 1 >> 0;
			} else if (s.charCodeAt(i) === 45) {
				i = i + 1 >> 0;
				esign = -1;
			}
			if (i >= s.length || s.charCodeAt(i) < 48 || s.charCodeAt(i) > 57) {
				return ok;
			}
			e = 0;
			while (i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {
				if (e < 10000) {
					e = ((x = 10, (((e >>> 16 << 16) * x >> 0) + (e << 16 >>> 16) * x) >> 0) + (s.charCodeAt(i) >> 0) >> 0) - 48 >> 0;
				}
				i = i + 1 >> 0;
			}
			b.dp = b.dp + (((((e >>> 16 << 16) * esign >> 0) + (e << 16 >>> 16) * esign) >> 0)) >> 0;
		}
		if (!((i === s.length))) {
			return ok;
		}
		ok = true;
		return ok;
	};
	decimal.prototype.set = function(s) { return this.go$val.set(s); };
	var readFloat = function(s) {
		var mantissa, exp, neg, trunc, ok, i, sawdot, sawdigits, nd, ndMant, dp, c, _ref, x, esign, e, x$1;
		mantissa = new Go$Uint64(0, 0);
		exp = 0;
		neg = false;
		trunc = false;
		ok = false;
		i = 0;
		if (i >= s.length) {
			return [mantissa, exp, neg, trunc, ok];
		}
		if (s.charCodeAt(i) === 43) {
			i = i + 1 >> 0;
		} else if (s.charCodeAt(i) === 45) {
			neg = true;
			i = i + 1 >> 0;
		}
		sawdot = false;
		sawdigits = false;
		nd = 0;
		ndMant = 0;
		dp = 0;
		while (i < s.length) {
			c = s.charCodeAt(i);
			_ref = true;
			if (_ref === (c === 46)) {
				if (sawdot) {
					return [mantissa, exp, neg, trunc, ok];
				}
				sawdot = true;
				dp = nd;
				i = i + 1 >> 0;
				continue;
			} else if (_ref === 48 <= c && c <= 57) {
				sawdigits = true;
				if ((c === 48) && (nd === 0)) {
					dp = dp - 1 >> 0;
					i = i + 1 >> 0;
					continue;
				}
				nd = nd + 1 >> 0;
				if (ndMant < 19) {
					mantissa = go$mul64(mantissa, new Go$Uint64(0, 10));
					mantissa = (x = new Go$Uint64(0, (c - 48 << 24 >>> 24)), new Go$Uint64(mantissa.high + x.high, mantissa.low + x.low));
					ndMant = ndMant + 1 >> 0;
				} else if (!((s.charCodeAt(i) === 48))) {
					trunc = true;
				}
				i = i + 1 >> 0;
				continue;
			}
			break;
		}
		if (!sawdigits) {
			return [mantissa, exp, neg, trunc, ok];
		}
		if (!sawdot) {
			dp = nd;
		}
		if (i < s.length && ((s.charCodeAt(i) === 101) || (s.charCodeAt(i) === 69))) {
			i = i + 1 >> 0;
			if (i >= s.length) {
				return [mantissa, exp, neg, trunc, ok];
			}
			esign = 1;
			if (s.charCodeAt(i) === 43) {
				i = i + 1 >> 0;
			} else if (s.charCodeAt(i) === 45) {
				i = i + 1 >> 0;
				esign = -1;
			}
			if (i >= s.length || s.charCodeAt(i) < 48 || s.charCodeAt(i) > 57) {
				return [mantissa, exp, neg, trunc, ok];
			}
			e = 0;
			while (i < s.length && 48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {
				if (e < 10000) {
					e = ((x$1 = 10, (((e >>> 16 << 16) * x$1 >> 0) + (e << 16 >>> 16) * x$1) >> 0) + (s.charCodeAt(i) >> 0) >> 0) - 48 >> 0;
				}
				i = i + 1 >> 0;
			}
			dp = dp + (((((e >>> 16 << 16) * esign >> 0) + (e << 16 >>> 16) * esign) >> 0)) >> 0;
		}
		if (!((i === s.length))) {
			return [mantissa, exp, neg, trunc, ok];
		}
		exp = dp - ndMant >> 0;
		ok = true;
		return [mantissa, exp, neg, trunc, ok];
	};
	decimal.Ptr.prototype.floatBits = function(flt) {
		var b, overflow, d, exp, mant, n, _slice, _index, n$1, _slice$1, _index$1, n$2, y, x, y$1, x$1, x$2, y$2, x$3, x$4, bits, x$5, y$3, x$6, _tuple;
		b = new Go$Uint64(0, 0);
		overflow = false;
		d = this;
		exp = 0;
		mant = new Go$Uint64(0, 0);
		if (d.nd === 0) {
			mant = new Go$Uint64(0, 0);
			exp = flt.bias;
			go$notSupported("goto");
		}
		if (d.dp > 310) {
			go$notSupported("goto");
		}
		if (d.dp < -330) {
			mant = new Go$Uint64(0, 0);
			exp = flt.bias;
			go$notSupported("goto");
		}
		exp = 0;
		while (d.dp > 0) {
			n = 0;
			if (d.dp >= powtab.length) {
				n = 27;
			} else {
				n = (_slice = powtab, _index = d.dp, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			}
			d.Shift(-n);
			exp = exp + (n) >> 0;
		}
		while (d.dp < 0 || (d.dp === 0) && d.d[0] < 53) {
			n$1 = 0;
			if (-d.dp >= powtab.length) {
				n$1 = 27;
			} else {
				n$1 = (_slice$1 = powtab, _index$1 = -d.dp, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			}
			d.Shift(n$1);
			exp = exp - (n$1) >> 0;
		}
		exp = exp - 1 >> 0;
		if (exp < (flt.bias + 1 >> 0)) {
			n$2 = (flt.bias + 1 >> 0) - exp >> 0;
			d.Shift(-n$2);
			exp = exp + (n$2) >> 0;
		}
		if ((exp - flt.bias >> 0) >= (((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0)) {
			go$notSupported("goto");
		}
		d.Shift(((1 + flt.mantbits >>> 0) >> 0));
		mant = d.RoundedInteger();
		if ((x = go$shiftLeft64(new Go$Uint64(0, 2), flt.mantbits), (mant.high === x.high && mant.low === x.low))) {
			mant = go$shiftRightUint64(mant, 1);
			exp = exp + 1 >> 0;
			if ((exp - flt.bias >> 0) >= (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0)) {
				go$notSupported("goto");
			}
		}
		if ((x$1 = (x$2 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), new Go$Uint64(mant.high & x$2.high, (mant.low & x$2.low) >>> 0)), (x$1.high === 0 && x$1.low === 0))) {
			exp = flt.bias;
		}
		go$notSupported("goto");
		overflow: mant = new Go$Uint64(0, 0);
		exp = (((y$2 = flt.expbits, y$2 < 32 ? (1 << y$2) : 0) >> 0) - 1 >> 0) + flt.bias >> 0;
		overflow = true;
		out: bits = (x$3 = (x$4 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), new Go$Uint64(x$4.high - 0, x$4.low - 1)), new Go$Uint64(mant.high & x$3.high, (mant.low & x$3.low) >>> 0));
		bits = (x$5 = go$shiftLeft64(new Go$Uint64(0, (((exp - flt.bias >> 0)) & ((((y$3 = flt.expbits, y$3 < 32 ? (1 << y$3) : 0) >> 0) - 1 >> 0)))), flt.mantbits), new Go$Uint64(bits.high | x$5.high, (bits.low | x$5.low) >>> 0));
		if (d.neg) {
			bits = (x$6 = go$shiftLeft64(go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), flt.expbits), new Go$Uint64(bits.high | x$6.high, (bits.low | x$6.low) >>> 0));
		}
		_tuple = [bits, overflow], b = _tuple[0], overflow = _tuple[1];
		return [b, overflow];
	};
	decimal.prototype.floatBits = function(flt) { return this.go$val.floatBits(flt); };
	decimal.Ptr.prototype.atof32int = function() {
		var d, f, i;
		d = this;
		f = 0;
		i = 0;
		while (i < d.nd) {
			f = f * 10 + (d.d[i] - 48 << 24 >>> 24);
			i = i + 1 >> 0;
		}
		if (d.neg) {
			f = -f;
		}
		return f;
	};
	decimal.prototype.atof32int = function() { return this.go$val.atof32int(); };
	var atof64exact = function(mantissa, exp, neg) {
		var f, ok, x, _tuple, _slice, _index, _slice$1, _index$1, _tuple$1, _slice$2, _index$2, _tuple$2;
		f = 0;
		ok = false;
		if (!((x = go$shiftRightUint64(mantissa, float64info.mantbits), (x.high === 0 && x.low === 0)))) {
			return [f, ok];
		}
		f = go$flatten64(mantissa);
		if (neg) {
			f = -f;
		}
		if (exp === 0) {
			_tuple = [f, true], f = _tuple[0], ok = _tuple[1];
			return [f, ok];
		} else if (exp > 0 && exp <= 37) {
			if (exp > 22) {
				f = f * ((_slice = float64pow10, _index = (exp - 22 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
				exp = 22;
			}
			if (f > 1e+15 || f < -1e+15) {
				return [f, ok];
			}
			_tuple$1 = [f * (_slice$1 = float64pow10, _index$1 = exp, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), true], f = _tuple$1[0], ok = _tuple$1[1];
			return [f, ok];
		} else if (exp < 0 && exp >= -22) {
			_tuple$2 = [f / (_slice$2 = float64pow10, _index$2 = -exp, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), true], f = _tuple$2[0], ok = _tuple$2[1];
			return [f, ok];
		}
		return [f, ok];
	};
	var atof32exact = function(mantissa, exp, neg) {
		var f, ok, x, _tuple, _slice, _index, _slice$1, _index$1, _tuple$1, _slice$2, _index$2, _tuple$2;
		f = 0;
		ok = false;
		if (!((x = go$shiftRightUint64(mantissa, float32info.mantbits), (x.high === 0 && x.low === 0)))) {
			return [f, ok];
		}
		f = go$flatten64(mantissa);
		if (neg) {
			f = -f;
		}
		if (exp === 0) {
			_tuple = [f, true], f = _tuple[0], ok = _tuple[1];
			return [f, ok];
		} else if (exp > 0 && exp <= 17) {
			if (exp > 10) {
				f = f * ((_slice = float32pow10, _index = (exp - 10 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
				exp = 10;
			}
			if (f > 1e+07 || f < -1e+07) {
				return [f, ok];
			}
			_tuple$1 = [f * (_slice$1 = float32pow10, _index$1 = exp, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), true], f = _tuple$1[0], ok = _tuple$1[1];
			return [f, ok];
		} else if (exp < 0 && exp >= -10) {
			_tuple$2 = [f / (_slice$2 = float32pow10, _index$2 = -exp, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), true], f = _tuple$2[0], ok = _tuple$2[1];
			return [f, ok];
		}
		return [f, ok];
	};
	var atof32 = function(s) {
		var f, err, ok, _tuple, val, _tuple$1, _tuple$2, mantissa, exp, neg, trunc, ok$1, ok$2, _tuple$3, f$1, _tuple$4, ext, ok$3, _tuple$5, b, ovf, _tuple$6, d, _tuple$7, _tuple$8, b$1, ovf$1, _tuple$9;
		f = 0;
		err = null;
		if (_tuple = special(s), val = _tuple[0], ok = _tuple[1], ok) {
			_tuple$1 = [val, null], f = _tuple$1[0], err = _tuple$1[1];
			return [f, err];
		}
		if (optimize) {
			_tuple$2 = readFloat(s), mantissa = _tuple$2[0], exp = _tuple$2[1], neg = _tuple$2[2], trunc = _tuple$2[3], ok$1 = _tuple$2[4];
			if (ok$1) {
				if (!trunc) {
					if (_tuple$3 = atof32exact(mantissa, exp, neg), f$1 = _tuple$3[0], ok$2 = _tuple$3[1], ok$2) {
						_tuple$4 = [f$1, null], f = _tuple$4[0], err = _tuple$4[1];
						return [f, err];
					}
				}
				ext = new extFloat.Ptr();
				if (ok$3 = ext.AssignDecimal(mantissa, exp, neg, trunc, float32info), ok$3) {
					_tuple$5 = ext.floatBits(float32info), b = _tuple$5[0], ovf = _tuple$5[1];
					f = math.Float32frombits((b.low >>> 0));
					if (ovf) {
						err = rangeError("ParseFloat", s);
					}
					_tuple$6 = [f, err], f = _tuple$6[0], err = _tuple$6[1];
					return [f, err];
				}
			}
		}
		d = new decimal.Ptr();
		if (!d.set(s)) {
			_tuple$7 = [0, syntaxError("ParseFloat", s)], f = _tuple$7[0], err = _tuple$7[1];
			return [f, err];
		}
		_tuple$8 = d.floatBits(float32info), b$1 = _tuple$8[0], ovf$1 = _tuple$8[1];
		f = math.Float32frombits((b$1.low >>> 0));
		if (ovf$1) {
			err = rangeError("ParseFloat", s);
		}
		_tuple$9 = [f, err], f = _tuple$9[0], err = _tuple$9[1];
		return [f, err];
	};
	var atof64 = function(s) {
		var f, err, ok, _tuple, val, _tuple$1, _tuple$2, mantissa, exp, neg, trunc, ok$1, ok$2, _tuple$3, f$1, _tuple$4, ext, ok$3, _tuple$5, b, ovf, _tuple$6, d, _tuple$7, _tuple$8, b$1, ovf$1, _tuple$9;
		f = 0;
		err = null;
		if (_tuple = special(s), val = _tuple[0], ok = _tuple[1], ok) {
			_tuple$1 = [val, null], f = _tuple$1[0], err = _tuple$1[1];
			return [f, err];
		}
		if (optimize) {
			_tuple$2 = readFloat(s), mantissa = _tuple$2[0], exp = _tuple$2[1], neg = _tuple$2[2], trunc = _tuple$2[3], ok$1 = _tuple$2[4];
			if (ok$1) {
				if (!trunc) {
					if (_tuple$3 = atof64exact(mantissa, exp, neg), f$1 = _tuple$3[0], ok$2 = _tuple$3[1], ok$2) {
						_tuple$4 = [f$1, null], f = _tuple$4[0], err = _tuple$4[1];
						return [f, err];
					}
				}
				ext = new extFloat.Ptr();
				if (ok$3 = ext.AssignDecimal(mantissa, exp, neg, trunc, float64info), ok$3) {
					_tuple$5 = ext.floatBits(float64info), b = _tuple$5[0], ovf = _tuple$5[1];
					f = math.Float64frombits(b);
					if (ovf) {
						err = rangeError("ParseFloat", s);
					}
					_tuple$6 = [f, err], f = _tuple$6[0], err = _tuple$6[1];
					return [f, err];
				}
			}
		}
		d = new decimal.Ptr();
		if (!d.set(s)) {
			_tuple$7 = [0, syntaxError("ParseFloat", s)], f = _tuple$7[0], err = _tuple$7[1];
			return [f, err];
		}
		_tuple$8 = d.floatBits(float64info), b$1 = _tuple$8[0], ovf$1 = _tuple$8[1];
		f = math.Float64frombits(b$1);
		if (ovf$1) {
			err = rangeError("ParseFloat", s);
		}
		_tuple$9 = [f, err], f = _tuple$9[0], err = _tuple$9[1];
		return [f, err];
	};
	var ParseFloat = go$pkg.ParseFloat = function(s, bitSize) {
		var f, err, _tuple, f1, err1, _tuple$1, _tuple$2, f1$1, err1$1, _tuple$3;
		f = 0;
		err = null;
		if (bitSize === 32) {
			_tuple = atof32(s), f1 = _tuple[0], err1 = _tuple[1];
			_tuple$1 = [f1, err1], f = _tuple$1[0], err = _tuple$1[1];
			return [f, err];
		}
		_tuple$2 = atof64(s), f1$1 = _tuple$2[0], err1$1 = _tuple$2[1];
		_tuple$3 = [f1$1, err1$1], f = _tuple$3[0], err = _tuple$3[1];
		return [f, err];
	};
	NumError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "strconv." + e.Func + ": " + "parsing " + Quote(e.Num) + ": " + e.Err.Error();
	};
	NumError.prototype.Error = function() { return this.go$val.Error(); };
	var syntaxError = function(fn, str) {
		return new NumError.Ptr(fn, str, go$pkg.ErrSyntax);
	};
	var rangeError = function(fn, str) {
		return new NumError.Ptr(fn, str, go$pkg.ErrRange);
	};
	var cutoff64 = function(base) {
		var x;
		if (base < 2) {
			return new Go$Uint64(0, 0);
		}
		return (x = go$div64(new Go$Uint64(4294967295, 4294967295), new Go$Uint64(0, base), false), new Go$Uint64(x.high + 0, x.low + 1));
	};
	var ParseUint = go$pkg.ParseUint = function(s, base, bitSize) {
		var n, err, _tuple, cutoff, maxVal, s0, x, i, v, d, x$1, n1, _tuple$1, _tuple$2;
		n = new Go$Uint64(0, 0);
		err = null;
		_tuple = [new Go$Uint64(0, 0), new Go$Uint64(0, 0)], cutoff = _tuple[0], maxVal = _tuple[1];
		if (bitSize === 0) {
			bitSize = 32;
		}
		s0 = s;
		if (s.length < 1) {
			err = go$pkg.ErrSyntax;
			go$notSupported("goto");
		} else if (2 <= base && base <= 36) {
		} else if (base === 0) {
			if ((s.charCodeAt(0) === 48) && s.length > 1 && ((s.charCodeAt(1) === 120) || (s.charCodeAt(1) === 88))) {
				base = 16;
				s = s.substring(2);
				if (s.length < 1) {
					err = go$pkg.ErrSyntax;
					go$notSupported("goto");
				}
			} else if (s.charCodeAt(0) === 48) {
				base = 8;
			} else {
				base = 10;
			}
		} else {
			err = errors.New("invalid base " + Itoa(base));
			go$notSupported("goto");
		}
		n = new Go$Uint64(0, 0);
		cutoff = cutoff64(base);
		maxVal = (x = go$shiftLeft64(new Go$Uint64(0, 1), (bitSize >>> 0)), new Go$Uint64(x.high - 0, x.low - 1));
		i = 0;
		while (i < s.length) {
			v = 0;
			d = s.charCodeAt(i);
			if (48 <= d && d <= 57) {
				v = d - 48 << 24 >>> 24;
			} else if (97 <= d && d <= 122) {
				v = (d - 97 << 24 >>> 24) + 10 << 24 >>> 24;
			} else if (65 <= d && d <= 90) {
				v = (d - 65 << 24 >>> 24) + 10 << 24 >>> 24;
			} else {
				n = new Go$Uint64(0, 0);
				err = go$pkg.ErrSyntax;
				go$notSupported("goto");
			}
			if ((v >> 0) >= base) {
				n = new Go$Uint64(0, 0);
				err = go$pkg.ErrSyntax;
				go$notSupported("goto");
			}
			if ((n.high > cutoff.high || (n.high === cutoff.high && n.low >= cutoff.low))) {
				n = new Go$Uint64(4294967295, 4294967295);
				err = go$pkg.ErrRange;
				go$notSupported("goto");
			}
			n = go$mul64(n, (new Go$Uint64(0, base)));
			n1 = (x$1 = new Go$Uint64(0, v), new Go$Uint64(n.high + x$1.high, n.low + x$1.low));
			if ((n1.high < n.high || (n1.high === n.high && n1.low < n.low)) || (n1.high > maxVal.high || (n1.high === maxVal.high && n1.low > maxVal.low))) {
				n = new Go$Uint64(4294967295, 4294967295);
				err = go$pkg.ErrRange;
				go$notSupported("goto");
			}
			n = n1;
			i = i + 1 >> 0;
		}
		_tuple$1 = [n, null], n = _tuple$1[0], err = _tuple$1[1];
		return [n, err];
		Error: _tuple$2 = [n, new NumError.Ptr("ParseUint", s0, err)], n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	var ParseInt = go$pkg.ParseInt = function(s, base, bitSize) {
		var i, err, _tuple, s0, neg, un, _tuple$1, _tuple$2, cutoff, x, _tuple$3, x$1, _tuple$4, n, _tuple$5;
		i = new Go$Int64(0, 0);
		err = null;
		if (bitSize === 0) {
			bitSize = 32;
		}
		if (s.length === 0) {
			_tuple = [new Go$Int64(0, 0), syntaxError("ParseInt", s)], i = _tuple[0], err = _tuple[1];
			return [i, err];
		}
		s0 = s;
		neg = false;
		if (s.charCodeAt(0) === 43) {
			s = s.substring(1);
		} else if (s.charCodeAt(0) === 45) {
			neg = true;
			s = s.substring(1);
		}
		un = new Go$Uint64(0, 0);
		_tuple$1 = ParseUint(s, base, bitSize), un = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null)) && !(go$interfaceIsEqual((err !== null && err.constructor === (go$ptrType(NumError)) ? err.go$val : go$typeAssertionFailed(err, (go$ptrType(NumError)))).Err, go$pkg.ErrRange))) {
			(err !== null && err.constructor === (go$ptrType(NumError)) ? err.go$val : go$typeAssertionFailed(err, (go$ptrType(NumError)))).Func = "ParseInt";
			(err !== null && err.constructor === (go$ptrType(NumError)) ? err.go$val : go$typeAssertionFailed(err, (go$ptrType(NumError)))).Num = s0;
			_tuple$2 = [new Go$Int64(0, 0), err], i = _tuple$2[0], err = _tuple$2[1];
			return [i, err];
		}
		cutoff = go$shiftLeft64(new Go$Uint64(0, 1), ((bitSize - 1 >> 0) >>> 0));
		if (!neg && (un.high > cutoff.high || (un.high === cutoff.high && un.low >= cutoff.low))) {
			_tuple$3 = [(x = new Go$Uint64(cutoff.high - 0, cutoff.low - 1), new Go$Int64(x.high, x.low)), rangeError("ParseInt", s0)], i = _tuple$3[0], err = _tuple$3[1];
			return [i, err];
		}
		if (neg && (un.high > cutoff.high || (un.high === cutoff.high && un.low > cutoff.low))) {
			_tuple$4 = [(x$1 = new Go$Int64(cutoff.high, cutoff.low), new Go$Int64(-x$1.high, -x$1.low)), rangeError("ParseInt", s0)], i = _tuple$4[0], err = _tuple$4[1];
			return [i, err];
		}
		n = new Go$Int64(un.high, un.low);
		if (neg) {
			n = new Go$Int64(-n.high, -n.low);
		}
		_tuple$5 = [n, null], i = _tuple$5[0], err = _tuple$5[1];
		return [i, err];
	};
	var Atoi = go$pkg.Atoi = function(s) {
		var i, err, _tuple, i64, _tuple$1;
		i = 0;
		err = null;
		_tuple = ParseInt(s, 10, 0), i64 = _tuple[0], err = _tuple[1];
		_tuple$1 = [((i64.low + ((i64.high >> 31) * 4294967296)) >> 0), err], i = _tuple$1[0], err = _tuple$1[1];
		return [i, err];
	};
	decimal.Ptr.prototype.String = function() {
		var a, n, buf, w, _slice, _index, _slice$1, _index$1, _slice$2, _index$2;
		a = this;
		n = 10 + a.nd >> 0;
		if (a.dp > 0) {
			n = n + (a.dp) >> 0;
		}
		if (a.dp < 0) {
			n = n + (-a.dp) >> 0;
		}
		buf = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
		w = 0;
		if (a.nd === 0) {
			return "0";
		} else if (a.dp <= 0) {
			_slice = buf, _index = w, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 48) : go$throwRuntimeError("index out of range");
			w = w + 1 >> 0;
			_slice$1 = buf, _index$1 = w, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 46) : go$throwRuntimeError("index out of range");
			w = w + 1 >> 0;
			w = w + (digitZero(go$subslice(buf, w, (w + -a.dp >> 0)))) >> 0;
			w = w + (go$copySlice(go$subslice(buf, w), go$subslice(new (go$sliceType(Go$Uint8))(a.d), 0, a.nd))) >> 0;
		} else if (a.dp < a.nd) {
			w = w + (go$copySlice(go$subslice(buf, w), go$subslice(new (go$sliceType(Go$Uint8))(a.d), 0, a.dp))) >> 0;
			_slice$2 = buf, _index$2 = w, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 46) : go$throwRuntimeError("index out of range");
			w = w + 1 >> 0;
			w = w + (go$copySlice(go$subslice(buf, w), go$subslice(new (go$sliceType(Go$Uint8))(a.d), a.dp, a.nd))) >> 0;
		} else {
			w = w + (go$copySlice(go$subslice(buf, w), go$subslice(new (go$sliceType(Go$Uint8))(a.d), 0, a.nd))) >> 0;
			w = w + (digitZero(go$subslice(buf, w, ((w + a.dp >> 0) - a.nd >> 0)))) >> 0;
		}
		return go$bytesToString(go$subslice(buf, 0, w));
	};
	decimal.prototype.String = function() { return this.go$val.String(); };
	var digitZero = function(dst) {
		var _ref, _i, i, _slice, _index;
		_ref = dst;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			_slice = dst, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 48) : go$throwRuntimeError("index out of range");
			_i++;
		}
		return dst.length;
	};
	var trim = function(a) {
		while (a.nd > 0 && (a.d[(a.nd - 1 >> 0)] === 48)) {
			a.nd = a.nd - 1 >> 0;
		}
		if (a.nd === 0) {
			a.dp = 0;
		}
	};
	decimal.Ptr.prototype.Assign = function(v) {
		var a, buf, n, v1, x;
		a = this;
		buf = go$makeNativeArray("Uint8", 24, function() { return 0; });
		n = 0;
		while ((v.high > 0 || (v.high === 0 && v.low > 0))) {
			v1 = go$div64(v, new Go$Uint64(0, 10), false);
			v = (x = go$mul64(new Go$Uint64(0, 10), v1), new Go$Uint64(v.high - x.high, v.low - x.low));
			buf[n] = (new Go$Uint64(v.high + 0, v.low + 48).low << 24 >>> 24);
			n = n + 1 >> 0;
			v = v1;
		}
		a.nd = 0;
		n = n - 1 >> 0;
		while (n >= 0) {
			a.d[a.nd] = buf[n];
			a.nd = a.nd + 1 >> 0;
			n = n - 1 >> 0;
		}
		a.dp = a.nd;
		trim(a);
	};
	decimal.prototype.Assign = function(v) { return this.go$val.Assign(v); };
	var rightShift = function(a, k) {
		var r, w, n, x, c, x$1, c$1, dig, y, x$2, dig$1, y$1, x$3;
		r = 0;
		w = 0;
		n = 0;
		while (((n >> go$min(k, 31)) >> 0) === 0) {
			if (r >= a.nd) {
				if (n === 0) {
					a.nd = 0;
					return;
				}
				while (((n >> go$min(k, 31)) >> 0) === 0) {
					n = (x = 10, (((n >>> 16 << 16) * x >> 0) + (n << 16 >>> 16) * x) >> 0);
					r = r + 1 >> 0;
				}
				break;
			}
			c = (a.d[r] >> 0);
			n = ((x$1 = 10, (((n >>> 16 << 16) * x$1 >> 0) + (n << 16 >>> 16) * x$1) >> 0) + c >> 0) - 48 >> 0;
			r = r + 1 >> 0;
		}
		a.dp = a.dp - ((r - 1 >> 0)) >> 0;
		while (r < a.nd) {
			c$1 = (a.d[r] >> 0);
			dig = (n >> go$min(k, 31)) >> 0;
			n = n - (((y = k, y < 32 ? (dig << y) : 0) >> 0)) >> 0;
			a.d[w] = ((dig + 48 >> 0) << 24 >>> 24);
			w = w + 1 >> 0;
			n = ((x$2 = 10, (((n >>> 16 << 16) * x$2 >> 0) + (n << 16 >>> 16) * x$2) >> 0) + c$1 >> 0) - 48 >> 0;
			r = r + 1 >> 0;
		}
		while (n > 0) {
			dig$1 = (n >> go$min(k, 31)) >> 0;
			n = n - (((y$1 = k, y$1 < 32 ? (dig$1 << y$1) : 0) >> 0)) >> 0;
			if (w < 800) {
				a.d[w] = ((dig$1 + 48 >> 0) << 24 >>> 24);
				w = w + 1 >> 0;
			} else if (dig$1 > 0) {
				a.trunc = true;
			}
			n = (x$3 = 10, (((n >>> 16 << 16) * x$3 >> 0) + (n << 16 >>> 16) * x$3) >> 0);
		}
		a.nd = w;
		trim(a);
	};
	var prefixIsLessThan = function(b, s) {
		var i, _slice, _index, _slice$1, _index$1;
		i = 0;
		while (i < s.length) {
			if (i >= b.length) {
				return true;
			}
			if (!(((_slice = b, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === s.charCodeAt(i)))) {
				return (_slice$1 = b, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) < s.charCodeAt(i);
			}
			i = i + 1 >> 0;
		}
		return false;
	};
	var leftShift = function(a, k) {
		var _slice, _index, delta, _slice$1, _index$1, r, w, n, y, _q, quo, x, rem, _q$1, quo$1, x$1, rem$1;
		delta = (_slice = leftcheats, _index = k, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).delta;
		if (prefixIsLessThan(go$subslice(new (go$sliceType(Go$Uint8))(a.d), 0, a.nd), (_slice$1 = leftcheats, _index$1 = k, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).cutoff)) {
			delta = delta - 1 >> 0;
		}
		r = a.nd;
		w = a.nd + delta >> 0;
		n = 0;
		r = r - 1 >> 0;
		while (r >= 0) {
			n = n + (((y = k, y < 32 ? ((((a.d[r] >> 0) - 48 >> 0)) << y) : 0) >> 0)) >> 0;
			quo = (_q = n / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
			rem = n - (x = 10, (((x >>> 16 << 16) * quo >> 0) + (x << 16 >>> 16) * quo) >> 0) >> 0;
			w = w - 1 >> 0;
			if (w < 800) {
				a.d[w] = ((rem + 48 >> 0) << 24 >>> 24);
			} else if (!((rem === 0))) {
				a.trunc = true;
			}
			n = quo;
			r = r - 1 >> 0;
		}
		while (n > 0) {
			quo$1 = (_q$1 = n / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
			rem$1 = n - (x$1 = 10, (((x$1 >>> 16 << 16) * quo$1 >> 0) + (x$1 << 16 >>> 16) * quo$1) >> 0) >> 0;
			w = w - 1 >> 0;
			if (w < 800) {
				a.d[w] = ((rem$1 + 48 >> 0) << 24 >>> 24);
			} else if (!((rem$1 === 0))) {
				a.trunc = true;
			}
			n = quo$1;
		}
		a.nd = a.nd + (delta) >> 0;
		if (a.nd >= 800) {
			a.nd = 800;
		}
		a.dp = a.dp + (delta) >> 0;
		trim(a);
	};
	decimal.Ptr.prototype.Shift = function(k) {
		var a;
		a = this;
		if (a.nd === 0) {
		} else if (k > 0) {
			while (k > 27) {
				leftShift(a, 27);
				k = k - 27 >> 0;
			}
			leftShift(a, (k >>> 0));
		} else if (k < 0) {
			while (k < -27) {
				rightShift(a, 27);
				k = k + 27 >> 0;
			}
			rightShift(a, (-k >>> 0));
		}
	};
	decimal.prototype.Shift = function(k) { return this.go$val.Shift(k); };
	var shouldRoundUp = function(a, nd) {
		var _r;
		if (nd < 0 || nd >= a.nd) {
			return false;
		}
		if ((a.d[nd] === 53) && ((nd + 1 >> 0) === a.nd)) {
			if (a.trunc) {
				return true;
			}
			return nd > 0 && !(((_r = ((a.d[(nd - 1 >> 0)] - 48 << 24 >>> 24)) % 2, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0));
		}
		return a.d[nd] >= 53;
	};
	decimal.Ptr.prototype.Round = function(nd) {
		var a;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		if (shouldRoundUp(a, nd)) {
			a.RoundUp(nd);
		} else {
			a.RoundDown(nd);
		}
	};
	decimal.prototype.Round = function(nd) { return this.go$val.Round(nd); };
	decimal.Ptr.prototype.RoundDown = function(nd) {
		var a;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		a.nd = nd;
		trim(a);
	};
	decimal.prototype.RoundDown = function(nd) { return this.go$val.RoundDown(nd); };
	decimal.Ptr.prototype.RoundUp = function(nd) {
		var a, i, c, _lhs, _index;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		i = nd - 1 >> 0;
		while (i >= 0) {
			c = a.d[i];
			if (c < 57) {
				_lhs = a.d, _index = i, _lhs[_index] = _lhs[_index] + 1 << 24 >>> 24;
				a.nd = i + 1 >> 0;
				return;
			}
			i = i - 1 >> 0;
		}
		a.d[0] = 49;
		a.nd = 1;
		a.dp = a.dp + 1 >> 0;
	};
	decimal.prototype.RoundUp = function(nd) { return this.go$val.RoundUp(nd); };
	decimal.Ptr.prototype.RoundedInteger = function() {
		var a, i, n, x, x$1;
		a = this;
		if (a.dp > 20) {
			return new Go$Uint64(4294967295, 4294967295);
		}
		i = 0;
		n = new Go$Uint64(0, 0);
		i = 0;
		while (i < a.dp && i < a.nd) {
			n = (x = go$mul64(n, new Go$Uint64(0, 10)), x$1 = new Go$Uint64(0, (a.d[i] - 48 << 24 >>> 24)), new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
			i = i + 1 >> 0;
		}
		while (i < a.dp) {
			n = go$mul64(n, new Go$Uint64(0, 10));
			i = i + 1 >> 0;
		}
		if (shouldRoundUp(a, a.dp)) {
			n = new Go$Uint64(n.high + 0, n.low + 1);
		}
		return n;
	};
	decimal.prototype.RoundedInteger = function() { return this.go$val.RoundedInteger(); };
	extFloat.Ptr.prototype.floatBits = function(flt) {
		var bits, overflow, f, exp, n, mant, x, x$1, x$2, x$3, y, x$4, x$5, y$1, x$6, x$7, x$8, y$2, x$9;
		bits = new Go$Uint64(0, 0);
		overflow = false;
		f = this;
		f.Normalize();
		exp = f.exp + 63 >> 0;
		if (exp < (flt.bias + 1 >> 0)) {
			n = (flt.bias + 1 >> 0) - exp >> 0;
			f.mant = go$shiftRightUint64(f.mant, ((n >>> 0)));
			exp = exp + (n) >> 0;
		}
		mant = go$shiftRightUint64(f.mant, ((63 - flt.mantbits >>> 0)));
		if (!((x = (x$1 = f.mant, x$2 = go$shiftLeft64(new Go$Uint64(0, 1), ((62 - flt.mantbits >>> 0))), new Go$Uint64(x$1.high & x$2.high, (x$1.low & x$2.low) >>> 0)), (x.high === 0 && x.low === 0)))) {
			mant = new Go$Uint64(mant.high + 0, mant.low + 1);
		}
		if ((x$3 = go$shiftLeft64(new Go$Uint64(0, 2), flt.mantbits), (mant.high === x$3.high && mant.low === x$3.low))) {
			mant = go$shiftRightUint64(mant, 1);
			exp = exp + 1 >> 0;
		}
		if ((exp - flt.bias >> 0) >= (((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0)) {
			mant = new Go$Uint64(0, 0);
			exp = (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0) + flt.bias >> 0;
			overflow = true;
		} else if ((x$4 = (x$5 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), new Go$Uint64(mant.high & x$5.high, (mant.low & x$5.low) >>> 0)), (x$4.high === 0 && x$4.low === 0))) {
			exp = flt.bias;
		}
		bits = (x$6 = (x$7 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), new Go$Uint64(x$7.high - 0, x$7.low - 1)), new Go$Uint64(mant.high & x$6.high, (mant.low & x$6.low) >>> 0));
		bits = (x$8 = go$shiftLeft64(new Go$Uint64(0, (((exp - flt.bias >> 0)) & ((((y$2 = flt.expbits, y$2 < 32 ? (1 << y$2) : 0) >> 0) - 1 >> 0)))), flt.mantbits), new Go$Uint64(bits.high | x$8.high, (bits.low | x$8.low) >>> 0));
		if (f.neg) {
			bits = (x$9 = go$shiftLeft64(new Go$Uint64(0, 1), ((flt.mantbits + flt.expbits >>> 0))), new Go$Uint64(bits.high | x$9.high, (bits.low | x$9.low) >>> 0));
		}
		return [bits, overflow];
	};
	extFloat.prototype.floatBits = function(flt) { return this.go$val.floatBits(flt); };
	extFloat.Ptr.prototype.AssignComputeBounds = function(mant, exp, neg, flt) {
		var lower, upper, f, x, _struct, _struct$1, _tuple, _struct$2, _struct$3, expBiased, x$1, x$2, x$3, x$4, _struct$4, _struct$5;
		lower = new extFloat.Ptr();
		upper = new extFloat.Ptr();
		f = this;
		f.mant = mant;
		f.exp = exp - (flt.mantbits >> 0) >> 0;
		f.neg = neg;
		if (f.exp <= 0 && (x = go$shiftLeft64((go$shiftRightUint64(mant, (-f.exp >>> 0))), (-f.exp >>> 0)), (mant.high === x.high && mant.low === x.low))) {
			f.mant = go$shiftRightUint64(f.mant, ((-f.exp >>> 0)));
			f.exp = 0;
			_tuple = [(_struct = f, new extFloat.Ptr(_struct.mant, _struct.exp, _struct.neg)), (_struct$1 = f, new extFloat.Ptr(_struct$1.mant, _struct$1.exp, _struct$1.neg))], lower = _tuple[0], upper = _tuple[1];
			return [(_struct$2 = lower, new extFloat.Ptr(_struct$2.mant, _struct$2.exp, _struct$2.neg)), (_struct$3 = upper, new extFloat.Ptr(_struct$3.mant, _struct$3.exp, _struct$3.neg))];
		}
		expBiased = exp - flt.bias >> 0;
		upper = new extFloat.Ptr((x$1 = go$mul64(new Go$Uint64(0, 2), f.mant), new Go$Uint64(x$1.high + 0, x$1.low + 1)), f.exp - 1 >> 0, f.neg);
		if (!((x$2 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), (mant.high === x$2.high && mant.low === x$2.low))) || (expBiased === 1)) {
			lower = new extFloat.Ptr((x$3 = go$mul64(new Go$Uint64(0, 2), f.mant), new Go$Uint64(x$3.high - 0, x$3.low - 1)), f.exp - 1 >> 0, f.neg);
		} else {
			lower = new extFloat.Ptr((x$4 = go$mul64(new Go$Uint64(0, 4), f.mant), new Go$Uint64(x$4.high - 0, x$4.low - 1)), f.exp - 2 >> 0, f.neg);
		}
		return [(_struct$4 = lower, new extFloat.Ptr(_struct$4.mant, _struct$4.exp, _struct$4.neg)), (_struct$5 = upper, new extFloat.Ptr(_struct$5.mant, _struct$5.exp, _struct$5.neg))];
	};
	extFloat.prototype.AssignComputeBounds = function(mant, exp, neg, flt) { return this.go$val.AssignComputeBounds(mant, exp, neg, flt); };
	extFloat.Ptr.prototype.Normalize = function() {
		var shift, f, _tuple, mant, exp, x, x$1, x$2, x$3, x$4, x$5, _tuple$1;
		shift = 0;
		f = this;
		_tuple = [f.mant, f.exp], mant = _tuple[0], exp = _tuple[1];
		if ((mant.high === 0 && mant.low === 0)) {
			shift = 0;
			return shift;
		}
		if ((x = go$shiftRightUint64(mant, 32), (x.high === 0 && x.low === 0))) {
			mant = go$shiftLeft64(mant, 32);
			exp = exp - 32 >> 0;
		}
		if ((x$1 = go$shiftRightUint64(mant, 48), (x$1.high === 0 && x$1.low === 0))) {
			mant = go$shiftLeft64(mant, 16);
			exp = exp - 16 >> 0;
		}
		if ((x$2 = go$shiftRightUint64(mant, 56), (x$2.high === 0 && x$2.low === 0))) {
			mant = go$shiftLeft64(mant, 8);
			exp = exp - 8 >> 0;
		}
		if ((x$3 = go$shiftRightUint64(mant, 60), (x$3.high === 0 && x$3.low === 0))) {
			mant = go$shiftLeft64(mant, 4);
			exp = exp - 4 >> 0;
		}
		if ((x$4 = go$shiftRightUint64(mant, 62), (x$4.high === 0 && x$4.low === 0))) {
			mant = go$shiftLeft64(mant, 2);
			exp = exp - 2 >> 0;
		}
		if ((x$5 = go$shiftRightUint64(mant, 63), (x$5.high === 0 && x$5.low === 0))) {
			mant = go$shiftLeft64(mant, 1);
			exp = exp - 1 >> 0;
		}
		shift = ((f.exp - exp >> 0) >>> 0);
		_tuple$1 = [mant, exp], f.mant = _tuple$1[0], f.exp = _tuple$1[1];
		return shift;
	};
	extFloat.prototype.Normalize = function() { return this.go$val.Normalize(); };
	extFloat.Ptr.prototype.Multiply = function(g) {
		var f, _tuple, fhi, flo, _tuple$1, ghi, glo, cross1, cross2, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, rem, x$8, x$9;
		f = this;
		_tuple = [go$shiftRightUint64(f.mant, 32), new Go$Uint64(0, (f.mant.low >>> 0))], fhi = _tuple[0], flo = _tuple[1];
		_tuple$1 = [go$shiftRightUint64(g.mant, 32), new Go$Uint64(0, (g.mant.low >>> 0))], ghi = _tuple$1[0], glo = _tuple$1[1];
		cross1 = go$mul64(fhi, glo);
		cross2 = go$mul64(flo, ghi);
		f.mant = (x = (x$1 = go$mul64(fhi, ghi), x$2 = go$shiftRightUint64(cross1, 32), new Go$Uint64(x$1.high + x$2.high, x$1.low + x$2.low)), x$3 = go$shiftRightUint64(cross2, 32), new Go$Uint64(x.high + x$3.high, x.low + x$3.low));
		rem = (x$4 = (x$5 = new Go$Uint64(0, (cross1.low >>> 0)), x$6 = new Go$Uint64(0, (cross2.low >>> 0)), new Go$Uint64(x$5.high + x$6.high, x$5.low + x$6.low)), x$7 = go$shiftRightUint64((go$mul64(flo, glo)), 32), new Go$Uint64(x$4.high + x$7.high, x$4.low + x$7.low));
		rem = new Go$Uint64(rem.high + 0, rem.low + 2147483648);
		f.mant = (x$8 = f.mant, x$9 = (go$shiftRightUint64(rem, 32)), new Go$Uint64(x$8.high + x$9.high, x$8.low + x$9.low));
		f.exp = (f.exp + g.exp >> 0) + 64 >> 0;
	};
	extFloat.prototype.Multiply = function(g) { return this.go$val.Multiply(g); };
	extFloat.Ptr.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) {
		var ok, f, errors$1, _q, i, _r, adjExp, x, _struct, _struct$1, shift, y, denormalExp, extrabits, halfway, x$1, x$2, x$3, mant_extra, x$4, x$5, x$6, x$7, x$8, x$9, x$10, x$11;
		ok = false;
		f = this;
		errors$1 = 0;
		if (trunc) {
			errors$1 = errors$1 + 4 >> 0;
		}
		f.mant = mantissa;
		f.exp = 0;
		f.neg = neg;
		i = (_q = ((exp10 - -348 >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		if (exp10 < -348 || i >= 87) {
			ok = false;
			return ok;
		}
		adjExp = (_r = ((exp10 - -348 >> 0)) % 8, _r === _r ? _r : go$throwRuntimeError("integer divide by zero"));
		if (adjExp < 19 && (x = uint64pow10[(19 - adjExp >> 0)], (mantissa.high < x.high || (mantissa.high === x.high && mantissa.low < x.low)))) {
			f.mant = go$mul64(f.mant, (uint64pow10[adjExp]));
			f.Normalize();
		} else {
			f.Normalize();
			f.Multiply((_struct = smallPowersOfTen[adjExp], new extFloat.Ptr(_struct.mant, _struct.exp, _struct.neg)));
			errors$1 = errors$1 + 4 >> 0;
		}
		f.Multiply((_struct$1 = powersOfTen[i], new extFloat.Ptr(_struct$1.mant, _struct$1.exp, _struct$1.neg)));
		if (errors$1 > 0) {
			errors$1 = errors$1 + 1 >> 0;
		}
		errors$1 = errors$1 + 4 >> 0;
		shift = f.Normalize();
		errors$1 = (y = (shift), y < 32 ? (errors$1 << y) : 0) >> 0;
		denormalExp = flt.bias - 63 >> 0;
		extrabits = 0;
		if (f.exp <= denormalExp) {
			extrabits = (((63 - flt.mantbits >>> 0) + 1 >>> 0) + ((denormalExp - f.exp >> 0) >>> 0) >>> 0);
		} else {
			extrabits = (63 - flt.mantbits >>> 0);
		}
		halfway = go$shiftLeft64(new Go$Uint64(0, 1), ((extrabits - 1 >>> 0)));
		mant_extra = (x$1 = f.mant, x$2 = (x$3 = go$shiftLeft64(new Go$Uint64(0, 1), extrabits), new Go$Uint64(x$3.high - 0, x$3.low - 1)), new Go$Uint64(x$1.high & x$2.high, (x$1.low & x$2.low) >>> 0));
		if ((x$4 = (x$5 = new Go$Int64(halfway.high, halfway.low), x$6 = new Go$Int64(0, errors$1), new Go$Int64(x$5.high - x$6.high, x$5.low - x$6.low)), x$7 = new Go$Int64(mant_extra.high, mant_extra.low), (x$4.high < x$7.high || (x$4.high === x$7.high && x$4.low < x$7.low))) && (x$8 = new Go$Int64(mant_extra.high, mant_extra.low), x$9 = (x$10 = new Go$Int64(halfway.high, halfway.low), x$11 = new Go$Int64(0, errors$1), new Go$Int64(x$10.high + x$11.high, x$10.low + x$11.low)), (x$8.high < x$9.high || (x$8.high === x$9.high && x$8.low < x$9.low)))) {
			ok = false;
			return ok;
		}
		ok = true;
		return ok;
	};
	extFloat.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) { return this.go$val.AssignDecimal(mantissa, exp10, neg, trunc, flt); };
	extFloat.Ptr.prototype.frexp10 = function() {
		var exp10, index, f, _q, x, x$1, approxExp10, _q$1, i, exp, _struct, _tuple;
		exp10 = 0;
		index = 0;
		f = this;
		approxExp10 = (_q = (x = (-46 - f.exp >> 0), x$1 = 28, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) / 93, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		i = (_q$1 = ((approxExp10 - -348 >> 0)) / 8, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
		Loop: while (true) {
			exp = (f.exp + powersOfTen[i].exp >> 0) + 64 >> 0;
			if (exp < -60) {
				i = i + 1 >> 0;
			} else if (exp > -32) {
				i = i - 1 >> 0;
			} else {
				break Loop;
			}
		}
		f.Multiply((_struct = powersOfTen[i], new extFloat.Ptr(_struct.mant, _struct.exp, _struct.neg)));
		_tuple = [-((-348 + ((((i >>> 16 << 16) * 8 >> 0) + (i << 16 >>> 16) * 8) >> 0) >> 0)), i], exp10 = _tuple[0], index = _tuple[1];
		return [exp10, index];
	};
	extFloat.prototype.frexp10 = function() { return this.go$val.frexp10(); };
	var frexp10Many = function(a, b, c) {
		var exp10, _tuple, i, _struct, _struct$1;
		exp10 = 0;
		_tuple = c.frexp10(), exp10 = _tuple[0], i = _tuple[1];
		a.Multiply((_struct = powersOfTen[i], new extFloat.Ptr(_struct.mant, _struct.exp, _struct.neg)));
		b.Multiply((_struct$1 = powersOfTen[i], new extFloat.Ptr(_struct$1.mant, _struct$1.exp, _struct$1.neg)));
		return exp10;
	};
	extFloat.Ptr.prototype.FixedDecimal = function(d, n) {
		var f, x, _tuple, exp10, shift, integer, x$1, x$2, fraction, nonAsciiName, needed, integerDigits, pow10, _tuple$1, i, pow, x$3, rest, _q, x$4, buf, pos, v, _q$1, v1, x$5, i$1, _slice, _index, nd, x$6, x$7, digit, _slice$1, _index$1, x$8, x$9, ok, i$2, _slice$2, _index$2;
		f = this;
		if ((x = f.mant, (x.high === 0 && x.low === 0))) {
			d.nd = 0;
			d.dp = 0;
			d.neg = f.neg;
			return true;
		}
		if (n === 0) {
			throw go$panic(new Go$String("strconv: internal error: extFloat.FixedDecimal called with n == 0"));
		}
		f.Normalize();
		_tuple = f.frexp10(), exp10 = _tuple[0];
		shift = (-f.exp >>> 0);
		integer = (go$shiftRightUint64(f.mant, shift).low >>> 0);
		fraction = (x$1 = f.mant, x$2 = go$shiftLeft64(new Go$Uint64(0, integer), shift), new Go$Uint64(x$1.high - x$2.high, x$1.low - x$2.low));
		nonAsciiName = new Go$Uint64(0, 1);
		needed = n;
		integerDigits = 0;
		pow10 = new Go$Uint64(0, 1);
		_tuple$1 = [0, new Go$Uint64(0, 1)], i = _tuple$1[0], pow = _tuple$1[1];
		while (i < 20) {
			if ((x$3 = new Go$Uint64(0, integer), (pow.high > x$3.high || (pow.high === x$3.high && pow.low > x$3.low)))) {
				integerDigits = i;
				break;
			}
			pow = go$mul64(pow, new Go$Uint64(0, 10));
			i = i + 1 >> 0;
		}
		rest = integer;
		if (integerDigits > needed) {
			pow10 = uint64pow10[(integerDigits - needed >> 0)];
			integer = (_q = integer / ((pow10.low >>> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero"));
			rest = rest - ((x$4 = (pow10.low >>> 0), (((integer >>> 16 << 16) * x$4 >>> 0) + (integer << 16 >>> 16) * x$4) >>> 0)) >>> 0;
		} else {
			rest = 0;
		}
		buf = go$makeNativeArray("Uint8", 32, function() { return 0; });
		pos = 32;
		v = integer;
		while (v > 0) {
			v1 = (_q$1 = v / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : go$throwRuntimeError("integer divide by zero"));
			v = v - ((x$5 = 10, (((x$5 >>> 16 << 16) * v1 >>> 0) + (x$5 << 16 >>> 16) * v1) >>> 0)) >>> 0;
			pos = pos - 1 >> 0;
			buf[pos] = ((v + 48 >>> 0) << 24 >>> 24);
			v = v1;
		}
		i$1 = pos;
		while (i$1 < 32) {
			_slice = d.d, _index = i$1 - pos >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = buf[i$1]) : go$throwRuntimeError("index out of range");
			i$1 = i$1 + 1 >> 0;
		}
		nd = 32 - pos >> 0;
		d.nd = nd;
		d.dp = integerDigits + exp10 >> 0;
		needed = needed - (nd) >> 0;
		if (needed > 0) {
			if (!((rest === 0)) || !((pow10.high === 0 && pow10.low === 1))) {
				throw go$panic(new Go$String("strconv: internal error, rest != 0 but needed > 0"));
			}
			while (needed > 0) {
				fraction = go$mul64(fraction, new Go$Uint64(0, 10));
				nonAsciiName = go$mul64(nonAsciiName, new Go$Uint64(0, 10));
				if ((x$6 = go$mul64(new Go$Uint64(0, 2), nonAsciiName), x$7 = go$shiftLeft64(new Go$Uint64(0, 1), shift), (x$6.high > x$7.high || (x$6.high === x$7.high && x$6.low > x$7.low)))) {
					return false;
				}
				digit = go$shiftRightUint64(fraction, shift);
				_slice$1 = d.d, _index$1 = nd, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (new Go$Uint64(digit.high + 0, digit.low + 48).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
				fraction = (x$8 = go$shiftLeft64(digit, shift), new Go$Uint64(fraction.high - x$8.high, fraction.low - x$8.low));
				nd = nd + 1 >> 0;
				needed = needed - 1 >> 0;
			}
			d.nd = nd;
		}
		ok = adjustLastDigitFixed(d, (x$9 = go$shiftLeft64(new Go$Uint64(0, rest), shift), new Go$Uint64(x$9.high | fraction.high, (x$9.low | fraction.low) >>> 0)), pow10, shift, nonAsciiName);
		if (!ok) {
			return false;
		}
		i$2 = d.nd - 1 >> 0;
		while (i$2 >= 0) {
			if (!(((_slice$2 = d.d, _index$2 = i$2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) === 48))) {
				d.nd = i$2 + 1 >> 0;
				break;
			}
			i$2 = i$2 - 1 >> 0;
		}
		return true;
	};
	extFloat.prototype.FixedDecimal = function(d, n) { return this.go$val.FixedDecimal(d, n); };
	var adjustLastDigitFixed = function(d, num, den, shift, nonAsciiName) {
		var x, x$1, x$2, x$3, x$4, x$5, x$6, i, _slice, _index, _slice$1, _index$1, _lhs, _index$2, _slice$2, _index$3, _slice$3, _index$4;
		if ((x = go$shiftLeft64(den, shift), (num.high > x.high || (num.high === x.high && num.low > x.low)))) {
			throw go$panic(new Go$String("strconv: num > den<<shift in adjustLastDigitFixed"));
		}
		if ((x$1 = go$mul64(new Go$Uint64(0, 2), nonAsciiName), x$2 = go$shiftLeft64(den, shift), (x$1.high > x$2.high || (x$1.high === x$2.high && x$1.low > x$2.low)))) {
			throw go$panic(new Go$String("strconv: \xCE\xB5 > (den<<shift)/2"));
		}
		if ((x$3 = go$mul64(new Go$Uint64(0, 2), (new Go$Uint64(num.high + nonAsciiName.high, num.low + nonAsciiName.low))), x$4 = go$shiftLeft64(den, shift), (x$3.high < x$4.high || (x$3.high === x$4.high && x$3.low < x$4.low)))) {
			return true;
		}
		if ((x$5 = go$mul64(new Go$Uint64(0, 2), (new Go$Uint64(num.high - nonAsciiName.high, num.low - nonAsciiName.low))), x$6 = go$shiftLeft64(den, shift), (x$5.high > x$6.high || (x$5.high === x$6.high && x$5.low > x$6.low)))) {
			i = d.nd - 1 >> 0;
			while (i >= 0) {
				if ((_slice = d.d, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 57) {
					d.nd = d.nd - 1 >> 0;
				} else {
					break;
				}
				i = i - 1 >> 0;
			}
			if (i < 0) {
				_slice$1 = d.d, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 49) : go$throwRuntimeError("index out of range");
				d.nd = 1;
				d.dp = d.dp + 1 >> 0;
			} else {
				_lhs = d.d, _index$2 = i, _slice$3 = _lhs, _index$4 = _index$2, (_index$4 >= 0 && _index$4 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$4] = (_slice$2 = _lhs, _index$3 = _index$2, (_index$3 >= 0 && _index$3 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$3] : go$throwRuntimeError("index out of range")) + 1 << 24 >>> 24) : go$throwRuntimeError("index out of range");
			}
			return true;
		}
		return false;
	};
	extFloat.Ptr.prototype.ShortestDecimal = function(d, lower, upper) {
		var f, x, x$1, y, x$2, y$1, buf, n, v, v1, x$3, nd, i, _slice, _index, _tuple, _slice$1, _index$1, exp10, x$4, x$5, shift, integer, x$6, x$7, fraction, x$8, x$9, allowance, x$10, x$11, targetDiff, integerDigits, _tuple$1, i$1, pow, x$12, i$2, pow$1, _q, digit, _slice$2, _index$2, x$13, currentDiff, x$14, digit$1, multiplier, _slice$3, _index$3, x$15, x$16;
		f = this;
		if ((x = f.mant, (x.high === 0 && x.low === 0))) {
			d.nd = 0;
			d.dp = 0;
			d.neg = f.neg;
			return true;
		}
		if ((f.exp === 0) && (x$1 = lower, y = f, (x$1.mant.high === y.mant.high && x$1.mant.low === y.mant.low) && x$1.exp === y.exp && x$1.neg === y.neg) && (x$2 = lower, y$1 = upper, (x$2.mant.high === y$1.mant.high && x$2.mant.low === y$1.mant.low) && x$2.exp === y$1.exp && x$2.neg === y$1.neg)) {
			buf = go$makeNativeArray("Uint8", 24, function() { return 0; });
			n = 23;
			v = f.mant;
			while ((v.high > 0 || (v.high === 0 && v.low > 0))) {
				v1 = go$div64(v, new Go$Uint64(0, 10), false);
				v = (x$3 = go$mul64(new Go$Uint64(0, 10), v1), new Go$Uint64(v.high - x$3.high, v.low - x$3.low));
				buf[n] = (new Go$Uint64(v.high + 0, v.low + 48).low << 24 >>> 24);
				n = n - 1 >> 0;
				v = v1;
			}
			nd = (24 - n >> 0) - 1 >> 0;
			i = 0;
			while (i < nd) {
				_slice = d.d, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = buf[((n + 1 >> 0) + i >> 0)]) : go$throwRuntimeError("index out of range");
				i = i + 1 >> 0;
			}
			_tuple = [nd, nd], d.nd = _tuple[0], d.dp = _tuple[1];
			while (d.nd > 0 && ((_slice$1 = d.d, _index$1 = (d.nd - 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 48)) {
				d.nd = d.nd - 1 >> 0;
			}
			if (d.nd === 0) {
				d.dp = 0;
			}
			d.neg = f.neg;
			return true;
		}
		upper.Normalize();
		if (f.exp > upper.exp) {
			f.mant = go$shiftLeft64(f.mant, (((f.exp - upper.exp >> 0) >>> 0)));
			f.exp = upper.exp;
		}
		if (lower.exp > upper.exp) {
			lower.mant = go$shiftLeft64(lower.mant, (((lower.exp - upper.exp >> 0) >>> 0)));
			lower.exp = upper.exp;
		}
		exp10 = frexp10Many(lower, f, upper);
		upper.mant = (x$4 = upper.mant, new Go$Uint64(x$4.high + 0, x$4.low + 1));
		lower.mant = (x$5 = lower.mant, new Go$Uint64(x$5.high - 0, x$5.low - 1));
		shift = (-upper.exp >>> 0);
		integer = (go$shiftRightUint64(upper.mant, shift).low >>> 0);
		fraction = (x$6 = upper.mant, x$7 = go$shiftLeft64(new Go$Uint64(0, integer), shift), new Go$Uint64(x$6.high - x$7.high, x$6.low - x$7.low));
		allowance = (x$8 = upper.mant, x$9 = lower.mant, new Go$Uint64(x$8.high - x$9.high, x$8.low - x$9.low));
		targetDiff = (x$10 = upper.mant, x$11 = f.mant, new Go$Uint64(x$10.high - x$11.high, x$10.low - x$11.low));
		integerDigits = 0;
		_tuple$1 = [0, new Go$Uint64(0, 1)], i$1 = _tuple$1[0], pow = _tuple$1[1];
		while (i$1 < 20) {
			if ((x$12 = new Go$Uint64(0, integer), (pow.high > x$12.high || (pow.high === x$12.high && pow.low > x$12.low)))) {
				integerDigits = i$1;
				break;
			}
			pow = go$mul64(pow, new Go$Uint64(0, 10));
			i$1 = i$1 + 1 >> 0;
		}
		i$2 = 0;
		while (i$2 < integerDigits) {
			pow$1 = uint64pow10[((integerDigits - i$2 >> 0) - 1 >> 0)];
			digit = (_q = integer / (pow$1.low >>> 0), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero"));
			_slice$2 = d.d, _index$2 = i$2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ((digit + 48 >>> 0) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
			integer = integer - ((x$13 = (pow$1.low >>> 0), (((digit >>> 16 << 16) * x$13 >>> 0) + (digit << 16 >>> 16) * x$13) >>> 0)) >>> 0;
			if (currentDiff = (x$14 = go$shiftLeft64(new Go$Uint64(0, integer), shift), new Go$Uint64(x$14.high + fraction.high, x$14.low + fraction.low)), (currentDiff.high < allowance.high || (currentDiff.high === allowance.high && currentDiff.low < allowance.low))) {
				d.nd = i$2 + 1 >> 0;
				d.dp = integerDigits + exp10 >> 0;
				d.neg = f.neg;
				return adjustLastDigit(d, currentDiff, targetDiff, allowance, go$shiftLeft64(pow$1, shift), new Go$Uint64(0, 2));
			}
			i$2 = i$2 + 1 >> 0;
		}
		d.nd = integerDigits;
		d.dp = d.nd + exp10 >> 0;
		d.neg = f.neg;
		digit$1 = 0;
		multiplier = new Go$Uint64(0, 1);
		while (true) {
			fraction = go$mul64(fraction, new Go$Uint64(0, 10));
			multiplier = go$mul64(multiplier, new Go$Uint64(0, 10));
			digit$1 = (go$shiftRightUint64(fraction, shift).low >> 0);
			_slice$3 = d.d, _index$3 = d.nd, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = ((digit$1 + 48 >> 0) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
			d.nd = d.nd + 1 >> 0;
			fraction = (x$15 = go$shiftLeft64(new Go$Uint64(0, digit$1), shift), new Go$Uint64(fraction.high - x$15.high, fraction.low - x$15.low));
			if ((x$16 = go$mul64(allowance, multiplier), (fraction.high < x$16.high || (fraction.high === x$16.high && fraction.low < x$16.low)))) {
				return adjustLastDigit(d, fraction, go$mul64(targetDiff, multiplier), go$mul64(allowance, multiplier), go$shiftLeft64(new Go$Uint64(0, 1), shift), go$mul64(multiplier, new Go$Uint64(0, 2)));
			}
		}
	};
	extFloat.prototype.ShortestDecimal = function(d, lower, upper) { return this.go$val.ShortestDecimal(d, lower, upper); };
	var adjustLastDigit = function(d, currentDiff, targetDiff, maxDiff, ulpDecimal, ulpBinary) {
		var x, x$1, x$2, x$3, _lhs, _index, _slice, _index$1, _slice$1, _index$2, x$4, x$5, x$6, x$7, x$8, x$9, _slice$2, _index$3;
		if ((x = go$mul64(new Go$Uint64(0, 2), ulpBinary), (ulpDecimal.high < x.high || (ulpDecimal.high === x.high && ulpDecimal.low < x.low)))) {
			return false;
		}
		while ((x$1 = (x$2 = (x$3 = go$div64(ulpDecimal, new Go$Uint64(0, 2), false), new Go$Uint64(currentDiff.high + x$3.high, currentDiff.low + x$3.low)), new Go$Uint64(x$2.high + ulpBinary.high, x$2.low + ulpBinary.low)), (x$1.high < targetDiff.high || (x$1.high === targetDiff.high && x$1.low < targetDiff.low)))) {
			_lhs = d.d, _index = d.nd - 1 >> 0, _slice$1 = _lhs, _index$2 = _index, (_index$2 >= 0 && _index$2 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$2] = (_slice = _lhs, _index$1 = _index, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) - 1 << 24 >>> 24) : go$throwRuntimeError("index out of range");
			currentDiff = (x$4 = ulpDecimal, new Go$Uint64(currentDiff.high + x$4.high, currentDiff.low + x$4.low));
		}
		if ((x$5 = new Go$Uint64(currentDiff.high + ulpDecimal.high, currentDiff.low + ulpDecimal.low), x$6 = (x$7 = (x$8 = go$div64(ulpDecimal, new Go$Uint64(0, 2), false), new Go$Uint64(targetDiff.high + x$8.high, targetDiff.low + x$8.low)), new Go$Uint64(x$7.high + ulpBinary.high, x$7.low + ulpBinary.low)), (x$5.high < x$6.high || (x$5.high === x$6.high && x$5.low <= x$6.low)))) {
			return false;
		}
		if ((currentDiff.high < ulpBinary.high || (currentDiff.high === ulpBinary.high && currentDiff.low < ulpBinary.low)) || (x$9 = new Go$Uint64(maxDiff.high - ulpBinary.high, maxDiff.low - ulpBinary.low), (currentDiff.high > x$9.high || (currentDiff.high === x$9.high && currentDiff.low > x$9.low)))) {
			return false;
		}
		if ((d.nd === 1) && ((_slice$2 = d.d, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$3] : go$throwRuntimeError("index out of range")) === 48)) {
			d.nd = 0;
			d.dp = 0;
		}
		return true;
	};
	var FormatFloat = go$pkg.FormatFloat = function(f, fmt, prec, bitSize) {
		return go$bytesToString(genericFtoa((go$sliceType(Go$Uint8)).make(0, max(prec + 4 >> 0, 24), function() { return 0; }), f, fmt, prec, bitSize));
	};
	var AppendFloat = go$pkg.AppendFloat = function(dst, f, fmt, prec, bitSize) {
		return genericFtoa(dst, f, fmt, prec, bitSize);
	};
	var genericFtoa = function(dst, val, fmt, prec, bitSize) {
		var bits, flt, _ref, x, neg, y, exp, x$1, x$2, mant, _ref$1, y$1, s, x$3, digs, ok, shortest, f, _tuple, _struct, lower, _struct$1, upper, buf, _ref$2, digits, _ref$3, buf$1, f$1, _struct$2;
		bits = new Go$Uint64(0, 0);
		flt = (go$ptrType(floatInfo)).nil;
		_ref = bitSize;
		if (_ref === 32) {
			bits = new Go$Uint64(0, math.Float32bits(val));
			flt = float32info;
		} else if (_ref === 64) {
			bits = math.Float64bits(val);
			flt = float64info;
		} else {
			throw go$panic(new Go$String("strconv: illegal AppendFloat/FormatFloat bitSize"));
		}
		neg = !((x = go$shiftRightUint64(bits, ((flt.expbits + flt.mantbits >>> 0))), (x.high === 0 && x.low === 0)));
		exp = (go$shiftRightUint64(bits, flt.mantbits).low >> 0) & ((((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0));
		mant = (x$1 = (x$2 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), new Go$Uint64(x$2.high - 0, x$2.low - 1)), new Go$Uint64(bits.high & x$1.high, (bits.low & x$1.low) >>> 0));
		_ref$1 = exp;
		if (_ref$1 === (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0)) {
			s = "";
			if (!((mant.high === 0 && mant.low === 0))) {
				s = "NaN";
			} else if (neg) {
				s = "-Inf";
			} else {
				s = "+Inf";
			}
			return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes(s)));
		} else if (_ref$1 === 0) {
			exp = exp + 1 >> 0;
		} else {
			mant = (x$3 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), new Go$Uint64(mant.high | x$3.high, (mant.low | x$3.low) >>> 0));
		}
		exp = exp + (flt.bias) >> 0;
		if (fmt === 98) {
			return fmtB(dst, neg, mant, exp, flt);
		}
		if (!optimize) {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
		}
		digs = new decimalSlice.Ptr();
		ok = false;
		shortest = prec < 0;
		if (shortest) {
			f = new extFloat.Ptr();
			_tuple = f.AssignComputeBounds(mant, exp, neg, flt), lower = (_struct = _tuple[0], new extFloat.Ptr(_struct.mant, _struct.exp, _struct.neg)), upper = (_struct$1 = _tuple[1], new extFloat.Ptr(_struct$1.mant, _struct$1.exp, _struct$1.neg));
			buf = go$makeNativeArray("Uint8", 32, function() { return 0; });
			digs.d = new (go$sliceType(Go$Uint8))(buf);
			ok = f.ShortestDecimal(digs, lower, upper);
			if (!ok) {
				return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
			}
			_ref$2 = fmt;
			if (_ref$2 === 101 || _ref$2 === 69) {
				prec = digs.nd - 1 >> 0;
			} else if (_ref$2 === 102) {
				prec = max(digs.nd - digs.dp >> 0, 0);
			} else if (_ref$2 === 103 || _ref$2 === 71) {
				prec = digs.nd;
			}
		} else if (!((fmt === 102))) {
			digits = prec;
			_ref$3 = fmt;
			if (_ref$3 === 101 || _ref$3 === 69) {
				digits = digits + 1 >> 0;
			} else if (_ref$3 === 103 || _ref$3 === 71) {
				if (prec === 0) {
					prec = 1;
				}
				digits = prec;
			}
			if (digits <= 15) {
				buf$1 = go$makeNativeArray("Uint8", 24, function() { return 0; });
				digs.d = new (go$sliceType(Go$Uint8))(buf$1);
				f$1 = new extFloat.Ptr(mant, exp - (flt.mantbits >> 0) >> 0, neg);
				ok = f$1.FixedDecimal(digs, digits);
			}
		}
		if (!ok) {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
		}
		return formatDigits(dst, shortest, neg, (_struct$2 = digs, new decimalSlice.Ptr(_struct$2.d, _struct$2.nd, _struct$2.dp, _struct$2.neg)), prec, fmt);
	};
	var bigFtoa = function(dst, prec, fmt, neg, mant, exp, flt) {
		var d, digs, shortest, _ref, _ref$1, _struct;
		d = new decimal.Ptr();
		d.Assign(mant);
		d.Shift(exp - (flt.mantbits >> 0) >> 0);
		digs = new decimalSlice.Ptr();
		shortest = prec < 0;
		if (shortest) {
			roundShortest(d, mant, exp, flt);
			digs = new decimalSlice.Ptr(new (go$sliceType(Go$Uint8))(d.d), d.nd, d.dp, false);
			_ref = fmt;
			if (_ref === 101 || _ref === 69) {
				prec = digs.nd - 1 >> 0;
			} else if (_ref === 102) {
				prec = max(digs.nd - digs.dp >> 0, 0);
			} else if (_ref === 103 || _ref === 71) {
				prec = digs.nd;
			}
		} else {
			_ref$1 = fmt;
			if (_ref$1 === 101 || _ref$1 === 69) {
				d.Round(prec + 1 >> 0);
			} else if (_ref$1 === 102) {
				d.Round(d.dp + prec >> 0);
			} else if (_ref$1 === 103 || _ref$1 === 71) {
				if (prec === 0) {
					prec = 1;
				}
				d.Round(prec);
			}
			digs = new decimalSlice.Ptr(new (go$sliceType(Go$Uint8))(d.d), d.nd, d.dp, false);
		}
		return formatDigits(dst, shortest, neg, (_struct = digs, new decimalSlice.Ptr(_struct.d, _struct.nd, _struct.dp, _struct.neg)), prec, fmt);
	};
	var formatDigits = function(dst, shortest, neg, digs, prec, fmt) {
		var _ref, _struct, _struct$1, eprec, exp, _struct$2, _struct$3;
		_ref = fmt;
		if (_ref === 101 || _ref === 69) {
			return fmtE(dst, neg, (_struct = digs, new decimalSlice.Ptr(_struct.d, _struct.nd, _struct.dp, _struct.neg)), prec, fmt);
		} else if (_ref === 102) {
			return fmtF(dst, neg, (_struct$1 = digs, new decimalSlice.Ptr(_struct$1.d, _struct$1.nd, _struct$1.dp, _struct$1.neg)), prec);
		} else if (_ref === 103 || _ref === 71) {
			eprec = prec;
			if (eprec > digs.nd && digs.nd >= digs.dp) {
				eprec = digs.nd;
			}
			if (shortest) {
				eprec = 6;
			}
			exp = digs.dp - 1 >> 0;
			if (exp < -4 || exp >= eprec) {
				if (prec > digs.nd) {
					prec = digs.nd;
				}
				return fmtE(dst, neg, (_struct$2 = digs, new decimalSlice.Ptr(_struct$2.d, _struct$2.nd, _struct$2.dp, _struct$2.neg)), prec - 1 >> 0, (fmt + 101 << 24 >>> 24) - 103 << 24 >>> 24);
			}
			if (prec > digs.dp) {
				prec = digs.nd;
			}
			return fmtF(dst, neg, (_struct$3 = digs, new decimalSlice.Ptr(_struct$3.d, _struct$3.nd, _struct$3.dp, _struct$3.neg)), max(prec - digs.dp >> 0, 0));
		}
		return go$append(dst, 37, fmt);
	};
	var roundShortest = function(d, mant, exp, flt) {
		var minexp, x, x$1, x$2, x$3, upper, x$4, mantlo, explo, x$5, x$6, lower, x$7, x$8, inclusive, i, _tuple, l, m, u, okdown, okup;
		if ((mant.high === 0 && mant.low === 0)) {
			d.nd = 0;
			return;
		}
		minexp = flt.bias + 1 >> 0;
		if (exp > minexp && (x = 332, x$1 = (d.dp - d.nd >> 0), (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) >= (x$2 = 100, x$3 = (exp - (flt.mantbits >> 0) >> 0), (((x$2 >>> 16 << 16) * x$3 >> 0) + (x$2 << 16 >>> 16) * x$3) >> 0)) {
			return;
		}
		upper = new decimal.Ptr();
		upper.Assign((x$4 = go$mul64(mant, new Go$Uint64(0, 2)), new Go$Uint64(x$4.high + 0, x$4.low + 1)));
		upper.Shift((exp - (flt.mantbits >> 0) >> 0) - 1 >> 0);
		mantlo = new Go$Uint64(0, 0);
		explo = 0;
		if ((x$5 = go$shiftLeft64(new Go$Uint64(0, 1), flt.mantbits), (mant.high > x$5.high || (mant.high === x$5.high && mant.low > x$5.low))) || (exp === minexp)) {
			mantlo = new Go$Uint64(mant.high - 0, mant.low - 1);
			explo = exp;
		} else {
			mantlo = (x$6 = go$mul64(mant, new Go$Uint64(0, 2)), new Go$Uint64(x$6.high - 0, x$6.low - 1));
			explo = exp - 1 >> 0;
		}
		lower = new decimal.Ptr();
		lower.Assign((x$7 = go$mul64(mantlo, new Go$Uint64(0, 2)), new Go$Uint64(x$7.high + 0, x$7.low + 1)));
		lower.Shift((explo - (flt.mantbits >> 0) >> 0) - 1 >> 0);
		inclusive = (x$8 = go$div64(mant, new Go$Uint64(0, 2), true), (x$8.high === 0 && x$8.low === 0));
		i = 0;
		while (i < d.nd) {
			_tuple = [0, 0, 0], l = _tuple[0], m = _tuple[1], u = _tuple[2];
			if (i < lower.nd) {
				l = lower.d[i];
			} else {
				l = 48;
			}
			m = d.d[i];
			if (i < upper.nd) {
				u = upper.d[i];
			} else {
				u = 48;
			}
			okdown = !((l === m)) || (inclusive && (l === m) && ((i + 1 >> 0) === lower.nd));
			okup = !((m === u)) && (inclusive || (m + 1 << 24 >>> 24) < u || (i + 1 >> 0) < upper.nd);
			if (okdown && okup) {
				d.Round(i + 1 >> 0);
				return;
			} else if (okdown) {
				d.RoundDown(i + 1 >> 0);
				return;
			} else if (okup) {
				d.RoundUp(i + 1 >> 0);
				return;
			}
			i = i + 1 >> 0;
		}
	};
	var fmtE = function(dst, neg, d, prec, fmt) {
		var ch, _slice, _index, i, m, _slice$1, _index$1, exp, buf, i$1, _r, _q, _ref;
		if (neg) {
			dst = go$append(dst, 45);
		}
		ch = 48;
		if (!((d.nd === 0))) {
			ch = (_slice = d.d, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		}
		dst = go$append(dst, ch);
		if (prec > 0) {
			dst = go$append(dst, 46);
			i = 1;
			m = ((d.nd + prec >> 0) + 1 >> 0) - max(d.nd, prec + 1 >> 0) >> 0;
			while (i < m) {
				dst = go$append(dst, (_slice$1 = d.d, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")));
				i = i + 1 >> 0;
			}
			while (i <= prec) {
				dst = go$append(dst, 48);
				i = i + 1 >> 0;
			}
		}
		dst = go$append(dst, fmt);
		exp = d.dp - 1 >> 0;
		if (d.nd === 0) {
			exp = 0;
		}
		if (exp < 0) {
			ch = 45;
			exp = -exp;
		} else {
			ch = 43;
		}
		dst = go$append(dst, ch);
		buf = go$makeNativeArray("Uint8", 3, function() { return 0; });
		i$1 = 3;
		while (exp >= 10) {
			i$1 = i$1 - 1 >> 0;
			buf[i$1] = (((_r = exp % 10, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) + 48 >> 0) << 24 >>> 24);
			exp = (_q = exp / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		}
		i$1 = i$1 - 1 >> 0;
		buf[i$1] = ((exp + 48 >> 0) << 24 >>> 24);
		_ref = i$1;
		if (_ref === 0) {
			dst = go$append(dst, buf[0], buf[1], buf[2]);
		} else if (_ref === 1) {
			dst = go$append(dst, buf[1], buf[2]);
		} else if (_ref === 2) {
			dst = go$append(dst, 48, buf[2]);
		}
		return dst;
	};
	var fmtF = function(dst, neg, d, prec) {
		var i, _slice, _index, i$1, ch, j, _slice$1, _index$1;
		if (neg) {
			dst = go$append(dst, 45);
		}
		if (d.dp > 0) {
			i = 0;
			i = 0;
			while (i < d.dp && i < d.nd) {
				dst = go$append(dst, (_slice = d.d, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
				i = i + 1 >> 0;
			}
			while (i < d.dp) {
				dst = go$append(dst, 48);
				i = i + 1 >> 0;
			}
		} else {
			dst = go$append(dst, 48);
		}
		if (prec > 0) {
			dst = go$append(dst, 46);
			i$1 = 0;
			while (i$1 < prec) {
				ch = 48;
				if (j = d.dp + i$1 >> 0, 0 <= j && j < d.nd) {
					ch = (_slice$1 = d.d, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				}
				dst = go$append(dst, ch);
				i$1 = i$1 + 1 >> 0;
			}
		}
		return dst;
	};
	var fmtB = function(dst, neg, mant, exp, flt) {
		var buf, w, esign, n, _r, _q, x;
		buf = go$makeNativeArray("Uint8", 50, function() { return 0; });
		w = 50;
		exp = exp - ((flt.mantbits >> 0)) >> 0;
		esign = 43;
		if (exp < 0) {
			esign = 45;
			exp = -exp;
		}
		n = 0;
		while (exp > 0 || n < 1) {
			n = n + 1 >> 0;
			w = w - 1 >> 0;
			buf[w] = (((_r = exp % 10, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) + 48 >> 0) << 24 >>> 24);
			exp = (_q = exp / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		}
		w = w - 1 >> 0;
		buf[w] = esign;
		w = w - 1 >> 0;
		buf[w] = 112;
		n = 0;
		while ((mant.high > 0 || (mant.high === 0 && mant.low > 0)) || n < 1) {
			n = n + 1 >> 0;
			w = w - 1 >> 0;
			buf[w] = ((x = go$div64(mant, new Go$Uint64(0, 10), true), new Go$Uint64(x.high + 0, x.low + 48)).low << 24 >>> 24);
			mant = go$div64(mant, new Go$Uint64(0, 10), false);
		}
		if (neg) {
			w = w - 1 >> 0;
			buf[w] = 45;
		}
		return go$appendSlice(dst, go$subslice(new (go$sliceType(Go$Uint8))(buf), w));
	};
	var max = function(a, b) {
		if (a > b) {
			return a;
		}
		return b;
	};
	var FormatUint = go$pkg.FormatUint = function(i, base) {
		var _tuple, s;
		_tuple = formatBits((go$sliceType(Go$Uint8)).nil, i, base, false, false), s = _tuple[1];
		return s;
	};
	var FormatInt = go$pkg.FormatInt = function(i, base) {
		var _tuple, s;
		_tuple = formatBits((go$sliceType(Go$Uint8)).nil, new Go$Uint64(i.high, i.low), base, (i.high < 0 || (i.high === 0 && i.low < 0)), false), s = _tuple[1];
		return s;
	};
	var Itoa = go$pkg.Itoa = function(i) {
		return FormatInt(new Go$Int64(0, i), 10);
	};
	var AppendInt = go$pkg.AppendInt = function(dst, i, base) {
		var _tuple;
		_tuple = formatBits(dst, new Go$Uint64(i.high, i.low), base, (i.high < 0 || (i.high === 0 && i.low < 0)), true), dst = _tuple[0];
		return dst;
	};
	var AppendUint = go$pkg.AppendUint = function(dst, i, base) {
		var _tuple;
		_tuple = formatBits(dst, i, base, false, true), dst = _tuple[0];
		return dst;
	};
	var formatBits = function(dst, u, base, neg, append_) {
		var d, s, a, i, s$1, q, x, j, q$1, x$1, b, m, b$1;
		d = (go$sliceType(Go$Uint8)).nil;
		s = "";
		if (base < 2 || base > 36) {
			throw go$panic(new Go$String("strconv: illegal AppendInt/FormatInt base"));
		}
		a = go$makeNativeArray("Uint8", 65, function() { return 0; });
		i = 65;
		if (neg) {
			u = new Go$Uint64(-u.high, -u.low);
		}
		if (base === 10) {
			while ((u.high > 0 || (u.high === 0 && u.low >= 100))) {
				i = i - 2 >> 0;
				q = go$div64(u, new Go$Uint64(0, 100), false);
				j = ((x = go$mul64(q, new Go$Uint64(0, 100)), new Go$Uint64(u.high - x.high, u.low - x.low)).low >>> 0);
				a[i + 1 >> 0] = "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789".charCodeAt(j);
				a[i + 0 >> 0] = "0000000000111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999".charCodeAt(j);
				u = q;
			}
			if ((u.high > 0 || (u.high === 0 && u.low >= 10))) {
				i = i - 1 >> 0;
				q$1 = go$div64(u, new Go$Uint64(0, 10), false);
				a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((x$1 = go$mul64(q$1, new Go$Uint64(0, 10)), new Go$Uint64(u.high - x$1.high, u.low - x$1.low)).low >>> 0));
				u = q$1;
			}
		} else if (s$1 = shifts[base], s$1 > 0) {
			b = new Go$Uint64(0, base);
			m = (b.low >>> 0) - 1 >>> 0;
			while ((u.high > b.high || (u.high === b.high && u.low >= b.low))) {
				i = i - 1 >> 0;
				a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((((u.low >>> 0) & m) >>> 0));
				u = go$shiftRightUint64(u, (s$1));
			}
		} else {
			b$1 = new Go$Uint64(0, base);
			while ((u.high > b$1.high || (u.high === b$1.high && u.low >= b$1.low))) {
				i = i - 1 >> 0;
				a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((go$div64(u, b$1, true).low >>> 0));
				u = go$div64(u, (b$1), false);
			}
		}
		i = i - 1 >> 0;
		a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((u.low >>> 0));
		if (neg) {
			i = i - 1 >> 0;
			a[i] = 45;
		}
		if (append_) {
			d = go$appendSlice(dst, go$subslice(new (go$sliceType(Go$Uint8))(a), i));
			return [d, s];
		}
		s = go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(a), i));
		return [d, s];
	};
	var quoteWith = function(s, quote, ASCIIonly) {
		var runeTmp, _q, x, x$1, buf, width, r, _tuple, n, _ref, s$1, s$2;
		runeTmp = go$makeNativeArray("Uint8", 4, function() { return 0; });
		buf = (go$sliceType(Go$Uint8)).make(0, (_q = (x = 3, x$1 = s.length, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), function() { return 0; });
		buf = go$append(buf, quote);
		width = 0;
		while (s.length > 0) {
			r = (s.charCodeAt(0) >> 0);
			width = 1;
			if (r >= 128) {
				_tuple = utf8.DecodeRuneInString(s), r = _tuple[0], width = _tuple[1];
			}
			if ((width === 1) && (r === 65533)) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\x")));
				buf = go$append(buf, "0123456789abcdef".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));
				buf = go$append(buf, "0123456789abcdef".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));
				s = s.substring(width);
				continue;
			}
			if ((r === (quote >> 0)) || (r === 92)) {
				buf = go$append(buf, 92);
				buf = go$append(buf, (r << 24 >>> 24));
				s = s.substring(width);
				continue;
			}
			if (ASCIIonly) {
				if (r < 128 && IsPrint(r)) {
					buf = go$append(buf, (r << 24 >>> 24));
					s = s.substring(width);
					continue;
				}
			} else if (IsPrint(r)) {
				n = utf8.EncodeRune(new (go$sliceType(Go$Uint8))(runeTmp), r);
				buf = go$appendSlice(buf, go$subslice(new (go$sliceType(Go$Uint8))(runeTmp), 0, n));
				s = s.substring(width);
				continue;
			}
			_ref = r;
			if (_ref === 7) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\a")));
			} else if (_ref === 8) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\b")));
			} else if (_ref === 12) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\f")));
			} else if (_ref === 10) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\n")));
			} else if (_ref === 13) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\r")));
			} else if (_ref === 9) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\t")));
			} else if (_ref === 11) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\v")));
			} else {
				if (r < 32) {
					buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\x")));
					buf = go$append(buf, "0123456789abcdef".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));
					buf = go$append(buf, "0123456789abcdef".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));
				} else if (r > 1114111) {
					r = 65533;
					buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\u")));
					s$1 = 12;
					while (s$1 >= 0) {
						buf = go$append(buf, "0123456789abcdef".charCodeAt((((r >> go$min((s$1 >>> 0), 31)) >> 0) & 15)));
						s$1 = s$1 - 4 >> 0;
					}
				} else if (r < 65536) {
					buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\u")));
					s$1 = 12;
					while (s$1 >= 0) {
						buf = go$append(buf, "0123456789abcdef".charCodeAt((((r >> go$min((s$1 >>> 0), 31)) >> 0) & 15)));
						s$1 = s$1 - 4 >> 0;
					}
				} else {
					buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes("\\U")));
					s$2 = 28;
					while (s$2 >= 0) {
						buf = go$append(buf, "0123456789abcdef".charCodeAt((((r >> go$min((s$2 >>> 0), 31)) >> 0) & 15)));
						s$2 = s$2 - 4 >> 0;
					}
				}
			}
			s = s.substring(width);
		}
		buf = go$append(buf, quote);
		return go$bytesToString(buf);
	};
	var Quote = go$pkg.Quote = function(s) {
		return quoteWith(s, 34, false);
	};
	var AppendQuote = go$pkg.AppendQuote = function(dst, s) {
		return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes(Quote(s))));
	};
	var QuoteToASCII = go$pkg.QuoteToASCII = function(s) {
		return quoteWith(s, 34, true);
	};
	var AppendQuoteToASCII = go$pkg.AppendQuoteToASCII = function(dst, s) {
		return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes(QuoteToASCII(s))));
	};
	var QuoteRune = go$pkg.QuoteRune = function(r) {
		return quoteWith(go$encodeRune(r), 39, false);
	};
	var AppendQuoteRune = go$pkg.AppendQuoteRune = function(dst, r) {
		return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes(QuoteRune(r))));
	};
	var QuoteRuneToASCII = go$pkg.QuoteRuneToASCII = function(r) {
		return quoteWith(go$encodeRune(r), 39, true);
	};
	var AppendQuoteRuneToASCII = go$pkg.AppendQuoteRuneToASCII = function(dst, r) {
		return go$appendSlice(dst, new (go$sliceType(Go$Uint8))(go$stringToBytes(QuoteRuneToASCII(r))));
	};
	var CanBackquote = go$pkg.CanBackquote = function(s) {
		var i;
		i = 0;
		while (i < s.length) {
			if ((s.charCodeAt(i) < 32 && !((s.charCodeAt(i) === 9))) || (s.charCodeAt(i) === 96)) {
				return false;
			}
			i = i + 1 >> 0;
		}
		return true;
	};
	var unhex = function(b) {
		var v, ok, c, _tuple, _tuple$1, _tuple$2;
		v = 0;
		ok = false;
		c = (b >> 0);
		if (48 <= c && c <= 57) {
			_tuple = [c - 48 >> 0, true], v = _tuple[0], ok = _tuple[1];
			return [v, ok];
		} else if (97 <= c && c <= 102) {
			_tuple$1 = [(c - 97 >> 0) + 10 >> 0, true], v = _tuple$1[0], ok = _tuple$1[1];
			return [v, ok];
		} else if (65 <= c && c <= 70) {
			_tuple$2 = [(c - 65 >> 0) + 10 >> 0, true], v = _tuple$2[0], ok = _tuple$2[1];
			return [v, ok];
		}
		return [v, ok];
	};
	var UnquoteChar = go$pkg.UnquoteChar = function(s, quote) {
		var value, multibyte, tail, err, c, _tuple, r, size, _tuple$1, _tuple$2, c$1, _ref, n, _ref$1, v, j, _tuple$3, x, ok, v$1, j$1, x$1;
		value = 0;
		multibyte = false;
		tail = "";
		err = null;
		c = s.charCodeAt(0);
		if ((c === quote) && ((quote === 39) || (quote === 34))) {
			err = go$pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		} else if (c >= 128) {
			_tuple = utf8.DecodeRuneInString(s), r = _tuple[0], size = _tuple[1];
			_tuple$1 = [r, true, s.substring(size), null], value = _tuple$1[0], multibyte = _tuple$1[1], tail = _tuple$1[2], err = _tuple$1[3];
			return [value, multibyte, tail, err];
		} else if (!((c === 92))) {
			_tuple$2 = [(s.charCodeAt(0) >> 0), false, s.substring(1), null], value = _tuple$2[0], multibyte = _tuple$2[1], tail = _tuple$2[2], err = _tuple$2[3];
			return [value, multibyte, tail, err];
		}
		if (s.length <= 1) {
			err = go$pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		}
		c$1 = s.charCodeAt(1);
		s = s.substring(2);
		_ref = c$1;
		switch (0) { default: if (_ref === 97) {
			value = 7;
		} else if (_ref === 98) {
			value = 8;
		} else if (_ref === 102) {
			value = 12;
		} else if (_ref === 110) {
			value = 10;
		} else if (_ref === 114) {
			value = 13;
		} else if (_ref === 116) {
			value = 9;
		} else if (_ref === 118) {
			value = 11;
		} else if (_ref === 120 || _ref === 117 || _ref === 85) {
			n = 0;
			_ref$1 = c$1;
			if (_ref$1 === 120) {
				n = 2;
			} else if (_ref$1 === 117) {
				n = 4;
			} else if (_ref$1 === 85) {
				n = 8;
			}
			v = 0;
			if (s.length < n) {
				err = go$pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
			j = 0;
			while (j < n) {
				_tuple$3 = unhex(s.charCodeAt(j)), x = _tuple$3[0], ok = _tuple$3[1];
				if (!ok) {
					err = go$pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				v = (v << 4 >> 0) | x;
				j = j + 1 >> 0;
			}
			s = s.substring(n);
			if (c$1 === 120) {
				value = v;
				break;
			}
			if (v > 1114111) {
				err = go$pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
			value = v;
			multibyte = true;
		} else if (_ref === 48 || _ref === 49 || _ref === 50 || _ref === 51 || _ref === 52 || _ref === 53 || _ref === 54 || _ref === 55) {
			v$1 = (c$1 >> 0) - 48 >> 0;
			if (s.length < 2) {
				err = go$pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
			j$1 = 0;
			while (j$1 < 2) {
				x$1 = (s.charCodeAt(j$1) >> 0) - 48 >> 0;
				if (x$1 < 0 || x$1 > 7) {
					err = go$pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				v$1 = ((v$1 << 3 >> 0)) | x$1;
				j$1 = j$1 + 1 >> 0;
			}
			s = s.substring(2);
			if (v$1 > 255) {
				err = go$pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
			value = v$1;
		} else if (_ref === 92) {
			value = 92;
		} else if (_ref === 39 || _ref === 34) {
			if (!((c$1 === quote))) {
				err = go$pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
			value = (c$1 >> 0);
		} else {
			err = go$pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		} }
		tail = s;
		return [value, multibyte, tail, err];
	};
	var Unquote = go$pkg.Unquote = function(s) {
		var t, err, n, _tuple, quote, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _ref, _tuple$6, _tuple$7, r, size, _tuple$8, runeTmp, _q, x, x$1, buf, _tuple$9, c, multibyte, ss, err$1, _tuple$10, n$1, _tuple$11, _tuple$12;
		t = "";
		err = null;
		n = s.length;
		if (n < 2) {
			_tuple = ["", go$pkg.ErrSyntax], t = _tuple[0], err = _tuple[1];
			return [t, err];
		}
		quote = s.charCodeAt(0);
		if (!((quote === s.charCodeAt((n - 1 >> 0))))) {
			_tuple$1 = ["", go$pkg.ErrSyntax], t = _tuple$1[0], err = _tuple$1[1];
			return [t, err];
		}
		s = s.substring(1, (n - 1 >> 0));
		if (quote === 96) {
			if (contains(s, 96)) {
				_tuple$2 = ["", go$pkg.ErrSyntax], t = _tuple$2[0], err = _tuple$2[1];
				return [t, err];
			}
			_tuple$3 = [s, null], t = _tuple$3[0], err = _tuple$3[1];
			return [t, err];
		}
		if (!((quote === 34)) && !((quote === 39))) {
			_tuple$4 = ["", go$pkg.ErrSyntax], t = _tuple$4[0], err = _tuple$4[1];
			return [t, err];
		}
		if (contains(s, 10)) {
			_tuple$5 = ["", go$pkg.ErrSyntax], t = _tuple$5[0], err = _tuple$5[1];
			return [t, err];
		}
		if (!contains(s, 92) && !contains(s, quote)) {
			_ref = quote;
			if (_ref === 34) {
				_tuple$6 = [s, null], t = _tuple$6[0], err = _tuple$6[1];
				return [t, err];
			} else if (_ref === 39) {
				_tuple$7 = utf8.DecodeRuneInString(s), r = _tuple$7[0], size = _tuple$7[1];
				if ((size === s.length) && (!((r === 65533)) || !((size === 1)))) {
					_tuple$8 = [s, null], t = _tuple$8[0], err = _tuple$8[1];
					return [t, err];
				}
			}
		}
		runeTmp = go$makeNativeArray("Uint8", 4, function() { return 0; });
		buf = (go$sliceType(Go$Uint8)).make(0, (_q = (x = 3, x$1 = s.length, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), function() { return 0; });
		while (s.length > 0) {
			_tuple$9 = UnquoteChar(s, quote), c = _tuple$9[0], multibyte = _tuple$9[1], ss = _tuple$9[2], err$1 = _tuple$9[3];
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$10 = ["", err$1], t = _tuple$10[0], err = _tuple$10[1];
				return [t, err];
			}
			s = ss;
			if (c < 128 || !multibyte) {
				buf = go$append(buf, (c << 24 >>> 24));
			} else {
				n$1 = utf8.EncodeRune(new (go$sliceType(Go$Uint8))(runeTmp), c);
				buf = go$appendSlice(buf, go$subslice(new (go$sliceType(Go$Uint8))(runeTmp), 0, n$1));
			}
			if ((quote === 39) && !((s.length === 0))) {
				_tuple$11 = ["", go$pkg.ErrSyntax], t = _tuple$11[0], err = _tuple$11[1];
				return [t, err];
			}
		}
		_tuple$12 = [go$bytesToString(buf), null], t = _tuple$12[0], err = _tuple$12[1];
		return [t, err];
	};
	var contains = function(s, c) {
		var i;
		i = 0;
		while (i < s.length) {
			if (s.charCodeAt(i) === c) {
				return true;
			}
			i = i + 1 >> 0;
		}
		return false;
	};
	var bsearch16 = function(a, x) {
		var _tuple, i, j, _q, h, _slice, _index;
		_tuple = [0, a.length], i = _tuple[0], j = _tuple[1];
		while (i < j) {
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			if ((_slice = a, _index = h, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	var bsearch32 = function(a, x) {
		var _tuple, i, j, _q, h, _slice, _index;
		_tuple = [0, a.length], i = _tuple[0], j = _tuple[1];
		while (i < j) {
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			if ((_slice = a, _index = h, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	var IsPrint = go$pkg.IsPrint = function(r) {
		var _tuple, rr, isPrint, isNotPrint, i, _slice, _index, _slice$1, _index$1, j, _slice$2, _index$2, _tuple$1, rr$1, isPrint$1, isNotPrint$1, i$1, _slice$3, _index$3, _slice$4, _index$4, j$1, _slice$5, _index$5;
		if (r <= 255) {
			if (32 <= r && r <= 126) {
				return true;
			}
			if (161 <= r && r <= 255) {
				return !((r === 173));
			}
			return false;
		}
		if (0 <= r && r < 65536) {
			_tuple = [(r << 16 >>> 16), isPrint16, isNotPrint16], rr = _tuple[0], isPrint = _tuple[1], isNotPrint = _tuple[2];
			i = bsearch16(isPrint, rr);
			if (i >= isPrint.length || rr < (_slice = isPrint, _index = (i & ~1), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) || (_slice$1 = isPrint, _index$1 = (i | 1), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) < rr) {
				return false;
			}
			j = bsearch16(isNotPrint, rr);
			return j >= isNotPrint.length || !(((_slice$2 = isNotPrint, _index$2 = j, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) === rr));
		}
		_tuple$1 = [(r >>> 0), isPrint32, isNotPrint32], rr$1 = _tuple$1[0], isPrint$1 = _tuple$1[1], isNotPrint$1 = _tuple$1[2];
		i$1 = bsearch32(isPrint$1, rr$1);
		if (i$1 >= isPrint$1.length || rr$1 < (_slice$3 = isPrint$1, _index$3 = (i$1 & ~1), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) || (_slice$4 = isPrint$1, _index$4 = (i$1 | 1), (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")) < rr$1) {
			return false;
		}
		if (r >= 131072) {
			return true;
		}
		r = r - 65536 >> 0;
		j$1 = bsearch16(isNotPrint$1, (r << 16 >>> 16));
		return j$1 >= isNotPrint$1.length || !(((_slice$5 = isNotPrint$1, _index$5 = j$1, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")) === (r << 16 >>> 16)));
	};
	go$pkg.init = function() {
		optimize = true;
		powtab = new (go$sliceType(Go$Int))([1, 3, 6, 9, 13, 16, 19, 23, 26]);
		float64pow10 = new (go$sliceType(Go$Float64))([1, 10, 100, 1000, 10000, 100000, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22]);
		float32pow10 = new (go$sliceType(Go$Float32))([1, 10, 100, 1000, 10000, 100000, 1e+06, 1e+07, 1e+08, 1e+09, 1e+10]);
		go$pkg.ErrRange = errors.New("value out of range");
		go$pkg.ErrSyntax = errors.New("invalid syntax");
		leftcheats = new (go$sliceType(leftCheat))([new leftCheat.Ptr(0, ""), new leftCheat.Ptr(1, "5"), new leftCheat.Ptr(1, "25"), new leftCheat.Ptr(1, "125"), new leftCheat.Ptr(2, "625"), new leftCheat.Ptr(2, "3125"), new leftCheat.Ptr(2, "15625"), new leftCheat.Ptr(3, "78125"), new leftCheat.Ptr(3, "390625"), new leftCheat.Ptr(3, "1953125"), new leftCheat.Ptr(4, "9765625"), new leftCheat.Ptr(4, "48828125"), new leftCheat.Ptr(4, "244140625"), new leftCheat.Ptr(4, "1220703125"), new leftCheat.Ptr(5, "6103515625"), new leftCheat.Ptr(5, "30517578125"), new leftCheat.Ptr(5, "152587890625"), new leftCheat.Ptr(6, "762939453125"), new leftCheat.Ptr(6, "3814697265625"), new leftCheat.Ptr(6, "19073486328125"), new leftCheat.Ptr(7, "95367431640625"), new leftCheat.Ptr(7, "476837158203125"), new leftCheat.Ptr(7, "2384185791015625"), new leftCheat.Ptr(7, "11920928955078125"), new leftCheat.Ptr(8, "59604644775390625"), new leftCheat.Ptr(8, "298023223876953125"), new leftCheat.Ptr(8, "1490116119384765625"), new leftCheat.Ptr(9, "7450580596923828125")]);
		smallPowersOfTen = go$toNativeArray("Struct", [new extFloat.Ptr(new Go$Uint64(2147483648, 0), -63, false), new extFloat.Ptr(new Go$Uint64(2684354560, 0), -60, false), new extFloat.Ptr(new Go$Uint64(3355443200, 0), -57, false), new extFloat.Ptr(new Go$Uint64(4194304000, 0), -54, false), new extFloat.Ptr(new Go$Uint64(2621440000, 0), -50, false), new extFloat.Ptr(new Go$Uint64(3276800000, 0), -47, false), new extFloat.Ptr(new Go$Uint64(4096000000, 0), -44, false), new extFloat.Ptr(new Go$Uint64(2560000000, 0), -40, false)]);
		powersOfTen = go$toNativeArray("Struct", [new extFloat.Ptr(new Go$Uint64(4203730336, 136053384), -1220, false), new extFloat.Ptr(new Go$Uint64(3132023167, 2722021238), -1193, false), new extFloat.Ptr(new Go$Uint64(2333539104, 810921078), -1166, false), new extFloat.Ptr(new Go$Uint64(3477244234, 1573795306), -1140, false), new extFloat.Ptr(new Go$Uint64(2590748842, 1432697645), -1113, false), new extFloat.Ptr(new Go$Uint64(3860516611, 1025131999), -1087, false), new extFloat.Ptr(new Go$Uint64(2876309015, 3348809418), -1060, false), new extFloat.Ptr(new Go$Uint64(4286034428, 3200048207), -1034, false), new extFloat.Ptr(new Go$Uint64(3193344495, 1097586188), -1007, false), new extFloat.Ptr(new Go$Uint64(2379227053, 2424306748), -980, false), new extFloat.Ptr(new Go$Uint64(3545324584, 827693699), -954, false), new extFloat.Ptr(new Go$Uint64(2641472655, 2913388981), -927, false), new extFloat.Ptr(new Go$Uint64(3936100983, 602835915), -901, false), new extFloat.Ptr(new Go$Uint64(2932623761, 1081627501), -874, false), new extFloat.Ptr(new Go$Uint64(2184974969, 1572261463), -847, false), new extFloat.Ptr(new Go$Uint64(3255866422, 1308317239), -821, false), new extFloat.Ptr(new Go$Uint64(2425809519, 944281679), -794, false), new extFloat.Ptr(new Go$Uint64(3614737867, 629291719), -768, false), new extFloat.Ptr(new Go$Uint64(2693189581, 2545915892), -741, false), new extFloat.Ptr(new Go$Uint64(4013165208, 388672741), -715, false), new extFloat.Ptr(new Go$Uint64(2990041083, 708162190), -688, false), new extFloat.Ptr(new Go$Uint64(2227754207, 3536207675), -661, false), new extFloat.Ptr(new Go$Uint64(3319612455, 450088378), -635, false), new extFloat.Ptr(new Go$Uint64(2473304014, 3139815830), -608, false), new extFloat.Ptr(new Go$Uint64(3685510180, 2103616900), -582, false), new extFloat.Ptr(new Go$Uint64(2745919064, 224385782), -555, false), new extFloat.Ptr(new Go$Uint64(4091738259, 3737383206), -529, false), new extFloat.Ptr(new Go$Uint64(3048582568, 2868871352), -502, false), new extFloat.Ptr(new Go$Uint64(2271371013, 1820084875), -475, false), new extFloat.Ptr(new Go$Uint64(3384606560, 885076051), -449, false), new extFloat.Ptr(new Go$Uint64(2521728396, 2444895829), -422, false), new extFloat.Ptr(new Go$Uint64(3757668132, 1881767613), -396, false), new extFloat.Ptr(new Go$Uint64(2799680927, 3102062735), -369, false), new extFloat.Ptr(new Go$Uint64(4171849679, 2289335700), -343, false), new extFloat.Ptr(new Go$Uint64(3108270227, 2410191823), -316, false), new extFloat.Ptr(new Go$Uint64(2315841784, 3205436779), -289, false), new extFloat.Ptr(new Go$Uint64(3450873173, 1697722806), -263, false), new extFloat.Ptr(new Go$Uint64(2571100870, 3497754540), -236, false), new extFloat.Ptr(new Go$Uint64(3831238852, 707476230), -210, false), new extFloat.Ptr(new Go$Uint64(2854495385, 1769181907), -183, false), new extFloat.Ptr(new Go$Uint64(4253529586, 2197867022), -157, false), new extFloat.Ptr(new Go$Uint64(3169126500, 2450594539), -130, false), new extFloat.Ptr(new Go$Uint64(2361183241, 1867548876), -103, false), new extFloat.Ptr(new Go$Uint64(3518437208, 3793315116), -77, false), new extFloat.Ptr(new Go$Uint64(2621440000, 0), -50, false), new extFloat.Ptr(new Go$Uint64(3906250000, 0), -24, false), new extFloat.Ptr(new Go$Uint64(2910383045, 2892103680), 3, false), new extFloat.Ptr(new Go$Uint64(2168404344, 4170451332), 30, false), new extFloat.Ptr(new Go$Uint64(3231174267, 3372684723), 56, false), new extFloat.Ptr(new Go$Uint64(2407412430, 2078956656), 83, false), new extFloat.Ptr(new Go$Uint64(3587324068, 2884206696), 109, false), new extFloat.Ptr(new Go$Uint64(2672764710, 395977285), 136, false), new extFloat.Ptr(new Go$Uint64(3982729777, 3569679143), 162, false), new extFloat.Ptr(new Go$Uint64(2967364920, 2361961896), 189, false), new extFloat.Ptr(new Go$Uint64(2210859150, 447440347), 216, false), new extFloat.Ptr(new Go$Uint64(3294436857, 1114709402), 242, false), new extFloat.Ptr(new Go$Uint64(2454546732, 2786846552), 269, false), new extFloat.Ptr(new Go$Uint64(3657559652, 443583978), 295, false), new extFloat.Ptr(new Go$Uint64(2725094297, 2599384906), 322, false), new extFloat.Ptr(new Go$Uint64(4060706939, 3028118405), 348, false), new extFloat.Ptr(new Go$Uint64(3025462433, 2044532855), 375, false), new extFloat.Ptr(new Go$Uint64(2254145170, 1536935362), 402, false), new extFloat.Ptr(new Go$Uint64(3358938053, 3365297469), 428, false), new extFloat.Ptr(new Go$Uint64(2502603868, 4204241075), 455, false), new extFloat.Ptr(new Go$Uint64(3729170365, 2577424355), 481, false), new extFloat.Ptr(new Go$Uint64(2778448436, 3677981733), 508, false), new extFloat.Ptr(new Go$Uint64(4140210802, 2744688476), 534, false), new extFloat.Ptr(new Go$Uint64(3084697427, 1424604878), 561, false), new extFloat.Ptr(new Go$Uint64(2298278679, 4062331362), 588, false), new extFloat.Ptr(new Go$Uint64(3424702107, 3546052773), 614, false), new extFloat.Ptr(new Go$Uint64(2551601907, 2065781727), 641, false), new extFloat.Ptr(new Go$Uint64(3802183132, 2535403578), 667, false), new extFloat.Ptr(new Go$Uint64(2832847187, 1558426518), 694, false), new extFloat.Ptr(new Go$Uint64(4221271257, 2762425404), 720, false), new extFloat.Ptr(new Go$Uint64(3145092172, 2812560400), 747, false), new extFloat.Ptr(new Go$Uint64(2343276271, 3057687578), 774, false), new extFloat.Ptr(new Go$Uint64(3491753744, 2790753324), 800, false), new extFloat.Ptr(new Go$Uint64(2601559269, 3918606633), 827, false), new extFloat.Ptr(new Go$Uint64(3876625403, 2711358621), 853, false), new extFloat.Ptr(new Go$Uint64(2888311001, 1648096297), 880, false), new extFloat.Ptr(new Go$Uint64(2151959390, 2057817989), 907, false), new extFloat.Ptr(new Go$Uint64(3206669376, 61660461), 933, false), new extFloat.Ptr(new Go$Uint64(2389154863, 1581580175), 960, false), new extFloat.Ptr(new Go$Uint64(3560118173, 2626467905), 986, false), new extFloat.Ptr(new Go$Uint64(2652494738, 3034782633), 1013, false), new extFloat.Ptr(new Go$Uint64(3952525166, 3135207385), 1039, false), new extFloat.Ptr(new Go$Uint64(2944860731, 2616258155), 1066, false)]);
		uint64pow10 = go$toNativeArray("Uint64", [new Go$Uint64(0, 1), new Go$Uint64(0, 10), new Go$Uint64(0, 100), new Go$Uint64(0, 1000), new Go$Uint64(0, 10000), new Go$Uint64(0, 100000), new Go$Uint64(0, 1000000), new Go$Uint64(0, 10000000), new Go$Uint64(0, 100000000), new Go$Uint64(0, 1000000000), new Go$Uint64(2, 1410065408), new Go$Uint64(23, 1215752192), new Go$Uint64(232, 3567587328), new Go$Uint64(2328, 1316134912), new Go$Uint64(23283, 276447232), new Go$Uint64(232830, 2764472320), new Go$Uint64(2328306, 1874919424), new Go$Uint64(23283064, 1569325056), new Go$Uint64(232830643, 2808348672), new Go$Uint64(2328306436, 2313682944)]);
		float32info = new floatInfo.Ptr(23, 8, -127);
		float64info = new floatInfo.Ptr(52, 11, -1023);
		isPrint16 = new (go$sliceType(Go$Uint16))([32, 126, 161, 887, 890, 894, 900, 1319, 1329, 1366, 1369, 1418, 1423, 1479, 1488, 1514, 1520, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869, 1969, 1984, 2042, 2048, 2093, 2096, 2139, 2142, 2142, 2208, 2220, 2276, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2555, 2561, 2570, 2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2654, 2662, 2677, 2689, 2745, 2748, 2765, 2768, 2768, 2784, 2787, 2790, 2801, 2817, 2828, 2831, 2832, 2835, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2915, 2918, 2935, 2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066, 3073, 3129, 3133, 3149, 3157, 3161, 3168, 3171, 3174, 3183, 3192, 3199, 3202, 3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3330, 3386, 3389, 3406, 3415, 3415, 3424, 3427, 3430, 3445, 3449, 3455, 3458, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535, 3551, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3716, 3719, 3722, 3725, 3725, 3732, 3751, 3754, 3773, 3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096, 4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789, 4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024, 5108, 5120, 5788, 5792, 5872, 5888, 5908, 5920, 5942, 5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809, 6816, 6829, 6912, 6987, 6992, 7036, 7040, 7155, 7164, 7223, 7227, 7241, 7245, 7295, 7360, 7367, 7376, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064, 8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305, 8308, 8348, 8352, 8378, 8400, 8432, 8448, 8585, 8592, 9203, 9216, 9254, 9280, 9290, 9312, 11084, 11088, 11097, 11264, 11507, 11513, 11559, 11565, 11565, 11568, 11623, 11631, 11632, 11647, 11670, 11680, 11835, 11904, 12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543, 12549, 12589, 12593, 12730, 12736, 12771, 12784, 19893, 19904, 40908, 40960, 42124, 42128, 42182, 42192, 42539, 42560, 42647, 42655, 42743, 42752, 42899, 42912, 42922, 43000, 43051, 43056, 43065, 43072, 43127, 43136, 43204, 43214, 43225, 43232, 43259, 43264, 43347, 43359, 43388, 43392, 43481, 43486, 43487, 43520, 43574, 43584, 43597, 43600, 43609, 43612, 43643, 43648, 43714, 43739, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43822, 43968, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831, 64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056, 65062, 65072, 65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533]);
		isNotPrint16 = new (go$sliceType(Go$Uint16))([173, 907, 909, 930, 1376, 1416, 1424, 1757, 2111, 2209, 2303, 2424, 2432, 2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653, 2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2820, 2857, 2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3076, 3085, 3089, 3113, 3124, 3141, 3145, 3159, 3204, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312, 3332, 3341, 3345, 3397, 3401, 3460, 3506, 3516, 3541, 3543, 3715, 3721, 3736, 3744, 3748, 3750, 3756, 3770, 3781, 3783, 3912, 3992, 4029, 4045, 4294, 4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901, 5997, 6001, 6751, 8024, 8026, 8028, 8030, 8117, 8133, 8156, 8181, 8335, 9984, 11311, 11359, 11558, 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, 11930, 12352, 12687, 12831, 13055, 42895, 43470, 43815, 64311, 64317, 64319, 64322, 64325, 65107, 65127, 65141, 65511]);
		isPrint32 = new (go$sliceType(Go$Uint32))([65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799, 65843, 65847, 65930, 65936, 65947, 66000, 66045, 66176, 66204, 66208, 66256, 66304, 66339, 66352, 66378, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729, 67584, 67589, 67592, 67640, 67644, 67644, 67647, 67679, 67840, 67867, 67871, 67897, 67903, 67903, 67968, 68023, 68030, 68031, 68096, 68102, 68108, 68147, 68152, 68154, 68159, 68167, 68176, 68184, 68192, 68223, 68352, 68405, 68409, 68437, 68440, 68466, 68472, 68479, 68608, 68680, 69216, 69246, 69632, 69709, 69714, 69743, 69760, 69825, 69840, 69864, 69872, 69881, 69888, 69955, 70016, 70088, 70096, 70105, 71296, 71351, 71360, 71369, 73728, 74606, 74752, 74850, 74864, 74867, 77824, 78894, 92160, 92728, 93952, 94020, 94032, 94078, 94095, 94111, 110592, 110593, 118784, 119029, 119040, 119078, 119081, 119154, 119163, 119261, 119296, 119365, 119552, 119638, 119648, 119665, 119808, 119967, 119970, 119970, 119973, 119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488, 120779, 120782, 120831, 126464, 126500, 126503, 126523, 126530, 126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625, 126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136, 127150, 127153, 127166, 127169, 127199, 127232, 127242, 127248, 127339, 127344, 127386, 127462, 127490, 127504, 127546, 127552, 127560, 127568, 127569, 127744, 127776, 127792, 127868, 127872, 127891, 127904, 127946, 127968, 127984, 128000, 128252, 128256, 128317, 128320, 128323, 128336, 128359, 128507, 128576, 128581, 128591, 128640, 128709, 128768, 128883, 131072, 173782, 173824, 177972, 177984, 178205, 194560, 195101, 917760, 917999]);
		isNotPrint32 = new (go$sliceType(Go$Uint16))([12, 39, 59, 62, 799, 926, 2057, 2102, 2134, 2564, 2580, 2584, 4285, 4405, 54357, 54429, 54445, 54458, 54460, 54468, 54534, 54549, 54557, 54586, 54591, 54597, 54609, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000, 61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024, 61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098, 61648, 61743, 62262, 62405, 62527, 62529, 62712]);
		shifts = go$toNativeArray("Uint", [0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0]);
	};
	return go$pkg;
})();
go$packages["strings"] = (function() {
	var go$pkg = {};
	var errors = go$packages["errors"];
	var io = go$packages["io"];
	var utf8 = go$packages["unicode/utf8"];
	var unicode = go$packages["unicode"];
	var Reader;
	Reader = go$newType(0, "Struct", "strings.Reader", "Reader", "strings", function(s_, i_, prevRune_) {
		this.go$val = this;
		this.s = s_ !== undefined ? s_ : "";
		this.i = i_ !== undefined ? i_ : 0;
		this.prevRune = prevRune_ !== undefined ? prevRune_ : 0;
	});
	go$pkg.Reader = Reader;
	var Replacer;
	Replacer = go$newType(0, "Struct", "strings.Replacer", "Replacer", "strings", function(r_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
	});
	go$pkg.Replacer = Replacer;
	var replacer;
	replacer = go$newType(0, "Interface", "strings.replacer", "replacer", "strings", null);
	go$pkg.replacer = replacer;
	var byteBitmap;
	byteBitmap = go$newType(0, "Array", "strings.byteBitmap", "byteBitmap", "strings", null);
	go$pkg.byteBitmap = byteBitmap;
	var trieNode;
	trieNode = go$newType(0, "Struct", "strings.trieNode", "trieNode", "strings", function(value_, priority_, prefix_, next_, table_) {
		this.go$val = this;
		this.value = value_ !== undefined ? value_ : "";
		this.priority = priority_ !== undefined ? priority_ : 0;
		this.prefix = prefix_ !== undefined ? prefix_ : "";
		this.next = next_ !== undefined ? next_ : (go$ptrType(trieNode)).nil;
		this.table = table_ !== undefined ? table_ : (go$sliceType((go$ptrType(trieNode)))).nil;
	});
	go$pkg.trieNode = trieNode;
	var genericReplacer;
	genericReplacer = go$newType(0, "Struct", "strings.genericReplacer", "genericReplacer", "strings", function(root_, tableSize_, mapping_) {
		this.go$val = this;
		this.root = root_ !== undefined ? root_ : new trieNode.Ptr();
		this.tableSize = tableSize_ !== undefined ? tableSize_ : 0;
		this.mapping = mapping_ !== undefined ? mapping_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
	});
	go$pkg.genericReplacer = genericReplacer;
	var appendSliceWriter;
	appendSliceWriter = go$newType(0, "Slice", "strings.appendSliceWriter", "appendSliceWriter", "strings", null);
	go$pkg.appendSliceWriter = appendSliceWriter;
	var stringWriterIface;
	stringWriterIface = go$newType(0, "Interface", "strings.stringWriterIface", "stringWriterIface", "strings", null);
	go$pkg.stringWriterIface = stringWriterIface;
	var stringWriter;
	stringWriter = go$newType(0, "Struct", "strings.stringWriter", "stringWriter", "strings", function(w_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : null;
	});
	go$pkg.stringWriter = stringWriter;
	var singleStringReplacer;
	singleStringReplacer = go$newType(0, "Struct", "strings.singleStringReplacer", "singleStringReplacer", "strings", function(finder_, value_) {
		this.go$val = this;
		this.finder = finder_ !== undefined ? finder_ : (go$ptrType(stringFinder)).nil;
		this.value = value_ !== undefined ? value_ : "";
	});
	go$pkg.singleStringReplacer = singleStringReplacer;
	var byteReplacer;
	byteReplacer = go$newType(0, "Struct", "strings.byteReplacer", "byteReplacer", "strings", function(old_, new$1_) {
		this.go$val = this;
		this.old = old_ !== undefined ? old_ : go$makeNativeArray("Uint32", 8, function() { return 0; });
		this.new$1 = new$1_ !== undefined ? new$1_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
	});
	go$pkg.byteReplacer = byteReplacer;
	var byteStringReplacer;
	byteStringReplacer = go$newType(0, "Struct", "strings.byteStringReplacer", "byteStringReplacer", "strings", function(old_, new$1_) {
		this.go$val = this;
		this.old = old_ !== undefined ? old_ : go$makeNativeArray("Uint32", 8, function() { return 0; });
		this.new$1 = new$1_ !== undefined ? new$1_ : go$makeNativeArray("Slice", 256, function() { return (go$sliceType(Go$Uint8)).nil; });
	});
	go$pkg.byteStringReplacer = byteStringReplacer;
	var stringFinder;
	stringFinder = go$newType(0, "Struct", "strings.stringFinder", "stringFinder", "strings", function(pattern_, badCharSkip_, goodSuffixSkip_) {
		this.go$val = this;
		this.pattern = pattern_ !== undefined ? pattern_ : "";
		this.badCharSkip = badCharSkip_ !== undefined ? badCharSkip_ : go$makeNativeArray("Int", 256, function() { return 0; });
		this.goodSuffixSkip = goodSuffixSkip_ !== undefined ? goodSuffixSkip_ : (go$sliceType(Go$Int)).nil;
	});
	go$pkg.stringFinder = stringFinder;
	Reader.init([["s", "strings", Go$String, ""], ["i", "strings", Go$Int, ""], ["prevRune", "strings", Go$Int, ""]]);
	(go$ptrType(Reader)).methods = [["Len", "", [], [Go$Int], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["ReadByte", "", [], [Go$Uint8, go$error], false], ["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["Seek", "", [Go$Int64, Go$Int], [Go$Int64, go$error], false], ["UnreadByte", "", [], [go$error], false], ["UnreadRune", "", [], [go$error], false], ["WriteTo", "", [io.Writer], [Go$Int64, go$error], false]];
	Replacer.init([["r", "strings", replacer, ""]]);
	(go$ptrType(Replacer)).methods = [["Replace", "", [Go$String], [Go$String], false], ["WriteString", "", [io.Writer, Go$String], [Go$Int, go$error], false]];
	replacer.init([["Replace", "", (go$funcType([Go$String], [Go$String], false))], ["WriteString", "", (go$funcType([io.Writer, Go$String], [Go$Int, go$error], false))]]);
	byteBitmap.init(Go$Uint32, 8);
	(go$ptrType(byteBitmap)).methods = [["set", "strings", [Go$Uint8], [], false]];
	trieNode.init([["value", "strings", Go$String, ""], ["priority", "strings", Go$Int, ""], ["prefix", "strings", Go$String, ""], ["next", "strings", (go$ptrType(trieNode)), ""], ["table", "strings", (go$sliceType((go$ptrType(trieNode)))), ""]]);
	(go$ptrType(trieNode)).methods = [["add", "strings", [Go$String, Go$String, Go$Int, (go$ptrType(genericReplacer))], [], false]];
	genericReplacer.init([["root", "strings", trieNode, ""], ["tableSize", "strings", Go$Int, ""], ["mapping", "strings", (go$arrayType(Go$Uint8, 256)), ""]]);
	(go$ptrType(genericReplacer)).methods = [["Replace", "", [Go$String], [Go$String], false], ["WriteString", "", [io.Writer, Go$String], [Go$Int, go$error], false], ["lookup", "strings", [Go$String, Go$Bool], [Go$String, Go$Int, Go$Bool], false]];
	appendSliceWriter.init(Go$Uint8);
	(go$ptrType(appendSliceWriter)).methods = [["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["WriteString", "", [Go$String], [Go$Int, go$error], false]];
	stringWriterIface.init([["WriteString", "", (go$funcType([Go$String], [Go$Int, go$error], false))]]);
	stringWriter.init([["w", "strings", io.Writer, ""]]);
	stringWriter.methods = [["WriteString", "", [Go$String], [Go$Int, go$error], false]];
	(go$ptrType(stringWriter)).methods = [["WriteString", "", [Go$String], [Go$Int, go$error], false]];
	singleStringReplacer.init([["finder", "strings", (go$ptrType(stringFinder)), ""], ["value", "strings", Go$String, ""]]);
	(go$ptrType(singleStringReplacer)).methods = [["Replace", "", [Go$String], [Go$String], false], ["WriteString", "", [io.Writer, Go$String], [Go$Int, go$error], false]];
	byteReplacer.init([["old", "strings", byteBitmap, ""], ["new", "strings", (go$arrayType(Go$Uint8, 256)), ""]]);
	(go$ptrType(byteReplacer)).methods = [["Replace", "", [Go$String], [Go$String], false], ["WriteString", "", [io.Writer, Go$String], [Go$Int, go$error], false]];
	byteStringReplacer.init([["old", "strings", byteBitmap, ""], ["new", "strings", (go$arrayType((go$sliceType(Go$Uint8)), 256)), ""]]);
	(go$ptrType(byteStringReplacer)).methods = [["Replace", "", [Go$String], [Go$String], false], ["WriteString", "", [io.Writer, Go$String], [Go$Int, go$error], false]];
	stringFinder.init([["pattern", "strings", Go$String, ""], ["badCharSkip", "strings", (go$arrayType(Go$Int, 256)), ""], ["goodSuffixSkip", "strings", (go$sliceType(Go$Int)), ""]]);
	(go$ptrType(stringFinder)).methods = [["next", "strings", [Go$String], [Go$Int], false]];
	Reader.Ptr.prototype.Len = function() {
		var r;
		r = this;
		if (r.i >= r.s.length) {
			return 0;
		}
		return r.s.length - r.i >> 0;
	};
	Reader.prototype.Len = function() { return this.go$val.Len(); };
	Reader.Ptr.prototype.Read = function(b) {
		var n, err, r, _tuple, _tuple$1;
		n = 0;
		err = null;
		r = this;
		if (b.length === 0) {
			_tuple = [0, null], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (r.i >= r.s.length) {
			_tuple$1 = [0, io.EOF], n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		n = go$copyString(b, r.s.substring(r.i));
		r.i = r.i + (n) >> 0;
		r.prevRune = -1;
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.go$val.Read(b); };
	Reader.Ptr.prototype.ReadAt = function(b, off) {
		var n, err, r, _tuple, x, _tuple$1;
		n = 0;
		err = null;
		r = this;
		if ((off.high < 0 || (off.high === 0 && off.low < 0))) {
			_tuple = [0, errors.New("strings: invalid offset")], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if ((x = new Go$Int64(0, r.s.length), (off.high > x.high || (off.high === x.high && off.low >= x.low)))) {
			_tuple$1 = [0, io.EOF], n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		n = go$copyString(b, r.s.substring(((off.low + ((off.high >> 31) * 4294967296)) >> 0)));
		if (n < b.length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.go$val.ReadAt(b, off); };
	Reader.Ptr.prototype.ReadByte = function() {
		var b, err, r, _tuple;
		b = 0;
		err = null;
		r = this;
		if (r.i >= r.s.length) {
			_tuple = [0, io.EOF], b = _tuple[0], err = _tuple[1];
			return [b, err];
		}
		b = r.s.charCodeAt(r.i);
		r.i = r.i + 1 >> 0;
		r.prevRune = -1;
		return [b, err];
	};
	Reader.prototype.ReadByte = function() { return this.go$val.ReadByte(); };
	Reader.Ptr.prototype.UnreadByte = function() {
		var r;
		r = this;
		if (r.i <= 0) {
			return errors.New("strings.Reader: at beginning of string");
		}
		r.i = r.i - 1 >> 0;
		r.prevRune = -1;
		return null;
	};
	Reader.prototype.UnreadByte = function() { return this.go$val.UnreadByte(); };
	Reader.Ptr.prototype.ReadRune = function() {
		var ch, size, err, r, _tuple, c, _tuple$1, _tuple$2;
		ch = 0;
		size = 0;
		err = null;
		r = this;
		if (r.i >= r.s.length) {
			_tuple = [0, 0, io.EOF], ch = _tuple[0], size = _tuple[1], err = _tuple[2];
			return [ch, size, err];
		}
		r.prevRune = r.i;
		if (c = r.s.charCodeAt(r.i), c < 128) {
			r.i = r.i + 1 >> 0;
			_tuple$1 = [(c >> 0), 1, null], ch = _tuple$1[0], size = _tuple$1[1], err = _tuple$1[2];
			return [ch, size, err];
		}
		_tuple$2 = utf8.DecodeRuneInString(r.s.substring(r.i)), ch = _tuple$2[0], size = _tuple$2[1];
		r.i = r.i + (size) >> 0;
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	Reader.Ptr.prototype.UnreadRune = function() {
		var r;
		r = this;
		if (r.prevRune < 0) {
			return errors.New("strings.Reader: previous operation was not ReadRune");
		}
		r.i = r.prevRune;
		r.prevRune = -1;
		return null;
	};
	Reader.prototype.UnreadRune = function() { return this.go$val.UnreadRune(); };
	Reader.Ptr.prototype.Seek = function(offset, whence) {
		var r, abs, _ref, x, x$1;
		r = this;
		abs = new Go$Int64(0, 0);
		_ref = whence;
		if (_ref === 0) {
			abs = offset;
		} else if (_ref === 1) {
			abs = (x = new Go$Int64(0, r.i), new Go$Int64(x.high + offset.high, x.low + offset.low));
		} else if (_ref === 2) {
			abs = (x$1 = new Go$Int64(0, r.s.length), new Go$Int64(x$1.high + offset.high, x$1.low + offset.low));
		} else {
			return [new Go$Int64(0, 0), errors.New("strings: invalid whence")];
		}
		if ((abs.high < 0 || (abs.high === 0 && abs.low < 0))) {
			return [new Go$Int64(0, 0), errors.New("strings: negative position")];
		}
		if ((abs.high > 0 || (abs.high === 0 && abs.low >= 2147483648))) {
			return [new Go$Int64(0, 0), errors.New("strings: position out of range")];
		}
		r.i = ((abs.low + ((abs.high >> 31) * 4294967296)) >> 0);
		return [abs, null];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.go$val.Seek(offset, whence); };
	Reader.Ptr.prototype.WriteTo = function(w) {
		var n, err, r, _tuple, s, _tuple$1, m;
		n = new Go$Int64(0, 0);
		err = null;
		r = this;
		r.prevRune = -1;
		if (r.i >= r.s.length) {
			_tuple = [new Go$Int64(0, 0), null], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		s = r.s.substring(r.i);
		_tuple$1 = io.WriteString(w, s), m = _tuple$1[0], err = _tuple$1[1];
		if (m > s.length) {
			throw go$panic(new Go$String("strings.Reader.WriteTo: invalid WriteString count"));
		}
		r.i = r.i + (m) >> 0;
		n = new Go$Int64(0, m);
		if (!((m === s.length)) && go$interfaceIsEqual(err, null)) {
			err = io.ErrShortWrite;
		}
		return [n, err];
	};
	Reader.prototype.WriteTo = function(w) { return this.go$val.WriteTo(w); };
	var NewReader = go$pkg.NewReader = function(s) {
		return new Reader.Ptr(s, 0, -1);
	};
	byteBitmap.prototype.set = function(b) {
		var m, _lhs, _index, y;
		m = this.go$val;
		_lhs = m, _index = b >>> 5 << 24 >>> 24, _lhs[_index] = (_lhs[_index] | (((y = (((b & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0;
	};
	go$ptrType(byteBitmap).prototype.set = function(b) { return (new byteBitmap(this.go$get())).set(b); };
	var NewReplacer = go$pkg.NewReplacer = function(oldnew) {
		var _r, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, allNewBytes, i, _slice$3, _index$3, _slice$4, _index$4, bb, i$1, _slice$5, _index$5, _slice$6, _index$6, _tuple, o, n, y, bs, i$2, _slice$7, _index$7, _slice$8, _index$8, _tuple$1, o$1, new$1, y$1;
		if ((_r = oldnew.length % 2, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 1) {
			throw go$panic(new Go$String("strings.NewReplacer: odd argument count"));
		}
		if ((oldnew.length === 2) && (_slice = oldnew, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).length > 1) {
			return new Replacer.Ptr(makeSingleStringReplacer((_slice$1 = oldnew, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = oldnew, _index$2 = 1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))));
		}
		allNewBytes = true;
		i = 0;
		while (i < oldnew.length) {
			if (!(((_slice$3 = oldnew, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).length === 1))) {
				return new Replacer.Ptr(makeGenericReplacer(oldnew));
			}
			if (!(((_slice$4 = oldnew, _index$4 = (i + 1 >> 0), (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).length === 1))) {
				allNewBytes = false;
			}
			i = i + 2 >> 0;
		}
		if (allNewBytes) {
			bb = new byteReplacer.Ptr(go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint8", 256, function() { return 0; }));
			i$1 = 0;
			while (i$1 < oldnew.length) {
				_tuple = [(_slice$5 = oldnew, _index$5 = i$1, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).charCodeAt(0), (_slice$6 = oldnew, _index$6 = (i$1 + 1 >> 0), (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).charCodeAt(0)], o = _tuple[0], n = _tuple[1];
				if (!((((bb.old[(o >>> 5 << 24 >>> 24)] & ((y = (((o & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0)) >>> 0) === 0))) {
					i$1 = i$1 + 2 >> 0;
					continue;
				}
				(new byteBitmap(bb.old)).set(o);
				bb.new$1[o] = n;
				i$1 = i$1 + 2 >> 0;
			}
			return new Replacer.Ptr(bb);
		}
		bs = new byteStringReplacer.Ptr(go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Slice", 256, function() { return (go$sliceType(Go$Uint8)).nil; }));
		i$2 = 0;
		while (i$2 < oldnew.length) {
			_tuple$1 = [(_slice$7 = oldnew, _index$7 = i$2, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).charCodeAt(0), (_slice$8 = oldnew, _index$8 = (i$2 + 1 >> 0), (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range"))], o$1 = _tuple$1[0], new$1 = _tuple$1[1];
			if (!((((bs.old[(o$1 >>> 5 << 24 >>> 24)] & ((y$1 = (((o$1 & 31) >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >>> 0)) >>> 0) === 0))) {
				i$2 = i$2 + 2 >> 0;
				continue;
			}
			(new byteBitmap(bs.old)).set(o$1);
			bs.new$1[o$1] = new (go$sliceType(Go$Uint8))(go$stringToBytes(new$1));
			i$2 = i$2 + 2 >> 0;
		}
		return new Replacer.Ptr(bs);
	};
	Replacer.Ptr.prototype.Replace = function(s) {
		var r;
		r = this;
		return r.r.Replace(s);
	};
	Replacer.prototype.Replace = function(s) { return this.go$val.Replace(s); };
	Replacer.Ptr.prototype.WriteString = function(w, s) {
		var n, err, r, _tuple;
		n = 0;
		err = null;
		r = this;
		_tuple = r.r.WriteString(w, s), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	Replacer.prototype.WriteString = function(w, s) { return this.go$val.WriteString(w, s); };
	trieNode.Ptr.prototype.add = function(key, val, priority, r) {
		var t, n, prefixNode, keyNode, _slice, _index, _slice$1, _index$1, next, m, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4;
		t = this;
		if (key === "") {
			if (t.priority === 0) {
				t.value = val;
				t.priority = priority;
			}
			return;
		}
		if (!(t.prefix === "")) {
			n = 0;
			while (n < t.prefix.length && n < key.length) {
				if (!((t.prefix.charCodeAt(n) === key.charCodeAt(n)))) {
					break;
				}
				n = n + 1 >> 0;
			}
			if (n === t.prefix.length) {
				t.next.add(key.substring(n), val, priority, r);
			} else if (n === 0) {
				prefixNode = (go$ptrType(trieNode)).nil;
				if (t.prefix.length === 1) {
					prefixNode = t.next;
				} else {
					prefixNode = new trieNode.Ptr("", 0, t.prefix.substring(1), t.next, (go$sliceType((go$ptrType(trieNode)))).nil);
				}
				keyNode = new trieNode.Ptr();
				t.table = (go$sliceType((go$ptrType(trieNode)))).make(r.tableSize, 0, function() { return (go$ptrType(trieNode)).nil; });
				_slice = t.table, _index = r.mapping[t.prefix.charCodeAt(0)], (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = prefixNode) : go$throwRuntimeError("index out of range");
				_slice$1 = t.table, _index$1 = r.mapping[key.charCodeAt(0)], (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = keyNode) : go$throwRuntimeError("index out of range");
				t.prefix = "";
				t.next = (go$ptrType(trieNode)).nil;
				keyNode.add(key.substring(1), val, priority, r);
			} else {
				next = new trieNode.Ptr("", 0, t.prefix.substring(n), t.next, (go$sliceType((go$ptrType(trieNode)))).nil);
				t.prefix = t.prefix.substring(0, n);
				t.next = next;
				next.add(key.substring(n), val, priority, r);
			}
		} else if (!(t.table === (go$sliceType((go$ptrType(trieNode)))).nil)) {
			m = r.mapping[key.charCodeAt(0)];
			if ((_slice$2 = t.table, _index$2 = m, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) === (go$ptrType(trieNode)).nil) {
				_slice$3 = t.table, _index$3 = m, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = new trieNode.Ptr()) : go$throwRuntimeError("index out of range");
			}
			(_slice$4 = t.table, _index$4 = m, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).add(key.substring(1), val, priority, r);
		} else {
			t.prefix = key;
			t.next = new trieNode.Ptr();
			t.next.add("", val, priority, r);
		}
	};
	trieNode.prototype.add = function(key, val, priority, r) { return this.go$val.add(key, val, priority, r); };
	genericReplacer.Ptr.prototype.lookup = function(s, ignoreRoot) {
		var val, keylen, found, r, bestPriority, node, n, index, _slice, _index;
		val = "";
		keylen = 0;
		found = false;
		r = this;
		bestPriority = 0;
		node = r.root;
		n = 0;
		while (!(node === (go$ptrType(trieNode)).nil)) {
			if (node.priority > bestPriority && !(ignoreRoot && node === r.root)) {
				bestPriority = node.priority;
				val = node.value;
				keylen = n;
				found = true;
			}
			if (s === "") {
				break;
			}
			if (!(node.table === (go$sliceType((go$ptrType(trieNode)))).nil)) {
				index = r.mapping[s.charCodeAt(0)];
				if ((index >> 0) === r.tableSize) {
					break;
				}
				node = (_slice = node.table, _index = index, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				s = s.substring(1);
				n = n + 1 >> 0;
			} else if (!(node.prefix === "") && HasPrefix(s, node.prefix)) {
				n = n + (node.prefix.length) >> 0;
				s = s.substring(node.prefix.length);
				node = node.next;
			} else {
				break;
			}
		}
		return [val, keylen, found];
	};
	genericReplacer.prototype.lookup = function(s, ignoreRoot) { return this.go$val.lookup(s, ignoreRoot); };
	var makeGenericReplacer = function(oldnew) {
		var r, i, _slice, _index, key, j, _ref, _i, b, index, _ref$1, _i$1, b$1, i$1, i$2, _slice$1, _index$1, _slice$2, _index$2;
		r = new genericReplacer.Ptr();
		i = 0;
		while (i < oldnew.length) {
			key = (_slice = oldnew, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			j = 0;
			while (j < key.length) {
				r.mapping[key.charCodeAt(j)] = 1;
				j = j + 1 >> 0;
			}
			i = i + 2 >> 0;
		}
		_ref = r.mapping;
		_i = 0;
		while (_i < 256) {
			b = _ref[_i];
			r.tableSize = r.tableSize + ((b >> 0)) >> 0;
			_i++;
		}
		index = 0;
		_ref$1 = r.mapping;
		_i$1 = 0;
		while (_i$1 < 256) {
			b$1 = _ref$1[_i$1];
			i$1 = _i$1;
			if (b$1 === 0) {
				r.mapping[i$1] = (r.tableSize << 24 >>> 24);
			} else {
				r.mapping[i$1] = index;
				index = index + 1 << 24 >>> 24;
			}
			_i$1++;
		}
		r.root.table = (go$sliceType((go$ptrType(trieNode)))).make(r.tableSize, 0, function() { return (go$ptrType(trieNode)).nil; });
		i$2 = 0;
		while (i$2 < oldnew.length) {
			r.root.add((_slice$1 = oldnew, _index$1 = i$2, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = oldnew, _index$2 = (i$2 + 1 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), oldnew.length - i$2 >> 0, r);
			i$2 = i$2 + 2 >> 0;
		}
		return r;
	};
	go$ptrType(appendSliceWriter).prototype.Write = function(p) {
		var w;
		w = this;
		w.go$set(go$appendSlice(w.go$get(), p));
		return [p.length, null];
	};
	appendSliceWriter.prototype.Write = function(p) { var obj = this; return (new (go$ptrType(appendSliceWriter))(function() { return obj; }, null)).Write(p); };
	go$ptrType(appendSliceWriter).prototype.WriteString = function(s) {
		var w;
		w = this;
		w.go$set(go$appendSlice(w.go$get(), new appendSliceWriter(go$stringToBytes(s))));
		return [s.length, null];
	};
	appendSliceWriter.prototype.WriteString = function(s) { var obj = this; return (new (go$ptrType(appendSliceWriter))(function() { return obj; }, null)).WriteString(s); };
	stringWriter.Ptr.prototype.WriteString = function(s) {
		var _struct, w;
		w = (_struct = this, new stringWriter.Ptr(_struct.w));
		return w.w.Write(new (go$sliceType(Go$Uint8))(go$stringToBytes(s)));
	};
	stringWriter.prototype.WriteString = function(s) { return this.go$val.WriteString(s); };
	var getStringWriter = function(w) {
		var _tuple, sw, ok, x;
		_tuple = (w !== null && stringWriterIface.implementedBy.indexOf(w.constructor) !== -1 ? [w, true] : [null, false]), sw = _tuple[0], ok = _tuple[1];
		if (!ok) {
			sw = (x = new stringWriter.Ptr(w), new x.constructor.Struct(x));
		}
		return sw;
	};
	genericReplacer.Ptr.prototype.Replace = function(s) {
		var r, buf, v;
		r = this;
		buf = appendSliceWriter.make(0, s.length, function() { return 0; });
		r.WriteString(new (go$ptrType(appendSliceWriter))(function() { return buf; }, function(v) { buf = v; }), s);
		return go$bytesToString(buf);
	};
	genericReplacer.prototype.Replace = function(s) { return this.go$val.Replace(s); };
	genericReplacer.Ptr.prototype.WriteString = function(w, s) {
		var n, err, r, sw, _tuple, last, wn, prevMatchEmpty, i, _tuple$1, val, keylen, match, _tuple$2, _tuple$3, _tuple$4;
		n = 0;
		err = null;
		r = this;
		sw = getStringWriter(w);
		_tuple = [0, 0], last = _tuple[0], wn = _tuple[1];
		prevMatchEmpty = false;
		i = 0;
		while (i <= s.length) {
			_tuple$1 = r.lookup(s.substring(i), prevMatchEmpty), val = _tuple$1[0], keylen = _tuple$1[1], match = _tuple$1[2];
			prevMatchEmpty = match && (keylen === 0);
			if (match) {
				_tuple$2 = sw.WriteString(s.substring(last, i)), wn = _tuple$2[0], err = _tuple$2[1];
				n = n + (wn) >> 0;
				if (!(go$interfaceIsEqual(err, null))) {
					return [n, err];
				}
				_tuple$3 = sw.WriteString(val), wn = _tuple$3[0], err = _tuple$3[1];
				n = n + (wn) >> 0;
				if (!(go$interfaceIsEqual(err, null))) {
					return [n, err];
				}
				i = i + (keylen) >> 0;
				last = i;
				continue;
			}
			i = i + 1 >> 0;
		}
		if (!((last === s.length))) {
			_tuple$4 = sw.WriteString(s.substring(last)), wn = _tuple$4[0], err = _tuple$4[1];
			n = n + (wn) >> 0;
		}
		return [n, err];
	};
	genericReplacer.prototype.WriteString = function(w, s) { return this.go$val.WriteString(w, s); };
	var makeSingleStringReplacer = function(pattern, value) {
		return new singleStringReplacer.Ptr(makeStringFinder(pattern), value);
	};
	singleStringReplacer.Ptr.prototype.Replace = function(s) {
		var r, buf, _tuple, i, matched, match;
		r = this;
		buf = (go$sliceType(Go$Uint8)).nil;
		_tuple = [0, false], i = _tuple[0], matched = _tuple[1];
		while (true) {
			match = r.finder.next(s.substring(i));
			if (match === -1) {
				break;
			}
			matched = true;
			buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes(s.substring(i, (i + match >> 0)))));
			buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes(r.value)));
			i = i + ((match + r.finder.pattern.length >> 0)) >> 0;
		}
		if (!matched) {
			return s;
		}
		buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes(s.substring(i))));
		return go$bytesToString(buf);
	};
	singleStringReplacer.prototype.Replace = function(s) { return this.go$val.Replace(s); };
	singleStringReplacer.Ptr.prototype.WriteString = function(w, s) {
		var n, err, r, sw, _tuple, i, wn, match, _tuple$1, _tuple$2, _tuple$3;
		n = 0;
		err = null;
		r = this;
		sw = getStringWriter(w);
		_tuple = [0, 0], i = _tuple[0], wn = _tuple[1];
		while (true) {
			match = r.finder.next(s.substring(i));
			if (match === -1) {
				break;
			}
			_tuple$1 = sw.WriteString(s.substring(i, (i + match >> 0))), wn = _tuple$1[0], err = _tuple$1[1];
			n = n + (wn) >> 0;
			if (!(go$interfaceIsEqual(err, null))) {
				return [n, err];
			}
			_tuple$2 = sw.WriteString(r.value), wn = _tuple$2[0], err = _tuple$2[1];
			n = n + (wn) >> 0;
			if (!(go$interfaceIsEqual(err, null))) {
				return [n, err];
			}
			i = i + ((match + r.finder.pattern.length >> 0)) >> 0;
		}
		_tuple$3 = sw.WriteString(s.substring(i)), wn = _tuple$3[0], err = _tuple$3[1];
		n = n + (wn) >> 0;
		return [n, err];
	};
	singleStringReplacer.prototype.WriteString = function(w, s) { return this.go$val.WriteString(w, s); };
	byteReplacer.Ptr.prototype.Replace = function(s) {
		var r, buf, i, b, y, _slice, _index;
		r = this;
		buf = (go$sliceType(Go$Uint8)).nil;
		i = 0;
		while (i < s.length) {
			b = s.charCodeAt(i);
			if (!((((r.old[(b >>> 5 << 24 >>> 24)] & ((y = (((b & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0)) >>> 0) === 0))) {
				if (buf === (go$sliceType(Go$Uint8)).nil) {
					buf = new (go$sliceType(Go$Uint8))(go$stringToBytes(s));
				}
				_slice = buf, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = r.new$1[b]) : go$throwRuntimeError("index out of range");
			}
			i = i + 1 >> 0;
		}
		if (buf === (go$sliceType(Go$Uint8)).nil) {
			return s;
		}
		return go$bytesToString(buf);
	};
	byteReplacer.prototype.Replace = function(s) { return this.go$val.Replace(s); };
	byteReplacer.Ptr.prototype.WriteString = function(w, s) {
		var n, err, r, bufsize, buf, ncopy, _ref, _i, _slice, _index, b, i, y, _slice$1, _index$1, _tuple, wn, err$1, _tuple$1, _tuple$2;
		n = 0;
		err = null;
		r = this;
		bufsize = 32768;
		if (s.length < bufsize) {
			bufsize = s.length;
		}
		buf = (go$sliceType(Go$Uint8)).make(bufsize, 0, function() { return 0; });
		while (s.length > 0) {
			ncopy = go$copyString(buf, s);
			s = s.substring(ncopy);
			_ref = go$subslice(buf, 0, ncopy);
			_i = 0;
			while (_i < _ref.length) {
				b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				if (!((((r.old[(b >>> 5 << 24 >>> 24)] & ((y = (((b & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0)) >>> 0) === 0))) {
					_slice$1 = buf, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = r.new$1[b]) : go$throwRuntimeError("index out of range");
				}
				_i++;
			}
			_tuple = w.Write(go$subslice(buf, 0, ncopy)), wn = _tuple[0], err$1 = _tuple[1];
			n = n + (wn) >> 0;
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$1 = [n, err$1], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
		}
		_tuple$2 = [n, null], n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	byteReplacer.prototype.WriteString = function(w, s) { return this.go$val.WriteString(w, s); };
	byteStringReplacer.Ptr.prototype.Replace = function(s) {
		var r, newSize, anyChanges, i, b, y, buf, bi, i$1, b$1, y$1, n, _slice, _index;
		r = this;
		newSize = 0;
		anyChanges = false;
		i = 0;
		while (i < s.length) {
			b = s.charCodeAt(i);
			if (!((((r.old[(b >>> 5 << 24 >>> 24)] & ((y = (((b & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0)) >>> 0) === 0))) {
				anyChanges = true;
				newSize = newSize + (r.new$1[b].length) >> 0;
			} else {
				newSize = newSize + 1 >> 0;
			}
			i = i + 1 >> 0;
		}
		if (!anyChanges) {
			return s;
		}
		buf = (go$sliceType(Go$Uint8)).make(newSize, 0, function() { return 0; });
		bi = buf;
		i$1 = 0;
		while (i$1 < s.length) {
			b$1 = s.charCodeAt(i$1);
			if (!((((r.old[(b$1 >>> 5 << 24 >>> 24)] & ((y$1 = (((b$1 & 31) >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >>> 0)) >>> 0) === 0))) {
				n = go$copySlice(bi, r.new$1[b$1]);
				bi = go$subslice(bi, n);
			} else {
				_slice = bi, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = b$1) : go$throwRuntimeError("index out of range");
				bi = go$subslice(bi, 1);
			}
			i$1 = i$1 + 1 >> 0;
		}
		return go$bytesToString(buf);
	};
	byteStringReplacer.prototype.Replace = function(s) { return this.go$val.Replace(s); };
	byteStringReplacer.Ptr.prototype.WriteString = function(w, s) {
		var n, err, r, bufsize, buf, bi, i, b, new$1, y, _tuple, nw, err$1, _tuple$1, _tuple$2, nw$1, err$2, _tuple$3, _tuple$4, nw$2, err$3, _tuple$5, _tuple$6;
		n = 0;
		err = null;
		r = this;
		bufsize = 32768;
		if (s.length < bufsize) {
			bufsize = s.length;
		}
		buf = (go$sliceType(Go$Uint8)).make(bufsize, 0, function() { return 0; });
		bi = go$subslice(buf, 0, 0);
		i = 0;
		while (i < s.length) {
			b = s.charCodeAt(i);
			new$1 = (go$sliceType(Go$Uint8)).nil;
			if (!((((r.old[(b >>> 5 << 24 >>> 24)] & ((y = (((b & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0)) >>> 0) === 0))) {
				new$1 = r.new$1[b];
			} else {
				bi = go$append(bi, b);
			}
			if ((bi.length === bi.capacity) || (bi.length > 0 && new$1.length > 0)) {
				_tuple = w.Write(bi), nw = _tuple[0], err$1 = _tuple[1];
				n = n + (nw) >> 0;
				if (!(go$interfaceIsEqual(err$1, null))) {
					_tuple$1 = [n, err$1], n = _tuple$1[0], err = _tuple$1[1];
					return [n, err];
				}
				bi = go$subslice(buf, 0, 0);
			}
			if (new$1.length > 0) {
				_tuple$2 = w.Write(new$1), nw$1 = _tuple$2[0], err$2 = _tuple$2[1];
				n = n + (nw$1) >> 0;
				if (!(go$interfaceIsEqual(err$2, null))) {
					_tuple$3 = [n, err$2], n = _tuple$3[0], err = _tuple$3[1];
					return [n, err];
				}
			}
			i = i + 1 >> 0;
		}
		if (bi.length > 0) {
			_tuple$4 = w.Write(bi), nw$2 = _tuple$4[0], err$3 = _tuple$4[1];
			n = n + (nw$2) >> 0;
			if (!(go$interfaceIsEqual(err$3, null))) {
				_tuple$5 = [n, err$3], n = _tuple$5[0], err = _tuple$5[1];
				return [n, err];
			}
		}
		_tuple$6 = [n, null], n = _tuple$6[0], err = _tuple$6[1];
		return [n, err];
	};
	byteStringReplacer.prototype.WriteString = function(w, s) { return this.go$val.WriteString(w, s); };
	var makeStringFinder = function(pattern) {
		var f, last, _ref, _i, i, i$1, lastPrefix, i$2, _slice, _index, i$3, lenSuffix, _slice$1, _index$1;
		f = new stringFinder.Ptr(pattern, go$makeNativeArray("Int", 256, function() { return 0; }), (go$sliceType(Go$Int)).make(pattern.length, 0, function() { return 0; }));
		last = pattern.length - 1 >> 0;
		_ref = f.badCharSkip;
		_i = 0;
		while (_i < 256) {
			i = _i;
			f.badCharSkip[i] = pattern.length;
			_i++;
		}
		i$1 = 0;
		while (i$1 < last) {
			f.badCharSkip[pattern.charCodeAt(i$1)] = last - i$1 >> 0;
			i$1 = i$1 + 1 >> 0;
		}
		lastPrefix = last;
		i$2 = last;
		while (i$2 >= 0) {
			if (HasPrefix(pattern, pattern.substring((i$2 + 1 >> 0)))) {
				lastPrefix = i$2 + 1 >> 0;
			}
			_slice = f.goodSuffixSkip, _index = i$2, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (lastPrefix + last >> 0) - i$2 >> 0) : go$throwRuntimeError("index out of range");
			i$2 = i$2 - 1 >> 0;
		}
		i$3 = 0;
		while (i$3 < last) {
			lenSuffix = longestCommonSuffix(pattern, pattern.substring(1, (i$3 + 1 >> 0)));
			if (!((pattern.charCodeAt((i$3 - lenSuffix >> 0)) === pattern.charCodeAt((last - lenSuffix >> 0))))) {
				_slice$1 = f.goodSuffixSkip, _index$1 = last - lenSuffix >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (lenSuffix + last >> 0) - i$3 >> 0) : go$throwRuntimeError("index out of range");
			}
			i$3 = i$3 + 1 >> 0;
		}
		return f;
	};
	var longestCommonSuffix = function(a, b) {
		var i;
		i = 0;
		while (i < a.length && i < b.length) {
			if (!((a.charCodeAt(((a.length - 1 >> 0) - i >> 0)) === b.charCodeAt(((b.length - 1 >> 0) - i >> 0))))) {
				break;
			}
			i = i + 1 >> 0;
		}
		return i;
	};
	stringFinder.Ptr.prototype.next = function(text) {
		var f, i, j, _slice, _index;
		f = this;
		i = f.pattern.length - 1 >> 0;
		while (i < text.length) {
			j = f.pattern.length - 1 >> 0;
			while (j >= 0 && (text.charCodeAt(i) === f.pattern.charCodeAt(j))) {
				i = i - 1 >> 0;
				j = j - 1 >> 0;
			}
			if (j < 0) {
				return i + 1 >> 0;
			}
			i = i + (max(f.badCharSkip[text.charCodeAt(i)], (_slice = f.goodSuffixSkip, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")))) >> 0;
		}
		return -1;
	};
	stringFinder.prototype.next = function(text) { return this.go$val.next(text); };
	var max = function(a, b) {
		if (a > b) {
			return a;
		}
		return b;
	};
	var explode = function(s, n) {
		var l, a, size, ch, _tuple, i, cur, _tuple$1, _slice, _index, _slice$1, _index$1, _slice$2, _index$2;
		if (n === 0) {
			return (go$sliceType(Go$String)).nil;
		}
		l = utf8.RuneCountInString(s);
		if (n <= 0 || n > l) {
			n = l;
		}
		a = (go$sliceType(Go$String)).make(n, 0, function() { return ""; });
		size = 0;
		ch = 0;
		_tuple = [0, 0], i = _tuple[0], cur = _tuple[1];
		while ((i + 1 >> 0) < n) {
			_tuple$1 = utf8.DecodeRuneInString(s.substring(cur)), ch = _tuple$1[0], size = _tuple$1[1];
			if (ch === 65533) {
				_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = "\xEF\xBF\xBD") : go$throwRuntimeError("index out of range");
			} else {
				_slice$1 = a, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = s.substring(cur, (cur + size >> 0))) : go$throwRuntimeError("index out of range");
			}
			cur = cur + (size) >> 0;
			i = i + 1 >> 0;
		}
		if (cur < s.length) {
			_slice$2 = a, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = s.substring(cur)) : go$throwRuntimeError("index out of range");
		}
		return a;
	};
	var hashstr = function(sep) {
		var hash, i, _tuple, pow, sq, i$1, x, x$1;
		hash = 0;
		i = 0;
		while (i < sep.length) {
			hash = ((((hash >>> 16 << 16) * 16777619 >>> 0) + (hash << 16 >>> 16) * 16777619) >>> 0) + (sep.charCodeAt(i) >>> 0) >>> 0;
			i = i + 1 >> 0;
		}
		_tuple = [1, 16777619], pow = _tuple[0], sq = _tuple[1];
		i$1 = sep.length;
		while (i$1 > 0) {
			if (!(((i$1 & 1) === 0))) {
				pow = (x = sq, (((pow >>> 16 << 16) * x >>> 0) + (pow << 16 >>> 16) * x) >>> 0);
			}
			sq = (x$1 = sq, (((sq >>> 16 << 16) * x$1 >>> 0) + (sq << 16 >>> 16) * x$1) >>> 0);
			i$1 = i$1 >> 1 >> 0;
		}
		return [hash, pow];
	};
	var Count = go$pkg.Count = function(s, sep) {
		var n, c, i, _tuple, hashsep, pow, h, i$1, lastmatch, i$2, x, x$1;
		n = 0;
		if (sep.length === 0) {
			return utf8.RuneCountInString(s) + 1 >> 0;
		} else if (sep.length === 1) {
			c = sep.charCodeAt(0);
			i = 0;
			while (i < s.length) {
				if (s.charCodeAt(i) === c) {
					n = n + 1 >> 0;
				}
				i = i + 1 >> 0;
			}
			return n;
		} else if (sep.length > s.length) {
			return 0;
		} else if (sep.length === s.length) {
			if (sep === s) {
				return 1;
			}
			return 0;
		}
		_tuple = hashstr(sep), hashsep = _tuple[0], pow = _tuple[1];
		h = 0;
		i$1 = 0;
		while (i$1 < sep.length) {
			h = ((((h >>> 16 << 16) * 16777619 >>> 0) + (h << 16 >>> 16) * 16777619) >>> 0) + (s.charCodeAt(i$1) >>> 0) >>> 0;
			i$1 = i$1 + 1 >> 0;
		}
		lastmatch = 0;
		if ((h === hashsep) && s.substring(0, sep.length) === sep) {
			n = n + 1 >> 0;
			lastmatch = sep.length;
		}
		i$2 = sep.length;
		while (i$2 < s.length) {
			h = (x = 16777619, (((h >>> 16 << 16) * x >>> 0) + (h << 16 >>> 16) * x) >>> 0);
			h = h + ((s.charCodeAt(i$2) >>> 0)) >>> 0;
			h = h - ((x$1 = (s.charCodeAt((i$2 - sep.length >> 0)) >>> 0), (((pow >>> 16 << 16) * x$1 >>> 0) + (pow << 16 >>> 16) * x$1) >>> 0)) >>> 0;
			i$2 = i$2 + 1 >> 0;
			if ((h === hashsep) && lastmatch <= (i$2 - sep.length >> 0) && s.substring(i$2 - sep.length >> 0, i$2) === sep) {
				n = n + 1 >> 0;
				lastmatch = i$2;
			}
		}
		return n;
	};
	var Contains = go$pkg.Contains = function(s, substr) {
		return Index(s, substr) >= 0;
	};
	var ContainsAny = go$pkg.ContainsAny = function(s, chars) {
		return IndexAny(s, chars) >= 0;
	};
	var ContainsRune = go$pkg.ContainsRune = function(s, r) {
		return IndexRune(s, r) >= 0;
	};
	var Index = go$pkg.Index = function(s, sep) {
		var n, _tuple, hashsep, pow, h, i, i$1, x, x$1;
		n = sep.length;
		if (n === 0) {
			return 0;
		} else if (n === 1) {
			return IndexByte(s, sep.charCodeAt(0));
		} else if (n === s.length) {
			if (sep === s) {
				return 0;
			}
			return -1;
		} else if (n > s.length) {
			return -1;
		}
		_tuple = hashstr(sep), hashsep = _tuple[0], pow = _tuple[1];
		h = 0;
		i = 0;
		while (i < n) {
			h = ((((h >>> 16 << 16) * 16777619 >>> 0) + (h << 16 >>> 16) * 16777619) >>> 0) + (s.charCodeAt(i) >>> 0) >>> 0;
			i = i + 1 >> 0;
		}
		if ((h === hashsep) && s.substring(0, n) === sep) {
			return 0;
		}
		i$1 = n;
		while (i$1 < s.length) {
			h = (x = 16777619, (((h >>> 16 << 16) * x >>> 0) + (h << 16 >>> 16) * x) >>> 0);
			h = h + ((s.charCodeAt(i$1) >>> 0)) >>> 0;
			h = h - ((x$1 = (s.charCodeAt((i$1 - n >> 0)) >>> 0), (((pow >>> 16 << 16) * x$1 >>> 0) + (pow << 16 >>> 16) * x$1) >>> 0)) >>> 0;
			i$1 = i$1 + 1 >> 0;
			if ((h === hashsep) && s.substring(i$1 - n >> 0, i$1) === sep) {
				return i$1 - n >> 0;
			}
		}
		return -1;
	};
	var LastIndex = go$pkg.LastIndex = function(s, sep) {
		var n, c, i, i$1;
		n = sep.length;
		if (n === 0) {
			return s.length;
		}
		c = sep.charCodeAt(0);
		if (n === 1) {
			i = s.length - 1 >> 0;
			while (i >= 0) {
				if (s.charCodeAt(i) === c) {
					return i;
				}
				i = i - 1 >> 0;
			}
			return -1;
		}
		i$1 = s.length - n >> 0;
		while (i$1 >= 0) {
			if ((s.charCodeAt(i$1) === c) && s.substring(i$1, (i$1 + n >> 0)) === sep) {
				return i$1;
			}
			i$1 = i$1 - 1 >> 0;
		}
		return -1;
	};
	var IndexRune = go$pkg.IndexRune = function(s, r) {
		var b, i, _ref, _i, _rune, c, i$1;
		if (r < 128) {
			b = (r << 24 >>> 24);
			i = 0;
			while (i < s.length) {
				if (s.charCodeAt(i) === b) {
					return i;
				}
				i = i + 1 >> 0;
			}
		} else {
			_ref = s;
			_i = 0;
			while (_i < _ref.length) {
				_rune = go$decodeRune(_ref, _i);
				c = _rune[0];
				i$1 = _i;
				if (c === r) {
					return i$1;
				}
				_i += _rune[1];
			}
		}
		return -1;
	};
	var IndexAny = go$pkg.IndexAny = function(s, chars) {
		var _ref, _i, _rune, c, i, _ref$1, _i$1, _rune$1, m;
		if (chars.length > 0) {
			_ref = s;
			_i = 0;
			while (_i < _ref.length) {
				_rune = go$decodeRune(_ref, _i);
				c = _rune[0];
				i = _i;
				_ref$1 = chars;
				_i$1 = 0;
				while (_i$1 < _ref$1.length) {
					_rune$1 = go$decodeRune(_ref$1, _i$1);
					m = _rune$1[0];
					if (c === m) {
						return i;
					}
					_i$1 += _rune$1[1];
				}
				_i += _rune[1];
			}
		}
		return -1;
	};
	var LastIndexAny = go$pkg.LastIndexAny = function(s, chars) {
		var i, _tuple, rune, size, _ref, _i, _rune, m;
		if (chars.length > 0) {
			i = s.length;
			while (i > 0) {
				_tuple = utf8.DecodeLastRuneInString(s.substring(0, i)), rune = _tuple[0], size = _tuple[1];
				i = i - (size) >> 0;
				_ref = chars;
				_i = 0;
				while (_i < _ref.length) {
					_rune = go$decodeRune(_ref, _i);
					m = _rune[0];
					if (rune === m) {
						return i;
					}
					_i += _rune[1];
				}
			}
		}
		return -1;
	};
	var genSplit = function(s, sep, sepSave, n) {
		var c, start, a, na, i, _slice, _index, _slice$1, _index$1;
		if (n === 0) {
			return (go$sliceType(Go$String)).nil;
		}
		if (sep === "") {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		c = sep.charCodeAt(0);
		start = 0;
		a = (go$sliceType(Go$String)).make(n, 0, function() { return ""; });
		na = 0;
		i = 0;
		while ((i + sep.length >> 0) <= s.length && (na + 1 >> 0) < n) {
			if ((s.charCodeAt(i) === c) && ((sep.length === 1) || s.substring(i, (i + sep.length >> 0)) === sep)) {
				_slice = a, _index = na, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = s.substring(start, (i + sepSave >> 0))) : go$throwRuntimeError("index out of range");
				na = na + 1 >> 0;
				start = i + sep.length >> 0;
				i = i + ((sep.length - 1 >> 0)) >> 0;
			}
			i = i + 1 >> 0;
		}
		_slice$1 = a, _index$1 = na, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = s.substring(start)) : go$throwRuntimeError("index out of range");
		return go$subslice(a, 0, (na + 1 >> 0));
	};
	var SplitN = go$pkg.SplitN = function(s, sep, n) {
		return genSplit(s, sep, 0, n);
	};
	var SplitAfterN = go$pkg.SplitAfterN = function(s, sep, n) {
		return genSplit(s, sep, sep.length, n);
	};
	var Split = go$pkg.Split = function(s, sep) {
		return genSplit(s, sep, 0, -1);
	};
	var SplitAfter = go$pkg.SplitAfter = function(s, sep) {
		return genSplit(s, sep, sep.length, -1);
	};
	var Fields = go$pkg.Fields = function(s) {
		return FieldsFunc(s, unicode.IsSpace);
	};
	var FieldsFunc = go$pkg.FieldsFunc = function(s, f) {
		var n, inField, _ref, _i, _rune, rune, wasInField, a, na, fieldStart, _ref$1, _i$1, _rune$1, rune$1, i, _slice, _index, _slice$1, _index$1;
		n = 0;
		inField = false;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			rune = _rune[0];
			wasInField = inField;
			inField = !f(rune);
			if (inField && !wasInField) {
				n = n + 1 >> 0;
			}
			_i += _rune[1];
		}
		a = (go$sliceType(Go$String)).make(n, 0, function() { return ""; });
		na = 0;
		fieldStart = -1;
		_ref$1 = s;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			_rune$1 = go$decodeRune(_ref$1, _i$1);
			rune$1 = _rune$1[0];
			i = _i$1;
			if (f(rune$1)) {
				if (fieldStart >= 0) {
					_slice = a, _index = na, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = s.substring(fieldStart, i)) : go$throwRuntimeError("index out of range");
					na = na + 1 >> 0;
					fieldStart = -1;
				}
			} else if (fieldStart === -1) {
				fieldStart = i;
			}
			_i$1 += _rune$1[1];
		}
		if (fieldStart >= 0) {
			_slice$1 = a, _index$1 = na, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = s.substring(fieldStart)) : go$throwRuntimeError("index out of range");
		}
		return a;
	};
	var Join = go$pkg.Join = function(a, sep) {
		var _slice, _index, x, x$1, n, i, _slice$1, _index$1, b, _slice$2, _index$2, bp, _ref, _i, _slice$3, _index$3, s;
		if (a.length === 0) {
			return "";
		}
		if (a.length === 1) {
			return (_slice = a, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		}
		n = (x = sep.length, x$1 = (a.length - 1 >> 0), (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
		i = 0;
		while (i < a.length) {
			n = n + ((_slice$1 = a, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).length) >> 0;
			i = i + 1 >> 0;
		}
		b = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
		bp = go$copyString(b, (_slice$2 = a, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")));
		_ref = go$subslice(a, 1);
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice$3 = _ref, _index$3 = _i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			bp = bp + (go$copyString(go$subslice(b, bp), sep)) >> 0;
			bp = bp + (go$copyString(go$subslice(b, bp), s)) >> 0;
			_i++;
		}
		return go$bytesToString(b);
	};
	var HasPrefix = go$pkg.HasPrefix = function(s, prefix) {
		return s.length >= prefix.length && s.substring(0, prefix.length) === prefix;
	};
	var HasSuffix = go$pkg.HasSuffix = function(s, suffix) {
		return s.length >= suffix.length && s.substring((s.length - suffix.length >> 0)) === suffix;
	};
	var Map = go$pkg.Map = function(mapping, s) {
		var maxbytes, nbytes, b, _ref, _i, _rune, c, i, r, wid, x, nb;
		maxbytes = s.length;
		nbytes = 0;
		b = (go$sliceType(Go$Uint8)).nil;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			c = _rune[0];
			i = _i;
			r = mapping(c);
			if (b === (go$sliceType(Go$Uint8)).nil) {
				if (r === c) {
					_i += _rune[1];
					continue;
				}
				b = (go$sliceType(Go$Uint8)).make(maxbytes, 0, function() { return 0; });
				nbytes = go$copyString(b, s.substring(0, i));
			}
			if (r >= 0) {
				wid = 1;
				if (r >= 128) {
					wid = utf8.RuneLen(r);
				}
				if ((nbytes + wid >> 0) > maxbytes) {
					maxbytes = (x = 2, (((maxbytes >>> 16 << 16) * x >> 0) + (maxbytes << 16 >>> 16) * x) >> 0) + 4 >> 0;
					nb = (go$sliceType(Go$Uint8)).make(maxbytes, 0, function() { return 0; });
					go$copySlice(nb, go$subslice(b, 0, nbytes));
					b = nb;
				}
				nbytes = nbytes + (utf8.EncodeRune(go$subslice(b, nbytes, maxbytes), r)) >> 0;
			}
			_i += _rune[1];
		}
		if (b === (go$sliceType(Go$Uint8)).nil) {
			return s;
		}
		return go$bytesToString(go$subslice(b, 0, nbytes));
	};
	var Repeat = go$pkg.Repeat = function(s, count) {
		var x, b, bp, i;
		b = (go$sliceType(Go$Uint8)).make((x = s.length, (((x >>> 16 << 16) * count >> 0) + (x << 16 >>> 16) * count) >> 0), 0, function() { return 0; });
		bp = 0;
		i = 0;
		while (i < count) {
			bp = bp + (go$copyString(go$subslice(b, bp), s)) >> 0;
			i = i + 1 >> 0;
		}
		return go$bytesToString(b);
	};
	var ToUpper = go$pkg.ToUpper = function(s) {
		return Map(unicode.ToUpper, s);
	};
	var ToLower = go$pkg.ToLower = function(s) {
		return Map(unicode.ToLower, s);
	};
	var ToTitle = go$pkg.ToTitle = function(s) {
		return Map(unicode.ToTitle, s);
	};
	var ToUpperSpecial = go$pkg.ToUpperSpecial = function(_case, s) {
		return Map((function(r) {
			return _case.ToUpper(r);
		}), s);
	};
	var ToLowerSpecial = go$pkg.ToLowerSpecial = function(_case, s) {
		return Map((function(r) {
			return _case.ToLower(r);
		}), s);
	};
	var ToTitleSpecial = go$pkg.ToTitleSpecial = function(_case, s) {
		return Map((function(r) {
			return _case.ToTitle(r);
		}), s);
	};
	var isSeparator = function(r) {
		if (r <= 127) {
			if (48 <= r && r <= 57) {
				return false;
			} else if (97 <= r && r <= 122) {
				return false;
			} else if (65 <= r && r <= 90) {
				return false;
			} else if (r === 95) {
				return false;
			}
			return true;
		}
		if (unicode.IsLetter(r) || unicode.IsDigit(r)) {
			return false;
		}
		return unicode.IsSpace(r);
	};
	var Title = go$pkg.Title = function(s) {
		var prev;
		prev = 32;
		return Map((function(r) {
			if (isSeparator(prev)) {
				prev = r;
				return unicode.ToTitle(r);
			}
			prev = r;
			return r;
		}), s);
	};
	var TrimLeftFunc = go$pkg.TrimLeftFunc = function(s, f) {
		var i;
		i = indexFunc(s, f, false);
		if (i === -1) {
			return "";
		}
		return s.substring(i);
	};
	var TrimRightFunc = go$pkg.TrimRightFunc = function(s, f) {
		var i, _tuple, wid;
		i = lastIndexFunc(s, f, false);
		if (i >= 0 && s.charCodeAt(i) >= 128) {
			_tuple = utf8.DecodeRuneInString(s.substring(i)), wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + 1 >> 0;
		}
		return s.substring(0, i);
	};
	var TrimFunc = go$pkg.TrimFunc = function(s, f) {
		return TrimRightFunc(TrimLeftFunc(s, f), f);
	};
	var IndexFunc = go$pkg.IndexFunc = function(s, f) {
		return indexFunc(s, f, true);
	};
	var LastIndexFunc = go$pkg.LastIndexFunc = function(s, f) {
		return lastIndexFunc(s, f, true);
	};
	var indexFunc = function(s, f, truth) {
		var start, wid, r, _tuple;
		start = 0;
		while (start < s.length) {
			wid = 1;
			r = (s.charCodeAt(start) >> 0);
			if (r >= 128) {
				_tuple = utf8.DecodeRuneInString(s.substring(start)), r = _tuple[0], wid = _tuple[1];
			}
			if (f(r) === truth) {
				return start;
			}
			start = start + (wid) >> 0;
		}
		return -1;
	};
	var lastIndexFunc = function(s, f, truth) {
		var i, _tuple, r, size;
		i = s.length;
		while (i > 0) {
			_tuple = utf8.DecodeLastRuneInString(s.substring(0, i)), r = _tuple[0], size = _tuple[1];
			i = i - (size) >> 0;
			if (f(r) === truth) {
				return i;
			}
		}
		return -1;
	};
	var makeCutsetFunc = function(cutset) {
		return (function(r) {
			return IndexRune(cutset, r) >= 0;
		});
	};
	var Trim = go$pkg.Trim = function(s, cutset) {
		if (s === "" || cutset === "") {
			return s;
		}
		return TrimFunc(s, makeCutsetFunc(cutset));
	};
	var TrimLeft = go$pkg.TrimLeft = function(s, cutset) {
		if (s === "" || cutset === "") {
			return s;
		}
		return TrimLeftFunc(s, makeCutsetFunc(cutset));
	};
	var TrimRight = go$pkg.TrimRight = function(s, cutset) {
		if (s === "" || cutset === "") {
			return s;
		}
		return TrimRightFunc(s, makeCutsetFunc(cutset));
	};
	var TrimSpace = go$pkg.TrimSpace = function(s) {
		return TrimFunc(s, unicode.IsSpace);
	};
	var TrimPrefix = go$pkg.TrimPrefix = function(s, prefix) {
		if (HasPrefix(s, prefix)) {
			return s.substring(prefix.length);
		}
		return s;
	};
	var TrimSuffix = go$pkg.TrimSuffix = function(s, suffix) {
		if (HasSuffix(s, suffix)) {
			return s.substring(0, (s.length - suffix.length >> 0));
		}
		return s;
	};
	var Replace = go$pkg.Replace = function(s, old, new$1, n) {
		var m, x, t, w, start, i, j, _tuple, wid;
		if (old === new$1 || (n === 0)) {
			return s;
		}
		if (m = Count(s, old), m === 0) {
			return s;
		} else if (n < 0 || m < n) {
			n = m;
		}
		t = (go$sliceType(Go$Uint8)).make(s.length + (x = (new$1.length - old.length >> 0), (((n >>> 16 << 16) * x >> 0) + (n << 16 >>> 16) * x) >> 0) >> 0, 0, function() { return 0; });
		w = 0;
		start = 0;
		i = 0;
		while (i < n) {
			j = start;
			if (old.length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRuneInString(s.substring(start)), wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index(s.substring(start), old)) >> 0;
			}
			w = w + (go$copyString(go$subslice(t, w), s.substring(start, j))) >> 0;
			w = w + (go$copyString(go$subslice(t, w), new$1)) >> 0;
			start = j + old.length >> 0;
			i = i + 1 >> 0;
		}
		w = w + (go$copyString(go$subslice(t, w), s.substring(start))) >> 0;
		return go$bytesToString(go$subslice(t, 0, w));
	};
	var EqualFold = go$pkg.EqualFold = function(s, t) {
		var _tuple, sr, tr, _tuple$1, _tuple$2, r, size, _tuple$3, _tuple$4, _tuple$5, r$1, size$1, _tuple$6, _tuple$7, r$2;
		while (!(s === "") && !(t === "")) {
			_tuple = [0, 0], sr = _tuple[0], tr = _tuple[1];
			if (s.charCodeAt(0) < 128) {
				_tuple$1 = [(s.charCodeAt(0) >> 0), s.substring(1)], sr = _tuple$1[0], s = _tuple$1[1];
			} else {
				_tuple$2 = utf8.DecodeRuneInString(s), r = _tuple$2[0], size = _tuple$2[1];
				_tuple$3 = [r, s.substring(size)], sr = _tuple$3[0], s = _tuple$3[1];
			}
			if (t.charCodeAt(0) < 128) {
				_tuple$4 = [(t.charCodeAt(0) >> 0), t.substring(1)], tr = _tuple$4[0], t = _tuple$4[1];
			} else {
				_tuple$5 = utf8.DecodeRuneInString(t), r$1 = _tuple$5[0], size$1 = _tuple$5[1];
				_tuple$6 = [r$1, t.substring(size$1)], tr = _tuple$6[0], t = _tuple$6[1];
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tuple$7 = [sr, tr], tr = _tuple$7[0], sr = _tuple$7[1];
			}
			if (tr < 128 && 65 <= sr && sr <= 90) {
				if (tr === ((sr + 97 >> 0) - 65 >> 0)) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (!((r$2 === sr)) && r$2 < tr) {
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s === t;
	};
	var IndexByte = go$pkg.IndexByte = function(s, c) { return s.indexOf(String.fromCharCode(c)); };
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["encoding/base64"] = (function() {
	var go$pkg = {};
	var bytes = go$packages["bytes"];
	var io = go$packages["io"];
	var strconv = go$packages["strconv"];
	var strings = go$packages["strings"];
	var Encoding;
	Encoding = go$newType(0, "Struct", "base64.Encoding", "Encoding", "encoding/base64", function(encode_, decodeMap_) {
		this.go$val = this;
		this.encode = encode_ !== undefined ? encode_ : "";
		this.decodeMap = decodeMap_ !== undefined ? decodeMap_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
	});
	go$pkg.Encoding = Encoding;
	var encoder;
	encoder = go$newType(0, "Struct", "base64.encoder", "encoder", "encoding/base64", function(err_, enc_, w_, buf_, nbuf_, out_) {
		this.go$val = this;
		this.err = err_ !== undefined ? err_ : null;
		this.enc = enc_ !== undefined ? enc_ : (go$ptrType(Encoding)).nil;
		this.w = w_ !== undefined ? w_ : null;
		this.buf = buf_ !== undefined ? buf_ : go$makeNativeArray("Uint8", 3, function() { return 0; });
		this.nbuf = nbuf_ !== undefined ? nbuf_ : 0;
		this.out = out_ !== undefined ? out_ : go$makeNativeArray("Uint8", 1024, function() { return 0; });
	});
	go$pkg.encoder = encoder;
	var CorruptInputError;
	CorruptInputError = go$newType(8, "Int64", "base64.CorruptInputError", "CorruptInputError", "encoding/base64", null);
	go$pkg.CorruptInputError = CorruptInputError;
	var decoder;
	decoder = go$newType(0, "Struct", "base64.decoder", "decoder", "encoding/base64", function(err_, enc_, r_, end_, buf_, nbuf_, out_, outbuf_) {
		this.go$val = this;
		this.err = err_ !== undefined ? err_ : null;
		this.enc = enc_ !== undefined ? enc_ : (go$ptrType(Encoding)).nil;
		this.r = r_ !== undefined ? r_ : null;
		this.end = end_ !== undefined ? end_ : false;
		this.buf = buf_ !== undefined ? buf_ : go$makeNativeArray("Uint8", 1024, function() { return 0; });
		this.nbuf = nbuf_ !== undefined ? nbuf_ : 0;
		this.out = out_ !== undefined ? out_ : (go$sliceType(Go$Uint8)).nil;
		this.outbuf = outbuf_ !== undefined ? outbuf_ : go$makeNativeArray("Uint8", 768, function() { return 0; });
	});
	go$pkg.decoder = decoder;
	var newlineFilteringReader;
	newlineFilteringReader = go$newType(0, "Struct", "base64.newlineFilteringReader", "newlineFilteringReader", "encoding/base64", function(wrapped_) {
		this.go$val = this;
		this.wrapped = wrapped_ !== undefined ? wrapped_ : null;
	});
	go$pkg.newlineFilteringReader = newlineFilteringReader;
	Encoding.init([["encode", "encoding/base64", Go$String, ""], ["decodeMap", "encoding/base64", (go$arrayType(Go$Uint8, 256)), ""]]);
	(go$ptrType(Encoding)).methods = [["Decode", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["DecodeString", "", [Go$String], [(go$sliceType(Go$Uint8)), go$error], false], ["DecodedLen", "", [Go$Int], [Go$Int], false], ["Encode", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false], ["EncodeToString", "", [(go$sliceType(Go$Uint8))], [Go$String], false], ["EncodedLen", "", [Go$Int], [Go$Int], false], ["decode", "encoding/base64", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [Go$Int, Go$Bool, go$error], false]];
	encoder.init([["err", "encoding/base64", go$error, ""], ["enc", "encoding/base64", (go$ptrType(Encoding)), ""], ["w", "encoding/base64", io.Writer, ""], ["buf", "encoding/base64", (go$arrayType(Go$Uint8, 3)), ""], ["nbuf", "encoding/base64", Go$Int, ""], ["out", "encoding/base64", (go$arrayType(Go$Uint8, 1024)), ""]]);
	(go$ptrType(encoder)).methods = [["Close", "", [], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	CorruptInputError.methods = [["Error", "", [], [Go$String], false]];
	(go$ptrType(CorruptInputError)).methods = [["Error", "", [], [Go$String], false]];
	decoder.init([["err", "encoding/base64", go$error, ""], ["enc", "encoding/base64", (go$ptrType(Encoding)), ""], ["r", "encoding/base64", io.Reader, ""], ["end", "encoding/base64", Go$Bool, ""], ["buf", "encoding/base64", (go$arrayType(Go$Uint8, 1024)), ""], ["nbuf", "encoding/base64", Go$Int, ""], ["out", "encoding/base64", (go$sliceType(Go$Uint8)), ""], ["outbuf", "encoding/base64", (go$arrayType(Go$Uint8, 768)), ""]]);
	(go$ptrType(decoder)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	newlineFilteringReader.init([["wrapped", "encoding/base64", io.Reader, ""]]);
	(go$ptrType(newlineFilteringReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	var removeNewlinesMapper;
	var NewEncoding = go$pkg.NewEncoding = function(encoder$1) {
		var e, i, i$1;
		e = new Encoding.Ptr();
		e.encode = encoder$1;
		i = 0;
		while (i < 256) {
			e.decodeMap[i] = 255;
			i = i + 1 >> 0;
		}
		i$1 = 0;
		while (i$1 < encoder$1.length) {
			e.decodeMap[encoder$1.charCodeAt(i$1)] = (i$1 << 24 >>> 24);
			i$1 = i$1 + 1 >> 0;
		}
		return e;
	};
	Encoding.Ptr.prototype.Encode = function(dst, src) {
		var enc, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _ref, _lhs, _index$4, _slice$4, _index$5, _slice$5, _index$6, _slice$6, _index$7, _lhs$1, _index$8, _slice$7, _index$9, _slice$8, _index$10, _slice$9, _index$11, _lhs$2, _index$12, _slice$10, _index$13, _slice$11, _index$14, _slice$12, _index$15, _lhs$3, _index$16, _slice$13, _index$17, _slice$14, _index$18, _slice$15, _index$19, _lhs$4, _index$20, _slice$16, _index$21, _slice$17, _index$22, _slice$18, _index$23, _lhs$5, _index$24, _slice$19, _index$25, _slice$20, _index$26, _slice$21, _index$27, _lhs$6, _index$28, _slice$22, _index$29, _slice$23, _index$30, _slice$24, _index$31, _lhs$7, _index$32, _slice$25, _index$33, _slice$26, _index$34, _slice$27, _index$35, _lhs$8, _index$36, _slice$28, _index$37, _slice$29, _index$38, _slice$30, _index$39, _lhs$9, _index$40, _slice$31, _index$41, _slice$32, _index$42, _slice$33, _index$43, _lhs$10, _index$44, _slice$34, _index$45, _slice$35, _index$46, _slice$36, _index$47, _lhs$11, _index$48, _slice$37, _index$49, _slice$38, _index$50, _slice$39, _index$51, j, _slice$40, _index$52, _slice$41, _index$53, _slice$42, _index$54, _slice$43, _index$55;
		enc = this;
		if (src.length === 0) {
			return;
		}
		while (src.length > 0) {
			_slice = dst, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 0) : go$throwRuntimeError("index out of range");
			_slice$1 = dst, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 0) : go$throwRuntimeError("index out of range");
			_slice$2 = dst, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 0) : go$throwRuntimeError("index out of range");
			_slice$3 = dst, _index$3 = 3, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = 0) : go$throwRuntimeError("index out of range");
			_ref = src.length;
			if (_ref === 2) {
				_lhs = dst, _index$4 = 2, _slice$6 = _lhs, _index$7 = _index$4, (_index$7 >= 0 && _index$7 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$7] = ((_slice$4 = _lhs, _index$5 = _index$4, (_index$5 >= 0 && _index$5 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$5] : go$throwRuntimeError("index out of range")) | ((((((_slice$5 = src, _index$6 = 1, (_index$6 >= 0 && _index$6 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$6] : go$throwRuntimeError("index out of range")) << 2 << 24 >>> 24)) & 63) >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$1 = dst, _index$8 = 1, _slice$9 = _lhs$1, _index$11 = _index$8, (_index$11 >= 0 && _index$11 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$11] = ((_slice$7 = _lhs$1, _index$9 = _index$8, (_index$9 >= 0 && _index$9 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$9] : go$throwRuntimeError("index out of range")) | (((_slice$8 = src, _index$10 = 1, (_index$10 >= 0 && _index$10 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$10] : go$throwRuntimeError("index out of range")) >>> 4 << 24 >>> 24))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$2 = dst, _index$12 = 1, _slice$12 = _lhs$2, _index$15 = _index$12, (_index$15 >= 0 && _index$15 < _slice$12.length) ? (_slice$12.array[_slice$12.offset + _index$15] = ((_slice$10 = _lhs$2, _index$13 = _index$12, (_index$13 >= 0 && _index$13 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$13] : go$throwRuntimeError("index out of range")) | ((((((_slice$11 = src, _index$14 = 0, (_index$14 >= 0 && _index$14 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$14] : go$throwRuntimeError("index out of range")) << 4 << 24 >>> 24)) & 63) >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$3 = dst, _index$16 = 0, _slice$15 = _lhs$3, _index$19 = _index$16, (_index$19 >= 0 && _index$19 < _slice$15.length) ? (_slice$15.array[_slice$15.offset + _index$19] = ((_slice$13 = _lhs$3, _index$17 = _index$16, (_index$17 >= 0 && _index$17 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$17] : go$throwRuntimeError("index out of range")) | (((_slice$14 = src, _index$18 = 0, (_index$18 >= 0 && _index$18 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$18] : go$throwRuntimeError("index out of range")) >>> 2 << 24 >>> 24))) >>> 0) : go$throwRuntimeError("index out of range");
			} else if (_ref === 1) {
				_lhs$4 = dst, _index$20 = 1, _slice$18 = _lhs$4, _index$23 = _index$20, (_index$23 >= 0 && _index$23 < _slice$18.length) ? (_slice$18.array[_slice$18.offset + _index$23] = ((_slice$16 = _lhs$4, _index$21 = _index$20, (_index$21 >= 0 && _index$21 < _slice$16.length) ? _slice$16.array[_slice$16.offset + _index$21] : go$throwRuntimeError("index out of range")) | ((((((_slice$17 = src, _index$22 = 0, (_index$22 >= 0 && _index$22 < _slice$17.length) ? _slice$17.array[_slice$17.offset + _index$22] : go$throwRuntimeError("index out of range")) << 4 << 24 >>> 24)) & 63) >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$5 = dst, _index$24 = 0, _slice$21 = _lhs$5, _index$27 = _index$24, (_index$27 >= 0 && _index$27 < _slice$21.length) ? (_slice$21.array[_slice$21.offset + _index$27] = ((_slice$19 = _lhs$5, _index$25 = _index$24, (_index$25 >= 0 && _index$25 < _slice$19.length) ? _slice$19.array[_slice$19.offset + _index$25] : go$throwRuntimeError("index out of range")) | (((_slice$20 = src, _index$26 = 0, (_index$26 >= 0 && _index$26 < _slice$20.length) ? _slice$20.array[_slice$20.offset + _index$26] : go$throwRuntimeError("index out of range")) >>> 2 << 24 >>> 24))) >>> 0) : go$throwRuntimeError("index out of range");
			} else {
				_lhs$6 = dst, _index$28 = 3, _slice$24 = _lhs$6, _index$31 = _index$28, (_index$31 >= 0 && _index$31 < _slice$24.length) ? (_slice$24.array[_slice$24.offset + _index$31] = ((_slice$22 = _lhs$6, _index$29 = _index$28, (_index$29 >= 0 && _index$29 < _slice$22.length) ? _slice$22.array[_slice$22.offset + _index$29] : go$throwRuntimeError("index out of range")) | ((((_slice$23 = src, _index$30 = 2, (_index$30 >= 0 && _index$30 < _slice$23.length) ? _slice$23.array[_slice$23.offset + _index$30] : go$throwRuntimeError("index out of range")) & 63) >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$7 = dst, _index$32 = 2, _slice$27 = _lhs$7, _index$35 = _index$32, (_index$35 >= 0 && _index$35 < _slice$27.length) ? (_slice$27.array[_slice$27.offset + _index$35] = ((_slice$25 = _lhs$7, _index$33 = _index$32, (_index$33 >= 0 && _index$33 < _slice$25.length) ? _slice$25.array[_slice$25.offset + _index$33] : go$throwRuntimeError("index out of range")) | (((_slice$26 = src, _index$34 = 2, (_index$34 >= 0 && _index$34 < _slice$26.length) ? _slice$26.array[_slice$26.offset + _index$34] : go$throwRuntimeError("index out of range")) >>> 6 << 24 >>> 24))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$8 = dst, _index$36 = 2, _slice$30 = _lhs$8, _index$39 = _index$36, (_index$39 >= 0 && _index$39 < _slice$30.length) ? (_slice$30.array[_slice$30.offset + _index$39] = ((_slice$28 = _lhs$8, _index$37 = _index$36, (_index$37 >= 0 && _index$37 < _slice$28.length) ? _slice$28.array[_slice$28.offset + _index$37] : go$throwRuntimeError("index out of range")) | ((((((_slice$29 = src, _index$38 = 1, (_index$38 >= 0 && _index$38 < _slice$29.length) ? _slice$29.array[_slice$29.offset + _index$38] : go$throwRuntimeError("index out of range")) << 2 << 24 >>> 24)) & 63) >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$9 = dst, _index$40 = 1, _slice$33 = _lhs$9, _index$43 = _index$40, (_index$43 >= 0 && _index$43 < _slice$33.length) ? (_slice$33.array[_slice$33.offset + _index$43] = ((_slice$31 = _lhs$9, _index$41 = _index$40, (_index$41 >= 0 && _index$41 < _slice$31.length) ? _slice$31.array[_slice$31.offset + _index$41] : go$throwRuntimeError("index out of range")) | (((_slice$32 = src, _index$42 = 1, (_index$42 >= 0 && _index$42 < _slice$32.length) ? _slice$32.array[_slice$32.offset + _index$42] : go$throwRuntimeError("index out of range")) >>> 4 << 24 >>> 24))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$10 = dst, _index$44 = 1, _slice$36 = _lhs$10, _index$47 = _index$44, (_index$47 >= 0 && _index$47 < _slice$36.length) ? (_slice$36.array[_slice$36.offset + _index$47] = ((_slice$34 = _lhs$10, _index$45 = _index$44, (_index$45 >= 0 && _index$45 < _slice$34.length) ? _slice$34.array[_slice$34.offset + _index$45] : go$throwRuntimeError("index out of range")) | ((((((_slice$35 = src, _index$46 = 0, (_index$46 >= 0 && _index$46 < _slice$35.length) ? _slice$35.array[_slice$35.offset + _index$46] : go$throwRuntimeError("index out of range")) << 4 << 24 >>> 24)) & 63) >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
				_lhs$11 = dst, _index$48 = 0, _slice$39 = _lhs$11, _index$51 = _index$48, (_index$51 >= 0 && _index$51 < _slice$39.length) ? (_slice$39.array[_slice$39.offset + _index$51] = ((_slice$37 = _lhs$11, _index$49 = _index$48, (_index$49 >= 0 && _index$49 < _slice$37.length) ? _slice$37.array[_slice$37.offset + _index$49] : go$throwRuntimeError("index out of range")) | (((_slice$38 = src, _index$50 = 0, (_index$50 >= 0 && _index$50 < _slice$38.length) ? _slice$38.array[_slice$38.offset + _index$50] : go$throwRuntimeError("index out of range")) >>> 2 << 24 >>> 24))) >>> 0) : go$throwRuntimeError("index out of range");
			}
			j = 0;
			while (j < 4) {
				_slice$41 = dst, _index$53 = j, (_index$53 >= 0 && _index$53 < _slice$41.length) ? (_slice$41.array[_slice$41.offset + _index$53] = enc.encode.charCodeAt((_slice$40 = dst, _index$52 = j, (_index$52 >= 0 && _index$52 < _slice$40.length) ? _slice$40.array[_slice$40.offset + _index$52] : go$throwRuntimeError("index out of range")))) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
			}
			if (src.length < 3) {
				_slice$42 = dst, _index$54 = 3, (_index$54 >= 0 && _index$54 < _slice$42.length) ? (_slice$42.array[_slice$42.offset + _index$54] = 61) : go$throwRuntimeError("index out of range");
				if (src.length < 2) {
					_slice$43 = dst, _index$55 = 2, (_index$55 >= 0 && _index$55 < _slice$43.length) ? (_slice$43.array[_slice$43.offset + _index$55] = 61) : go$throwRuntimeError("index out of range");
				}
				break;
			}
			src = go$subslice(src, 3);
			dst = go$subslice(dst, 4);
		}
	};
	Encoding.prototype.Encode = function(dst, src) { return this.go$val.Encode(dst, src); };
	Encoding.Ptr.prototype.EncodeToString = function(src) {
		var enc, buf;
		enc = this;
		buf = (go$sliceType(Go$Uint8)).make(enc.EncodedLen(src.length), 0, function() { return 0; });
		enc.Encode(buf, src);
		return go$bytesToString(buf);
	};
	Encoding.prototype.EncodeToString = function(src) { return this.go$val.EncodeToString(src); };
	encoder.Ptr.prototype.Write = function(p) {
		var n, err, e, _tuple, i, _slice, _index, _tuple$1, _tuple$2, nn, _r, _tuple$3, x, _q, x$1, _tuple$4, i$1, _slice$1, _index$1;
		n = 0;
		err = null;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			_tuple = [0, e.err], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (e.nbuf > 0) {
			i = 0;
			i = 0;
			while (i < p.length && e.nbuf < 3) {
				e.buf[e.nbuf] = (_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				e.nbuf = e.nbuf + 1 >> 0;
				i = i + 1 >> 0;
			}
			n = n + (i) >> 0;
			p = go$subslice(p, i);
			if (e.nbuf < 3) {
				return [n, err];
			}
			e.enc.Encode(go$subslice(new (go$sliceType(Go$Uint8))(e.out), 0), go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0));
			if (_tuple$1 = e.w.Write(go$subslice(new (go$sliceType(Go$Uint8))(e.out), 0, 4)), e.err = _tuple$1[1], !(go$interfaceIsEqual(e.err, null))) {
				_tuple$2 = [n, e.err], n = _tuple$2[0], err = _tuple$2[1];
				return [n, err];
			}
			e.nbuf = 0;
		}
		while (p.length >= 3) {
			nn = 768;
			if (nn > p.length) {
				nn = p.length;
			}
			nn = nn - ((_r = nn % 3, _r === _r ? _r : go$throwRuntimeError("integer divide by zero"))) >> 0;
			if (nn > 0) {
				e.enc.Encode(go$subslice(new (go$sliceType(Go$Uint8))(e.out), 0), go$subslice(p, 0, nn));
				if (_tuple$3 = e.w.Write(go$subslice(new (go$sliceType(Go$Uint8))(e.out), 0, (x = (_q = nn / 3, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), x$1 = 4, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0))), e.err = _tuple$3[1], !(go$interfaceIsEqual(e.err, null))) {
					_tuple$4 = [n, e.err], n = _tuple$4[0], err = _tuple$4[1];
					return [n, err];
				}
			}
			n = n + (nn) >> 0;
			p = go$subslice(p, nn);
		}
		i$1 = 0;
		while (i$1 < p.length) {
			e.buf[i$1] = (_slice$1 = p, _index$1 = i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			i$1 = i$1 + 1 >> 0;
		}
		e.nbuf = p.length;
		n = n + (p.length) >> 0;
		return [n, err];
	};
	encoder.prototype.Write = function(p) { return this.go$val.Write(p); };
	encoder.Ptr.prototype.Close = function() {
		var e, _tuple;
		e = this;
		if (go$interfaceIsEqual(e.err, null) && e.nbuf > 0) {
			e.enc.Encode(go$subslice(new (go$sliceType(Go$Uint8))(e.out), 0), go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, e.nbuf));
			e.nbuf = 0;
			_tuple = e.w.Write(go$subslice(new (go$sliceType(Go$Uint8))(e.out), 0, 4)), e.err = _tuple[1];
		}
		return e.err;
	};
	encoder.prototype.Close = function() { return this.go$val.Close(); };
	var NewEncoder = go$pkg.NewEncoder = function(enc, w) {
		return new encoder.Ptr(null, enc, w, go$makeNativeArray("Uint8", 3, function() { return 0; }), 0, go$makeNativeArray("Uint8", 1024, function() { return 0; }));
	};
	Encoding.Ptr.prototype.EncodedLen = function(n) {
		var enc, x, _q, x$1;
		enc = this;
		return (x = (_q = ((n + 2 >> 0)) / 3, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), x$1 = 4, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
	};
	Encoding.prototype.EncodedLen = function(n) { return this.go$val.EncodedLen(n); };
	CorruptInputError.prototype.Error = function() {
		var e;
		e = this;
		return "illegal base64 data at input byte " + strconv.FormatInt(new Go$Int64(e.high, e.low), 10);
	};
	go$ptrType(CorruptInputError).prototype.Error = function() { return this.go$get().Error(); };
	Encoding.Ptr.prototype.decode = function(dst, src) {
		var n, end, err, enc, olen, dbuf, dlen, j, _tuple, _slice, _index, in$1, _tuple$1, _slice$1, _index$1, _tuple$2, _tuple$3, _tuple$4, _ref, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _tuple$5;
		n = 0;
		end = false;
		err = null;
		enc = this;
		olen = src.length;
		while (src.length > 0 && !end) {
			dbuf = go$makeNativeArray("Uint8", 4, function() { return 0; });
			dlen = 4;
			j = 0;
			while (j < 4) {
				if (src.length === 0) {
					_tuple = [n, false, new CorruptInputError(0, ((olen - src.length >> 0) - j >> 0))], n = _tuple[0], end = _tuple[1], err = _tuple[2];
					return [n, end, err];
				}
				in$1 = (_slice = src, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				src = go$subslice(src, 1);
				if ((in$1 === 61) && j >= 2 && src.length < 4) {
					if ((src.length + j >> 0) < 3) {
						_tuple$1 = [n, false, new CorruptInputError(0, olen)], n = _tuple$1[0], end = _tuple$1[1], err = _tuple$1[2];
						return [n, end, err];
					}
					if (src.length > 0 && !(((_slice$1 = src, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 61))) {
						_tuple$2 = [n, false, new CorruptInputError(0, ((olen - src.length >> 0) - 1 >> 0))], n = _tuple$2[0], end = _tuple$2[1], err = _tuple$2[2];
						return [n, end, err];
					}
					_tuple$3 = [j, true], dlen = _tuple$3[0], end = _tuple$3[1];
					break;
				}
				dbuf[j] = enc.decodeMap[in$1];
				if (dbuf[j] === 255) {
					_tuple$4 = [n, false, new CorruptInputError(0, ((olen - src.length >> 0) - 1 >> 0))], n = _tuple$4[0], end = _tuple$4[1], err = _tuple$4[2];
					return [n, end, err];
				}
				j = j + 1 >> 0;
			}
			_ref = dlen;
			if (_ref === 4) {
				_slice$2 = dst, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ((dbuf[2] << 6 << 24 >>> 24) | dbuf[3]) >>> 0) : go$throwRuntimeError("index out of range");
				_slice$3 = dst, _index$3 = 1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = ((dbuf[1] << 4 << 24 >>> 24) | (dbuf[2] >>> 2 << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
				_slice$4 = dst, _index$4 = 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = ((dbuf[0] << 2 << 24 >>> 24) | (dbuf[1] >>> 4 << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
			} else if (_ref === 3) {
				_slice$5 = dst, _index$5 = 1, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = ((dbuf[1] << 4 << 24 >>> 24) | (dbuf[2] >>> 2 << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
				_slice$6 = dst, _index$6 = 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = ((dbuf[0] << 2 << 24 >>> 24) | (dbuf[1] >>> 4 << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
			} else if (_ref === 2) {
				_slice$7 = dst, _index$7 = 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = ((dbuf[0] << 2 << 24 >>> 24) | (dbuf[1] >>> 4 << 24 >>> 24)) >>> 0) : go$throwRuntimeError("index out of range");
			}
			dst = go$subslice(dst, 3);
			n = n + ((dlen - 1 >> 0)) >> 0;
		}
		_tuple$5 = [n, end, null], n = _tuple$5[0], end = _tuple$5[1], err = _tuple$5[2];
		return [n, end, err];
	};
	Encoding.prototype.decode = function(dst, src) { return this.go$val.decode(dst, src); };
	Encoding.Ptr.prototype.Decode = function(dst, src) {
		var n, err, enc, _tuple;
		n = 0;
		err = null;
		enc = this;
		src = bytes.Map(removeNewlinesMapper, src);
		_tuple = enc.decode(dst, src), n = _tuple[0], err = _tuple[2];
		return [n, err];
	};
	Encoding.prototype.Decode = function(dst, src) { return this.go$val.Decode(dst, src); };
	Encoding.Ptr.prototype.DecodeString = function(s) {
		var enc, dbuf, _tuple, n, err;
		enc = this;
		s = strings.Map(removeNewlinesMapper, s);
		dbuf = (go$sliceType(Go$Uint8)).make(enc.DecodedLen(s.length), 0, function() { return 0; });
		_tuple = enc.Decode(dbuf, new (go$sliceType(Go$Uint8))(go$stringToBytes(s))), n = _tuple[0], err = _tuple[1];
		return [go$subslice(dbuf, 0, n), err];
	};
	Encoding.prototype.DecodeString = function(s) { return this.go$val.DecodeString(s); };
	decoder.Ptr.prototype.Read = function(p) {
		var n, err, d, _tuple, _tuple$1, x, _q, x$1, nn, _tuple$2, _tuple$3, x$2, _q$1, x$3, nr, x$4, _q$2, x$5, nw, _tuple$4, _tuple$5, i, _tuple$6;
		n = 0;
		err = null;
		d = this;
		if (!(go$interfaceIsEqual(d.err, null))) {
			_tuple = [0, d.err], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (d.out.length > 0) {
			n = go$copySlice(p, d.out);
			d.out = go$subslice(d.out, n);
			_tuple$1 = [n, null], n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		nn = (x = (_q = p.length / 3, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), x$1 = 4, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
		if (nn < 4) {
			nn = 4;
		}
		if (nn > 1024) {
			nn = 1024;
		}
		_tuple$2 = io.ReadAtLeast(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.buf), d.nbuf, nn), 4 - d.nbuf >> 0), nn = _tuple$2[0], d.err = _tuple$2[1];
		d.nbuf = d.nbuf + (nn) >> 0;
		if (!(go$interfaceIsEqual(d.err, null)) || d.nbuf < 4) {
			_tuple$3 = [0, d.err], n = _tuple$3[0], err = _tuple$3[1];
			return [n, err];
		}
		nr = (x$2 = (_q$1 = d.nbuf / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")), x$3 = 4, (((x$2 >>> 16 << 16) * x$3 >> 0) + (x$2 << 16 >>> 16) * x$3) >> 0);
		nw = (x$4 = (_q$2 = d.nbuf / 4, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero")), x$5 = 3, (((x$4 >>> 16 << 16) * x$5 >> 0) + (x$4 << 16 >>> 16) * x$5) >> 0);
		if (nw > p.length) {
			_tuple$4 = d.enc.decode(go$subslice(new (go$sliceType(Go$Uint8))(d.outbuf), 0), go$subslice(new (go$sliceType(Go$Uint8))(d.buf), 0, nr)), nw = _tuple$4[0], d.end = _tuple$4[1], d.err = _tuple$4[2];
			d.out = go$subslice(new (go$sliceType(Go$Uint8))(d.outbuf), 0, nw);
			n = go$copySlice(p, d.out);
			d.out = go$subslice(d.out, n);
		} else {
			_tuple$5 = d.enc.decode(p, go$subslice(new (go$sliceType(Go$Uint8))(d.buf), 0, nr)), n = _tuple$5[0], d.end = _tuple$5[1], d.err = _tuple$5[2];
		}
		d.nbuf = d.nbuf - (nr) >> 0;
		i = 0;
		while (i < d.nbuf) {
			d.buf[i] = d.buf[(i + nr >> 0)];
			i = i + 1 >> 0;
		}
		if (go$interfaceIsEqual(d.err, null)) {
			d.err = err;
		}
		_tuple$6 = [n, d.err], n = _tuple$6[0], err = _tuple$6[1];
		return [n, err];
	};
	decoder.prototype.Read = function(p) { return this.go$val.Read(p); };
	newlineFilteringReader.Ptr.prototype.Read = function(p) {
		var r, _tuple, n, err, offset, _ref, _i, _slice, _index, b, i, _slice$1, _index$1, _tuple$1;
		r = this;
		_tuple = r.wrapped.Read(p), n = _tuple[0], err = _tuple[1];
		while (n > 0) {
			offset = 0;
			_ref = go$subslice(p, 0, n);
			_i = 0;
			while (_i < _ref.length) {
				b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				if (!((b === 13)) && !((b === 10))) {
					if (!((i === offset))) {
						_slice$1 = p, _index$1 = offset, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = b) : go$throwRuntimeError("index out of range");
					}
					offset = offset + 1 >> 0;
				}
				_i++;
			}
			if (offset > 0) {
				return [offset, err];
			}
			_tuple$1 = r.wrapped.Read(p), n = _tuple$1[0], err = _tuple$1[1];
		}
		return [n, err];
	};
	newlineFilteringReader.prototype.Read = function(p) { return this.go$val.Read(p); };
	var NewDecoder = go$pkg.NewDecoder = function(enc, r) {
		return new decoder.Ptr(null, enc, new newlineFilteringReader.Ptr(r), false, go$makeNativeArray("Uint8", 1024, function() { return 0; }), 0, (go$sliceType(Go$Uint8)).nil, go$makeNativeArray("Uint8", 768, function() { return 0; }));
	};
	Encoding.Ptr.prototype.DecodedLen = function(n) {
		var enc, x, _q, x$1;
		enc = this;
		return (x = (_q = n / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), x$1 = 3, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
	};
	Encoding.prototype.DecodedLen = function(n) { return this.go$val.DecodedLen(n); };
	go$pkg.init = function() {
		go$pkg.StdEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
		go$pkg.URLEncoding = NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_");
		removeNewlinesMapper = (function(r) {
			if ((r === 13) || (r === 10)) {
				return -1;
			}
			return r;
		});
	};
	return go$pkg;
})();
go$packages["unicode/utf16"] = (function() {
	var go$pkg = {};
	var IsSurrogate = go$pkg.IsSurrogate = function(r) {
		return 55296 <= r && r < 57344;
	};
	var DecodeRune = go$pkg.DecodeRune = function(r1, r2) {
		if (55296 <= r1 && r1 < 56320 && 56320 <= r2 && r2 < 57344) {
			return ((((r1 - 55296 >> 0)) << 10 >> 0) | ((r2 - 56320 >> 0))) + 65536 >> 0;
		}
		return 65533;
	};
	var EncodeRune = go$pkg.EncodeRune = function(r) {
		var r1, r2, _tuple, _tuple$1;
		r1 = 0;
		r2 = 0;
		if (r < 65536 || r > 1114111 || IsSurrogate(r)) {
			_tuple = [65533, 65533], r1 = _tuple[0], r2 = _tuple[1];
			return [r1, r2];
		}
		r = r - 65536 >> 0;
		_tuple$1 = [55296 + (((r >> 10 >> 0)) & 1023) >> 0, 56320 + (r & 1023) >> 0], r1 = _tuple$1[0], r2 = _tuple$1[1];
		return [r1, r2];
	};
	var Encode = go$pkg.Encode = function(s) {
		var n, _ref, _i, _slice, _index, v, a, _ref$1, _i$1, _slice$1, _index$1, v$1, _slice$2, _index$2, _slice$3, _index$3, _tuple, r1, r2, _slice$4, _index$4, _slice$5, _index$5;
		n = s.length;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (v >= 65536) {
				n = n + 1 >> 0;
			}
			_i++;
		}
		a = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
		n = 0;
		_ref$1 = s;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			v$1 = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			if (v$1 < 0 || 55296 <= v$1 && v$1 < 57344 || v$1 > 1114111) {
				v$1 = 65533;
				_slice$2 = a, _index$2 = n, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = (v$1 << 16 >>> 16)) : go$throwRuntimeError("index out of range");
				n = n + 1 >> 0;
			} else if (v$1 < 65536) {
				_slice$3 = a, _index$3 = n, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (v$1 << 16 >>> 16)) : go$throwRuntimeError("index out of range");
				n = n + 1 >> 0;
			} else {
				_tuple = EncodeRune(v$1), r1 = _tuple[0], r2 = _tuple[1];
				_slice$4 = a, _index$4 = n, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = (r1 << 16 >>> 16)) : go$throwRuntimeError("index out of range");
				_slice$5 = a, _index$5 = n + 1 >> 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (r2 << 16 >>> 16)) : go$throwRuntimeError("index out of range");
				n = n + 2 >> 0;
			}
			_i$1++;
		}
		return go$subslice(a, 0, n);
	};
	var Decode = go$pkg.Decode = function(s) {
		var a, n, i, _slice, _index, r, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6;
		a = (go$sliceType(Go$Int32)).make(s.length, 0, function() { return 0; });
		n = 0;
		i = 0;
		while (i < s.length) {
			r = (_slice = s, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (55296 <= r && r < 56320 && (i + 1 >> 0) < s.length && 56320 <= (_slice$1 = s, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) && (_slice$2 = s, _index$2 = (i + 1 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) < 57344) {
				_slice$4 = a, _index$4 = n, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = DecodeRune((r >> 0), ((_slice$3 = s, _index$3 = (i + 1 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) >> 0))) : go$throwRuntimeError("index out of range");
				i = i + 1 >> 0;
				n = n + 1 >> 0;
			} else if (55296 <= r && r < 57344) {
				_slice$5 = a, _index$5 = n, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = 65533) : go$throwRuntimeError("index out of range");
				n = n + 1 >> 0;
			} else {
				_slice$6 = a, _index$6 = n, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = (r >> 0)) : go$throwRuntimeError("index out of range");
				n = n + 1 >> 0;
			}
			i = i + 1 >> 0;
		}
		return go$subslice(a, 0, n);
	};
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["syscall"] = (function() {
	var go$pkg = {};
	var sync = go$packages["sync"];
	var atomic = go$packages["sync/atomic"];
	var utf16 = go$packages["unicode/utf16"];
	var errors$1 = go$packages["errors"];
	var DLLError;
	DLLError = go$newType(0, "Struct", "syscall.DLLError", "DLLError", "syscall", function(Err_, ObjName_, Msg_) {
		this.go$val = this;
		this.Err = Err_ !== undefined ? Err_ : null;
		this.ObjName = ObjName_ !== undefined ? ObjName_ : "";
		this.Msg = Msg_ !== undefined ? Msg_ : "";
	});
	go$pkg.DLLError = DLLError;
	var DLL;
	DLL = go$newType(0, "Struct", "syscall.DLL", "DLL", "syscall", function(Name_, Handle_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Handle = Handle_ !== undefined ? Handle_ : 0;
	});
	go$pkg.DLL = DLL;
	var Proc;
	Proc = go$newType(0, "Struct", "syscall.Proc", "Proc", "syscall", function(Dll_, Name_, addr_) {
		this.go$val = this;
		this.Dll = Dll_ !== undefined ? Dll_ : (go$ptrType(DLL)).nil;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.addr = addr_ !== undefined ? addr_ : 0;
	});
	go$pkg.Proc = Proc;
	var LazyDLL;
	LazyDLL = go$newType(0, "Struct", "syscall.LazyDLL", "LazyDLL", "syscall", function(mu_, dll_, Name_) {
		this.go$val = this;
		this.mu = mu_ !== undefined ? mu_ : new sync.Mutex.Ptr();
		this.dll = dll_ !== undefined ? dll_ : (go$ptrType(DLL)).nil;
		this.Name = Name_ !== undefined ? Name_ : "";
	});
	go$pkg.LazyDLL = LazyDLL;
	var LazyProc;
	LazyProc = go$newType(0, "Struct", "syscall.LazyProc", "LazyProc", "syscall", function(mu_, Name_, l_, proc_) {
		this.go$val = this;
		this.mu = mu_ !== undefined ? mu_ : new sync.Mutex.Ptr();
		this.Name = Name_ !== undefined ? Name_ : "";
		this.l = l_ !== undefined ? l_ : (go$ptrType(LazyDLL)).nil;
		this.proc = proc_ !== undefined ? proc_ : (go$ptrType(Proc)).nil;
	});
	go$pkg.LazyProc = LazyProc;
	var ProcAttr;
	ProcAttr = go$newType(0, "Struct", "syscall.ProcAttr", "ProcAttr", "syscall", function(Dir_, Env_, Files_, Sys_) {
		this.go$val = this;
		this.Dir = Dir_ !== undefined ? Dir_ : "";
		this.Env = Env_ !== undefined ? Env_ : (go$sliceType(Go$String)).nil;
		this.Files = Files_ !== undefined ? Files_ : (go$sliceType(Go$Uintptr)).nil;
		this.Sys = Sys_ !== undefined ? Sys_ : (go$ptrType(SysProcAttr)).nil;
	});
	go$pkg.ProcAttr = ProcAttr;
	var SysProcAttr;
	SysProcAttr = go$newType(0, "Struct", "syscall.SysProcAttr", "SysProcAttr", "syscall", function(HideWindow_, CmdLine_, CreationFlags_) {
		this.go$val = this;
		this.HideWindow = HideWindow_ !== undefined ? HideWindow_ : false;
		this.CmdLine = CmdLine_ !== undefined ? CmdLine_ : "";
		this.CreationFlags = CreationFlags_ !== undefined ? CreationFlags_ : 0;
	});
	go$pkg.SysProcAttr = SysProcAttr;
	var UserInfo10;
	UserInfo10 = go$newType(0, "Struct", "syscall.UserInfo10", "UserInfo10", "syscall", function(Name_, Comment_, UsrComment_, FullName_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Go$Uint16)).nil;
		this.Comment = Comment_ !== undefined ? Comment_ : (go$ptrType(Go$Uint16)).nil;
		this.UsrComment = UsrComment_ !== undefined ? UsrComment_ : (go$ptrType(Go$Uint16)).nil;
		this.FullName = FullName_ !== undefined ? FullName_ : (go$ptrType(Go$Uint16)).nil;
	});
	go$pkg.UserInfo10 = UserInfo10;
	var SID;
	SID = go$newType(0, "Struct", "syscall.SID", "SID", "syscall", function() {
		this.go$val = this;
	});
	go$pkg.SID = SID;
	var SIDAndAttributes;
	SIDAndAttributes = go$newType(0, "Struct", "syscall.SIDAndAttributes", "SIDAndAttributes", "syscall", function(Sid_, Attributes_) {
		this.go$val = this;
		this.Sid = Sid_ !== undefined ? Sid_ : (go$ptrType(SID)).nil;
		this.Attributes = Attributes_ !== undefined ? Attributes_ : 0;
	});
	go$pkg.SIDAndAttributes = SIDAndAttributes;
	var Tokenuser;
	Tokenuser = go$newType(0, "Struct", "syscall.Tokenuser", "Tokenuser", "syscall", function(User_) {
		this.go$val = this;
		this.User = User_ !== undefined ? User_ : new SIDAndAttributes.Ptr();
	});
	go$pkg.Tokenuser = Tokenuser;
	var Tokenprimarygroup;
	Tokenprimarygroup = go$newType(0, "Struct", "syscall.Tokenprimarygroup", "Tokenprimarygroup", "syscall", function(PrimaryGroup_) {
		this.go$val = this;
		this.PrimaryGroup = PrimaryGroup_ !== undefined ? PrimaryGroup_ : (go$ptrType(SID)).nil;
	});
	go$pkg.Tokenprimarygroup = Tokenprimarygroup;
	var Token;
	Token = go$newType(4, "Uintptr", "syscall.Token", "Token", "syscall", null);
	go$pkg.Token = Token;
	var Handle;
	Handle = go$newType(4, "Uintptr", "syscall.Handle", "Handle", "syscall", null);
	go$pkg.Handle = Handle;
	var Errno;
	Errno = go$newType(4, "Uintptr", "syscall.Errno", "Errno", "syscall", null);
	go$pkg.Errno = Errno;
	var RawSockaddrInet4;
	RawSockaddrInet4 = go$newType(0, "Struct", "syscall.RawSockaddrInet4", "RawSockaddrInet4", "syscall", function(Family_, Port_, Addr_, Zero_) {
		this.go$val = this;
		this.Family = Family_ !== undefined ? Family_ : 0;
		this.Port = Port_ !== undefined ? Port_ : 0;
		this.Addr = Addr_ !== undefined ? Addr_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
		this.Zero = Zero_ !== undefined ? Zero_ : go$makeNativeArray("Uint8", 8, function() { return 0; });
	});
	go$pkg.RawSockaddrInet4 = RawSockaddrInet4;
	var RawSockaddrInet6;
	RawSockaddrInet6 = go$newType(0, "Struct", "syscall.RawSockaddrInet6", "RawSockaddrInet6", "syscall", function(Family_, Port_, Flowinfo_, Addr_, Scope_id_) {
		this.go$val = this;
		this.Family = Family_ !== undefined ? Family_ : 0;
		this.Port = Port_ !== undefined ? Port_ : 0;
		this.Flowinfo = Flowinfo_ !== undefined ? Flowinfo_ : 0;
		this.Addr = Addr_ !== undefined ? Addr_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Scope_id = Scope_id_ !== undefined ? Scope_id_ : 0;
	});
	go$pkg.RawSockaddrInet6 = RawSockaddrInet6;
	var RawSockaddr;
	RawSockaddr = go$newType(0, "Struct", "syscall.RawSockaddr", "RawSockaddr", "syscall", function(Family_, Data_) {
		this.go$val = this;
		this.Family = Family_ !== undefined ? Family_ : 0;
		this.Data = Data_ !== undefined ? Data_ : go$makeNativeArray("Int8", 14, function() { return 0; });
	});
	go$pkg.RawSockaddr = RawSockaddr;
	var RawSockaddrAny;
	RawSockaddrAny = go$newType(0, "Struct", "syscall.RawSockaddrAny", "RawSockaddrAny", "syscall", function(Addr_, Pad_) {
		this.go$val = this;
		this.Addr = Addr_ !== undefined ? Addr_ : new RawSockaddr.Ptr();
		this.Pad = Pad_ !== undefined ? Pad_ : go$makeNativeArray("Int8", 96, function() { return 0; });
	});
	go$pkg.RawSockaddrAny = RawSockaddrAny;
	var Sockaddr;
	Sockaddr = go$newType(0, "Interface", "syscall.Sockaddr", "Sockaddr", "syscall", null);
	go$pkg.Sockaddr = Sockaddr;
	var SockaddrInet4;
	SockaddrInet4 = go$newType(0, "Struct", "syscall.SockaddrInet4", "SockaddrInet4", "syscall", function(Port_, Addr_, raw_) {
		this.go$val = this;
		this.Port = Port_ !== undefined ? Port_ : 0;
		this.Addr = Addr_ !== undefined ? Addr_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
		this.raw = raw_ !== undefined ? raw_ : new RawSockaddrInet4.Ptr();
	});
	go$pkg.SockaddrInet4 = SockaddrInet4;
	var SockaddrInet6;
	SockaddrInet6 = go$newType(0, "Struct", "syscall.SockaddrInet6", "SockaddrInet6", "syscall", function(Port_, ZoneId_, Addr_, raw_) {
		this.go$val = this;
		this.Port = Port_ !== undefined ? Port_ : 0;
		this.ZoneId = ZoneId_ !== undefined ? ZoneId_ : 0;
		this.Addr = Addr_ !== undefined ? Addr_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.raw = raw_ !== undefined ? raw_ : new RawSockaddrInet6.Ptr();
	});
	go$pkg.SockaddrInet6 = SockaddrInet6;
	var SockaddrUnix;
	SockaddrUnix = go$newType(0, "Struct", "syscall.SockaddrUnix", "SockaddrUnix", "syscall", function(Name_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
	});
	go$pkg.SockaddrUnix = SockaddrUnix;
	var Rusage;
	Rusage = go$newType(0, "Struct", "syscall.Rusage", "Rusage", "syscall", function(CreationTime_, ExitTime_, KernelTime_, UserTime_) {
		this.go$val = this;
		this.CreationTime = CreationTime_ !== undefined ? CreationTime_ : new Filetime.Ptr();
		this.ExitTime = ExitTime_ !== undefined ? ExitTime_ : new Filetime.Ptr();
		this.KernelTime = KernelTime_ !== undefined ? KernelTime_ : new Filetime.Ptr();
		this.UserTime = UserTime_ !== undefined ? UserTime_ : new Filetime.Ptr();
	});
	go$pkg.Rusage = Rusage;
	var WaitStatus;
	WaitStatus = go$newType(0, "Struct", "syscall.WaitStatus", "WaitStatus", "syscall", function(ExitCode_) {
		this.go$val = this;
		this.ExitCode = ExitCode_ !== undefined ? ExitCode_ : 0;
	});
	go$pkg.WaitStatus = WaitStatus;
	var Timespec;
	Timespec = go$newType(0, "Struct", "syscall.Timespec", "Timespec", "syscall", function(Sec_, Nsec_) {
		this.go$val = this;
		this.Sec = Sec_ !== undefined ? Sec_ : new Go$Int64(0, 0);
		this.Nsec = Nsec_ !== undefined ? Nsec_ : new Go$Int64(0, 0);
	});
	go$pkg.Timespec = Timespec;
	var Linger;
	Linger = go$newType(0, "Struct", "syscall.Linger", "Linger", "syscall", function(Onoff_, Linger_) {
		this.go$val = this;
		this.Onoff = Onoff_ !== undefined ? Onoff_ : 0;
		this.Linger = Linger_ !== undefined ? Linger_ : 0;
	});
	go$pkg.Linger = Linger;
	var sysLinger;
	sysLinger = go$newType(0, "Struct", "syscall.sysLinger", "sysLinger", "syscall", function(Onoff_, Linger_) {
		this.go$val = this;
		this.Onoff = Onoff_ !== undefined ? Onoff_ : 0;
		this.Linger = Linger_ !== undefined ? Linger_ : 0;
	});
	go$pkg.sysLinger = sysLinger;
	var IPMreq;
	IPMreq = go$newType(0, "Struct", "syscall.IPMreq", "IPMreq", "syscall", function(Multiaddr_, Interface_) {
		this.go$val = this;
		this.Multiaddr = Multiaddr_ !== undefined ? Multiaddr_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
		this.Interface = Interface_ !== undefined ? Interface_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
	});
	go$pkg.IPMreq = IPMreq;
	var IPv6Mreq;
	IPv6Mreq = go$newType(0, "Struct", "syscall.IPv6Mreq", "IPv6Mreq", "syscall", function(Multiaddr_, Interface_) {
		this.go$val = this;
		this.Multiaddr = Multiaddr_ !== undefined ? Multiaddr_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Interface = Interface_ !== undefined ? Interface_ : 0;
	});
	go$pkg.IPv6Mreq = IPv6Mreq;
	var Signal;
	Signal = go$newType(4, "Int", "syscall.Signal", "Signal", "syscall", null);
	go$pkg.Signal = Signal;
	var Timeval;
	Timeval = go$newType(0, "Struct", "syscall.Timeval", "Timeval", "syscall", function(Sec_, Usec_) {
		this.go$val = this;
		this.Sec = Sec_ !== undefined ? Sec_ : 0;
		this.Usec = Usec_ !== undefined ? Usec_ : 0;
	});
	go$pkg.Timeval = Timeval;
	var SecurityAttributes;
	SecurityAttributes = go$newType(0, "Struct", "syscall.SecurityAttributes", "SecurityAttributes", "syscall", function(Length_, SecurityDescriptor_, InheritHandle_) {
		this.go$val = this;
		this.Length = Length_ !== undefined ? Length_ : 0;
		this.SecurityDescriptor = SecurityDescriptor_ !== undefined ? SecurityDescriptor_ : 0;
		this.InheritHandle = InheritHandle_ !== undefined ? InheritHandle_ : 0;
	});
	go$pkg.SecurityAttributes = SecurityAttributes;
	var Overlapped;
	Overlapped = go$newType(0, "Struct", "syscall.Overlapped", "Overlapped", "syscall", function(Internal_, InternalHigh_, Offset_, OffsetHigh_, HEvent_) {
		this.go$val = this;
		this.Internal = Internal_ !== undefined ? Internal_ : 0;
		this.InternalHigh = InternalHigh_ !== undefined ? InternalHigh_ : 0;
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.OffsetHigh = OffsetHigh_ !== undefined ? OffsetHigh_ : 0;
		this.HEvent = HEvent_ !== undefined ? HEvent_ : 0;
	});
	go$pkg.Overlapped = Overlapped;
	var FileNotifyInformation;
	FileNotifyInformation = go$newType(0, "Struct", "syscall.FileNotifyInformation", "FileNotifyInformation", "syscall", function(NextEntryOffset_, Action_, FileNameLength_, FileName_) {
		this.go$val = this;
		this.NextEntryOffset = NextEntryOffset_ !== undefined ? NextEntryOffset_ : 0;
		this.Action = Action_ !== undefined ? Action_ : 0;
		this.FileNameLength = FileNameLength_ !== undefined ? FileNameLength_ : 0;
		this.FileName = FileName_ !== undefined ? FileName_ : 0;
	});
	go$pkg.FileNotifyInformation = FileNotifyInformation;
	var Filetime;
	Filetime = go$newType(0, "Struct", "syscall.Filetime", "Filetime", "syscall", function(LowDateTime_, HighDateTime_) {
		this.go$val = this;
		this.LowDateTime = LowDateTime_ !== undefined ? LowDateTime_ : 0;
		this.HighDateTime = HighDateTime_ !== undefined ? HighDateTime_ : 0;
	});
	go$pkg.Filetime = Filetime;
	var Win32finddata;
	Win32finddata = go$newType(0, "Struct", "syscall.Win32finddata", "Win32finddata", "syscall", function(FileAttributes_, CreationTime_, LastAccessTime_, LastWriteTime_, FileSizeHigh_, FileSizeLow_, Reserved0_, Reserved1_, FileName_, AlternateFileName_) {
		this.go$val = this;
		this.FileAttributes = FileAttributes_ !== undefined ? FileAttributes_ : 0;
		this.CreationTime = CreationTime_ !== undefined ? CreationTime_ : new Filetime.Ptr();
		this.LastAccessTime = LastAccessTime_ !== undefined ? LastAccessTime_ : new Filetime.Ptr();
		this.LastWriteTime = LastWriteTime_ !== undefined ? LastWriteTime_ : new Filetime.Ptr();
		this.FileSizeHigh = FileSizeHigh_ !== undefined ? FileSizeHigh_ : 0;
		this.FileSizeLow = FileSizeLow_ !== undefined ? FileSizeLow_ : 0;
		this.Reserved0 = Reserved0_ !== undefined ? Reserved0_ : 0;
		this.Reserved1 = Reserved1_ !== undefined ? Reserved1_ : 0;
		this.FileName = FileName_ !== undefined ? FileName_ : go$makeNativeArray("Uint16", 259, function() { return 0; });
		this.AlternateFileName = AlternateFileName_ !== undefined ? AlternateFileName_ : go$makeNativeArray("Uint16", 13, function() { return 0; });
	});
	go$pkg.Win32finddata = Win32finddata;
	var win32finddata1;
	win32finddata1 = go$newType(0, "Struct", "syscall.win32finddata1", "win32finddata1", "syscall", function(FileAttributes_, CreationTime_, LastAccessTime_, LastWriteTime_, FileSizeHigh_, FileSizeLow_, Reserved0_, Reserved1_, FileName_, AlternateFileName_) {
		this.go$val = this;
		this.FileAttributes = FileAttributes_ !== undefined ? FileAttributes_ : 0;
		this.CreationTime = CreationTime_ !== undefined ? CreationTime_ : new Filetime.Ptr();
		this.LastAccessTime = LastAccessTime_ !== undefined ? LastAccessTime_ : new Filetime.Ptr();
		this.LastWriteTime = LastWriteTime_ !== undefined ? LastWriteTime_ : new Filetime.Ptr();
		this.FileSizeHigh = FileSizeHigh_ !== undefined ? FileSizeHigh_ : 0;
		this.FileSizeLow = FileSizeLow_ !== undefined ? FileSizeLow_ : 0;
		this.Reserved0 = Reserved0_ !== undefined ? Reserved0_ : 0;
		this.Reserved1 = Reserved1_ !== undefined ? Reserved1_ : 0;
		this.FileName = FileName_ !== undefined ? FileName_ : go$makeNativeArray("Uint16", 260, function() { return 0; });
		this.AlternateFileName = AlternateFileName_ !== undefined ? AlternateFileName_ : go$makeNativeArray("Uint16", 14, function() { return 0; });
	});
	go$pkg.win32finddata1 = win32finddata1;
	var ByHandleFileInformation;
	ByHandleFileInformation = go$newType(0, "Struct", "syscall.ByHandleFileInformation", "ByHandleFileInformation", "syscall", function(FileAttributes_, CreationTime_, LastAccessTime_, LastWriteTime_, VolumeSerialNumber_, FileSizeHigh_, FileSizeLow_, NumberOfLinks_, FileIndexHigh_, FileIndexLow_) {
		this.go$val = this;
		this.FileAttributes = FileAttributes_ !== undefined ? FileAttributes_ : 0;
		this.CreationTime = CreationTime_ !== undefined ? CreationTime_ : new Filetime.Ptr();
		this.LastAccessTime = LastAccessTime_ !== undefined ? LastAccessTime_ : new Filetime.Ptr();
		this.LastWriteTime = LastWriteTime_ !== undefined ? LastWriteTime_ : new Filetime.Ptr();
		this.VolumeSerialNumber = VolumeSerialNumber_ !== undefined ? VolumeSerialNumber_ : 0;
		this.FileSizeHigh = FileSizeHigh_ !== undefined ? FileSizeHigh_ : 0;
		this.FileSizeLow = FileSizeLow_ !== undefined ? FileSizeLow_ : 0;
		this.NumberOfLinks = NumberOfLinks_ !== undefined ? NumberOfLinks_ : 0;
		this.FileIndexHigh = FileIndexHigh_ !== undefined ? FileIndexHigh_ : 0;
		this.FileIndexLow = FileIndexLow_ !== undefined ? FileIndexLow_ : 0;
	});
	go$pkg.ByHandleFileInformation = ByHandleFileInformation;
	var Win32FileAttributeData;
	Win32FileAttributeData = go$newType(0, "Struct", "syscall.Win32FileAttributeData", "Win32FileAttributeData", "syscall", function(FileAttributes_, CreationTime_, LastAccessTime_, LastWriteTime_, FileSizeHigh_, FileSizeLow_) {
		this.go$val = this;
		this.FileAttributes = FileAttributes_ !== undefined ? FileAttributes_ : 0;
		this.CreationTime = CreationTime_ !== undefined ? CreationTime_ : new Filetime.Ptr();
		this.LastAccessTime = LastAccessTime_ !== undefined ? LastAccessTime_ : new Filetime.Ptr();
		this.LastWriteTime = LastWriteTime_ !== undefined ? LastWriteTime_ : new Filetime.Ptr();
		this.FileSizeHigh = FileSizeHigh_ !== undefined ? FileSizeHigh_ : 0;
		this.FileSizeLow = FileSizeLow_ !== undefined ? FileSizeLow_ : 0;
	});
	go$pkg.Win32FileAttributeData = Win32FileAttributeData;
	var StartupInfo;
	StartupInfo = go$newType(0, "Struct", "syscall.StartupInfo", "StartupInfo", "syscall", function(Cb_, _$1_, Desktop_, Title_, X_, Y_, XSize_, YSize_, XCountChars_, YCountChars_, FillAttribute_, Flags_, ShowWindow_, _$13_, _$14_, StdInput_, StdOutput_, StdErr_) {
		this.go$val = this;
		this.Cb = Cb_ !== undefined ? Cb_ : 0;
		this._$1 = _$1_ !== undefined ? _$1_ : (go$ptrType(Go$Uint16)).nil;
		this.Desktop = Desktop_ !== undefined ? Desktop_ : (go$ptrType(Go$Uint16)).nil;
		this.Title = Title_ !== undefined ? Title_ : (go$ptrType(Go$Uint16)).nil;
		this.X = X_ !== undefined ? X_ : 0;
		this.Y = Y_ !== undefined ? Y_ : 0;
		this.XSize = XSize_ !== undefined ? XSize_ : 0;
		this.YSize = YSize_ !== undefined ? YSize_ : 0;
		this.XCountChars = XCountChars_ !== undefined ? XCountChars_ : 0;
		this.YCountChars = YCountChars_ !== undefined ? YCountChars_ : 0;
		this.FillAttribute = FillAttribute_ !== undefined ? FillAttribute_ : 0;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
		this.ShowWindow = ShowWindow_ !== undefined ? ShowWindow_ : 0;
		this._$13 = _$13_ !== undefined ? _$13_ : 0;
		this._$14 = _$14_ !== undefined ? _$14_ : (go$ptrType(Go$Uint8)).nil;
		this.StdInput = StdInput_ !== undefined ? StdInput_ : 0;
		this.StdOutput = StdOutput_ !== undefined ? StdOutput_ : 0;
		this.StdErr = StdErr_ !== undefined ? StdErr_ : 0;
	});
	go$pkg.StartupInfo = StartupInfo;
	var ProcessInformation;
	ProcessInformation = go$newType(0, "Struct", "syscall.ProcessInformation", "ProcessInformation", "syscall", function(Process_, Thread_, ProcessId_, ThreadId_) {
		this.go$val = this;
		this.Process = Process_ !== undefined ? Process_ : 0;
		this.Thread = Thread_ !== undefined ? Thread_ : 0;
		this.ProcessId = ProcessId_ !== undefined ? ProcessId_ : 0;
		this.ThreadId = ThreadId_ !== undefined ? ThreadId_ : 0;
	});
	go$pkg.ProcessInformation = ProcessInformation;
	var Systemtime;
	Systemtime = go$newType(0, "Struct", "syscall.Systemtime", "Systemtime", "syscall", function(Year_, Month_, DayOfWeek_, Day_, Hour_, Minute_, Second_, Milliseconds_) {
		this.go$val = this;
		this.Year = Year_ !== undefined ? Year_ : 0;
		this.Month = Month_ !== undefined ? Month_ : 0;
		this.DayOfWeek = DayOfWeek_ !== undefined ? DayOfWeek_ : 0;
		this.Day = Day_ !== undefined ? Day_ : 0;
		this.Hour = Hour_ !== undefined ? Hour_ : 0;
		this.Minute = Minute_ !== undefined ? Minute_ : 0;
		this.Second = Second_ !== undefined ? Second_ : 0;
		this.Milliseconds = Milliseconds_ !== undefined ? Milliseconds_ : 0;
	});
	go$pkg.Systemtime = Systemtime;
	var Timezoneinformation;
	Timezoneinformation = go$newType(0, "Struct", "syscall.Timezoneinformation", "Timezoneinformation", "syscall", function(Bias_, StandardName_, StandardDate_, StandardBias_, DaylightName_, DaylightDate_, DaylightBias_) {
		this.go$val = this;
		this.Bias = Bias_ !== undefined ? Bias_ : 0;
		this.StandardName = StandardName_ !== undefined ? StandardName_ : go$makeNativeArray("Uint16", 32, function() { return 0; });
		this.StandardDate = StandardDate_ !== undefined ? StandardDate_ : new Systemtime.Ptr();
		this.StandardBias = StandardBias_ !== undefined ? StandardBias_ : 0;
		this.DaylightName = DaylightName_ !== undefined ? DaylightName_ : go$makeNativeArray("Uint16", 32, function() { return 0; });
		this.DaylightDate = DaylightDate_ !== undefined ? DaylightDate_ : new Systemtime.Ptr();
		this.DaylightBias = DaylightBias_ !== undefined ? DaylightBias_ : 0;
	});
	go$pkg.Timezoneinformation = Timezoneinformation;
	var WSABuf;
	WSABuf = go$newType(0, "Struct", "syscall.WSABuf", "WSABuf", "syscall", function(Len_, Buf_) {
		this.go$val = this;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Buf = Buf_ !== undefined ? Buf_ : (go$ptrType(Go$Uint8)).nil;
	});
	go$pkg.WSABuf = WSABuf;
	var Hostent;
	Hostent = go$newType(0, "Struct", "syscall.Hostent", "Hostent", "syscall", function(Name_, Aliases_, AddrType_, Length_, AddrList_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Go$Uint8)).nil;
		this.Aliases = Aliases_ !== undefined ? Aliases_ : (go$ptrType((go$ptrType(Go$Uint8)))).nil;
		this.AddrType = AddrType_ !== undefined ? AddrType_ : 0;
		this.Length = Length_ !== undefined ? Length_ : 0;
		this.AddrList = AddrList_ !== undefined ? AddrList_ : (go$ptrType((go$ptrType(Go$Uint8)))).nil;
	});
	go$pkg.Hostent = Hostent;
	var Protoent;
	Protoent = go$newType(0, "Struct", "syscall.Protoent", "Protoent", "syscall", function(Name_, Aliases_, Proto_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Go$Uint8)).nil;
		this.Aliases = Aliases_ !== undefined ? Aliases_ : (go$ptrType((go$ptrType(Go$Uint8)))).nil;
		this.Proto = Proto_ !== undefined ? Proto_ : 0;
	});
	go$pkg.Protoent = Protoent;
	var DNSSRVData;
	DNSSRVData = go$newType(0, "Struct", "syscall.DNSSRVData", "DNSSRVData", "syscall", function(Target_, Priority_, Weight_, Port_, Pad_) {
		this.go$val = this;
		this.Target = Target_ !== undefined ? Target_ : (go$ptrType(Go$Uint16)).nil;
		this.Priority = Priority_ !== undefined ? Priority_ : 0;
		this.Weight = Weight_ !== undefined ? Weight_ : 0;
		this.Port = Port_ !== undefined ? Port_ : 0;
		this.Pad = Pad_ !== undefined ? Pad_ : 0;
	});
	go$pkg.DNSSRVData = DNSSRVData;
	var DNSPTRData;
	DNSPTRData = go$newType(0, "Struct", "syscall.DNSPTRData", "DNSPTRData", "syscall", function(Host_) {
		this.go$val = this;
		this.Host = Host_ !== undefined ? Host_ : (go$ptrType(Go$Uint16)).nil;
	});
	go$pkg.DNSPTRData = DNSPTRData;
	var DNSMXData;
	DNSMXData = go$newType(0, "Struct", "syscall.DNSMXData", "DNSMXData", "syscall", function(NameExchange_, Preference_, Pad_) {
		this.go$val = this;
		this.NameExchange = NameExchange_ !== undefined ? NameExchange_ : (go$ptrType(Go$Uint16)).nil;
		this.Preference = Preference_ !== undefined ? Preference_ : 0;
		this.Pad = Pad_ !== undefined ? Pad_ : 0;
	});
	go$pkg.DNSMXData = DNSMXData;
	var DNSTXTData;
	DNSTXTData = go$newType(0, "Struct", "syscall.DNSTXTData", "DNSTXTData", "syscall", function(StringCount_, StringArray_) {
		this.go$val = this;
		this.StringCount = StringCount_ !== undefined ? StringCount_ : 0;
		this.StringArray = StringArray_ !== undefined ? StringArray_ : go$makeNativeArray("Ptr", 1, function() { return (go$ptrType(Go$Uint16)).nil; });
	});
	go$pkg.DNSTXTData = DNSTXTData;
	var DNSRecord;
	DNSRecord = go$newType(0, "Struct", "syscall.DNSRecord", "DNSRecord", "syscall", function(Next_, Name_, Type_, Length_, Dw_, Ttl_, Reserved_, Data_) {
		this.go$val = this;
		this.Next = Next_ !== undefined ? Next_ : (go$ptrType(DNSRecord)).nil;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Go$Uint16)).nil;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Length = Length_ !== undefined ? Length_ : 0;
		this.Dw = Dw_ !== undefined ? Dw_ : 0;
		this.Ttl = Ttl_ !== undefined ? Ttl_ : 0;
		this.Reserved = Reserved_ !== undefined ? Reserved_ : 0;
		this.Data = Data_ !== undefined ? Data_ : go$makeNativeArray("Uint8", 40, function() { return 0; });
	});
	go$pkg.DNSRecord = DNSRecord;
	var TransmitFileBuffers;
	TransmitFileBuffers = go$newType(0, "Struct", "syscall.TransmitFileBuffers", "TransmitFileBuffers", "syscall", function(Head_, HeadLength_, Tail_, TailLength_) {
		this.go$val = this;
		this.Head = Head_ !== undefined ? Head_ : 0;
		this.HeadLength = HeadLength_ !== undefined ? HeadLength_ : 0;
		this.Tail = Tail_ !== undefined ? Tail_ : 0;
		this.TailLength = TailLength_ !== undefined ? TailLength_ : 0;
	});
	go$pkg.TransmitFileBuffers = TransmitFileBuffers;
	var SockaddrGen;
	SockaddrGen = go$newType(0, "Array", "syscall.SockaddrGen", "SockaddrGen", "syscall", null);
	go$pkg.SockaddrGen = SockaddrGen;
	var InterfaceInfo;
	InterfaceInfo = go$newType(0, "Struct", "syscall.InterfaceInfo", "InterfaceInfo", "syscall", function(Flags_, Address_, BroadcastAddress_, Netmask_) {
		this.go$val = this;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
		this.Address = Address_ !== undefined ? Address_ : go$makeNativeArray("Uint8", 24, function() { return 0; });
		this.BroadcastAddress = BroadcastAddress_ !== undefined ? BroadcastAddress_ : go$makeNativeArray("Uint8", 24, function() { return 0; });
		this.Netmask = Netmask_ !== undefined ? Netmask_ : go$makeNativeArray("Uint8", 24, function() { return 0; });
	});
	go$pkg.InterfaceInfo = InterfaceInfo;
	var IpAddressString;
	IpAddressString = go$newType(0, "Struct", "syscall.IpAddressString", "IpAddressString", "syscall", function(String_) {
		this.go$val = this;
		this.String = String_ !== undefined ? String_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
	});
	go$pkg.IpAddressString = IpAddressString;
	var IpMaskString;
	IpMaskString = go$newType(0, "Struct", "syscall.IpMaskString", "IpMaskString", "syscall", function(String_) {
		this.go$val = this;
		this.String = String_ !== undefined ? String_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
	});
	go$pkg.IpMaskString = IpMaskString;
	var IpAddrString;
	IpAddrString = go$newType(0, "Struct", "syscall.IpAddrString", "IpAddrString", "syscall", function(Next_, IpAddress_, IpMask_, Context_) {
		this.go$val = this;
		this.Next = Next_ !== undefined ? Next_ : (go$ptrType(IpAddrString)).nil;
		this.IpAddress = IpAddress_ !== undefined ? IpAddress_ : new IpAddressString.Ptr();
		this.IpMask = IpMask_ !== undefined ? IpMask_ : new IpMaskString.Ptr();
		this.Context = Context_ !== undefined ? Context_ : 0;
	});
	go$pkg.IpAddrString = IpAddrString;
	var IpAdapterInfo;
	IpAdapterInfo = go$newType(0, "Struct", "syscall.IpAdapterInfo", "IpAdapterInfo", "syscall", function(Next_, ComboIndex_, AdapterName_, Description_, AddressLength_, Address_, Index_, Type_, DhcpEnabled_, CurrentIpAddress_, IpAddressList_, GatewayList_, DhcpServer_, HaveWins_, PrimaryWinsServer_, SecondaryWinsServer_, LeaseObtained_, LeaseExpires_) {
		this.go$val = this;
		this.Next = Next_ !== undefined ? Next_ : (go$ptrType(IpAdapterInfo)).nil;
		this.ComboIndex = ComboIndex_ !== undefined ? ComboIndex_ : 0;
		this.AdapterName = AdapterName_ !== undefined ? AdapterName_ : go$makeNativeArray("Uint8", 260, function() { return 0; });
		this.Description = Description_ !== undefined ? Description_ : go$makeNativeArray("Uint8", 132, function() { return 0; });
		this.AddressLength = AddressLength_ !== undefined ? AddressLength_ : 0;
		this.Address = Address_ !== undefined ? Address_ : go$makeNativeArray("Uint8", 8, function() { return 0; });
		this.Index = Index_ !== undefined ? Index_ : 0;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.DhcpEnabled = DhcpEnabled_ !== undefined ? DhcpEnabled_ : 0;
		this.CurrentIpAddress = CurrentIpAddress_ !== undefined ? CurrentIpAddress_ : (go$ptrType(IpAddrString)).nil;
		this.IpAddressList = IpAddressList_ !== undefined ? IpAddressList_ : new IpAddrString.Ptr();
		this.GatewayList = GatewayList_ !== undefined ? GatewayList_ : new IpAddrString.Ptr();
		this.DhcpServer = DhcpServer_ !== undefined ? DhcpServer_ : new IpAddrString.Ptr();
		this.HaveWins = HaveWins_ !== undefined ? HaveWins_ : false;
		this.PrimaryWinsServer = PrimaryWinsServer_ !== undefined ? PrimaryWinsServer_ : new IpAddrString.Ptr();
		this.SecondaryWinsServer = SecondaryWinsServer_ !== undefined ? SecondaryWinsServer_ : new IpAddrString.Ptr();
		this.LeaseObtained = LeaseObtained_ !== undefined ? LeaseObtained_ : new Go$Int64(0, 0);
		this.LeaseExpires = LeaseExpires_ !== undefined ? LeaseExpires_ : new Go$Int64(0, 0);
	});
	go$pkg.IpAdapterInfo = IpAdapterInfo;
	var MibIfRow;
	MibIfRow = go$newType(0, "Struct", "syscall.MibIfRow", "MibIfRow", "syscall", function(Name_, Index_, Type_, Mtu_, Speed_, PhysAddrLen_, PhysAddr_, AdminStatus_, OperStatus_, LastChange_, InOctets_, InUcastPkts_, InNUcastPkts_, InDiscards_, InErrors_, InUnknownProtos_, OutOctets_, OutUcastPkts_, OutNUcastPkts_, OutDiscards_, OutErrors_, OutQLen_, DescrLen_, Descr_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : go$makeNativeArray("Uint16", 256, function() { return 0; });
		this.Index = Index_ !== undefined ? Index_ : 0;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Mtu = Mtu_ !== undefined ? Mtu_ : 0;
		this.Speed = Speed_ !== undefined ? Speed_ : 0;
		this.PhysAddrLen = PhysAddrLen_ !== undefined ? PhysAddrLen_ : 0;
		this.PhysAddr = PhysAddr_ !== undefined ? PhysAddr_ : go$makeNativeArray("Uint8", 8, function() { return 0; });
		this.AdminStatus = AdminStatus_ !== undefined ? AdminStatus_ : 0;
		this.OperStatus = OperStatus_ !== undefined ? OperStatus_ : 0;
		this.LastChange = LastChange_ !== undefined ? LastChange_ : 0;
		this.InOctets = InOctets_ !== undefined ? InOctets_ : 0;
		this.InUcastPkts = InUcastPkts_ !== undefined ? InUcastPkts_ : 0;
		this.InNUcastPkts = InNUcastPkts_ !== undefined ? InNUcastPkts_ : 0;
		this.InDiscards = InDiscards_ !== undefined ? InDiscards_ : 0;
		this.InErrors = InErrors_ !== undefined ? InErrors_ : 0;
		this.InUnknownProtos = InUnknownProtos_ !== undefined ? InUnknownProtos_ : 0;
		this.OutOctets = OutOctets_ !== undefined ? OutOctets_ : 0;
		this.OutUcastPkts = OutUcastPkts_ !== undefined ? OutUcastPkts_ : 0;
		this.OutNUcastPkts = OutNUcastPkts_ !== undefined ? OutNUcastPkts_ : 0;
		this.OutDiscards = OutDiscards_ !== undefined ? OutDiscards_ : 0;
		this.OutErrors = OutErrors_ !== undefined ? OutErrors_ : 0;
		this.OutQLen = OutQLen_ !== undefined ? OutQLen_ : 0;
		this.DescrLen = DescrLen_ !== undefined ? DescrLen_ : 0;
		this.Descr = Descr_ !== undefined ? Descr_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
	});
	go$pkg.MibIfRow = MibIfRow;
	var CertContext;
	CertContext = go$newType(0, "Struct", "syscall.CertContext", "CertContext", "syscall", function(EncodingType_, EncodedCert_, Length_, CertInfo_, Store_) {
		this.go$val = this;
		this.EncodingType = EncodingType_ !== undefined ? EncodingType_ : 0;
		this.EncodedCert = EncodedCert_ !== undefined ? EncodedCert_ : (go$ptrType(Go$Uint8)).nil;
		this.Length = Length_ !== undefined ? Length_ : 0;
		this.CertInfo = CertInfo_ !== undefined ? CertInfo_ : 0;
		this.Store = Store_ !== undefined ? Store_ : 0;
	});
	go$pkg.CertContext = CertContext;
	var CertChainContext;
	CertChainContext = go$newType(0, "Struct", "syscall.CertChainContext", "CertChainContext", "syscall", function(Size_, TrustStatus_, ChainCount_, Chains_, LowerQualityChainCount_, LowerQualityChains_, HasRevocationFreshnessTime_, RevocationFreshnessTime_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.TrustStatus = TrustStatus_ !== undefined ? TrustStatus_ : new CertTrustStatus.Ptr();
		this.ChainCount = ChainCount_ !== undefined ? ChainCount_ : 0;
		this.Chains = Chains_ !== undefined ? Chains_ : (go$ptrType((go$ptrType(CertSimpleChain)))).nil;
		this.LowerQualityChainCount = LowerQualityChainCount_ !== undefined ? LowerQualityChainCount_ : 0;
		this.LowerQualityChains = LowerQualityChains_ !== undefined ? LowerQualityChains_ : (go$ptrType((go$ptrType(CertChainContext)))).nil;
		this.HasRevocationFreshnessTime = HasRevocationFreshnessTime_ !== undefined ? HasRevocationFreshnessTime_ : 0;
		this.RevocationFreshnessTime = RevocationFreshnessTime_ !== undefined ? RevocationFreshnessTime_ : 0;
	});
	go$pkg.CertChainContext = CertChainContext;
	var CertSimpleChain;
	CertSimpleChain = go$newType(0, "Struct", "syscall.CertSimpleChain", "CertSimpleChain", "syscall", function(Size_, TrustStatus_, NumElements_, Elements_, TrustListInfo_, HasRevocationFreshnessTime_, RevocationFreshnessTime_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.TrustStatus = TrustStatus_ !== undefined ? TrustStatus_ : new CertTrustStatus.Ptr();
		this.NumElements = NumElements_ !== undefined ? NumElements_ : 0;
		this.Elements = Elements_ !== undefined ? Elements_ : (go$ptrType((go$ptrType(CertChainElement)))).nil;
		this.TrustListInfo = TrustListInfo_ !== undefined ? TrustListInfo_ : 0;
		this.HasRevocationFreshnessTime = HasRevocationFreshnessTime_ !== undefined ? HasRevocationFreshnessTime_ : 0;
		this.RevocationFreshnessTime = RevocationFreshnessTime_ !== undefined ? RevocationFreshnessTime_ : 0;
	});
	go$pkg.CertSimpleChain = CertSimpleChain;
	var CertChainElement;
	CertChainElement = go$newType(0, "Struct", "syscall.CertChainElement", "CertChainElement", "syscall", function(Size_, CertContext_, TrustStatus_, RevocationInfo_, IssuanceUsage_, ApplicationUsage_, ExtendedErrorInfo_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.CertContext = CertContext_ !== undefined ? CertContext_ : (go$ptrType(CertContext)).nil;
		this.TrustStatus = TrustStatus_ !== undefined ? TrustStatus_ : new CertTrustStatus.Ptr();
		this.RevocationInfo = RevocationInfo_ !== undefined ? RevocationInfo_ : (go$ptrType(CertRevocationInfo)).nil;
		this.IssuanceUsage = IssuanceUsage_ !== undefined ? IssuanceUsage_ : (go$ptrType(CertEnhKeyUsage)).nil;
		this.ApplicationUsage = ApplicationUsage_ !== undefined ? ApplicationUsage_ : (go$ptrType(CertEnhKeyUsage)).nil;
		this.ExtendedErrorInfo = ExtendedErrorInfo_ !== undefined ? ExtendedErrorInfo_ : (go$ptrType(Go$Uint16)).nil;
	});
	go$pkg.CertChainElement = CertChainElement;
	var CertRevocationInfo;
	CertRevocationInfo = go$newType(0, "Struct", "syscall.CertRevocationInfo", "CertRevocationInfo", "syscall", function(Size_, RevocationResult_, RevocationOid_, OidSpecificInfo_, HasFreshnessTime_, FreshnessTime_, CrlInfo_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.RevocationResult = RevocationResult_ !== undefined ? RevocationResult_ : 0;
		this.RevocationOid = RevocationOid_ !== undefined ? RevocationOid_ : (go$ptrType(Go$Uint8)).nil;
		this.OidSpecificInfo = OidSpecificInfo_ !== undefined ? OidSpecificInfo_ : 0;
		this.HasFreshnessTime = HasFreshnessTime_ !== undefined ? HasFreshnessTime_ : 0;
		this.FreshnessTime = FreshnessTime_ !== undefined ? FreshnessTime_ : 0;
		this.CrlInfo = CrlInfo_ !== undefined ? CrlInfo_ : 0;
	});
	go$pkg.CertRevocationInfo = CertRevocationInfo;
	var CertTrustStatus;
	CertTrustStatus = go$newType(0, "Struct", "syscall.CertTrustStatus", "CertTrustStatus", "syscall", function(ErrorStatus_, InfoStatus_) {
		this.go$val = this;
		this.ErrorStatus = ErrorStatus_ !== undefined ? ErrorStatus_ : 0;
		this.InfoStatus = InfoStatus_ !== undefined ? InfoStatus_ : 0;
	});
	go$pkg.CertTrustStatus = CertTrustStatus;
	var CertUsageMatch;
	CertUsageMatch = go$newType(0, "Struct", "syscall.CertUsageMatch", "CertUsageMatch", "syscall", function(Type_, Usage_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Usage = Usage_ !== undefined ? Usage_ : new CertEnhKeyUsage.Ptr();
	});
	go$pkg.CertUsageMatch = CertUsageMatch;
	var CertEnhKeyUsage;
	CertEnhKeyUsage = go$newType(0, "Struct", "syscall.CertEnhKeyUsage", "CertEnhKeyUsage", "syscall", function(Length_, UsageIdentifiers_) {
		this.go$val = this;
		this.Length = Length_ !== undefined ? Length_ : 0;
		this.UsageIdentifiers = UsageIdentifiers_ !== undefined ? UsageIdentifiers_ : (go$ptrType((go$ptrType(Go$Uint8)))).nil;
	});
	go$pkg.CertEnhKeyUsage = CertEnhKeyUsage;
	var CertChainPara;
	CertChainPara = go$newType(0, "Struct", "syscall.CertChainPara", "CertChainPara", "syscall", function(Size_, RequestedUsage_, RequstedIssuancePolicy_, URLRetrievalTimeout_, CheckRevocationFreshnessTime_, RevocationFreshnessTime_, CacheResync_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.RequestedUsage = RequestedUsage_ !== undefined ? RequestedUsage_ : new CertUsageMatch.Ptr();
		this.RequstedIssuancePolicy = RequstedIssuancePolicy_ !== undefined ? RequstedIssuancePolicy_ : new CertUsageMatch.Ptr();
		this.URLRetrievalTimeout = URLRetrievalTimeout_ !== undefined ? URLRetrievalTimeout_ : 0;
		this.CheckRevocationFreshnessTime = CheckRevocationFreshnessTime_ !== undefined ? CheckRevocationFreshnessTime_ : 0;
		this.RevocationFreshnessTime = RevocationFreshnessTime_ !== undefined ? RevocationFreshnessTime_ : 0;
		this.CacheResync = CacheResync_ !== undefined ? CacheResync_ : (go$ptrType(Filetime)).nil;
	});
	go$pkg.CertChainPara = CertChainPara;
	var CertChainPolicyPara;
	CertChainPolicyPara = go$newType(0, "Struct", "syscall.CertChainPolicyPara", "CertChainPolicyPara", "syscall", function(Size_, Flags_, ExtraPolicyPara_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
		this.ExtraPolicyPara = ExtraPolicyPara_ !== undefined ? ExtraPolicyPara_ : 0;
	});
	go$pkg.CertChainPolicyPara = CertChainPolicyPara;
	var SSLExtraCertChainPolicyPara;
	SSLExtraCertChainPolicyPara = go$newType(0, "Struct", "syscall.SSLExtraCertChainPolicyPara", "SSLExtraCertChainPolicyPara", "syscall", function(Size_, AuthType_, Checks_, ServerName_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.AuthType = AuthType_ !== undefined ? AuthType_ : 0;
		this.Checks = Checks_ !== undefined ? Checks_ : 0;
		this.ServerName = ServerName_ !== undefined ? ServerName_ : (go$ptrType(Go$Uint16)).nil;
	});
	go$pkg.SSLExtraCertChainPolicyPara = SSLExtraCertChainPolicyPara;
	var CertChainPolicyStatus;
	CertChainPolicyStatus = go$newType(0, "Struct", "syscall.CertChainPolicyStatus", "CertChainPolicyStatus", "syscall", function(Size_, Error_, ChainIndex_, ElementIndex_, ExtraPolicyStatus_) {
		this.go$val = this;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.Error = Error_ !== undefined ? Error_ : 0;
		this.ChainIndex = ChainIndex_ !== undefined ? ChainIndex_ : 0;
		this.ElementIndex = ElementIndex_ !== undefined ? ElementIndex_ : 0;
		this.ExtraPolicyStatus = ExtraPolicyStatus_ !== undefined ? ExtraPolicyStatus_ : 0;
	});
	go$pkg.CertChainPolicyStatus = CertChainPolicyStatus;
	var AddrinfoW;
	AddrinfoW = go$newType(0, "Struct", "syscall.AddrinfoW", "AddrinfoW", "syscall", function(Flags_, Family_, Socktype_, Protocol_, Addrlen_, Canonname_, Addr_, Next_) {
		this.go$val = this;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
		this.Family = Family_ !== undefined ? Family_ : 0;
		this.Socktype = Socktype_ !== undefined ? Socktype_ : 0;
		this.Protocol = Protocol_ !== undefined ? Protocol_ : 0;
		this.Addrlen = Addrlen_ !== undefined ? Addrlen_ : 0;
		this.Canonname = Canonname_ !== undefined ? Canonname_ : (go$ptrType(Go$Uint16)).nil;
		this.Addr = Addr_ !== undefined ? Addr_ : 0;
		this.Next = Next_ !== undefined ? Next_ : (go$ptrType(AddrinfoW)).nil;
	});
	go$pkg.AddrinfoW = AddrinfoW;
	var GUID;
	GUID = go$newType(0, "Struct", "syscall.GUID", "GUID", "syscall", function(Data1_, Data2_, Data3_, Data4_) {
		this.go$val = this;
		this.Data1 = Data1_ !== undefined ? Data1_ : 0;
		this.Data2 = Data2_ !== undefined ? Data2_ : 0;
		this.Data3 = Data3_ !== undefined ? Data3_ : 0;
		this.Data4 = Data4_ !== undefined ? Data4_ : go$makeNativeArray("Uint8", 8, function() { return 0; });
	});
	go$pkg.GUID = GUID;
	var WSAProtocolInfo;
	WSAProtocolInfo = go$newType(0, "Struct", "syscall.WSAProtocolInfo", "WSAProtocolInfo", "syscall", function(ServiceFlags1_, ServiceFlags2_, ServiceFlags3_, ServiceFlags4_, ProviderFlags_, ProviderId_, CatalogEntryId_, ProtocolChain_, Version_, AddressFamily_, MaxSockAddr_, MinSockAddr_, SocketType_, Protocol_, ProtocolMaxOffset_, NetworkByteOrder_, SecurityScheme_, MessageSize_, ProviderReserved_, ProtocolName_) {
		this.go$val = this;
		this.ServiceFlags1 = ServiceFlags1_ !== undefined ? ServiceFlags1_ : 0;
		this.ServiceFlags2 = ServiceFlags2_ !== undefined ? ServiceFlags2_ : 0;
		this.ServiceFlags3 = ServiceFlags3_ !== undefined ? ServiceFlags3_ : 0;
		this.ServiceFlags4 = ServiceFlags4_ !== undefined ? ServiceFlags4_ : 0;
		this.ProviderFlags = ProviderFlags_ !== undefined ? ProviderFlags_ : 0;
		this.ProviderId = ProviderId_ !== undefined ? ProviderId_ : new GUID.Ptr();
		this.CatalogEntryId = CatalogEntryId_ !== undefined ? CatalogEntryId_ : 0;
		this.ProtocolChain = ProtocolChain_ !== undefined ? ProtocolChain_ : new WSAProtocolChain.Ptr();
		this.Version = Version_ !== undefined ? Version_ : 0;
		this.AddressFamily = AddressFamily_ !== undefined ? AddressFamily_ : 0;
		this.MaxSockAddr = MaxSockAddr_ !== undefined ? MaxSockAddr_ : 0;
		this.MinSockAddr = MinSockAddr_ !== undefined ? MinSockAddr_ : 0;
		this.SocketType = SocketType_ !== undefined ? SocketType_ : 0;
		this.Protocol = Protocol_ !== undefined ? Protocol_ : 0;
		this.ProtocolMaxOffset = ProtocolMaxOffset_ !== undefined ? ProtocolMaxOffset_ : 0;
		this.NetworkByteOrder = NetworkByteOrder_ !== undefined ? NetworkByteOrder_ : 0;
		this.SecurityScheme = SecurityScheme_ !== undefined ? SecurityScheme_ : 0;
		this.MessageSize = MessageSize_ !== undefined ? MessageSize_ : 0;
		this.ProviderReserved = ProviderReserved_ !== undefined ? ProviderReserved_ : 0;
		this.ProtocolName = ProtocolName_ !== undefined ? ProtocolName_ : go$makeNativeArray("Uint16", 256, function() { return 0; });
	});
	go$pkg.WSAProtocolInfo = WSAProtocolInfo;
	var WSAProtocolChain;
	WSAProtocolChain = go$newType(0, "Struct", "syscall.WSAProtocolChain", "WSAProtocolChain", "syscall", function(ChainLen_, ChainEntries_) {
		this.go$val = this;
		this.ChainLen = ChainLen_ !== undefined ? ChainLen_ : 0;
		this.ChainEntries = ChainEntries_ !== undefined ? ChainEntries_ : go$makeNativeArray("Uint32", 7, function() { return 0; });
	});
	go$pkg.WSAProtocolChain = WSAProtocolChain;
	var WSAData;
	WSAData = go$newType(0, "Struct", "syscall.WSAData", "WSAData", "syscall", function(Version_, HighVersion_, MaxSockets_, MaxUdpDg_, VendorInfo_, Description_, SystemStatus_) {
		this.go$val = this;
		this.Version = Version_ !== undefined ? Version_ : 0;
		this.HighVersion = HighVersion_ !== undefined ? HighVersion_ : 0;
		this.MaxSockets = MaxSockets_ !== undefined ? MaxSockets_ : 0;
		this.MaxUdpDg = MaxUdpDg_ !== undefined ? MaxUdpDg_ : 0;
		this.VendorInfo = VendorInfo_ !== undefined ? VendorInfo_ : (go$ptrType(Go$Uint8)).nil;
		this.Description = Description_ !== undefined ? Description_ : go$makeNativeArray("Uint8", 257, function() { return 0; });
		this.SystemStatus = SystemStatus_ !== undefined ? SystemStatus_ : go$makeNativeArray("Uint8", 129, function() { return 0; });
	});
	go$pkg.WSAData = WSAData;
	var Servent;
	Servent = go$newType(0, "Struct", "syscall.Servent", "Servent", "syscall", function(Name_, Aliases_, Proto_, Port_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Go$Uint8)).nil;
		this.Aliases = Aliases_ !== undefined ? Aliases_ : (go$ptrType((go$ptrType(Go$Uint8)))).nil;
		this.Proto = Proto_ !== undefined ? Proto_ : (go$ptrType(Go$Uint8)).nil;
		this.Port = Port_ !== undefined ? Port_ : 0;
	});
	go$pkg.Servent = Servent;
	DLLError.init([["Err", "", go$error, ""], ["ObjName", "", Go$String, ""], ["Msg", "", Go$String, ""]]);
	(go$ptrType(DLLError)).methods = [["Error", "", [], [Go$String], false]];
	DLL.init([["Name", "", Go$String, ""], ["Handle", "", Handle, ""]]);
	(go$ptrType(DLL)).methods = [["FindProc", "", [Go$String], [(go$ptrType(Proc)), go$error], false], ["MustFindProc", "", [Go$String], [(go$ptrType(Proc))], false], ["Release", "", [], [go$error], false]];
	Proc.init([["Dll", "", (go$ptrType(DLL)), ""], ["Name", "", Go$String, ""], ["addr", "syscall", Go$Uintptr, ""]]);
	(go$ptrType(Proc)).methods = [["Addr", "", [], [Go$Uintptr], false], ["Call", "", [(go$sliceType(Go$Uintptr))], [Go$Uintptr, Go$Uintptr, go$error], true]];
	LazyDLL.init([["mu", "syscall", sync.Mutex, ""], ["dll", "syscall", (go$ptrType(DLL)), ""], ["Name", "", Go$String, ""]]);
	(go$ptrType(LazyDLL)).methods = [["Handle", "", [], [Go$Uintptr], false], ["Load", "", [], [go$error], false], ["NewProc", "", [Go$String], [(go$ptrType(LazyProc))], false], ["mustLoad", "syscall", [], [], false]];
	LazyProc.init([["mu", "syscall", sync.Mutex, ""], ["Name", "", Go$String, ""], ["l", "syscall", (go$ptrType(LazyDLL)), ""], ["proc", "syscall", (go$ptrType(Proc)), ""]]);
	(go$ptrType(LazyProc)).methods = [["Addr", "", [], [Go$Uintptr], false], ["Call", "", [(go$sliceType(Go$Uintptr))], [Go$Uintptr, Go$Uintptr, go$error], true], ["Find", "", [], [go$error], false], ["mustFind", "syscall", [], [], false]];
	ProcAttr.init([["Dir", "", Go$String, ""], ["Env", "", (go$sliceType(Go$String)), ""], ["Files", "", (go$sliceType(Go$Uintptr)), ""], ["Sys", "", (go$ptrType(SysProcAttr)), ""]]);
	SysProcAttr.init([["HideWindow", "", Go$Bool, ""], ["CmdLine", "", Go$String, ""], ["CreationFlags", "", Go$Uint32, ""]]);
	UserInfo10.init([["Name", "", (go$ptrType(Go$Uint16)), ""], ["Comment", "", (go$ptrType(Go$Uint16)), ""], ["UsrComment", "", (go$ptrType(Go$Uint16)), ""], ["FullName", "", (go$ptrType(Go$Uint16)), ""]]);
	SID.init([]);
	(go$ptrType(SID)).methods = [["Copy", "", [], [(go$ptrType(SID)), go$error], false], ["Len", "", [], [Go$Int], false], ["LookupAccount", "", [Go$String], [Go$String, Go$String, Go$Uint32, go$error], false], ["String", "", [], [Go$String, go$error], false]];
	SIDAndAttributes.init([["Sid", "", (go$ptrType(SID)), ""], ["Attributes", "", Go$Uint32, ""]]);
	Tokenuser.init([["User", "", SIDAndAttributes, ""]]);
	Tokenprimarygroup.init([["PrimaryGroup", "", (go$ptrType(SID)), ""]]);
	Token.methods = [["Close", "", [], [go$error], false], ["GetTokenPrimaryGroup", "", [], [(go$ptrType(Tokenprimarygroup)), go$error], false], ["GetTokenUser", "", [], [(go$ptrType(Tokenuser)), go$error], false], ["GetUserProfileDirectory", "", [], [Go$String, go$error], false], ["getInfo", "syscall", [Go$Uint32, Go$Int], [Go$UnsafePointer, go$error], false]];
	(go$ptrType(Token)).methods = [["Close", "", [], [go$error], false], ["GetTokenPrimaryGroup", "", [], [(go$ptrType(Tokenprimarygroup)), go$error], false], ["GetTokenUser", "", [], [(go$ptrType(Tokenuser)), go$error], false], ["GetUserProfileDirectory", "", [], [Go$String, go$error], false], ["getInfo", "syscall", [Go$Uint32, Go$Int], [Go$UnsafePointer, go$error], false]];
	Errno.methods = [["Error", "", [], [Go$String], false], ["Temporary", "", [], [Go$Bool], false], ["Timeout", "", [], [Go$Bool], false]];
	(go$ptrType(Errno)).methods = [["Error", "", [], [Go$String], false], ["Temporary", "", [], [Go$Bool], false], ["Timeout", "", [], [Go$Bool], false]];
	RawSockaddrInet4.init([["Family", "", Go$Uint16, ""], ["Port", "", Go$Uint16, ""], ["Addr", "", (go$arrayType(Go$Uint8, 4)), ""], ["Zero", "", (go$arrayType(Go$Uint8, 8)), ""]]);
	RawSockaddrInet6.init([["Family", "", Go$Uint16, ""], ["Port", "", Go$Uint16, ""], ["Flowinfo", "", Go$Uint32, ""], ["Addr", "", (go$arrayType(Go$Uint8, 16)), ""], ["Scope_id", "", Go$Uint32, ""]]);
	RawSockaddr.init([["Family", "", Go$Uint16, ""], ["Data", "", (go$arrayType(Go$Int8, 14)), ""]]);
	RawSockaddrAny.init([["Addr", "", RawSockaddr, ""], ["Pad", "", (go$arrayType(Go$Int8, 96)), ""]]);
	(go$ptrType(RawSockaddrAny)).methods = [["Sockaddr", "", [], [Sockaddr, go$error], false]];
	Sockaddr.init([["sockaddr", "syscall", (go$funcType([], [Go$Uintptr, Go$Int32, go$error], false))]]);
	SockaddrInet4.init([["Port", "", Go$Int, ""], ["Addr", "", (go$arrayType(Go$Uint8, 4)), ""], ["raw", "syscall", RawSockaddrInet4, ""]]);
	(go$ptrType(SockaddrInet4)).methods = [["sockaddr", "syscall", [], [Go$Uintptr, Go$Int32, go$error], false]];
	SockaddrInet6.init([["Port", "", Go$Int, ""], ["ZoneId", "", Go$Uint32, ""], ["Addr", "", (go$arrayType(Go$Uint8, 16)), ""], ["raw", "syscall", RawSockaddrInet6, ""]]);
	(go$ptrType(SockaddrInet6)).methods = [["sockaddr", "syscall", [], [Go$Uintptr, Go$Int32, go$error], false]];
	SockaddrUnix.init([["Name", "", Go$String, ""]]);
	(go$ptrType(SockaddrUnix)).methods = [["sockaddr", "syscall", [], [Go$Uintptr, Go$Int32, go$error], false]];
	Rusage.init([["CreationTime", "", Filetime, ""], ["ExitTime", "", Filetime, ""], ["KernelTime", "", Filetime, ""], ["UserTime", "", Filetime, ""]]);
	WaitStatus.init([["ExitCode", "", Go$Uint32, ""]]);
	WaitStatus.methods = [["Continued", "", [], [Go$Bool], false], ["CoreDump", "", [], [Go$Bool], false], ["ExitStatus", "", [], [Go$Int], false], ["Exited", "", [], [Go$Bool], false], ["Signal", "", [], [Signal], false], ["Signaled", "", [], [Go$Bool], false], ["StopSignal", "", [], [Signal], false], ["Stopped", "", [], [Go$Bool], false], ["TrapCause", "", [], [Go$Int], false]];
	(go$ptrType(WaitStatus)).methods = [["Continued", "", [], [Go$Bool], false], ["CoreDump", "", [], [Go$Bool], false], ["ExitStatus", "", [], [Go$Int], false], ["Exited", "", [], [Go$Bool], false], ["Signal", "", [], [Signal], false], ["Signaled", "", [], [Go$Bool], false], ["StopSignal", "", [], [Signal], false], ["Stopped", "", [], [Go$Bool], false], ["TrapCause", "", [], [Go$Int], false]];
	Timespec.init([["Sec", "", Go$Int64, ""], ["Nsec", "", Go$Int64, ""]]);
	(go$ptrType(Timespec)).methods = [["Nano", "", [], [Go$Int64], false], ["Unix", "", [], [Go$Int64, Go$Int64], false]];
	Linger.init([["Onoff", "", Go$Int32, ""], ["Linger", "", Go$Int32, ""]]);
	sysLinger.init([["Onoff", "", Go$Uint16, ""], ["Linger", "", Go$Uint16, ""]]);
	IPMreq.init([["Multiaddr", "", (go$arrayType(Go$Uint8, 4)), ""], ["Interface", "", (go$arrayType(Go$Uint8, 4)), ""]]);
	IPv6Mreq.init([["Multiaddr", "", (go$arrayType(Go$Uint8, 16)), ""], ["Interface", "", Go$Uint32, ""]]);
	Signal.methods = [["Signal", "", [], [], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Signal)).methods = [["Signal", "", [], [], false], ["String", "", [], [Go$String], false]];
	Timeval.init([["Sec", "", Go$Int32, ""], ["Usec", "", Go$Int32, ""]]);
	(go$ptrType(Timeval)).methods = [["Nano", "", [], [Go$Int64], false], ["Nanoseconds", "", [], [Go$Int64], false], ["Unix", "", [], [Go$Int64, Go$Int64], false]];
	SecurityAttributes.init([["Length", "", Go$Uint32, ""], ["SecurityDescriptor", "", Go$Uintptr, ""], ["InheritHandle", "", Go$Uint32, ""]]);
	Overlapped.init([["Internal", "", Go$Uintptr, ""], ["InternalHigh", "", Go$Uintptr, ""], ["Offset", "", Go$Uint32, ""], ["OffsetHigh", "", Go$Uint32, ""], ["HEvent", "", Handle, ""]]);
	FileNotifyInformation.init([["NextEntryOffset", "", Go$Uint32, ""], ["Action", "", Go$Uint32, ""], ["FileNameLength", "", Go$Uint32, ""], ["FileName", "", Go$Uint16, ""]]);
	Filetime.init([["LowDateTime", "", Go$Uint32, ""], ["HighDateTime", "", Go$Uint32, ""]]);
	(go$ptrType(Filetime)).methods = [["Nanoseconds", "", [], [Go$Int64], false]];
	Win32finddata.init([["FileAttributes", "", Go$Uint32, ""], ["CreationTime", "", Filetime, ""], ["LastAccessTime", "", Filetime, ""], ["LastWriteTime", "", Filetime, ""], ["FileSizeHigh", "", Go$Uint32, ""], ["FileSizeLow", "", Go$Uint32, ""], ["Reserved0", "", Go$Uint32, ""], ["Reserved1", "", Go$Uint32, ""], ["FileName", "", (go$arrayType(Go$Uint16, 259)), ""], ["AlternateFileName", "", (go$arrayType(Go$Uint16, 13)), ""]]);
	win32finddata1.init([["FileAttributes", "", Go$Uint32, ""], ["CreationTime", "", Filetime, ""], ["LastAccessTime", "", Filetime, ""], ["LastWriteTime", "", Filetime, ""], ["FileSizeHigh", "", Go$Uint32, ""], ["FileSizeLow", "", Go$Uint32, ""], ["Reserved0", "", Go$Uint32, ""], ["Reserved1", "", Go$Uint32, ""], ["FileName", "", (go$arrayType(Go$Uint16, 260)), ""], ["AlternateFileName", "", (go$arrayType(Go$Uint16, 14)), ""]]);
	ByHandleFileInformation.init([["FileAttributes", "", Go$Uint32, ""], ["CreationTime", "", Filetime, ""], ["LastAccessTime", "", Filetime, ""], ["LastWriteTime", "", Filetime, ""], ["VolumeSerialNumber", "", Go$Uint32, ""], ["FileSizeHigh", "", Go$Uint32, ""], ["FileSizeLow", "", Go$Uint32, ""], ["NumberOfLinks", "", Go$Uint32, ""], ["FileIndexHigh", "", Go$Uint32, ""], ["FileIndexLow", "", Go$Uint32, ""]]);
	Win32FileAttributeData.init([["FileAttributes", "", Go$Uint32, ""], ["CreationTime", "", Filetime, ""], ["LastAccessTime", "", Filetime, ""], ["LastWriteTime", "", Filetime, ""], ["FileSizeHigh", "", Go$Uint32, ""], ["FileSizeLow", "", Go$Uint32, ""]]);
	StartupInfo.init([["Cb", "", Go$Uint32, ""], ["_", "syscall", (go$ptrType(Go$Uint16)), ""], ["Desktop", "", (go$ptrType(Go$Uint16)), ""], ["Title", "", (go$ptrType(Go$Uint16)), ""], ["X", "", Go$Uint32, ""], ["Y", "", Go$Uint32, ""], ["XSize", "", Go$Uint32, ""], ["YSize", "", Go$Uint32, ""], ["XCountChars", "", Go$Uint32, ""], ["YCountChars", "", Go$Uint32, ""], ["FillAttribute", "", Go$Uint32, ""], ["Flags", "", Go$Uint32, ""], ["ShowWindow", "", Go$Uint16, ""], ["_", "syscall", Go$Uint16, ""], ["_", "syscall", (go$ptrType(Go$Uint8)), ""], ["StdInput", "", Handle, ""], ["StdOutput", "", Handle, ""], ["StdErr", "", Handle, ""]]);
	ProcessInformation.init([["Process", "", Handle, ""], ["Thread", "", Handle, ""], ["ProcessId", "", Go$Uint32, ""], ["ThreadId", "", Go$Uint32, ""]]);
	Systemtime.init([["Year", "", Go$Uint16, ""], ["Month", "", Go$Uint16, ""], ["DayOfWeek", "", Go$Uint16, ""], ["Day", "", Go$Uint16, ""], ["Hour", "", Go$Uint16, ""], ["Minute", "", Go$Uint16, ""], ["Second", "", Go$Uint16, ""], ["Milliseconds", "", Go$Uint16, ""]]);
	Timezoneinformation.init([["Bias", "", Go$Int32, ""], ["StandardName", "", (go$arrayType(Go$Uint16, 32)), ""], ["StandardDate", "", Systemtime, ""], ["StandardBias", "", Go$Int32, ""], ["DaylightName", "", (go$arrayType(Go$Uint16, 32)), ""], ["DaylightDate", "", Systemtime, ""], ["DaylightBias", "", Go$Int32, ""]]);
	WSABuf.init([["Len", "", Go$Uint32, ""], ["Buf", "", (go$ptrType(Go$Uint8)), ""]]);
	Hostent.init([["Name", "", (go$ptrType(Go$Uint8)), ""], ["Aliases", "", (go$ptrType((go$ptrType(Go$Uint8)))), ""], ["AddrType", "", Go$Uint16, ""], ["Length", "", Go$Uint16, ""], ["AddrList", "", (go$ptrType((go$ptrType(Go$Uint8)))), ""]]);
	Protoent.init([["Name", "", (go$ptrType(Go$Uint8)), ""], ["Aliases", "", (go$ptrType((go$ptrType(Go$Uint8)))), ""], ["Proto", "", Go$Uint16, ""]]);
	DNSSRVData.init([["Target", "", (go$ptrType(Go$Uint16)), ""], ["Priority", "", Go$Uint16, ""], ["Weight", "", Go$Uint16, ""], ["Port", "", Go$Uint16, ""], ["Pad", "", Go$Uint16, ""]]);
	DNSPTRData.init([["Host", "", (go$ptrType(Go$Uint16)), ""]]);
	DNSMXData.init([["NameExchange", "", (go$ptrType(Go$Uint16)), ""], ["Preference", "", Go$Uint16, ""], ["Pad", "", Go$Uint16, ""]]);
	DNSTXTData.init([["StringCount", "", Go$Uint16, ""], ["StringArray", "", (go$arrayType((go$ptrType(Go$Uint16)), 1)), ""]]);
	DNSRecord.init([["Next", "", (go$ptrType(DNSRecord)), ""], ["Name", "", (go$ptrType(Go$Uint16)), ""], ["Type", "", Go$Uint16, ""], ["Length", "", Go$Uint16, ""], ["Dw", "", Go$Uint32, ""], ["Ttl", "", Go$Uint32, ""], ["Reserved", "", Go$Uint32, ""], ["Data", "", (go$arrayType(Go$Uint8, 40)), ""]]);
	TransmitFileBuffers.init([["Head", "", Go$Uintptr, ""], ["HeadLength", "", Go$Uint32, ""], ["Tail", "", Go$Uintptr, ""], ["TailLength", "", Go$Uint32, ""]]);
	SockaddrGen.init(Go$Uint8, 24);
	InterfaceInfo.init([["Flags", "", Go$Uint32, ""], ["Address", "", SockaddrGen, ""], ["BroadcastAddress", "", SockaddrGen, ""], ["Netmask", "", SockaddrGen, ""]]);
	IpAddressString.init([["String", "", (go$arrayType(Go$Uint8, 16)), ""]]);
	IpMaskString.init([["String", "", (go$arrayType(Go$Uint8, 16)), ""]]);
	IpAddrString.init([["Next", "", (go$ptrType(IpAddrString)), ""], ["IpAddress", "", IpAddressString, ""], ["IpMask", "", IpMaskString, ""], ["Context", "", Go$Uint32, ""]]);
	IpAdapterInfo.init([["Next", "", (go$ptrType(IpAdapterInfo)), ""], ["ComboIndex", "", Go$Uint32, ""], ["AdapterName", "", (go$arrayType(Go$Uint8, 260)), ""], ["Description", "", (go$arrayType(Go$Uint8, 132)), ""], ["AddressLength", "", Go$Uint32, ""], ["Address", "", (go$arrayType(Go$Uint8, 8)), ""], ["Index", "", Go$Uint32, ""], ["Type", "", Go$Uint32, ""], ["DhcpEnabled", "", Go$Uint32, ""], ["CurrentIpAddress", "", (go$ptrType(IpAddrString)), ""], ["IpAddressList", "", IpAddrString, ""], ["GatewayList", "", IpAddrString, ""], ["DhcpServer", "", IpAddrString, ""], ["HaveWins", "", Go$Bool, ""], ["PrimaryWinsServer", "", IpAddrString, ""], ["SecondaryWinsServer", "", IpAddrString, ""], ["LeaseObtained", "", Go$Int64, ""], ["LeaseExpires", "", Go$Int64, ""]]);
	MibIfRow.init([["Name", "", (go$arrayType(Go$Uint16, 256)), ""], ["Index", "", Go$Uint32, ""], ["Type", "", Go$Uint32, ""], ["Mtu", "", Go$Uint32, ""], ["Speed", "", Go$Uint32, ""], ["PhysAddrLen", "", Go$Uint32, ""], ["PhysAddr", "", (go$arrayType(Go$Uint8, 8)), ""], ["AdminStatus", "", Go$Uint32, ""], ["OperStatus", "", Go$Uint32, ""], ["LastChange", "", Go$Uint32, ""], ["InOctets", "", Go$Uint32, ""], ["InUcastPkts", "", Go$Uint32, ""], ["InNUcastPkts", "", Go$Uint32, ""], ["InDiscards", "", Go$Uint32, ""], ["InErrors", "", Go$Uint32, ""], ["InUnknownProtos", "", Go$Uint32, ""], ["OutOctets", "", Go$Uint32, ""], ["OutUcastPkts", "", Go$Uint32, ""], ["OutNUcastPkts", "", Go$Uint32, ""], ["OutDiscards", "", Go$Uint32, ""], ["OutErrors", "", Go$Uint32, ""], ["OutQLen", "", Go$Uint32, ""], ["DescrLen", "", Go$Uint32, ""], ["Descr", "", (go$arrayType(Go$Uint8, 256)), ""]]);
	CertContext.init([["EncodingType", "", Go$Uint32, ""], ["EncodedCert", "", (go$ptrType(Go$Uint8)), ""], ["Length", "", Go$Uint32, ""], ["CertInfo", "", Go$Uintptr, ""], ["Store", "", Handle, ""]]);
	CertChainContext.init([["Size", "", Go$Uint32, ""], ["TrustStatus", "", CertTrustStatus, ""], ["ChainCount", "", Go$Uint32, ""], ["Chains", "", (go$ptrType((go$ptrType(CertSimpleChain)))), ""], ["LowerQualityChainCount", "", Go$Uint32, ""], ["LowerQualityChains", "", (go$ptrType((go$ptrType(CertChainContext)))), ""], ["HasRevocationFreshnessTime", "", Go$Uint32, ""], ["RevocationFreshnessTime", "", Go$Uint32, ""]]);
	CertSimpleChain.init([["Size", "", Go$Uint32, ""], ["TrustStatus", "", CertTrustStatus, ""], ["NumElements", "", Go$Uint32, ""], ["Elements", "", (go$ptrType((go$ptrType(CertChainElement)))), ""], ["TrustListInfo", "", Go$Uintptr, ""], ["HasRevocationFreshnessTime", "", Go$Uint32, ""], ["RevocationFreshnessTime", "", Go$Uint32, ""]]);
	CertChainElement.init([["Size", "", Go$Uint32, ""], ["CertContext", "", (go$ptrType(CertContext)), ""], ["TrustStatus", "", CertTrustStatus, ""], ["RevocationInfo", "", (go$ptrType(CertRevocationInfo)), ""], ["IssuanceUsage", "", (go$ptrType(CertEnhKeyUsage)), ""], ["ApplicationUsage", "", (go$ptrType(CertEnhKeyUsage)), ""], ["ExtendedErrorInfo", "", (go$ptrType(Go$Uint16)), ""]]);
	CertRevocationInfo.init([["Size", "", Go$Uint32, ""], ["RevocationResult", "", Go$Uint32, ""], ["RevocationOid", "", (go$ptrType(Go$Uint8)), ""], ["OidSpecificInfo", "", Go$Uintptr, ""], ["HasFreshnessTime", "", Go$Uint32, ""], ["FreshnessTime", "", Go$Uint32, ""], ["CrlInfo", "", Go$Uintptr, ""]]);
	CertTrustStatus.init([["ErrorStatus", "", Go$Uint32, ""], ["InfoStatus", "", Go$Uint32, ""]]);
	CertUsageMatch.init([["Type", "", Go$Uint32, ""], ["Usage", "", CertEnhKeyUsage, ""]]);
	CertEnhKeyUsage.init([["Length", "", Go$Uint32, ""], ["UsageIdentifiers", "", (go$ptrType((go$ptrType(Go$Uint8)))), ""]]);
	CertChainPara.init([["Size", "", Go$Uint32, ""], ["RequestedUsage", "", CertUsageMatch, ""], ["RequstedIssuancePolicy", "", CertUsageMatch, ""], ["URLRetrievalTimeout", "", Go$Uint32, ""], ["CheckRevocationFreshnessTime", "", Go$Uint32, ""], ["RevocationFreshnessTime", "", Go$Uint32, ""], ["CacheResync", "", (go$ptrType(Filetime)), ""]]);
	CertChainPolicyPara.init([["Size", "", Go$Uint32, ""], ["Flags", "", Go$Uint32, ""], ["ExtraPolicyPara", "", Go$Uintptr, ""]]);
	SSLExtraCertChainPolicyPara.init([["Size", "", Go$Uint32, ""], ["AuthType", "", Go$Uint32, ""], ["Checks", "", Go$Uint32, ""], ["ServerName", "", (go$ptrType(Go$Uint16)), ""]]);
	CertChainPolicyStatus.init([["Size", "", Go$Uint32, ""], ["Error", "", Go$Uint32, ""], ["ChainIndex", "", Go$Uint32, ""], ["ElementIndex", "", Go$Uint32, ""], ["ExtraPolicyStatus", "", Go$Uintptr, ""]]);
	AddrinfoW.init([["Flags", "", Go$Int32, ""], ["Family", "", Go$Int32, ""], ["Socktype", "", Go$Int32, ""], ["Protocol", "", Go$Int32, ""], ["Addrlen", "", Go$Uintptr, ""], ["Canonname", "", (go$ptrType(Go$Uint16)), ""], ["Addr", "", Go$Uintptr, ""], ["Next", "", (go$ptrType(AddrinfoW)), ""]]);
	GUID.init([["Data1", "", Go$Uint32, ""], ["Data2", "", Go$Uint16, ""], ["Data3", "", Go$Uint16, ""], ["Data4", "", (go$arrayType(Go$Uint8, 8)), ""]]);
	WSAProtocolInfo.init([["ServiceFlags1", "", Go$Uint32, ""], ["ServiceFlags2", "", Go$Uint32, ""], ["ServiceFlags3", "", Go$Uint32, ""], ["ServiceFlags4", "", Go$Uint32, ""], ["ProviderFlags", "", Go$Uint32, ""], ["ProviderId", "", GUID, ""], ["CatalogEntryId", "", Go$Uint32, ""], ["ProtocolChain", "", WSAProtocolChain, ""], ["Version", "", Go$Int32, ""], ["AddressFamily", "", Go$Int32, ""], ["MaxSockAddr", "", Go$Int32, ""], ["MinSockAddr", "", Go$Int32, ""], ["SocketType", "", Go$Int32, ""], ["Protocol", "", Go$Int32, ""], ["ProtocolMaxOffset", "", Go$Int32, ""], ["NetworkByteOrder", "", Go$Int32, ""], ["SecurityScheme", "", Go$Int32, ""], ["MessageSize", "", Go$Uint32, ""], ["ProviderReserved", "", Go$Uint32, ""], ["ProtocolName", "", (go$arrayType(Go$Uint16, 256)), ""]]);
	WSAProtocolChain.init([["ChainLen", "", Go$Int32, ""], ["ChainEntries", "", (go$arrayType(Go$Uint32, 7)), ""]]);
	WSAData.init([["Version", "", Go$Uint16, ""], ["HighVersion", "", Go$Uint16, ""], ["MaxSockets", "", Go$Uint16, ""], ["MaxUdpDg", "", Go$Uint16, ""], ["VendorInfo", "", (go$ptrType(Go$Uint8)), ""], ["Description", "", (go$arrayType(Go$Uint8, 257)), ""], ["SystemStatus", "", (go$arrayType(Go$Uint8, 129)), ""]]);
	Servent.init([["Name", "", (go$ptrType(Go$Uint8)), ""], ["Aliases", "", (go$ptrType((go$ptrType(Go$Uint8)))), ""], ["Proto", "", (go$ptrType(Go$Uint8)), ""], ["Port", "", Go$Uint16, ""]]);
	var zeroProcAttr, zeroSysProcAttr, _zero, ioSync, connectExFunc, errors, modkernel32, modadvapi32, modshell32, modmswsock, modcrypt32, modws2_32, moddnsapi, modiphlpapi, modsecur32, modnetapi32, moduserenv, procGetLastError, procLoadLibraryW, procFreeLibrary, procGetProcAddress, procGetVersion, procFormatMessageW, procExitProcess, procCreateFileW, procReadFile, procWriteFile, procSetFilePointer, procCloseHandle, procGetStdHandle, procFindFirstFileW, procFindNextFileW, procFindClose, procGetFileInformationByHandle, procGetCurrentDirectoryW, procSetCurrentDirectoryW, procCreateDirectoryW, procRemoveDirectoryW, procDeleteFileW, procMoveFileW, procGetComputerNameW, procSetEndOfFile, procGetSystemTimeAsFileTime, procGetTimeZoneInformation, procCreateIoCompletionPort, procGetQueuedCompletionStatus, procPostQueuedCompletionStatus, procCancelIo, procCancelIoEx, procCreateProcessW, procOpenProcess, procTerminateProcess, procGetExitCodeProcess, procGetStartupInfoW, procGetCurrentProcess, procGetProcessTimes, procDuplicateHandle, procWaitForSingleObject, procGetTempPathW, procCreatePipe, procGetFileType, procCryptAcquireContextW, procCryptReleaseContext, procCryptGenRandom, procGetEnvironmentStringsW, procFreeEnvironmentStringsW, procGetEnvironmentVariableW, procSetEnvironmentVariableW, procSetFileTime, procGetFileAttributesW, procSetFileAttributesW, procGetFileAttributesExW, procGetCommandLineW, procCommandLineToArgvW, procLocalFree, procSetHandleInformation, procFlushFileBuffers, procGetFullPathNameW, procGetLongPathNameW, procGetShortPathNameW, procCreateFileMappingW, procMapViewOfFile, procUnmapViewOfFile, procFlushViewOfFile, procVirtualLock, procVirtualUnlock, procTransmitFile, procReadDirectoryChangesW, procCertOpenSystemStoreW, procCertOpenStore, procCertEnumCertificatesInStore, procCertAddCertificateContextToStore, procCertCloseStore, procCertGetCertificateChain, procCertFreeCertificateChain, procCertCreateCertificateContext, procCertFreeCertificateContext, procCertVerifyCertificateChainPolicy, procRegOpenKeyExW, procRegCloseKey, procRegQueryInfoKeyW, procRegEnumKeyExW, procRegQueryValueExW, procGetCurrentProcessId, procGetConsoleMode, procWriteConsoleW, procReadConsoleW, procWSAStartup, procWSACleanup, procWSAIoctl, procsocket, procsetsockopt, procgetsockopt, procbind, procconnect, procgetsockname, procgetpeername, proclisten, procshutdown, procclosesocket, procAcceptEx, procGetAcceptExSockaddrs, procWSARecv, procWSASend, procWSARecvFrom, procWSASendTo, procgethostbyname, procgetservbyname, procntohs, procgetprotobyname, procDnsQuery_W, procDnsRecordListFree, procGetAddrInfoW, procFreeAddrInfoW, procGetIfEntry, procGetAdaptersInfo, procSetFileCompletionNotificationModes, procWSAEnumProtocolsW, procTranslateNameW, procGetUserNameExW, procNetUserGetInfo, procNetGetJoinInformation, procNetApiBufferFree, procLookupAccountSidW, procLookupAccountNameW, procConvertSidToStringSidW, procConvertStringSidToSidW, procGetLengthSid, procCopySid, procOpenProcessToken, procGetTokenInformation, procGetUserProfileDirectoryW, signals;
	DLLError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.Msg;
	};
	DLLError.prototype.Error = function() { return this.go$val.Error(); };
	var Syscall = go$pkg.Syscall = function(trap, nargs, a1, a2, a3) {
		throw go$panic("Native function not implemented: Syscall");
	};
	var Syscall6 = go$pkg.Syscall6 = function(trap, nargs, a1, a2, a3, a4, a5, a6) {
		throw go$panic("Native function not implemented: Syscall6");
	};
	var Syscall9 = go$pkg.Syscall9 = function(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
		throw go$panic("Native function not implemented: Syscall9");
	};
	var Syscall12 = go$pkg.Syscall12 = function(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
		throw go$panic("Native function not implemented: Syscall12");
	};
	var Syscall15 = go$pkg.Syscall15 = function(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
		throw go$panic("Native function not implemented: Syscall15");
	};
	var loadlibrary = function(filename) {
		throw go$panic("Native function not implemented: loadlibrary");
	};
	var getprocaddress = function(handle, procname) {
		throw go$panic("Native function not implemented: getprocaddress");
	};
	var LoadDLL = go$pkg.LoadDLL = function(name) {
		var dll, err, _tuple, namep, _tuple$1, _tuple$2, h, e, _tuple$3, d, _tuple$4;
		dll = (go$ptrType(DLL)).nil;
		err = null;
		_tuple = UTF16PtrFromString(name), namep = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = [(go$ptrType(DLL)).nil, err], dll = _tuple$1[0], err = _tuple$1[1];
			return [dll, err];
		}
		_tuple$2 = loadlibrary(namep), h = _tuple$2[0], e = _tuple$2[1];
		if (!((e === 0))) {
			_tuple$3 = [(go$ptrType(DLL)).nil, new DLLError.Ptr(new Errno(e), name, "Failed to load " + name + ": " + (new Errno(e)).Error())], dll = _tuple$3[0], err = _tuple$3[1];
			return [dll, err];
		}
		d = new DLL.Ptr(name, (h >>> 0));
		_tuple$4 = [d, null], dll = _tuple$4[0], err = _tuple$4[1];
		return [dll, err];
	};
	var MustLoadDLL = go$pkg.MustLoadDLL = function(name) {
		var _tuple, d, e;
		_tuple = LoadDLL(name), d = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			throw go$panic(e);
		}
		return d;
	};
	DLL.Ptr.prototype.FindProc = function(name) {
		var proc, err, d, _tuple, namep, _tuple$1, _tuple$2, a, e, _tuple$3, p, _tuple$4;
		proc = (go$ptrType(Proc)).nil;
		err = null;
		d = this;
		_tuple = BytePtrFromString(name), namep = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = [(go$ptrType(Proc)).nil, err], proc = _tuple$1[0], err = _tuple$1[1];
			return [proc, err];
		}
		_tuple$2 = getprocaddress((d.Handle >>> 0), namep), a = _tuple$2[0], e = _tuple$2[1];
		if (!((e === 0))) {
			_tuple$3 = [(go$ptrType(Proc)).nil, new DLLError.Ptr(new Errno(e), name, "Failed to find " + name + " procedure in " + d.Name + ": " + (new Errno(e)).Error())], proc = _tuple$3[0], err = _tuple$3[1];
			return [proc, err];
		}
		p = new Proc.Ptr(d, name, a);
		_tuple$4 = [p, null], proc = _tuple$4[0], err = _tuple$4[1];
		return [proc, err];
	};
	DLL.prototype.FindProc = function(name) { return this.go$val.FindProc(name); };
	DLL.Ptr.prototype.MustFindProc = function(name) {
		var d, _tuple, p, e;
		d = this;
		_tuple = d.FindProc(name), p = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			throw go$panic(e);
		}
		return p;
	};
	DLL.prototype.MustFindProc = function(name) { return this.go$val.MustFindProc(name); };
	DLL.Ptr.prototype.Release = function() {
		var err, d;
		err = null;
		d = this;
		err = FreeLibrary(d.Handle);
		return err;
	};
	DLL.prototype.Release = function() { return this.go$val.Release(); };
	Proc.Ptr.prototype.Addr = function() {
		var p;
		p = this;
		return p.addr;
	};
	Proc.prototype.Addr = function() { return this.go$val.Addr(); };
	Proc.Ptr.prototype.Call = function(a) {
		var r1, r2, lastErr, p, _ref, _tuple, _tuple$1, _slice, _index, _tuple$2, _slice$1, _index$1, _slice$2, _index$2, _tuple$3, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _tuple$4, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _tuple$5, _slice$10, _index$10, _slice$11, _index$11, _slice$12, _index$12, _slice$13, _index$13, _slice$14, _index$14, _tuple$6, _slice$15, _index$15, _slice$16, _index$16, _slice$17, _index$17, _slice$18, _index$18, _slice$19, _index$19, _slice$20, _index$20, _tuple$7, _slice$21, _index$21, _slice$22, _index$22, _slice$23, _index$23, _slice$24, _index$24, _slice$25, _index$25, _slice$26, _index$26, _slice$27, _index$27, _tuple$8, _slice$28, _index$28, _slice$29, _index$29, _slice$30, _index$30, _slice$31, _index$31, _slice$32, _index$32, _slice$33, _index$33, _slice$34, _index$34, _slice$35, _index$35, _tuple$9, _slice$36, _index$36, _slice$37, _index$37, _slice$38, _index$38, _slice$39, _index$39, _slice$40, _index$40, _slice$41, _index$41, _slice$42, _index$42, _slice$43, _index$43, _slice$44, _index$44, _tuple$10, _slice$45, _index$45, _slice$46, _index$46, _slice$47, _index$47, _slice$48, _index$48, _slice$49, _index$49, _slice$50, _index$50, _slice$51, _index$51, _slice$52, _index$52, _slice$53, _index$53, _slice$54, _index$54, _tuple$11, _slice$55, _index$55, _slice$56, _index$56, _slice$57, _index$57, _slice$58, _index$58, _slice$59, _index$59, _slice$60, _index$60, _slice$61, _index$61, _slice$62, _index$62, _slice$63, _index$63, _slice$64, _index$64, _slice$65, _index$65, _tuple$12, _slice$66, _index$66, _slice$67, _index$67, _slice$68, _index$68, _slice$69, _index$69, _slice$70, _index$70, _slice$71, _index$71, _slice$72, _index$72, _slice$73, _index$73, _slice$74, _index$74, _slice$75, _index$75, _slice$76, _index$76, _slice$77, _index$77, _tuple$13, _slice$78, _index$78, _slice$79, _index$79, _slice$80, _index$80, _slice$81, _index$81, _slice$82, _index$82, _slice$83, _index$83, _slice$84, _index$84, _slice$85, _index$85, _slice$86, _index$86, _slice$87, _index$87, _slice$88, _index$88, _slice$89, _index$89, _slice$90, _index$90, _tuple$14, _slice$91, _index$91, _slice$92, _index$92, _slice$93, _index$93, _slice$94, _index$94, _slice$95, _index$95, _slice$96, _index$96, _slice$97, _index$97, _slice$98, _index$98, _slice$99, _index$99, _slice$100, _index$100, _slice$101, _index$101, _slice$102, _index$102, _slice$103, _index$103, _slice$104, _index$104, _tuple$15, _slice$105, _index$105, _slice$106, _index$106, _slice$107, _index$107, _slice$108, _index$108, _slice$109, _index$109, _slice$110, _index$110, _slice$111, _index$111, _slice$112, _index$112, _slice$113, _index$113, _slice$114, _index$114, _slice$115, _index$115, _slice$116, _index$116, _slice$117, _index$117, _slice$118, _index$118, _slice$119, _index$119;
		r1 = 0;
		r2 = 0;
		lastErr = null;
		p = this;
		_ref = a.length;
		if (_ref === 0) {
			_tuple = Syscall(p.Addr(), (a.length >>> 0), 0, 0, 0), r1 = _tuple[0], r2 = _tuple[1], lastErr = new Errno(_tuple[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 1) {
			_tuple$1 = Syscall(p.Addr(), (a.length >>> 0), (_slice = a, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), 0, 0), r1 = _tuple$1[0], r2 = _tuple$1[1], lastErr = new Errno(_tuple$1[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 2) {
			_tuple$2 = Syscall(p.Addr(), (a.length >>> 0), (_slice$1 = a, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = a, _index$2 = 1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), 0), r1 = _tuple$2[0], r2 = _tuple$2[1], lastErr = new Errno(_tuple$2[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 3) {
			_tuple$3 = Syscall(p.Addr(), (a.length >>> 0), (_slice$3 = a, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")), (_slice$4 = a, _index$4 = 1, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")), (_slice$5 = a, _index$5 = 2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"))), r1 = _tuple$3[0], r2 = _tuple$3[1], lastErr = new Errno(_tuple$3[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 4) {
			_tuple$4 = Syscall6(p.Addr(), (a.length >>> 0), (_slice$6 = a, _index$6 = 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")), (_slice$7 = a, _index$7 = 1, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")), (_slice$8 = a, _index$8 = 2, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")), (_slice$9 = a, _index$9 = 3, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")), 0, 0), r1 = _tuple$4[0], r2 = _tuple$4[1], lastErr = new Errno(_tuple$4[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 5) {
			_tuple$5 = Syscall6(p.Addr(), (a.length >>> 0), (_slice$10 = a, _index$10 = 0, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")), (_slice$11 = a, _index$11 = 1, (_index$11 >= 0 && _index$11 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$11] : go$throwRuntimeError("index out of range")), (_slice$12 = a, _index$12 = 2, (_index$12 >= 0 && _index$12 < _slice$12.length) ? _slice$12.array[_slice$12.offset + _index$12] : go$throwRuntimeError("index out of range")), (_slice$13 = a, _index$13 = 3, (_index$13 >= 0 && _index$13 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$13] : go$throwRuntimeError("index out of range")), (_slice$14 = a, _index$14 = 4, (_index$14 >= 0 && _index$14 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$14] : go$throwRuntimeError("index out of range")), 0), r1 = _tuple$5[0], r2 = _tuple$5[1], lastErr = new Errno(_tuple$5[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 6) {
			_tuple$6 = Syscall6(p.Addr(), (a.length >>> 0), (_slice$15 = a, _index$15 = 0, (_index$15 >= 0 && _index$15 < _slice$15.length) ? _slice$15.array[_slice$15.offset + _index$15] : go$throwRuntimeError("index out of range")), (_slice$16 = a, _index$16 = 1, (_index$16 >= 0 && _index$16 < _slice$16.length) ? _slice$16.array[_slice$16.offset + _index$16] : go$throwRuntimeError("index out of range")), (_slice$17 = a, _index$17 = 2, (_index$17 >= 0 && _index$17 < _slice$17.length) ? _slice$17.array[_slice$17.offset + _index$17] : go$throwRuntimeError("index out of range")), (_slice$18 = a, _index$18 = 3, (_index$18 >= 0 && _index$18 < _slice$18.length) ? _slice$18.array[_slice$18.offset + _index$18] : go$throwRuntimeError("index out of range")), (_slice$19 = a, _index$19 = 4, (_index$19 >= 0 && _index$19 < _slice$19.length) ? _slice$19.array[_slice$19.offset + _index$19] : go$throwRuntimeError("index out of range")), (_slice$20 = a, _index$20 = 5, (_index$20 >= 0 && _index$20 < _slice$20.length) ? _slice$20.array[_slice$20.offset + _index$20] : go$throwRuntimeError("index out of range"))), r1 = _tuple$6[0], r2 = _tuple$6[1], lastErr = new Errno(_tuple$6[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 7) {
			_tuple$7 = Syscall9(p.Addr(), (a.length >>> 0), (_slice$21 = a, _index$21 = 0, (_index$21 >= 0 && _index$21 < _slice$21.length) ? _slice$21.array[_slice$21.offset + _index$21] : go$throwRuntimeError("index out of range")), (_slice$22 = a, _index$22 = 1, (_index$22 >= 0 && _index$22 < _slice$22.length) ? _slice$22.array[_slice$22.offset + _index$22] : go$throwRuntimeError("index out of range")), (_slice$23 = a, _index$23 = 2, (_index$23 >= 0 && _index$23 < _slice$23.length) ? _slice$23.array[_slice$23.offset + _index$23] : go$throwRuntimeError("index out of range")), (_slice$24 = a, _index$24 = 3, (_index$24 >= 0 && _index$24 < _slice$24.length) ? _slice$24.array[_slice$24.offset + _index$24] : go$throwRuntimeError("index out of range")), (_slice$25 = a, _index$25 = 4, (_index$25 >= 0 && _index$25 < _slice$25.length) ? _slice$25.array[_slice$25.offset + _index$25] : go$throwRuntimeError("index out of range")), (_slice$26 = a, _index$26 = 5, (_index$26 >= 0 && _index$26 < _slice$26.length) ? _slice$26.array[_slice$26.offset + _index$26] : go$throwRuntimeError("index out of range")), (_slice$27 = a, _index$27 = 6, (_index$27 >= 0 && _index$27 < _slice$27.length) ? _slice$27.array[_slice$27.offset + _index$27] : go$throwRuntimeError("index out of range")), 0, 0), r1 = _tuple$7[0], r2 = _tuple$7[1], lastErr = new Errno(_tuple$7[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 8) {
			_tuple$8 = Syscall9(p.Addr(), (a.length >>> 0), (_slice$28 = a, _index$28 = 0, (_index$28 >= 0 && _index$28 < _slice$28.length) ? _slice$28.array[_slice$28.offset + _index$28] : go$throwRuntimeError("index out of range")), (_slice$29 = a, _index$29 = 1, (_index$29 >= 0 && _index$29 < _slice$29.length) ? _slice$29.array[_slice$29.offset + _index$29] : go$throwRuntimeError("index out of range")), (_slice$30 = a, _index$30 = 2, (_index$30 >= 0 && _index$30 < _slice$30.length) ? _slice$30.array[_slice$30.offset + _index$30] : go$throwRuntimeError("index out of range")), (_slice$31 = a, _index$31 = 3, (_index$31 >= 0 && _index$31 < _slice$31.length) ? _slice$31.array[_slice$31.offset + _index$31] : go$throwRuntimeError("index out of range")), (_slice$32 = a, _index$32 = 4, (_index$32 >= 0 && _index$32 < _slice$32.length) ? _slice$32.array[_slice$32.offset + _index$32] : go$throwRuntimeError("index out of range")), (_slice$33 = a, _index$33 = 5, (_index$33 >= 0 && _index$33 < _slice$33.length) ? _slice$33.array[_slice$33.offset + _index$33] : go$throwRuntimeError("index out of range")), (_slice$34 = a, _index$34 = 6, (_index$34 >= 0 && _index$34 < _slice$34.length) ? _slice$34.array[_slice$34.offset + _index$34] : go$throwRuntimeError("index out of range")), (_slice$35 = a, _index$35 = 7, (_index$35 >= 0 && _index$35 < _slice$35.length) ? _slice$35.array[_slice$35.offset + _index$35] : go$throwRuntimeError("index out of range")), 0), r1 = _tuple$8[0], r2 = _tuple$8[1], lastErr = new Errno(_tuple$8[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 9) {
			_tuple$9 = Syscall9(p.Addr(), (a.length >>> 0), (_slice$36 = a, _index$36 = 0, (_index$36 >= 0 && _index$36 < _slice$36.length) ? _slice$36.array[_slice$36.offset + _index$36] : go$throwRuntimeError("index out of range")), (_slice$37 = a, _index$37 = 1, (_index$37 >= 0 && _index$37 < _slice$37.length) ? _slice$37.array[_slice$37.offset + _index$37] : go$throwRuntimeError("index out of range")), (_slice$38 = a, _index$38 = 2, (_index$38 >= 0 && _index$38 < _slice$38.length) ? _slice$38.array[_slice$38.offset + _index$38] : go$throwRuntimeError("index out of range")), (_slice$39 = a, _index$39 = 3, (_index$39 >= 0 && _index$39 < _slice$39.length) ? _slice$39.array[_slice$39.offset + _index$39] : go$throwRuntimeError("index out of range")), (_slice$40 = a, _index$40 = 4, (_index$40 >= 0 && _index$40 < _slice$40.length) ? _slice$40.array[_slice$40.offset + _index$40] : go$throwRuntimeError("index out of range")), (_slice$41 = a, _index$41 = 5, (_index$41 >= 0 && _index$41 < _slice$41.length) ? _slice$41.array[_slice$41.offset + _index$41] : go$throwRuntimeError("index out of range")), (_slice$42 = a, _index$42 = 6, (_index$42 >= 0 && _index$42 < _slice$42.length) ? _slice$42.array[_slice$42.offset + _index$42] : go$throwRuntimeError("index out of range")), (_slice$43 = a, _index$43 = 7, (_index$43 >= 0 && _index$43 < _slice$43.length) ? _slice$43.array[_slice$43.offset + _index$43] : go$throwRuntimeError("index out of range")), (_slice$44 = a, _index$44 = 8, (_index$44 >= 0 && _index$44 < _slice$44.length) ? _slice$44.array[_slice$44.offset + _index$44] : go$throwRuntimeError("index out of range"))), r1 = _tuple$9[0], r2 = _tuple$9[1], lastErr = new Errno(_tuple$9[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 10) {
			_tuple$10 = Syscall12(p.Addr(), (a.length >>> 0), (_slice$45 = a, _index$45 = 0, (_index$45 >= 0 && _index$45 < _slice$45.length) ? _slice$45.array[_slice$45.offset + _index$45] : go$throwRuntimeError("index out of range")), (_slice$46 = a, _index$46 = 1, (_index$46 >= 0 && _index$46 < _slice$46.length) ? _slice$46.array[_slice$46.offset + _index$46] : go$throwRuntimeError("index out of range")), (_slice$47 = a, _index$47 = 2, (_index$47 >= 0 && _index$47 < _slice$47.length) ? _slice$47.array[_slice$47.offset + _index$47] : go$throwRuntimeError("index out of range")), (_slice$48 = a, _index$48 = 3, (_index$48 >= 0 && _index$48 < _slice$48.length) ? _slice$48.array[_slice$48.offset + _index$48] : go$throwRuntimeError("index out of range")), (_slice$49 = a, _index$49 = 4, (_index$49 >= 0 && _index$49 < _slice$49.length) ? _slice$49.array[_slice$49.offset + _index$49] : go$throwRuntimeError("index out of range")), (_slice$50 = a, _index$50 = 5, (_index$50 >= 0 && _index$50 < _slice$50.length) ? _slice$50.array[_slice$50.offset + _index$50] : go$throwRuntimeError("index out of range")), (_slice$51 = a, _index$51 = 6, (_index$51 >= 0 && _index$51 < _slice$51.length) ? _slice$51.array[_slice$51.offset + _index$51] : go$throwRuntimeError("index out of range")), (_slice$52 = a, _index$52 = 7, (_index$52 >= 0 && _index$52 < _slice$52.length) ? _slice$52.array[_slice$52.offset + _index$52] : go$throwRuntimeError("index out of range")), (_slice$53 = a, _index$53 = 8, (_index$53 >= 0 && _index$53 < _slice$53.length) ? _slice$53.array[_slice$53.offset + _index$53] : go$throwRuntimeError("index out of range")), (_slice$54 = a, _index$54 = 9, (_index$54 >= 0 && _index$54 < _slice$54.length) ? _slice$54.array[_slice$54.offset + _index$54] : go$throwRuntimeError("index out of range")), 0, 0), r1 = _tuple$10[0], r2 = _tuple$10[1], lastErr = new Errno(_tuple$10[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 11) {
			_tuple$11 = Syscall12(p.Addr(), (a.length >>> 0), (_slice$55 = a, _index$55 = 0, (_index$55 >= 0 && _index$55 < _slice$55.length) ? _slice$55.array[_slice$55.offset + _index$55] : go$throwRuntimeError("index out of range")), (_slice$56 = a, _index$56 = 1, (_index$56 >= 0 && _index$56 < _slice$56.length) ? _slice$56.array[_slice$56.offset + _index$56] : go$throwRuntimeError("index out of range")), (_slice$57 = a, _index$57 = 2, (_index$57 >= 0 && _index$57 < _slice$57.length) ? _slice$57.array[_slice$57.offset + _index$57] : go$throwRuntimeError("index out of range")), (_slice$58 = a, _index$58 = 3, (_index$58 >= 0 && _index$58 < _slice$58.length) ? _slice$58.array[_slice$58.offset + _index$58] : go$throwRuntimeError("index out of range")), (_slice$59 = a, _index$59 = 4, (_index$59 >= 0 && _index$59 < _slice$59.length) ? _slice$59.array[_slice$59.offset + _index$59] : go$throwRuntimeError("index out of range")), (_slice$60 = a, _index$60 = 5, (_index$60 >= 0 && _index$60 < _slice$60.length) ? _slice$60.array[_slice$60.offset + _index$60] : go$throwRuntimeError("index out of range")), (_slice$61 = a, _index$61 = 6, (_index$61 >= 0 && _index$61 < _slice$61.length) ? _slice$61.array[_slice$61.offset + _index$61] : go$throwRuntimeError("index out of range")), (_slice$62 = a, _index$62 = 7, (_index$62 >= 0 && _index$62 < _slice$62.length) ? _slice$62.array[_slice$62.offset + _index$62] : go$throwRuntimeError("index out of range")), (_slice$63 = a, _index$63 = 8, (_index$63 >= 0 && _index$63 < _slice$63.length) ? _slice$63.array[_slice$63.offset + _index$63] : go$throwRuntimeError("index out of range")), (_slice$64 = a, _index$64 = 9, (_index$64 >= 0 && _index$64 < _slice$64.length) ? _slice$64.array[_slice$64.offset + _index$64] : go$throwRuntimeError("index out of range")), (_slice$65 = a, _index$65 = 10, (_index$65 >= 0 && _index$65 < _slice$65.length) ? _slice$65.array[_slice$65.offset + _index$65] : go$throwRuntimeError("index out of range")), 0), r1 = _tuple$11[0], r2 = _tuple$11[1], lastErr = new Errno(_tuple$11[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 12) {
			_tuple$12 = Syscall12(p.Addr(), (a.length >>> 0), (_slice$66 = a, _index$66 = 0, (_index$66 >= 0 && _index$66 < _slice$66.length) ? _slice$66.array[_slice$66.offset + _index$66] : go$throwRuntimeError("index out of range")), (_slice$67 = a, _index$67 = 1, (_index$67 >= 0 && _index$67 < _slice$67.length) ? _slice$67.array[_slice$67.offset + _index$67] : go$throwRuntimeError("index out of range")), (_slice$68 = a, _index$68 = 2, (_index$68 >= 0 && _index$68 < _slice$68.length) ? _slice$68.array[_slice$68.offset + _index$68] : go$throwRuntimeError("index out of range")), (_slice$69 = a, _index$69 = 3, (_index$69 >= 0 && _index$69 < _slice$69.length) ? _slice$69.array[_slice$69.offset + _index$69] : go$throwRuntimeError("index out of range")), (_slice$70 = a, _index$70 = 4, (_index$70 >= 0 && _index$70 < _slice$70.length) ? _slice$70.array[_slice$70.offset + _index$70] : go$throwRuntimeError("index out of range")), (_slice$71 = a, _index$71 = 5, (_index$71 >= 0 && _index$71 < _slice$71.length) ? _slice$71.array[_slice$71.offset + _index$71] : go$throwRuntimeError("index out of range")), (_slice$72 = a, _index$72 = 6, (_index$72 >= 0 && _index$72 < _slice$72.length) ? _slice$72.array[_slice$72.offset + _index$72] : go$throwRuntimeError("index out of range")), (_slice$73 = a, _index$73 = 7, (_index$73 >= 0 && _index$73 < _slice$73.length) ? _slice$73.array[_slice$73.offset + _index$73] : go$throwRuntimeError("index out of range")), (_slice$74 = a, _index$74 = 8, (_index$74 >= 0 && _index$74 < _slice$74.length) ? _slice$74.array[_slice$74.offset + _index$74] : go$throwRuntimeError("index out of range")), (_slice$75 = a, _index$75 = 9, (_index$75 >= 0 && _index$75 < _slice$75.length) ? _slice$75.array[_slice$75.offset + _index$75] : go$throwRuntimeError("index out of range")), (_slice$76 = a, _index$76 = 10, (_index$76 >= 0 && _index$76 < _slice$76.length) ? _slice$76.array[_slice$76.offset + _index$76] : go$throwRuntimeError("index out of range")), (_slice$77 = a, _index$77 = 11, (_index$77 >= 0 && _index$77 < _slice$77.length) ? _slice$77.array[_slice$77.offset + _index$77] : go$throwRuntimeError("index out of range"))), r1 = _tuple$12[0], r2 = _tuple$12[1], lastErr = new Errno(_tuple$12[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 13) {
			_tuple$13 = Syscall15(p.Addr(), (a.length >>> 0), (_slice$78 = a, _index$78 = 0, (_index$78 >= 0 && _index$78 < _slice$78.length) ? _slice$78.array[_slice$78.offset + _index$78] : go$throwRuntimeError("index out of range")), (_slice$79 = a, _index$79 = 1, (_index$79 >= 0 && _index$79 < _slice$79.length) ? _slice$79.array[_slice$79.offset + _index$79] : go$throwRuntimeError("index out of range")), (_slice$80 = a, _index$80 = 2, (_index$80 >= 0 && _index$80 < _slice$80.length) ? _slice$80.array[_slice$80.offset + _index$80] : go$throwRuntimeError("index out of range")), (_slice$81 = a, _index$81 = 3, (_index$81 >= 0 && _index$81 < _slice$81.length) ? _slice$81.array[_slice$81.offset + _index$81] : go$throwRuntimeError("index out of range")), (_slice$82 = a, _index$82 = 4, (_index$82 >= 0 && _index$82 < _slice$82.length) ? _slice$82.array[_slice$82.offset + _index$82] : go$throwRuntimeError("index out of range")), (_slice$83 = a, _index$83 = 5, (_index$83 >= 0 && _index$83 < _slice$83.length) ? _slice$83.array[_slice$83.offset + _index$83] : go$throwRuntimeError("index out of range")), (_slice$84 = a, _index$84 = 6, (_index$84 >= 0 && _index$84 < _slice$84.length) ? _slice$84.array[_slice$84.offset + _index$84] : go$throwRuntimeError("index out of range")), (_slice$85 = a, _index$85 = 7, (_index$85 >= 0 && _index$85 < _slice$85.length) ? _slice$85.array[_slice$85.offset + _index$85] : go$throwRuntimeError("index out of range")), (_slice$86 = a, _index$86 = 8, (_index$86 >= 0 && _index$86 < _slice$86.length) ? _slice$86.array[_slice$86.offset + _index$86] : go$throwRuntimeError("index out of range")), (_slice$87 = a, _index$87 = 9, (_index$87 >= 0 && _index$87 < _slice$87.length) ? _slice$87.array[_slice$87.offset + _index$87] : go$throwRuntimeError("index out of range")), (_slice$88 = a, _index$88 = 10, (_index$88 >= 0 && _index$88 < _slice$88.length) ? _slice$88.array[_slice$88.offset + _index$88] : go$throwRuntimeError("index out of range")), (_slice$89 = a, _index$89 = 11, (_index$89 >= 0 && _index$89 < _slice$89.length) ? _slice$89.array[_slice$89.offset + _index$89] : go$throwRuntimeError("index out of range")), (_slice$90 = a, _index$90 = 12, (_index$90 >= 0 && _index$90 < _slice$90.length) ? _slice$90.array[_slice$90.offset + _index$90] : go$throwRuntimeError("index out of range")), 0, 0), r1 = _tuple$13[0], r2 = _tuple$13[1], lastErr = new Errno(_tuple$13[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 14) {
			_tuple$14 = Syscall15(p.Addr(), (a.length >>> 0), (_slice$91 = a, _index$91 = 0, (_index$91 >= 0 && _index$91 < _slice$91.length) ? _slice$91.array[_slice$91.offset + _index$91] : go$throwRuntimeError("index out of range")), (_slice$92 = a, _index$92 = 1, (_index$92 >= 0 && _index$92 < _slice$92.length) ? _slice$92.array[_slice$92.offset + _index$92] : go$throwRuntimeError("index out of range")), (_slice$93 = a, _index$93 = 2, (_index$93 >= 0 && _index$93 < _slice$93.length) ? _slice$93.array[_slice$93.offset + _index$93] : go$throwRuntimeError("index out of range")), (_slice$94 = a, _index$94 = 3, (_index$94 >= 0 && _index$94 < _slice$94.length) ? _slice$94.array[_slice$94.offset + _index$94] : go$throwRuntimeError("index out of range")), (_slice$95 = a, _index$95 = 4, (_index$95 >= 0 && _index$95 < _slice$95.length) ? _slice$95.array[_slice$95.offset + _index$95] : go$throwRuntimeError("index out of range")), (_slice$96 = a, _index$96 = 5, (_index$96 >= 0 && _index$96 < _slice$96.length) ? _slice$96.array[_slice$96.offset + _index$96] : go$throwRuntimeError("index out of range")), (_slice$97 = a, _index$97 = 6, (_index$97 >= 0 && _index$97 < _slice$97.length) ? _slice$97.array[_slice$97.offset + _index$97] : go$throwRuntimeError("index out of range")), (_slice$98 = a, _index$98 = 7, (_index$98 >= 0 && _index$98 < _slice$98.length) ? _slice$98.array[_slice$98.offset + _index$98] : go$throwRuntimeError("index out of range")), (_slice$99 = a, _index$99 = 8, (_index$99 >= 0 && _index$99 < _slice$99.length) ? _slice$99.array[_slice$99.offset + _index$99] : go$throwRuntimeError("index out of range")), (_slice$100 = a, _index$100 = 9, (_index$100 >= 0 && _index$100 < _slice$100.length) ? _slice$100.array[_slice$100.offset + _index$100] : go$throwRuntimeError("index out of range")), (_slice$101 = a, _index$101 = 10, (_index$101 >= 0 && _index$101 < _slice$101.length) ? _slice$101.array[_slice$101.offset + _index$101] : go$throwRuntimeError("index out of range")), (_slice$102 = a, _index$102 = 11, (_index$102 >= 0 && _index$102 < _slice$102.length) ? _slice$102.array[_slice$102.offset + _index$102] : go$throwRuntimeError("index out of range")), (_slice$103 = a, _index$103 = 12, (_index$103 >= 0 && _index$103 < _slice$103.length) ? _slice$103.array[_slice$103.offset + _index$103] : go$throwRuntimeError("index out of range")), (_slice$104 = a, _index$104 = 13, (_index$104 >= 0 && _index$104 < _slice$104.length) ? _slice$104.array[_slice$104.offset + _index$104] : go$throwRuntimeError("index out of range")), 0), r1 = _tuple$14[0], r2 = _tuple$14[1], lastErr = new Errno(_tuple$14[2]);
			return [r1, r2, lastErr];
		} else if (_ref === 15) {
			_tuple$15 = Syscall15(p.Addr(), (a.length >>> 0), (_slice$105 = a, _index$105 = 0, (_index$105 >= 0 && _index$105 < _slice$105.length) ? _slice$105.array[_slice$105.offset + _index$105] : go$throwRuntimeError("index out of range")), (_slice$106 = a, _index$106 = 1, (_index$106 >= 0 && _index$106 < _slice$106.length) ? _slice$106.array[_slice$106.offset + _index$106] : go$throwRuntimeError("index out of range")), (_slice$107 = a, _index$107 = 2, (_index$107 >= 0 && _index$107 < _slice$107.length) ? _slice$107.array[_slice$107.offset + _index$107] : go$throwRuntimeError("index out of range")), (_slice$108 = a, _index$108 = 3, (_index$108 >= 0 && _index$108 < _slice$108.length) ? _slice$108.array[_slice$108.offset + _index$108] : go$throwRuntimeError("index out of range")), (_slice$109 = a, _index$109 = 4, (_index$109 >= 0 && _index$109 < _slice$109.length) ? _slice$109.array[_slice$109.offset + _index$109] : go$throwRuntimeError("index out of range")), (_slice$110 = a, _index$110 = 5, (_index$110 >= 0 && _index$110 < _slice$110.length) ? _slice$110.array[_slice$110.offset + _index$110] : go$throwRuntimeError("index out of range")), (_slice$111 = a, _index$111 = 6, (_index$111 >= 0 && _index$111 < _slice$111.length) ? _slice$111.array[_slice$111.offset + _index$111] : go$throwRuntimeError("index out of range")), (_slice$112 = a, _index$112 = 7, (_index$112 >= 0 && _index$112 < _slice$112.length) ? _slice$112.array[_slice$112.offset + _index$112] : go$throwRuntimeError("index out of range")), (_slice$113 = a, _index$113 = 8, (_index$113 >= 0 && _index$113 < _slice$113.length) ? _slice$113.array[_slice$113.offset + _index$113] : go$throwRuntimeError("index out of range")), (_slice$114 = a, _index$114 = 9, (_index$114 >= 0 && _index$114 < _slice$114.length) ? _slice$114.array[_slice$114.offset + _index$114] : go$throwRuntimeError("index out of range")), (_slice$115 = a, _index$115 = 10, (_index$115 >= 0 && _index$115 < _slice$115.length) ? _slice$115.array[_slice$115.offset + _index$115] : go$throwRuntimeError("index out of range")), (_slice$116 = a, _index$116 = 11, (_index$116 >= 0 && _index$116 < _slice$116.length) ? _slice$116.array[_slice$116.offset + _index$116] : go$throwRuntimeError("index out of range")), (_slice$117 = a, _index$117 = 12, (_index$117 >= 0 && _index$117 < _slice$117.length) ? _slice$117.array[_slice$117.offset + _index$117] : go$throwRuntimeError("index out of range")), (_slice$118 = a, _index$118 = 13, (_index$118 >= 0 && _index$118 < _slice$118.length) ? _slice$118.array[_slice$118.offset + _index$118] : go$throwRuntimeError("index out of range")), (_slice$119 = a, _index$119 = 14, (_index$119 >= 0 && _index$119 < _slice$119.length) ? _slice$119.array[_slice$119.offset + _index$119] : go$throwRuntimeError("index out of range"))), r1 = _tuple$15[0], r2 = _tuple$15[1], lastErr = new Errno(_tuple$15[2]);
			return [r1, r2, lastErr];
		} else {
			throw go$panic(new Go$String("Call " + p.Name + " with too many arguments " + itoa(a.length) + "."));
		}
		return [r1, r2, lastErr];
	};
	Proc.prototype.Call = function(a) { return this.go$val.Call(a); };
	LazyDLL.Ptr.prototype.Load = function() {
		var d, v, _tuple, dll, e, v$1, _array, _struct, _view;
		var go$deferred = [];
		try {
			d = this;
			if (atomic.LoadPointer(new (go$ptrType((go$ptrType(DLL))))(function() { return d.dll; }, function(v) { d.dll = v; })) === 0) {
				d.mu.Lock();
				go$deferred.push({ recv: d.mu, method: "Unlock", args: [] });
				if (d.dll === (go$ptrType(DLL)).nil) {
					_tuple = LoadDLL(d.Name), dll = _tuple[0], e = _tuple[1];
					if (!(go$interfaceIsEqual(e, null))) {
						return e;
					}
					_array = new Uint8Array(12);
					atomic.StorePointer(new (go$ptrType((go$ptrType(DLL))))(function() { return d.dll; }, function(v$1) { d.dll = v$1; }), _array);
					_struct = dll, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Handle = _view.getUintptr(8, true);
				}
			}
			return null;
		} catch(go$err) {
			go$pushErr(go$err);
			return null;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	LazyDLL.prototype.Load = function() { return this.go$val.Load(); };
	LazyDLL.Ptr.prototype.mustLoad = function() {
		var d, e;
		d = this;
		e = d.Load();
		if (!(go$interfaceIsEqual(e, null))) {
			throw go$panic(e);
		}
	};
	LazyDLL.prototype.mustLoad = function() { return this.go$val.mustLoad(); };
	LazyDLL.Ptr.prototype.Handle = function() {
		var d;
		d = this;
		d.mustLoad();
		return (d.dll.Handle >>> 0);
	};
	LazyDLL.prototype.Handle = function() { return this.go$val.Handle(); };
	LazyDLL.Ptr.prototype.NewProc = function(name) {
		var d;
		d = this;
		return new LazyProc.Ptr(new sync.Mutex.Ptr(), name, d, (go$ptrType(Proc)).nil);
	};
	LazyDLL.prototype.NewProc = function(name) { return this.go$val.NewProc(name); };
	var NewLazyDLL = go$pkg.NewLazyDLL = function(name) {
		return new LazyDLL.Ptr(new sync.Mutex.Ptr(), (go$ptrType(DLL)).nil, name);
	};
	LazyProc.Ptr.prototype.Find = function() {
		var p, v, e, _tuple, proc, v$1, _array, _struct, _view;
		var go$deferred = [];
		try {
			p = this;
			if (atomic.LoadPointer(new (go$ptrType((go$ptrType(Proc))))(function() { return p.proc; }, function(v) { p.proc = v; })) === 0) {
				p.mu.Lock();
				go$deferred.push({ recv: p.mu, method: "Unlock", args: [] });
				if (p.proc === (go$ptrType(Proc)).nil) {
					e = p.l.Load();
					if (!(go$interfaceIsEqual(e, null))) {
						return e;
					}
					_tuple = p.l.dll.FindProc(p.Name), proc = _tuple[0], e = _tuple[1];
					if (!(go$interfaceIsEqual(e, null))) {
						return e;
					}
					_array = new Uint8Array(20);
					atomic.StorePointer(new (go$ptrType((go$ptrType(Proc))))(function() { return p.proc; }, function(v$1) { p.proc = v$1; }), _array);
					_struct = proc, _view = new DataView(_array.buffer, _array.byteOffset), _struct.addr = _view.getUintptr(16, true);
				}
			}
			return null;
		} catch(go$err) {
			go$pushErr(go$err);
			return null;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	LazyProc.prototype.Find = function() { return this.go$val.Find(); };
	LazyProc.Ptr.prototype.mustFind = function() {
		var p, e;
		p = this;
		e = p.Find();
		if (!(go$interfaceIsEqual(e, null))) {
			throw go$panic(e);
		}
	};
	LazyProc.prototype.mustFind = function() { return this.go$val.mustFind(); };
	LazyProc.Ptr.prototype.Addr = function() {
		var p;
		p = this;
		p.mustFind();
		return p.proc.Addr();
	};
	LazyProc.prototype.Addr = function() { return this.go$val.Addr(); };
	LazyProc.Ptr.prototype.Call = function(a) {
		var r1, r2, lastErr, p, _tuple;
		r1 = 0;
		r2 = 0;
		lastErr = null;
		p = this;
		p.mustFind();
		_tuple = p.proc.Call(a), r1 = _tuple[0], r2 = _tuple[1], lastErr = _tuple[2];
		return [r1, r2, lastErr];
	};
	LazyProc.prototype.Call = function(a) { return this.go$val.Call(a); };
	var Getenv = go$pkg.Getenv = function(key) {
		var value, found, _tuple, keyp, err, _tuple$1, b, _tuple$2, v, _slice, _index, _slice$1, _index$1, n, e, _tuple$3, _tuple$4, v$1, _slice$2, _index$2, _slice$3, _index$3, _tuple$5;
		value = "";
		found = false;
		_tuple = UTF16PtrFromString(key), keyp = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = ["", false], value = _tuple$1[0], found = _tuple$1[1];
			return [value, found];
		}
		b = (go$sliceType(Go$Uint16)).make(100, 0, function() { return 0; });
		_tuple$2 = GetEnvironmentVariable(keyp, new (go$ptrType(Go$Uint16))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), (b.length >>> 0)), n = _tuple$2[0], e = _tuple$2[1];
		if ((n === 0) && go$interfaceIsEqual(e, new Errno(203))) {
			_tuple$3 = ["", false], value = _tuple$3[0], found = _tuple$3[1];
			return [value, found];
		}
		if (n > (b.length >>> 0)) {
			b = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
			_tuple$4 = GetEnvironmentVariable(keyp, new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = b, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$1) { _slice$3 = b, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$1) : go$throwRuntimeError("index out of range"); }), (b.length >>> 0)), n = _tuple$4[0], e = _tuple$4[1];
			if (n > (b.length >>> 0)) {
				n = 0;
			}
		}
		_tuple$5 = [go$runesToString(utf16.Decode(go$subslice(b, 0, n))), true], value = _tuple$5[0], found = _tuple$5[1];
		return [value, found];
	};
	var Setenv = go$pkg.Setenv = function(key, value) {
		var _tuple, v, err, _tuple$1, keyp, e;
		_tuple = UTF16PtrFromString(value), v = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		_tuple$1 = UTF16PtrFromString(key), keyp = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		e = SetEnvironmentVariable(keyp, v);
		if (!(go$interfaceIsEqual(e, null))) {
			return e;
		}
		return null;
	};
	var Clearenv = go$pkg.Clearenv = function() {
		var _ref, _i, _slice, _index, s, j;
		_ref = Environ();
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			j = 1;
			while (j < s.length) {
				if (s.charCodeAt(j) === 61) {
					Setenv(s.substring(0, j), "");
					break;
				}
				j = j + 1 >> 0;
			}
			_i++;
		}
	};
	var Environ = go$pkg.Environ = function() {
		var _tuple, s, e, r, _tuple$1, from, i, p;
		var go$deferred = [];
		try {
			_tuple = GetEnvironmentStrings(), s = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				return (go$sliceType(Go$String)).nil;
			}
			go$deferred.push({ fun: FreeEnvironmentStrings, args: [s] });
			r = (go$sliceType(Go$String)).make(0, 50, function() { return ""; });
			_tuple$1 = [0, 0, s], from = _tuple$1[0], i = _tuple$1[1], p = _tuple$1[2];
			while (true) {
				if (p[i] === 0) {
					if (i <= from) {
						break;
					}
					r = go$append(r, go$runesToString(utf16.Decode(go$subslice(new (go$sliceType(Go$Uint16))(p), from, i))));
					from = i + 1 >> 0;
				}
				i = i + 1 >> 0;
			}
			return r;
		} catch(go$err) {
			go$pushErr(go$err);
			return (go$sliceType(Go$String)).nil;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var EscapeArg = go$pkg.EscapeArg = function(s) {
		var n, hasSpace, i, _ref, qs, j, _slice, _index, slashes, i$1, _ref$1, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		if (s.length === 0) {
			return "\"\"";
		}
		n = s.length;
		hasSpace = false;
		i = 0;
		while (i < s.length) {
			_ref = s.charCodeAt(i);
			if (_ref === 34 || _ref === 92) {
				n = n + 1 >> 0;
			} else if (_ref === 32 || _ref === 9) {
				hasSpace = true;
			}
			i = i + 1 >> 0;
		}
		if (hasSpace) {
			n = n + 2 >> 0;
		}
		if (n === s.length) {
			return s;
		}
		qs = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
		j = 0;
		if (hasSpace) {
			_slice = qs, _index = j, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 34) : go$throwRuntimeError("index out of range");
			j = j + 1 >> 0;
		}
		slashes = 0;
		i$1 = 0;
		while (i$1 < s.length) {
			_ref$1 = s.charCodeAt(i$1);
			if (_ref$1 === 92) {
				slashes = slashes + 1 >> 0;
				_slice$1 = qs, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = s.charCodeAt(i$1)) : go$throwRuntimeError("index out of range");
			} else if (_ref$1 === 34) {
				while (slashes > 0) {
					_slice$2 = qs, _index$2 = j, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 92) : go$throwRuntimeError("index out of range");
					j = j + 1 >> 0;
					slashes = slashes - 1 >> 0;
				}
				_slice$3 = qs, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = 92) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
				_slice$4 = qs, _index$4 = j, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = s.charCodeAt(i$1)) : go$throwRuntimeError("index out of range");
			} else {
				slashes = 0;
				_slice$5 = qs, _index$5 = j, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = s.charCodeAt(i$1)) : go$throwRuntimeError("index out of range");
			}
			j = j + 1 >> 0;
			i$1 = i$1 + 1 >> 0;
		}
		if (hasSpace) {
			while (slashes > 0) {
				_slice$6 = qs, _index$6 = j, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = 92) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
				slashes = slashes - 1 >> 0;
			}
			_slice$7 = qs, _index$7 = j, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = 34) : go$throwRuntimeError("index out of range");
			j = j + 1 >> 0;
		}
		return go$bytesToString(go$subslice(qs, 0, j));
	};
	var makeCmdLine = function(args) {
		var s, _ref, _i, _slice, _index, v;
		s = "";
		_ref = args;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!(s === "")) {
				s = s + " ";
			}
			s = s + (EscapeArg(v));
			_i++;
		}
		return s;
	};
	var createEnvBlock = function(envv) {
		var v, _slice, _index, _slice$1, _index$1, length, _ref, _i, _slice$2, _index$2, s, b, i, _ref$1, _i$1, _slice$3, _index$3, s$1, l, v$1, _slice$4, _index$4, _slice$5, _index$5;
		if (envv.length === 0) {
			return new (go$ptrType(Go$Uint16))(function() { return (_slice = utf16.Encode(new (go$sliceType(Go$Int32))(go$stringToRunes("\x00\x00"))), _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = utf16.Encode(new (go$sliceType(Go$Int32))(go$stringToRunes("\x00\x00"))), _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
		}
		length = 0;
		_ref = envv;
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice$2 = _ref, _index$2 = _i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			length = length + ((s.length + 1 >> 0)) >> 0;
			_i++;
		}
		length = length + 1 >> 0;
		b = (go$sliceType(Go$Uint8)).make(length, 0, function() { return 0; });
		i = 0;
		_ref$1 = envv;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			s$1 = (_slice$3 = _ref$1, _index$3 = _i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			l = s$1.length;
			go$copySlice(go$subslice(b, i, (i + l >> 0)), new (go$sliceType(Go$Uint8))(go$stringToBytes(s$1)));
			go$copySlice(go$subslice(b, i + l >> 0, ((i + l >> 0) + 1 >> 0)), new (go$sliceType(Go$Uint8))([0]));
			i = (i + l >> 0) + 1 >> 0;
			_i$1++;
		}
		go$copySlice(go$subslice(b, i, (i + 1 >> 0)), new (go$sliceType(Go$Uint8))([0]));
		return new (go$ptrType(Go$Uint16))(function() { return (_slice$4 = utf16.Encode(new (go$sliceType(Go$Int32))(go$stringToRunes(go$bytesToString(b)))), _index$4 = 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")); }, function(v$1) { _slice$5 = utf16.Encode(new (go$sliceType(Go$Int32))(go$stringToRunes(go$bytesToString(b)))), _index$5 = 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = v$1) : go$throwRuntimeError("index out of range"); });
	};
	var CloseOnExec = go$pkg.CloseOnExec = function(fd) {
		SetHandleInformation(fd, 1, 0);
	};
	var SetNonblock = go$pkg.SetNonblock = function(fd, nonblocking) {
		var err;
		err = null;
		err = null;
		return err;
	};
	var getFullPath = function(name) {
		var path, err, _tuple, p, _tuple$1, buf, _tuple$2, v, _slice, _index, _slice$1, _index$1, n, _tuple$3, _tuple$4, v$1, _slice$2, _index$2, _slice$3, _index$3, _tuple$5, _tuple$6, _tuple$7;
		path = "";
		err = null;
		_tuple = UTF16PtrFromString(name), p = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = ["", err], path = _tuple$1[0], err = _tuple$1[1];
			return [path, err];
		}
		buf = (go$sliceType(Go$Uint16)).make(100, 0, function() { return 0; });
		_tuple$2 = GetFullPathName(p, (buf.length >>> 0), new (go$ptrType(Go$Uint16))(function() { return (_slice = buf, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = buf, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), (go$ptrType((go$ptrType(Go$Uint16)))).nil), n = _tuple$2[0], err = _tuple$2[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$3 = ["", err], path = _tuple$3[0], err = _tuple$3[1];
			return [path, err];
		}
		if (n > (buf.length >>> 0)) {
			buf = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
			_tuple$4 = GetFullPathName(p, (buf.length >>> 0), new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = buf, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$1) { _slice$3 = buf, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$1) : go$throwRuntimeError("index out of range"); }), (go$ptrType((go$ptrType(Go$Uint16)))).nil), n = _tuple$4[0], err = _tuple$4[1];
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$5 = ["", err], path = _tuple$5[0], err = _tuple$5[1];
				return [path, err];
			}
			if (n > (buf.length >>> 0)) {
				_tuple$6 = ["", new Errno(536870951)], path = _tuple$6[0], err = _tuple$6[1];
				return [path, err];
			}
		}
		_tuple$7 = [UTF16ToString(go$subslice(buf, 0, n)), null], path = _tuple$7[0], err = _tuple$7[1];
		return [path, err];
	};
	var isSlash = function(c) {
		return (c === 92) || (c === 47);
	};
	var normalizeDir = function(dir) {
		var name, err, _tuple, ndir, _tuple$1, _tuple$2, _tuple$3;
		name = "";
		err = null;
		_tuple = getFullPath(dir), ndir = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = ["", err], name = _tuple$1[0], err = _tuple$1[1];
			return [name, err];
		}
		if (ndir.length > 2 && isSlash(ndir.charCodeAt(0)) && isSlash(ndir.charCodeAt(1))) {
			_tuple$2 = ["", new Errno(536870951)], name = _tuple$2[0], err = _tuple$2[1];
			return [name, err];
		}
		_tuple$3 = [ndir, null], name = _tuple$3[0], err = _tuple$3[1];
		return [name, err];
	};
	var volToUpper = function(ch) {
		if (97 <= ch && ch <= 122) {
			ch = ch + -32 >> 0;
		}
		return ch;
	};
	var joinExeDirAndFName = function(dir, p) {
		var name, err, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, d, err$1, _tuple$5, _tuple$6, _tuple$7, _tuple$8, d$1, err$2, _tuple$9, _tuple$10, _tuple$11, _tuple$12;
		name = "";
		err = null;
		if (p.length === 0) {
			_tuple = ["", new Errno(536870951)], name = _tuple[0], err = _tuple[1];
			return [name, err];
		}
		if (p.length > 2 && isSlash(p.charCodeAt(0)) && isSlash(p.charCodeAt(1))) {
			_tuple$1 = [p, null], name = _tuple$1[0], err = _tuple$1[1];
			return [name, err];
		}
		if (p.length > 1 && (p.charCodeAt(1) === 58)) {
			if (p.length === 2) {
				_tuple$2 = ["", new Errno(536870951)], name = _tuple$2[0], err = _tuple$2[1];
				return [name, err];
			}
			if (isSlash(p.charCodeAt(2))) {
				_tuple$3 = [p, null], name = _tuple$3[0], err = _tuple$3[1];
				return [name, err];
			} else {
				_tuple$4 = normalizeDir(dir), d = _tuple$4[0], err$1 = _tuple$4[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					_tuple$5 = ["", err$1], name = _tuple$5[0], err = _tuple$5[1];
					return [name, err];
				}
				if (volToUpper((p.charCodeAt(0) >> 0)) === volToUpper((d.charCodeAt(0) >> 0))) {
					_tuple$6 = getFullPath(d + "\\" + p.substring(2)), name = _tuple$6[0], err = _tuple$6[1];
					return [name, err];
				} else {
					_tuple$7 = getFullPath(p), name = _tuple$7[0], err = _tuple$7[1];
					return [name, err];
				}
			}
		} else {
			_tuple$8 = normalizeDir(dir), d$1 = _tuple$8[0], err$2 = _tuple$8[1];
			if (!(go$interfaceIsEqual(err$2, null))) {
				_tuple$9 = ["", err$2], name = _tuple$9[0], err = _tuple$9[1];
				return [name, err];
			}
			if (isSlash(p.charCodeAt(0))) {
				_tuple$10 = getFullPath(d$1.substring(0, 2) + p), name = _tuple$10[0], err = _tuple$10[1];
				return [name, err];
			} else {
				_tuple$11 = getFullPath(d$1 + "\\" + p), name = _tuple$11[0], err = _tuple$11[1];
				return [name, err];
			}
		}
		_tuple$12 = ["", new Errno(536870951)], name = _tuple$12[0], err = _tuple$12[1];
		return [name, err];
	};
	var StartProcess = go$pkg.StartProcess = function(argv0, argv, attr) {
		var pid, handle, err, _tuple, sys, _tuple$1, err$1, _tuple$2, _tuple$3, _tuple$4, argv0p, _tuple$5, cmdline, argvp, _tuple$6, _tuple$7, dirp, _tuple$8, _tuple$9, _tuple$10, p, fd, _ref, _i, i, _slice, _index, _slice$1, _index$1, v, _slice$2, _index$2, _slice$3, _index$3, err$2, _tuple$11, _slice$4, _index$4, si, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, pi, flags, _tuple$12, _tuple$13;
		pid = 0;
		handle = 0;
		err = null;
		var go$deferred = [];
		try {
			if (argv0.length === 0) {
				_tuple = [0, 0, new Errno(536871042)], pid = _tuple[0], handle = _tuple[1], err = _tuple[2];
				return [pid, handle, err];
			}
			if (attr === (go$ptrType(ProcAttr)).nil) {
				attr = zeroProcAttr;
			}
			sys = attr.Sys;
			if (sys === (go$ptrType(SysProcAttr)).nil) {
				sys = zeroSysProcAttr;
			}
			if (attr.Files.length > 3) {
				_tuple$1 = [0, 0, new Errno(536871042)], pid = _tuple$1[0], handle = _tuple$1[1], err = _tuple$1[2];
				return [pid, handle, err];
			}
			if (!((attr.Dir.length === 0))) {
				err$1 = null;
				_tuple$2 = joinExeDirAndFName(attr.Dir, argv0), argv0 = _tuple$2[0], err$1 = _tuple$2[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					_tuple$3 = [0, 0, err$1], pid = _tuple$3[0], handle = _tuple$3[1], err = _tuple$3[2];
					return [pid, handle, err];
				}
			}
			_tuple$4 = UTF16PtrFromString(argv0), argv0p = _tuple$4[0], err = _tuple$4[1];
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$5 = [0, 0, err], pid = _tuple$5[0], handle = _tuple$5[1], err = _tuple$5[2];
				return [pid, handle, err];
			}
			cmdline = "";
			if (!(sys.CmdLine === "")) {
				cmdline = sys.CmdLine;
			} else {
				cmdline = makeCmdLine(argv);
			}
			argvp = (go$ptrType(Go$Uint16)).nil;
			if (!((cmdline.length === 0))) {
				_tuple$6 = UTF16PtrFromString(cmdline), argvp = _tuple$6[0], err = _tuple$6[1];
				if (!(go$interfaceIsEqual(err, null))) {
					_tuple$7 = [0, 0, err], pid = _tuple$7[0], handle = _tuple$7[1], err = _tuple$7[2];
					return [pid, handle, err];
				}
			}
			dirp = (go$ptrType(Go$Uint16)).nil;
			if (!((attr.Dir.length === 0))) {
				_tuple$8 = UTF16PtrFromString(attr.Dir), dirp = _tuple$8[0], err = _tuple$8[1];
				if (!(go$interfaceIsEqual(err, null))) {
					_tuple$9 = [0, 0, err], pid = _tuple$9[0], handle = _tuple$9[1], err = _tuple$9[2];
					return [pid, handle, err];
				}
			}
			go$pkg.ForkLock.Lock();
			go$deferred.push({ recv: go$pkg.ForkLock, method: "Unlock", args: [] });
			_tuple$10 = GetCurrentProcess(), p = _tuple$10[0];
			fd = (go$sliceType(Handle)).make(attr.Files.length, 0, function() { return 0; });
			_ref = attr.Files;
			_i = 0;
			while (_i < _ref.length) {
				i = _i;
				if ((_slice = attr.Files, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) > 0) {
					err$2 = DuplicateHandle(p, ((_slice$1 = attr.Files, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >>> 0), p, new (go$ptrType(Handle))(function() { return (_slice$2 = fd, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$3 = fd, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v) : go$throwRuntimeError("index out of range"); }), 0, true, 2);
					if (!(go$interfaceIsEqual(err$2, null))) {
						_tuple$11 = [0, 0, err$2], pid = _tuple$11[0], handle = _tuple$11[1], err = _tuple$11[2];
						return [pid, handle, err];
					}
					go$deferred.push({ fun: CloseHandle, args: [(_slice$4 = fd, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"))] });
				}
				_i++;
			}
			si = new StartupInfo.Ptr();
			si.Cb = 68;
			si.Flags = 256;
			if (sys.HideWindow) {
				si.Flags = (si.Flags | 1) >>> 0;
				si.ShowWindow = 0;
			}
			si.StdInput = (_slice$5 = fd, _index$5 = 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
			si.StdOutput = (_slice$6 = fd, _index$6 = 1, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range"));
			si.StdErr = (_slice$7 = fd, _index$7 = 2, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range"));
			pi = new ProcessInformation.Ptr();
			flags = (sys.CreationFlags | 1024) >>> 0;
			err = CreateProcess(argv0p, argvp, (go$ptrType(SecurityAttributes)).nil, (go$ptrType(SecurityAttributes)).nil, true, flags, createEnvBlock(attr.Env), dirp, si, pi);
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$12 = [0, 0, err], pid = _tuple$12[0], handle = _tuple$12[1], err = _tuple$12[2];
				return [pid, handle, err];
			}
			go$deferred.push({ fun: CloseHandle, args: [pi.Thread] });
			_tuple$13 = [(pi.ProcessId >> 0), (pi.Process >>> 0), null], pid = _tuple$13[0], handle = _tuple$13[1], err = _tuple$13[2];
			return [pid, handle, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [pid, handle, err];
		}
	};
	var Exec = go$pkg.Exec = function(argv0, argv, envv) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var raceAcquire = function(addr) {
	};
	var raceReleaseMerge = function(addr) {
	};
	var raceReadRange = function(addr, len) {
	};
	var raceWriteRange = function(addr, len) {
	};
	var TranslateAccountName = go$pkg.TranslateAccountName = function(username, from, to, initSize) {
		var _tuple, u, e, b, n, v, _slice, _index, _slice$1, _index$1, v$1, v$2, _slice$2, _index$2, _slice$3, _index$3, v$3;
		_tuple = UTF16PtrFromString(username), u = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			return ["", e];
		}
		b = (go$sliceType(Go$Uint16)).make(50, 0, function() { return 0; });
		n = (b.length >>> 0);
		e = TranslateName(u, from, to, new (go$ptrType(Go$Uint16))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; }));
		if (!(go$interfaceIsEqual(e, null))) {
			if (!(go$interfaceIsEqual(e, new Errno(122)))) {
				return ["", e];
			}
			b = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
			e = TranslateName(u, from, to, new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = b, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$2) { _slice$3 = b, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$2) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$3) { n = v$3; }));
			if (!(go$interfaceIsEqual(e, null))) {
				return ["", e];
			}
		}
		return [UTF16ToString(b), null];
	};
	var StringToSid = go$pkg.StringToSid = function(s) {
		var sid, _tuple, p, e, v, _array, _struct, _view;
		var go$deferred = [];
		try {
			sid = (go$ptrType(SID)).nil;
			_tuple = UTF16PtrFromString(s), p = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				return [(go$ptrType(SID)).nil, e];
			}
			e = ConvertStringSidToSid(p, new (go$ptrType((go$ptrType(SID))))(function() { return sid; }, function(v) { sid = v; }));
			if (!(go$interfaceIsEqual(e, null))) {
				return [(go$ptrType(SID)).nil, e];
			}
			_array = new Uint8Array(0);
			go$deferred.push({ fun: LocalFree, args: [_array] });
			_struct = sid, _view = new DataView(_array.buffer, _array.byteOffset);
			return sid.Copy();
		} catch(go$err) {
			go$pushErr(go$err);
			return [(go$ptrType(SID)).nil, null];
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var LookupSID = go$pkg.LookupSID = function(system, account) {
		var sid, domain, accType, err, _tuple, _tuple$1, acc, e, _tuple$2, sys, _tuple$3, _tuple$4, db, dn, b, n, _array, _struct, _view, v, v$1, _slice, _index, _slice$1, _index$1, v$2, v$3, _tuple$5, _array$1, _struct$1, _view$1, v$4, v$5, _slice$2, _index$2, _slice$3, _index$3, v$6, v$7, _tuple$6, _tuple$7;
		sid = (go$ptrType(SID)).nil;
		domain = "";
		accType = 0;
		err = null;
		if (account.length === 0) {
			_tuple = [(go$ptrType(SID)).nil, "", 0, new Errno(536870951)], sid = _tuple[0], domain = _tuple[1], accType = _tuple[2], err = _tuple[3];
			return [sid, domain, accType, err];
		}
		_tuple$1 = UTF16PtrFromString(account), acc = _tuple$1[0], e = _tuple$1[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$2 = [(go$ptrType(SID)).nil, "", 0, e], sid = _tuple$2[0], domain = _tuple$2[1], accType = _tuple$2[2], err = _tuple$2[3];
			return [sid, domain, accType, err];
		}
		sys = (go$ptrType(Go$Uint16)).nil;
		if (system.length > 0) {
			_tuple$3 = UTF16PtrFromString(system), sys = _tuple$3[0], e = _tuple$3[1];
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$4 = [(go$ptrType(SID)).nil, "", 0, e], sid = _tuple$4[0], domain = _tuple$4[1], accType = _tuple$4[2], err = _tuple$4[3];
				return [sid, domain, accType, err];
			}
		}
		db = (go$sliceType(Go$Uint16)).make(50, 0, function() { return 0; });
		dn = (db.length >>> 0);
		b = (go$sliceType(Go$Uint8)).make(50, 0, function() { return 0; });
		n = (b.length >>> 0);
		sid = (_array = go$sliceToArray(b), _struct = new SID.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct);
		e = LookupAccountName(sys, acc, sid, new (go$ptrType(Go$Uint32))(function() { return n; }, function(v) { n = v; }), new (go$ptrType(Go$Uint16))(function() { return (_slice = db, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v$1) { _slice$1 = db, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v$1) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return dn; }, function(v$2) { dn = v$2; }), new (go$ptrType(Go$Uint32))(function() { return accType; }, function(v$3) { accType = v$3; }));
		if (!(go$interfaceIsEqual(e, null))) {
			if (!(go$interfaceIsEqual(e, new Errno(122)))) {
				_tuple$5 = [(go$ptrType(SID)).nil, "", 0, e], sid = _tuple$5[0], domain = _tuple$5[1], accType = _tuple$5[2], err = _tuple$5[3];
				return [sid, domain, accType, err];
			}
			b = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
			sid = (_array$1 = go$sliceToArray(b), _struct$1 = new SID.Ptr(), _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1);
			db = (go$sliceType(Go$Uint16)).make(dn, 0, function() { return 0; });
			e = LookupAccountName(sys, acc, sid, new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$4) { n = v$4; }), new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = db, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$5) { _slice$3 = db, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$5) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return dn; }, function(v$6) { dn = v$6; }), new (go$ptrType(Go$Uint32))(function() { return accType; }, function(v$7) { accType = v$7; }));
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$6 = [(go$ptrType(SID)).nil, "", 0, e], sid = _tuple$6[0], domain = _tuple$6[1], accType = _tuple$6[2], err = _tuple$6[3];
				return [sid, domain, accType, err];
			}
		}
		_tuple$7 = [sid, UTF16ToString(db), accType, null], sid = _tuple$7[0], domain = _tuple$7[1], accType = _tuple$7[2], err = _tuple$7[3];
		return [sid, domain, accType, err];
	};
	SID.Ptr.prototype.String = function() {
		var sid, s, v, e;
		var go$deferred = [];
		try {
			sid = this;
			s = (go$ptrType(Go$Uint16)).nil;
			e = ConvertSidToStringSid(sid, new (go$ptrType((go$ptrType(Go$Uint16))))(function() { return s; }, function(v) { s = v; }));
			if (!(go$interfaceIsEqual(e, null))) {
				return ["", e];
			}
			go$deferred.push({ fun: LocalFree, args: [s] });
			return [UTF16ToString(new (go$sliceType(Go$Uint16))(s)), null];
		} catch(go$err) {
			go$pushErr(go$err);
			return ["", null];
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	SID.prototype.String = function() { return this.go$val.String(); };
	SID.Ptr.prototype.Len = function() {
		var sid;
		sid = this;
		return (GetLengthSid(sid) >> 0);
	};
	SID.prototype.Len = function() { return this.go$val.Len(); };
	SID.Ptr.prototype.Copy = function() {
		var sid, b, _array, _struct, _view, sid2, e;
		sid = this;
		b = (go$sliceType(Go$Uint8)).make(sid.Len(), 0, function() { return 0; });
		sid2 = (_array = go$sliceToArray(b), _struct = new SID.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct);
		e = CopySid((b.length >>> 0), sid2, sid);
		if (!(go$interfaceIsEqual(e, null))) {
			return [(go$ptrType(SID)).nil, e];
		}
		return [sid2, null];
	};
	SID.prototype.Copy = function() { return this.go$val.Copy(); };
	SID.Ptr.prototype.LookupAccount = function(system) {
		var account, domain, accType, err, sid, sys, _tuple, _tuple$1, b, n, db, dn, v, _slice, _index, _slice$1, _index$1, v$1, v$2, _slice$2, _index$2, _slice$3, _index$3, v$3, v$4, e, _tuple$2, v$5, _slice$4, _index$4, _slice$5, _index$5, v$6, v$7, _slice$6, _index$6, _slice$7, _index$7, v$8, v$9, _tuple$3, _tuple$4;
		account = "";
		domain = "";
		accType = 0;
		err = null;
		sid = this;
		sys = (go$ptrType(Go$Uint16)).nil;
		if (system.length > 0) {
			_tuple = UTF16PtrFromString(system), sys = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$1 = ["", "", 0, err], account = _tuple$1[0], domain = _tuple$1[1], accType = _tuple$1[2], err = _tuple$1[3];
				return [account, domain, accType, err];
			}
		}
		b = (go$sliceType(Go$Uint16)).make(50, 0, function() { return 0; });
		n = (b.length >>> 0);
		db = (go$sliceType(Go$Uint16)).make(50, 0, function() { return 0; });
		dn = (db.length >>> 0);
		e = LookupAccountSid(sys, sid, new (go$ptrType(Go$Uint16))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; }), new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = db, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$2) { _slice$3 = db, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$2) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return dn; }, function(v$3) { dn = v$3; }), new (go$ptrType(Go$Uint32))(function() { return accType; }, function(v$4) { accType = v$4; }));
		if (!(go$interfaceIsEqual(e, null))) {
			if (!(go$interfaceIsEqual(e, new Errno(122)))) {
				_tuple$2 = ["", "", 0, e], account = _tuple$2[0], domain = _tuple$2[1], accType = _tuple$2[2], err = _tuple$2[3];
				return [account, domain, accType, err];
			}
			b = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
			db = (go$sliceType(Go$Uint16)).make(dn, 0, function() { return 0; });
			e = LookupAccountSid((go$ptrType(Go$Uint16)).nil, sid, new (go$ptrType(Go$Uint16))(function() { return (_slice$4 = b, _index$4 = 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")); }, function(v$5) { _slice$5 = b, _index$5 = 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = v$5) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$6) { n = v$6; }), new (go$ptrType(Go$Uint16))(function() { return (_slice$6 = db, _index$6 = 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")); }, function(v$7) { _slice$7 = db, _index$7 = 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = v$7) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return dn; }, function(v$8) { dn = v$8; }), new (go$ptrType(Go$Uint32))(function() { return accType; }, function(v$9) { accType = v$9; }));
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$3 = ["", "", 0, e], account = _tuple$3[0], domain = _tuple$3[1], accType = _tuple$3[2], err = _tuple$3[3];
				return [account, domain, accType, err];
			}
		}
		_tuple$4 = [UTF16ToString(b), UTF16ToString(db), accType, null], account = _tuple$4[0], domain = _tuple$4[1], accType = _tuple$4[2], err = _tuple$4[3];
		return [account, domain, accType, err];
	};
	SID.prototype.LookupAccount = function(system) { return this.go$val.LookupAccount(system); };
	var OpenCurrentProcessToken = go$pkg.OpenCurrentProcessToken = function() {
		var _tuple, p, e, t, v;
		_tuple = GetCurrentProcess(), p = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			return [0, e];
		}
		t = 0;
		e = OpenProcessToken(p, 8, new (go$ptrType(Token))(function() { return t; }, function(v) { t = v; }));
		if (!(go$interfaceIsEqual(e, null))) {
			return [0, e];
		}
		return [t, null];
	};
	Token.prototype.Close = function() {
		var t;
		t = this.go$val;
		return CloseHandle((t >>> 0));
	};
	go$ptrType(Token).prototype.Close = function() { return new Token(this.go$get()).Close(); };
	Token.prototype.getInfo = function(class$1, initSize) {
		var t, b, n, v, _slice, _index, _slice$1, _index$1, v$1, e, v$2, _slice$2, _index$2, _slice$3, _index$3, v$3;
		t = this.go$val;
		b = (go$sliceType(Go$Uint8)).make(initSize, 0, function() { return 0; });
		n = 0;
		e = GetTokenInformation(t, class$1, new (go$ptrType(Go$Uint8))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), (b.length >>> 0), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; }));
		if (!(go$interfaceIsEqual(e, null))) {
			if (!(go$interfaceIsEqual(e, new Errno(122)))) {
				return [0, e];
			}
			b = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
			e = GetTokenInformation(t, class$1, new (go$ptrType(Go$Uint8))(function() { return (_slice$2 = b, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$2) { _slice$3 = b, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$2) : go$throwRuntimeError("index out of range"); }), (b.length >>> 0), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$3) { n = v$3; }));
			if (!(go$interfaceIsEqual(e, null))) {
				return [0, e];
			}
		}
		return [go$sliceToArray(b), null];
	};
	go$ptrType(Token).prototype.getInfo = function(class$1, initSize) { return new Token(this.go$get()).getInfo(class$1, initSize); };
	Token.prototype.GetTokenUser = function() {
		var t, _tuple, i, e, _array, _struct, _view;
		t = this.go$val;
		_tuple = (new Token(t)).getInfo(1, 50), i = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			return [(go$ptrType(Tokenuser)).nil, e];
		}
		return [(_array = i, _struct = new Tokenuser.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct.User.Attributes = _view.getUint32(4, true), _struct), null];
	};
	go$ptrType(Token).prototype.GetTokenUser = function() { return new Token(this.go$get()).GetTokenUser(); };
	Token.prototype.GetTokenPrimaryGroup = function() {
		var t, _tuple, i, e, _array, _struct, _view;
		t = this.go$val;
		_tuple = (new Token(t)).getInfo(5, 50), i = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			return [(go$ptrType(Tokenprimarygroup)).nil, e];
		}
		return [(_array = i, _struct = new Tokenprimarygroup.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct), null];
	};
	go$ptrType(Token).prototype.GetTokenPrimaryGroup = function() { return new Token(this.go$get()).GetTokenPrimaryGroup(); };
	Token.prototype.GetUserProfileDirectory = function() {
		var t, b, n, v, _slice, _index, _slice$1, _index$1, v$1, e, v$2, _slice$2, _index$2, _slice$3, _index$3, v$3;
		t = this.go$val;
		b = (go$sliceType(Go$Uint16)).make(100, 0, function() { return 0; });
		n = (b.length >>> 0);
		e = GetUserProfileDirectory(t, new (go$ptrType(Go$Uint16))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; }));
		if (!(go$interfaceIsEqual(e, null))) {
			if (!(go$interfaceIsEqual(e, new Errno(122)))) {
				return ["", e];
			}
			b = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
			e = GetUserProfileDirectory(t, new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = b, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$2) { _slice$3 = b, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$2) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$3) { n = v$3; }));
			if (!(go$interfaceIsEqual(e, null))) {
				return ["", e];
			}
		}
		return [UTF16ToString(b), null];
	};
	go$ptrType(Token).prototype.GetUserProfileDirectory = function() { return new Token(this.go$get()).GetUserProfileDirectory(); };
	var itoa = function(val) {
		var buf, i, _r, _q;
		if (val < 0) {
			return "-" + itoa(-val);
		}
		buf = go$makeNativeArray("Uint8", 32, function() { return 0; });
		i = 31;
		while (val >= 10) {
			buf[i] = (((_r = val % 10, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) + 48 >> 0) << 24 >>> 24);
			i = i - 1 >> 0;
			val = (_q = val / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		}
		buf[i] = ((val + 48 >> 0) << 24 >>> 24);
		return go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(buf), i));
	};
	var StringByteSlice = go$pkg.StringByteSlice = function(s) {
		var _tuple, a, err;
		_tuple = ByteSliceFromString(s), a = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			throw go$panic(new Go$String("syscall: string with NUL passed to StringByteSlice"));
		}
		return a;
	};
	var ByteSliceFromString = go$pkg.ByteSliceFromString = function(s) {
		var i, a;
		i = 0;
		while (i < s.length) {
			if (s.charCodeAt(i) === 0) {
				return [(go$sliceType(Go$Uint8)).nil, new Errno(536870951)];
			}
			i = i + 1 >> 0;
		}
		a = (go$sliceType(Go$Uint8)).make(s.length + 1 >> 0, 0, function() { return 0; });
		go$copyString(a, s);
		return [a, null];
	};
	var StringBytePtr = go$pkg.StringBytePtr = function(s) {
		var v, _slice, _index, _slice$1, _index$1;
		return new (go$ptrType(Go$Uint8))(function() { return (_slice = StringByteSlice(s), _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = StringByteSlice(s), _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
	};
	var BytePtrFromString = go$pkg.BytePtrFromString = function(s) {
		var _tuple, a, err, v, _slice, _index, _slice$1, _index$1;
		_tuple = ByteSliceFromString(s), a = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$ptrType(Go$Uint8)).nil, err];
		}
		return [new (go$ptrType(Go$Uint8))(function() { return (_slice = a, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = a, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), null];
	};
	Timespec.Ptr.prototype.Unix = function() {
		var sec, nsec, ts, _tuple;
		sec = new Go$Int64(0, 0);
		nsec = new Go$Int64(0, 0);
		ts = this;
		_tuple = [ts.Sec, ts.Nsec], sec = _tuple[0], nsec = _tuple[1];
		return [sec, nsec];
	};
	Timespec.prototype.Unix = function() { return this.go$val.Unix(); };
	Timeval.Ptr.prototype.Unix = function() {
		var sec, nsec, tv, _tuple;
		sec = new Go$Int64(0, 0);
		nsec = new Go$Int64(0, 0);
		tv = this;
		_tuple = [new Go$Int64(0, tv.Sec), go$mul64(new Go$Int64(0, tv.Usec), new Go$Int64(0, 1000))], sec = _tuple[0], nsec = _tuple[1];
		return [sec, nsec];
	};
	Timeval.prototype.Unix = function() { return this.go$val.Unix(); };
	Timespec.Ptr.prototype.Nano = function() {
		var ts, x, x$1;
		ts = this;
		return (x = go$mul64(ts.Sec, new Go$Int64(0, 1000000000)), x$1 = ts.Nsec, new Go$Int64(x.high + x$1.high, x.low + x$1.low));
	};
	Timespec.prototype.Nano = function() { return this.go$val.Nano(); };
	Timeval.Ptr.prototype.Nano = function() {
		var tv, x, x$1;
		tv = this;
		return (x = go$mul64(new Go$Int64(0, tv.Sec), new Go$Int64(0, 1000000000)), x$1 = go$mul64(new Go$Int64(0, tv.Usec), new Go$Int64(0, 1000)), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
	};
	Timeval.prototype.Nano = function() { return this.go$val.Nano(); };
	var StringToUTF16 = go$pkg.StringToUTF16 = function(s) {
		var _tuple, a, err;
		_tuple = UTF16FromString(s), a = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			throw go$panic(new Go$String("syscall: string with NUL passed to StringToUTF16"));
		}
		return a;
	};
	var UTF16FromString = go$pkg.UTF16FromString = function(s) {
		var i;
		i = 0;
		while (i < s.length) {
			if (s.charCodeAt(i) === 0) {
				return [(go$sliceType(Go$Uint16)).nil, new Errno(536870951)];
			}
			i = i + 1 >> 0;
		}
		return [utf16.Encode(new (go$sliceType(Go$Int32))(go$stringToRunes(s + "\x00"))), null];
	};
	var UTF16ToString = go$pkg.UTF16ToString = function(s) {
		var _ref, _i, _slice, _index, v, i;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (v === 0) {
				s = go$subslice(s, 0, i);
				break;
			}
			_i++;
		}
		return go$runesToString(utf16.Decode(s));
	};
	var StringToUTF16Ptr = go$pkg.StringToUTF16Ptr = function(s) {
		var v, _slice, _index, _slice$1, _index$1;
		return new (go$ptrType(Go$Uint16))(function() { return (_slice = StringToUTF16(s), _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = StringToUTF16(s), _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
	};
	var UTF16PtrFromString = go$pkg.UTF16PtrFromString = function(s) {
		var _tuple, a, err, v, _slice, _index, _slice$1, _index$1;
		_tuple = UTF16FromString(s), a = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$ptrType(Go$Uint16)).nil, err];
		}
		return [new (go$ptrType(Go$Uint16))(function() { return (_slice = a, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = a, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), null];
	};
	var Getpagesize = go$pkg.Getpagesize = function() {
		return 4096;
	};
	var langid = function(pri, sub) {
		return (((sub >>> 0) << 10 >>> 0) | (pri >>> 0)) >>> 0;
	};
	Errno.prototype.Error = function() {
		var e, idx, flags, b, _tuple, n, err, _tuple$1, _slice, _index, _slice$1, _index$1;
		e = this.go$val;
		idx = ((e - 536870912 >>> 0) >> 0);
		if (0 <= idx && idx < 131) {
			return errors[idx];
		}
		flags = 12800;
		b = (go$sliceType(Go$Uint16)).make(300, 0, function() { return 0; });
		_tuple = FormatMessage(flags, 0, (e >>> 0), langid(9, 1), b, (go$ptrType(Go$Uint8)).nil), n = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = FormatMessage(flags, 0, (e >>> 0), 0, b, (go$ptrType(Go$Uint8)).nil), n = _tuple$1[0], err = _tuple$1[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return "winapi error #" + itoa((e >> 0));
			}
		}
		while (n > 0 && (((_slice = b, _index = (n - 1 >>> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 10) || ((_slice$1 = b, _index$1 = (n - 1 >>> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 13))) {
			n = n - 1 >>> 0;
		}
		return go$runesToString(utf16.Decode(go$subslice(b, 0, n)));
	};
	go$ptrType(Errno).prototype.Error = function() { return new Errno(this.go$get()).Error(); };
	Errno.prototype.Temporary = function() {
		var e;
		e = this.go$val;
		return (e === 536870950) || (e === 536870971) || (new Errno(e)).Timeout();
	};
	go$ptrType(Errno).prototype.Temporary = function() { return new Errno(this.go$get()).Temporary(); };
	Errno.prototype.Timeout = function() {
		var e;
		e = this.go$val;
		return (e === 536870918) || (e === 536871039) || (e === 536871033);
	};
	go$ptrType(Errno).prototype.Timeout = function() { return new Errno(this.go$get()).Timeout(); };
	var NewCallback = go$pkg.NewCallback = function(fn) {
		throw go$panic("Native function not implemented: NewCallback");
	};
	var Exit = go$pkg.Exit = function(code) {
		ExitProcess((code >>> 0));
	};
	var makeInheritSa = function() {
		var sa;
		sa = new SecurityAttributes.Ptr();
		sa.Length = 12;
		sa.InheritHandle = 1;
		return sa;
	};
	var Open = go$pkg.Open = function(path, mode, perm) {
		var fd, err, _tuple, _tuple$1, pathp, _tuple$2, access, _ref, sharemode, sa, createmode, _tuple$3, h, e, _tuple$4;
		fd = 0;
		err = null;
		if (path.length === 0) {
			_tuple = [4294967295, new Errno(2)], fd = _tuple[0], err = _tuple[1];
			return [fd, err];
		}
		_tuple$1 = UTF16PtrFromString(path), pathp = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$2 = [4294967295, err], fd = _tuple$2[0], err = _tuple$2[1];
			return [fd, err];
		}
		access = 0;
		_ref = mode & 3;
		if (_ref === 0) {
			access = 2147483648;
		} else if (_ref === 1) {
			access = 1073741824;
		} else if (_ref === 2) {
			access = 3221225472;
		}
		if (!(((mode & 64) === 0))) {
			access = (access | 1073741824) >>> 0;
		}
		if (!(((mode & 1024) === 0))) {
			access = access & ~1073741824;
			access = (access | 4) >>> 0;
		}
		sharemode = 3;
		sa = (go$ptrType(SecurityAttributes)).nil;
		if ((mode & 524288) === 0) {
			sa = makeInheritSa();
		}
		createmode = 0;
		if ((mode & 192) === 192) {
			createmode = 1;
		} else if ((mode & 576) === 576) {
			createmode = 2;
		} else if ((mode & 64) === 64) {
			createmode = 4;
		} else if ((mode & 512) === 512) {
			createmode = 5;
		} else {
			createmode = 3;
		}
		_tuple$3 = CreateFile(pathp, access, sharemode, sa, createmode, 128, 0), h = _tuple$3[0], e = _tuple$3[1];
		_tuple$4 = [h, e], fd = _tuple$4[0], err = _tuple$4[1];
		return [fd, err];
	};
	var Read = go$pkg.Read = function(fd, p) {
		var n, err, done, v, e, _tuple, _tuple$1, _tuple$2;
		n = 0;
		err = null;
		done = 0;
		e = ReadFile(fd, p, new (go$ptrType(Go$Uint32))(function() { return done; }, function(v) { done = v; }), (go$ptrType(Overlapped)).nil);
		if (!(go$interfaceIsEqual(e, null))) {
			if (go$interfaceIsEqual(e, new Errno(109))) {
				_tuple = [0, null], n = _tuple[0], err = _tuple[1];
				return [n, err];
			}
			_tuple$1 = [0, e], n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		}
		_tuple$2 = [(done >> 0), null], n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	var Write = go$pkg.Write = function(fd, p) {
		var n, err, done, v, e, _tuple, _tuple$1;
		n = 0;
		err = null;
		done = 0;
		e = WriteFile(fd, p, new (go$ptrType(Go$Uint32))(function() { return done; }, function(v) { done = v; }), (go$ptrType(Overlapped)).nil);
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple = [0, e], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		_tuple$1 = [(done >> 0), null], n = _tuple$1[0], err = _tuple$1[1];
		return [n, err];
	};
	var Seek = go$pkg.Seek = function(fd, offset, whence) {
		var newoffset, err, w, _ref, x, hi, lo, _tuple, ft, _tuple$1, _tuple$2, v, rlo, e, _tuple$3, x$1, x$2, _tuple$4;
		newoffset = new Go$Int64(0, 0);
		err = null;
		w = 0;
		_ref = whence;
		if (_ref === 0) {
			w = 0;
		} else if (_ref === 1) {
			w = 1;
		} else if (_ref === 2) {
			w = 2;
		}
		hi = ((x = go$shiftRightInt64(offset, 32), x.low + ((x.high >> 31) * 4294967296)) >> 0);
		lo = ((offset.low + ((offset.high >> 31) * 4294967296)) >> 0);
		_tuple = GetFileType(fd), ft = _tuple[0];
		if (ft === 3) {
			_tuple$1 = [new Go$Int64(0, 0), new Errno(536871015)], newoffset = _tuple$1[0], err = _tuple$1[1];
			return [newoffset, err];
		}
		_tuple$2 = SetFilePointer(fd, lo, new (go$ptrType(Go$Int32))(function() { return hi; }, function(v) { hi = v; }), w), rlo = _tuple$2[0], e = _tuple$2[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$3 = [new Go$Int64(0, 0), e], newoffset = _tuple$3[0], err = _tuple$3[1];
			return [newoffset, err];
		}
		_tuple$4 = [(x$1 = go$shiftLeft64(new Go$Int64(0, hi), 32), x$2 = new Go$Int64(0, rlo), new Go$Int64(x$1.high + x$2.high, x$1.low + x$2.low)), null], newoffset = _tuple$4[0], err = _tuple$4[1];
		return [newoffset, err];
	};
	var Close = go$pkg.Close = function(fd) {
		var err;
		err = null;
		err = CloseHandle(fd);
		return err;
	};
	var getStdHandle = function(h) {
		var fd, _tuple, r;
		fd = 0;
		_tuple = GetStdHandle(h), r = _tuple[0];
		CloseOnExec(r);
		fd = r;
		return fd;
	};
	var Getwd = go$pkg.Getwd = function() {
		var wd, err, b, _tuple, v, _slice, _index, _slice$1, _index$1, n, e, _tuple$1, _tuple$2;
		wd = "";
		err = null;
		b = (go$sliceType(Go$Uint16)).make(300, 0, function() { return 0; });
		_tuple = GetCurrentDirectory((b.length >>> 0), new (go$ptrType(Go$Uint16))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); })), n = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$1 = ["", e], wd = _tuple$1[0], err = _tuple$1[1];
			return [wd, err];
		}
		_tuple$2 = [go$runesToString(utf16.Decode(go$subslice(b, 0, n))), null], wd = _tuple$2[0], err = _tuple$2[1];
		return [wd, err];
	};
	var Chdir = go$pkg.Chdir = function(path) {
		var err, _tuple, pathp;
		err = null;
		_tuple = UTF16PtrFromString(path), pathp = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = SetCurrentDirectory(pathp);
		return err;
	};
	var Mkdir = go$pkg.Mkdir = function(path, mode) {
		var err, _tuple, pathp;
		err = null;
		_tuple = UTF16PtrFromString(path), pathp = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = CreateDirectory(pathp, (go$ptrType(SecurityAttributes)).nil);
		return err;
	};
	var Rmdir = go$pkg.Rmdir = function(path) {
		var err, _tuple, pathp;
		err = null;
		_tuple = UTF16PtrFromString(path), pathp = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = RemoveDirectory(pathp);
		return err;
	};
	var Unlink = go$pkg.Unlink = function(path) {
		var err, _tuple, pathp;
		err = null;
		_tuple = UTF16PtrFromString(path), pathp = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = DeleteFile(pathp);
		return err;
	};
	var Rename = go$pkg.Rename = function(oldpath, newpath) {
		var err, _tuple, from, _tuple$1, to;
		err = null;
		_tuple = UTF16PtrFromString(oldpath), from = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		_tuple$1 = UTF16PtrFromString(newpath), to = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = MoveFile(from, to);
		return err;
	};
	var ComputerName = go$pkg.ComputerName = function() {
		var name, err, n, b, v, _slice, _index, _slice$1, _index$1, v$1, e, _tuple, _tuple$1;
		name = "";
		err = null;
		n = 16;
		b = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
		e = GetComputerName(new (go$ptrType(Go$Uint16))(function() { return (_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = b, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; }));
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple = ["", e], name = _tuple[0], err = _tuple[1];
			return [name, err];
		}
		_tuple$1 = [go$runesToString(utf16.Decode(go$subslice(b, 0, n))), null], name = _tuple$1[0], err = _tuple$1[1];
		return [name, err];
	};
	var Ftruncate = go$pkg.Ftruncate = function(fd, length) {
		var err, _tuple, curoffset, e, _tuple$1;
		err = null;
		var go$deferred = [];
		try {
			_tuple = Seek(fd, new Go$Int64(0, 0), 1), curoffset = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			go$deferred.push({ fun: Seek, args: [fd, curoffset, 0] });
			_tuple$1 = Seek(fd, length, 0), e = _tuple$1[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			e = SetEndOfFile(fd);
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			err = null;
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	var Gettimeofday = go$pkg.Gettimeofday = function(tv) {
		var err, ft, _struct, l, r;
		err = null;
		ft = new Filetime.Ptr();
		GetSystemTimeAsFileTime(ft);
		l = tv, r = (_struct = NsecToTimeval(ft.Nanoseconds()), new Timeval.Ptr(_struct.Sec, _struct.Usec)), l.Sec = r.Sec, l.Usec = r.Usec;
		err = null;
		return err;
	};
	var Pipe = go$pkg.Pipe = function(p) {
		var err, _tuple, r, w, v, v$1, e, _slice, _index, _slice$1, _index$1;
		err = null;
		if (!((p.length === 2))) {
			err = new Errno(536870951);
			return err;
		}
		_tuple = [0, 0], r = _tuple[0], w = _tuple[1];
		e = CreatePipe(new (go$ptrType(Handle))(function() { return r; }, function(v) { r = v; }), new (go$ptrType(Handle))(function() { return w; }, function(v$1) { w = v$1; }), makeInheritSa(), 0);
		if (!(go$interfaceIsEqual(e, null))) {
			err = e;
			return err;
		}
		_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = r) : go$throwRuntimeError("index out of range");
		_slice$1 = p, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = w) : go$throwRuntimeError("index out of range");
		err = null;
		return err;
	};
	var Utimes = go$pkg.Utimes = function(path, tv) {
		var err, _tuple, pathp, e, _tuple$1, h, _slice, _index, _struct, a, _slice$1, _index$1, _struct$1, w;
		err = null;
		var go$deferred = [];
		try {
			if (!((tv.length === 2))) {
				err = new Errno(536870951);
				return err;
			}
			_tuple = UTF16PtrFromString(path), pathp = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			_tuple$1 = CreateFile(pathp, 256, 2, (go$ptrType(SecurityAttributes)).nil, 3, 128, 0), h = _tuple$1[0], e = _tuple$1[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			go$deferred.push({ fun: Close, args: [h] });
			a = (_struct = NsecToFiletime((_slice = tv, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Nanoseconds()), new Filetime.Ptr(_struct.LowDateTime, _struct.HighDateTime));
			w = (_struct$1 = NsecToFiletime((_slice$1 = tv, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Nanoseconds()), new Filetime.Ptr(_struct$1.LowDateTime, _struct$1.HighDateTime));
			err = SetFileTime(h, (go$ptrType(Filetime)).nil, a, w);
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	var UtimesNano = go$pkg.UtimesNano = function(path, ts) {
		var err, _tuple, pathp, e, _tuple$1, h, _slice, _index, _struct, _struct$1, a, _slice$1, _index$1, _struct$2, _struct$3, w;
		err = null;
		var go$deferred = [];
		try {
			if (!((ts.length === 2))) {
				err = new Errno(536870951);
				return err;
			}
			_tuple = UTF16PtrFromString(path), pathp = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			_tuple$1 = CreateFile(pathp, 256, 2, (go$ptrType(SecurityAttributes)).nil, 3, 128, 0), h = _tuple$1[0], e = _tuple$1[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = e;
				return err;
			}
			go$deferred.push({ fun: Close, args: [h] });
			a = (_struct$1 = NsecToFiletime(TimespecToNsec((_struct = (_slice = ts, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new Timespec.Ptr(_struct.Sec, _struct.Nsec)))), new Filetime.Ptr(_struct$1.LowDateTime, _struct$1.HighDateTime));
			w = (_struct$3 = NsecToFiletime(TimespecToNsec((_struct$2 = (_slice$1 = ts, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new Timespec.Ptr(_struct$2.Sec, _struct$2.Nsec)))), new Filetime.Ptr(_struct$3.LowDateTime, _struct$3.HighDateTime));
			err = SetFileTime(h, (go$ptrType(Filetime)).nil, a, w);
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	var Fsync = go$pkg.Fsync = function(fd) {
		var err;
		err = null;
		err = FlushFileBuffers(fd);
		return err;
	};
	var Chmod = go$pkg.Chmod = function(path, mode) {
		var err, _tuple, p, e, _tuple$1, attrs;
		err = null;
		if (mode === 0) {
			err = new Errno(536870951);
			return err;
		}
		_tuple = UTF16PtrFromString(path), p = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			err = e;
			return err;
		}
		_tuple$1 = GetFileAttributes(p), attrs = _tuple$1[0], e = _tuple$1[1];
		if (!(go$interfaceIsEqual(e, null))) {
			err = e;
			return err;
		}
		if (!((((mode & 128) >>> 0) === 0))) {
			attrs = attrs & ~1;
		} else {
			attrs = (attrs | 1) >>> 0;
		}
		err = SetFileAttributes(p, attrs);
		return err;
	};
	var LoadCancelIoEx = go$pkg.LoadCancelIoEx = function() {
		return procCancelIoEx.Find();
	};
	var LoadSetFileCompletionNotificationModes = go$pkg.LoadSetFileCompletionNotificationModes = function() {
		return procSetFileCompletionNotificationModes.Find();
	};
	SockaddrInet4.Ptr.prototype.sockaddr = function() {
		var sa, v, p, i, _array, _struct, _view;
		sa = this;
		if (sa.Port < 0 || sa.Port > 65535) {
			return [0, 0, new Errno(536870951)];
		}
		sa.raw.Family = 2;
		p = new (go$ptrType(Go$Uint16))(function() { return sa.raw.Port; }, function(v) { sa.raw.Port = v; });
		p[0] = ((sa.Port >> 8 >> 0) << 24 >>> 24);
		p[1] = (sa.Port << 24 >>> 24);
		i = 0;
		while (i < 4) {
			sa.raw.Addr[i] = sa.Addr[i];
			i = i + 1 >> 0;
		}
		_array = new Uint8Array(16);
		return [_array, 16, null];
	};
	SockaddrInet4.prototype.sockaddr = function() { return this.go$val.sockaddr(); };
	SockaddrInet6.Ptr.prototype.sockaddr = function() {
		var sa, v, p, i, _array, _struct, _view;
		sa = this;
		if (sa.Port < 0 || sa.Port > 65535) {
			return [0, 0, new Errno(536870951)];
		}
		sa.raw.Family = 23;
		p = new (go$ptrType(Go$Uint16))(function() { return sa.raw.Port; }, function(v) { sa.raw.Port = v; });
		p[0] = ((sa.Port >> 8 >> 0) << 24 >>> 24);
		p[1] = (sa.Port << 24 >>> 24);
		sa.raw.Scope_id = sa.ZoneId;
		i = 0;
		while (i < 16) {
			sa.raw.Addr[i] = sa.Addr[i];
			i = i + 1 >> 0;
		}
		_array = new Uint8Array(28);
		return [_array, 28, null];
	};
	SockaddrInet6.prototype.sockaddr = function() { return this.go$val.sockaddr(); };
	SockaddrUnix.Ptr.prototype.sockaddr = function() {
		var sa;
		sa = this;
		return [0, 0, new Errno(536871042)];
	};
	SockaddrUnix.prototype.sockaddr = function() { return this.go$val.sockaddr(); };
	RawSockaddrAny.Ptr.prototype.Sockaddr = function() {
		var rsa, _ref, _array, _struct, _array$1, _struct$1, _view, _view$1, pp, sa, v, p, i, _array$2, _struct$2, _array$3, _struct$3, _view$2, _view$3, pp$1, sa$1, v$1, p$1, i$1;
		rsa = this;
		_ref = rsa.Addr.Family;
		if (_ref === 1) {
			return [null, new Errno(536871042)];
		} else if (_ref === 2) {
			_array$1 = new Uint8Array(112);
			pp = (_array = _array$1, _struct = new RawSockaddrInet4.Ptr(), _view$1 = new DataView(_array.buffer, _array.byteOffset), _struct.Family = _view$1.getUint16(0, true), _struct.Port = _view$1.getUint16(2, true), _struct.Addr = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 4, _array.buffer.byteLength)), _struct.Zero = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 8, _array.buffer.byteLength)), _struct);
			_struct$1 = rsa, _view = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Addr.Family = _view.getUint16(0, true), _struct$1.Addr.Data = new (go$nativeArray("Int8"))(_array$1.buffer, go$min(_array$1.byteOffset + 2, _array$1.buffer.byteLength)), _struct$1.Pad = new (go$nativeArray("Int8"))(_array$1.buffer, go$min(_array$1.byteOffset + 16, _array$1.buffer.byteLength));
			sa = new SockaddrInet4.Ptr();
			p = new (go$ptrType(Go$Uint16))(function() { return pp.Port; }, function(v) { pp.Port = v; });
			sa.Port = ((p[0] >> 0) << 8 >> 0) + (p[1] >> 0) >> 0;
			i = 0;
			while (i < 4) {
				sa.Addr[i] = pp.Addr[i];
				i = i + 1 >> 0;
			}
			return [sa, null];
		} else if (_ref === 23) {
			_array$3 = new Uint8Array(112);
			pp$1 = (_array$2 = _array$3, _struct$2 = new RawSockaddrInet6.Ptr(), _view$3 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Family = _view$3.getUint16(0, true), _struct$2.Port = _view$3.getUint16(2, true), _struct$2.Flowinfo = _view$3.getUint32(4, true), _struct$2.Addr = new (go$nativeArray("Uint8"))(_array$2.buffer, go$min(_array$2.byteOffset + 8, _array$2.buffer.byteLength)), _struct$2.Scope_id = _view$3.getUint32(24, true), _struct$2);
			_struct$3 = rsa, _view$2 = new DataView(_array$3.buffer, _array$3.byteOffset), _struct$3.Addr.Family = _view$2.getUint16(0, true), _struct$3.Addr.Data = new (go$nativeArray("Int8"))(_array$3.buffer, go$min(_array$3.byteOffset + 2, _array$3.buffer.byteLength)), _struct$3.Pad = new (go$nativeArray("Int8"))(_array$3.buffer, go$min(_array$3.byteOffset + 16, _array$3.buffer.byteLength));
			sa$1 = new SockaddrInet6.Ptr();
			p$1 = new (go$ptrType(Go$Uint16))(function() { return pp$1.Port; }, function(v$1) { pp$1.Port = v$1; });
			sa$1.Port = ((p$1[0] >> 0) << 8 >> 0) + (p$1[1] >> 0) >> 0;
			sa$1.ZoneId = pp$1.Scope_id;
			i$1 = 0;
			while (i$1 < 16) {
				sa$1.Addr[i$1] = pp$1.Addr[i$1];
				i$1 = i$1 + 1 >> 0;
			}
			return [sa$1, null];
		}
		return [null, new Errno(536870917)];
	};
	RawSockaddrAny.prototype.Sockaddr = function() { return this.go$val.Sockaddr(); };
	var Socket = go$pkg.Socket = function(domain, typ, proto) {
		var fd, err, _tuple, _tuple$1;
		fd = 0;
		err = null;
		if ((domain === 23) && go$pkg.SocketDisableIPv6) {
			_tuple = [4294967295, new Errno(536870917)], fd = _tuple[0], err = _tuple[1];
			return [fd, err];
		}
		_tuple$1 = socket((domain >> 0), (typ >> 0), (proto >> 0)), fd = _tuple$1[0], err = _tuple$1[1];
		return [fd, err];
	};
	var SetsockoptInt = go$pkg.SetsockoptInt = function(fd, level, opt, value) {
		var err, v, v$1;
		err = null;
		v = (value >> 0);
		err = Setsockopt(fd, (level >> 0), (opt >> 0), new (go$ptrType(Go$Int32))(function() { return v; }, function(v$1) { v = v$1; }), 4);
		return err;
	};
	var Bind = go$pkg.Bind = function(fd, sa) {
		var err, _tuple, ptr, n;
		err = null;
		_tuple = sa.sockaddr(), ptr = _tuple[0], n = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = bind(fd, ptr, n);
		return err;
	};
	var Connect = go$pkg.Connect = function(fd, sa) {
		var err, _tuple, ptr, n;
		err = null;
		_tuple = sa.sockaddr(), ptr = _tuple[0], n = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = connect(fd, ptr, n);
		return err;
	};
	var Getsockname = go$pkg.Getsockname = function(fd) {
		var sa, err, rsa, l, v, _tuple;
		sa = null;
		err = null;
		rsa = new RawSockaddrAny.Ptr();
		l = 112;
		if (err = getsockname(fd, rsa, new (go$ptrType(Go$Int32))(function() { return l; }, function(v) { l = v; })), !(go$interfaceIsEqual(err, null))) {
			return [sa, err];
		}
		_tuple = rsa.Sockaddr(), sa = _tuple[0], err = _tuple[1];
		return [sa, err];
	};
	var Getpeername = go$pkg.Getpeername = function(fd) {
		var sa, err, rsa, l, v, _tuple;
		sa = null;
		err = null;
		rsa = new RawSockaddrAny.Ptr();
		l = 112;
		if (err = getpeername(fd, rsa, new (go$ptrType(Go$Int32))(function() { return l; }, function(v) { l = v; })), !(go$interfaceIsEqual(err, null))) {
			return [sa, err];
		}
		_tuple = rsa.Sockaddr(), sa = _tuple[0], err = _tuple[1];
		return [sa, err];
	};
	var Listen = go$pkg.Listen = function(s, n) {
		var err;
		err = null;
		err = listen(s, (n >> 0));
		return err;
	};
	var Shutdown = go$pkg.Shutdown = function(fd, how) {
		var err;
		err = null;
		err = shutdown(fd, (how >> 0));
		return err;
	};
	var WSASendto = go$pkg.WSASendto = function(s, bufs, bufcnt, sent, flags, to, overlapped, croutine) {
		var err, _tuple, rsa, l, _array, _struct, _view;
		err = null;
		_tuple = to.sockaddr(), rsa = _tuple[0], l = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			err = err;
			return err;
		}
		err = WSASendTo(s, bufs, bufcnt, sent, flags, (_array = rsa, _struct = new RawSockaddrAny.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new (go$nativeArray("Int8"))(_array.buffer, go$min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new (go$nativeArray("Int8"))(_array.buffer, go$min(_array.byteOffset + 16, _array.buffer.byteLength)), _struct), l, overlapped, croutine);
		return err;
	};
	var LoadGetAddrInfo = go$pkg.LoadGetAddrInfo = function() {
		return procGetAddrInfoW.Find();
	};
	var LoadConnectEx = go$pkg.LoadConnectEx = function() {
		connectExFunc.once.Do((function() {
			var s, _tuple, n, _array, _struct, _view, v, v$1;
			var go$deferred = [];
			try {
				s = 0;
				_tuple = Socket(2, 1, 6), s = _tuple[0], connectExFunc.err = _tuple[1];
				if (!(go$interfaceIsEqual(connectExFunc.err, null))) {
					return;
				}
				go$deferred.push({ fun: CloseHandle, args: [s] });
				n = 0;
				_array = new Uint8Array(16);
				connectExFunc.err = WSAIoctl(s, 3355443206, _array, 16, new (go$ptrType(Go$Uintptr))(function() { return connectExFunc.addr; }, function(v) { connectExFunc.addr = v; }), 4, new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; }), (go$ptrType(Overlapped)).nil, 0);
				_struct = go$pkg.WSAID_CONNECTEX, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Data1 = _view.getUint32(0, true), _struct.Data2 = _view.getUint16(4, true), _struct.Data3 = _view.getUint16(6, true), _struct.Data4 = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 8, _array.buffer.byteLength));
			} catch(go$err) {
				go$pushErr(go$err);
			} finally {
				go$callDeferred(go$deferred);
			}
		}));
		return connectExFunc.err;
	};
	var connectEx = function(s, name, namelen, sendBuf, sendDataLen, bytesSent, overlapped) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall9(connectExFunc.addr, 7, (s >>> 0), name, (namelen >>> 0), sendBuf, (sendDataLen >>> 0), bytesSent, _array, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var ConnectEx = go$pkg.ConnectEx = function(fd, sa, sendBuf, sendDataLen, bytesSent, overlapped) {
		var err, _tuple, ptr, n;
		err = LoadConnectEx();
		if (!(go$interfaceIsEqual(err, null))) {
			return errors$1.New("failed to find ConnectEx: " + err.Error());
		}
		_tuple = sa.sockaddr(), ptr = _tuple[0], n = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped);
	};
	WaitStatus.Ptr.prototype.Exited = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return true;
	};
	WaitStatus.prototype.Exited = function() { return this.go$val.Exited(); };
	WaitStatus.Ptr.prototype.ExitStatus = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return (w.ExitCode >> 0);
	};
	WaitStatus.prototype.ExitStatus = function() { return this.go$val.ExitStatus(); };
	WaitStatus.Ptr.prototype.Signal = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return -1;
	};
	WaitStatus.prototype.Signal = function() { return this.go$val.Signal(); };
	WaitStatus.Ptr.prototype.CoreDump = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return false;
	};
	WaitStatus.prototype.CoreDump = function() { return this.go$val.CoreDump(); };
	WaitStatus.Ptr.prototype.Stopped = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return false;
	};
	WaitStatus.prototype.Stopped = function() { return this.go$val.Stopped(); };
	WaitStatus.Ptr.prototype.Continued = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return false;
	};
	WaitStatus.prototype.Continued = function() { return this.go$val.Continued(); };
	WaitStatus.Ptr.prototype.StopSignal = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return -1;
	};
	WaitStatus.prototype.StopSignal = function() { return this.go$val.StopSignal(); };
	WaitStatus.Ptr.prototype.Signaled = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return false;
	};
	WaitStatus.prototype.Signaled = function() { return this.go$val.Signaled(); };
	WaitStatus.Ptr.prototype.TrapCause = function() {
		var _struct, w;
		w = (_struct = this, new WaitStatus.Ptr(_struct.ExitCode));
		return -1;
	};
	WaitStatus.prototype.TrapCause = function() { return this.go$val.TrapCause(); };
	var TimespecToNsec = go$pkg.TimespecToNsec = function(ts) {
		var x, x$1;
		return (x = go$mul64(ts.Sec, new Go$Int64(0, 1000000000)), x$1 = ts.Nsec, new Go$Int64(x.high + x$1.high, x.low + x$1.low));
	};
	var NsecToTimespec = go$pkg.NsecToTimespec = function(nsec) {
		var ts, _struct;
		ts = new Timespec.Ptr();
		ts.Sec = go$div64(nsec, new Go$Int64(0, 1000000000), false);
		ts.Nsec = go$div64(nsec, new Go$Int64(0, 1000000000), true);
		return (_struct = ts, new Timespec.Ptr(_struct.Sec, _struct.Nsec));
	};
	var Accept = go$pkg.Accept = function(fd) {
		var nfd, sa, err, _tuple;
		nfd = 0;
		sa = null;
		err = null;
		_tuple = [0, null, new Errno(536871042)], nfd = _tuple[0], sa = _tuple[1], err = _tuple[2];
		return [nfd, sa, err];
	};
	var Recvfrom = go$pkg.Recvfrom = function(fd, p, flags) {
		var n, from, err, _tuple;
		n = 0;
		from = null;
		err = null;
		_tuple = [0, null, new Errno(536871042)], n = _tuple[0], from = _tuple[1], err = _tuple[2];
		return [n, from, err];
	};
	var Sendto = go$pkg.Sendto = function(fd, p, flags, to) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var SetsockoptTimeval = go$pkg.SetsockoptTimeval = function(fd, level, opt, tv) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var GetsockoptInt = go$pkg.GetsockoptInt = function(fd, level, opt) {
		return [-1, new Errno(536871042)];
	};
	var SetsockoptLinger = go$pkg.SetsockoptLinger = function(fd, level, opt, l) {
		var err, sys, _array, _struct, _view;
		err = null;
		sys = new sysLinger.Ptr((l.Onoff << 16 >>> 16), (l.Linger << 16 >>> 16));
		_array = new Uint8Array(4);
		err = Setsockopt(fd, (level >> 0), (opt >> 0), _array, 4);
		_struct = sys, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Onoff = _view.getUint16(0, true), _struct.Linger = _view.getUint16(2, true);
		return err;
	};
	var SetsockoptInet4Addr = go$pkg.SetsockoptInet4Addr = function(fd, level, opt, value) {
		var err;
		err = null;
		err = Setsockopt(fd, (level >> 0), (opt >> 0), go$sliceToArray(new (go$sliceType(Go$Uint8))(value)), 4);
		return err;
	};
	var SetsockoptIPMreq = go$pkg.SetsockoptIPMreq = function(fd, level, opt, mreq) {
		var err, _array, _struct, _view;
		err = null;
		_array = new Uint8Array(8);
		err = Setsockopt(fd, (level >> 0), (opt >> 0), _array, 8);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Interface = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 4, _array.buffer.byteLength));
		return err;
	};
	var SetsockoptIPv6Mreq = go$pkg.SetsockoptIPv6Mreq = function(fd, level, opt, mreq) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Getpid = go$pkg.Getpid = function() {
		var pid;
		pid = 0;
		pid = (getCurrentProcessId() >> 0);
		return pid;
	};
	var FindFirstFile = go$pkg.FindFirstFile = function(name, data) {
		var handle, err, data1, _tuple;
		handle = 0;
		err = null;
		data1 = new win32finddata1.Ptr();
		_tuple = findFirstFile1(name, data1), handle = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			copyFindData(data, data1);
		}
		return [handle, err];
	};
	var FindNextFile = go$pkg.FindNextFile = function(handle, data) {
		var err, data1;
		err = null;
		data1 = new win32finddata1.Ptr();
		err = findNextFile1(handle, data1);
		if (go$interfaceIsEqual(err, null)) {
			copyFindData(data, data1);
		}
		return err;
	};
	var Getppid = go$pkg.Getppid = function() {
		var ppid;
		ppid = 0;
		ppid = -1;
		return ppid;
	};
	var Fchdir = go$pkg.Fchdir = function(fd) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Link = go$pkg.Link = function(oldpath, newpath) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Symlink = go$pkg.Symlink = function(path, link) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Readlink = go$pkg.Readlink = function(path, buf) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = [0, new Errno(536871042)], n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Fchmod = go$pkg.Fchmod = function(fd, mode) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Chown = go$pkg.Chown = function(path, uid, gid) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Lchown = go$pkg.Lchown = function(path, uid, gid) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Fchown = go$pkg.Fchown = function(fd, uid, gid) {
		var err;
		err = null;
		err = new Errno(536871042);
		return err;
	};
	var Getuid = go$pkg.Getuid = function() {
		var uid;
		uid = 0;
		uid = -1;
		return uid;
	};
	var Geteuid = go$pkg.Geteuid = function() {
		var euid;
		euid = 0;
		euid = -1;
		return euid;
	};
	var Getgid = go$pkg.Getgid = function() {
		var gid;
		gid = 0;
		gid = -1;
		return gid;
	};
	var Getegid = go$pkg.Getegid = function() {
		var egid;
		egid = 0;
		egid = -1;
		return egid;
	};
	var Getgroups = go$pkg.Getgroups = function() {
		var gids, err, _tuple;
		gids = (go$sliceType(Go$Int)).nil;
		err = null;
		_tuple = [(go$sliceType(Go$Int)).nil, new Errno(536871042)], gids = _tuple[0], err = _tuple[1];
		return [gids, err];
	};
	Signal.prototype.Signal = function() {
		var s;
		s = this.go$val;
	};
	go$ptrType(Signal).prototype.Signal = function() { return new Signal(this.go$get()).Signal(); };
	Signal.prototype.String = function() {
		var s, str;
		s = this.go$val;
		if (0 <= s && (s >> 0) < 16) {
			str = signals[s];
			if (!(str === "")) {
				return str;
			}
		}
		return "signal " + itoa((s >> 0));
	};
	go$ptrType(Signal).prototype.String = function() { return new Signal(this.go$get()).String(); };
	var GetLastError = go$pkg.GetLastError = function() {
		var lasterr, _tuple, r0;
		lasterr = null;
		_tuple = Syscall(procGetLastError.Addr(), 0, 0, 0, 0), r0 = _tuple[0];
		if (!((r0 === 0))) {
			lasterr = new Errno((r0 >>> 0));
		}
		return lasterr;
	};
	var LoadLibrary = go$pkg.LoadLibrary = function(libname) {
		var handle, err, _p0, _tuple, _tuple$1, r0, e1;
		handle = 0;
		err = null;
		_p0 = (go$ptrType(Go$Uint16)).nil;
		_tuple = UTF16PtrFromString(libname), _p0 = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [handle, err];
		}
		_tuple$1 = Syscall(procLoadLibraryW.Addr(), 1, _p0, 0, 0), r0 = _tuple$1[0], e1 = _tuple$1[2];
		handle = (r0 >>> 0);
		if (handle === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var FreeLibrary = go$pkg.FreeLibrary = function(handle) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procFreeLibrary.Addr(), 1, (handle >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetProcAddress = go$pkg.GetProcAddress = function(module, procname) {
		var proc, err, _p0, _tuple, _tuple$1, r0, e1;
		proc = 0;
		err = null;
		_p0 = (go$ptrType(Go$Uint8)).nil;
		_tuple = BytePtrFromString(procname), _p0 = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [proc, err];
		}
		_tuple$1 = Syscall(procGetProcAddress.Addr(), 2, (module >>> 0), _p0, 0), r0 = _tuple$1[0], e1 = _tuple$1[2];
		proc = r0;
		if (proc === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [proc, err];
	};
	var GetVersion = go$pkg.GetVersion = function() {
		var ver, err, _tuple, r0, e1;
		ver = 0;
		err = null;
		_tuple = Syscall(procGetVersion.Addr(), 0, 0, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		ver = (r0 >>> 0);
		if (ver === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [ver, err];
	};
	var FormatMessage = go$pkg.FormatMessage = function(flags, msgsrc, msgid, langid$1, buf, args) {
		var n, err, _p0, v, _slice, _index, _slice$1, _index$1, _tuple, r0, e1;
		n = 0;
		err = null;
		_p0 = (go$ptrType(Go$Uint16)).nil;
		if (buf.length > 0) {
			_p0 = new (go$ptrType(Go$Uint16))(function() { return (_slice = buf, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = buf, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
		}
		_tuple = Syscall9(procFormatMessageW.Addr(), 7, (flags >>> 0), (msgsrc >>> 0), (msgid >>> 0), (langid$1 >>> 0), _p0, (buf.length >>> 0), args, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var ExitProcess = go$pkg.ExitProcess = function(exitcode) {
		Syscall(procExitProcess.Addr(), 1, (exitcode >>> 0), 0, 0);
		return;
	};
	var CreateFile = go$pkg.CreateFile = function(name, access, mode, sa, createmode, attrs, templatefile) {
		var handle, err, _tuple, _array, _struct, _view, r0, e1;
		handle = 0;
		err = null;
		_array = new Uint8Array(12);
		_tuple = Syscall9(procCreateFileW.Addr(), 7, name, (access >>> 0), (mode >>> 0), _array, (createmode >>> 0), (attrs >>> 0), (templatefile >>> 0), 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		_struct = sa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Length = _view.getUint32(0, true), _struct.SecurityDescriptor = _view.getUintptr(4, true), _struct.InheritHandle = _view.getUint32(8, true);
		handle = (r0 >>> 0);
		if (handle === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var ReadFile = go$pkg.ReadFile = function(handle, buf, done, overlapped) {
		var err, _p0, v, _slice, _index, _slice$1, _index$1, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_p0 = (go$ptrType(Go$Uint8)).nil;
		if (buf.length > 0) {
			_p0 = new (go$ptrType(Go$Uint8))(function() { return (_slice = buf, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = buf, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
		}
		_array = new Uint8Array(20);
		_tuple = Syscall6(procReadFile.Addr(), 5, (handle >>> 0), _p0, (buf.length >>> 0), done, _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WriteFile = go$pkg.WriteFile = function(handle, buf, done, overlapped) {
		var err, _p0, v, _slice, _index, _slice$1, _index$1, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_p0 = (go$ptrType(Go$Uint8)).nil;
		if (buf.length > 0) {
			_p0 = new (go$ptrType(Go$Uint8))(function() { return (_slice = buf, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = buf, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
		}
		_array = new Uint8Array(20);
		_tuple = Syscall6(procWriteFile.Addr(), 5, (handle >>> 0), _p0, (buf.length >>> 0), done, _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var SetFilePointer = go$pkg.SetFilePointer = function(handle, lowoffset, highoffsetptr, whence) {
		var newlowoffset, err, _tuple, r0, e1;
		newlowoffset = 0;
		err = null;
		_tuple = Syscall6(procSetFilePointer.Addr(), 4, (handle >>> 0), (lowoffset >>> 0), highoffsetptr, (whence >>> 0), 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		newlowoffset = (r0 >>> 0);
		if (newlowoffset === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [newlowoffset, err];
	};
	var CloseHandle = go$pkg.CloseHandle = function(handle) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procCloseHandle.Addr(), 1, (handle >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetStdHandle = go$pkg.GetStdHandle = function(stdhandle) {
		var handle, err, _tuple, r0, e1;
		handle = 0;
		err = null;
		_tuple = Syscall(procGetStdHandle.Addr(), 1, (stdhandle >>> 0), 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		handle = (r0 >>> 0);
		if (handle === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var findFirstFile1 = function(name, data) {
		var handle, err, _tuple, _array, _struct, _view, r0, e1;
		handle = 0;
		err = null;
		_array = new Uint8Array(592);
		_tuple = Syscall(procFindFirstFileW.Addr(), 2, name, _array, 0), r0 = _tuple[0], e1 = _tuple[2];
		_struct = data, _view = new DataView(_array.buffer, _array.byteOffset), _struct.FileAttributes = _view.getUint32(0, true), _struct.CreationTime.LowDateTime = _view.getUint32(4, true), _struct.CreationTime.HighDateTime = _view.getUint32(8, true), _struct.LastAccessTime.LowDateTime = _view.getUint32(12, true), _struct.LastAccessTime.HighDateTime = _view.getUint32(16, true), _struct.LastWriteTime.LowDateTime = _view.getUint32(20, true), _struct.LastWriteTime.HighDateTime = _view.getUint32(24, true), _struct.FileSizeHigh = _view.getUint32(28, true), _struct.FileSizeLow = _view.getUint32(32, true), _struct.Reserved0 = _view.getUint32(36, true), _struct.Reserved1 = _view.getUint32(40, true), _struct.FileName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 44, _array.buffer.byteLength)), _struct.AlternateFileName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 564, _array.buffer.byteLength));
		handle = (r0 >>> 0);
		if (handle === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var findNextFile1 = function(handle, data) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(592);
		_tuple = Syscall(procFindNextFileW.Addr(), 2, (handle >>> 0), _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = data, _view = new DataView(_array.buffer, _array.byteOffset), _struct.FileAttributes = _view.getUint32(0, true), _struct.CreationTime.LowDateTime = _view.getUint32(4, true), _struct.CreationTime.HighDateTime = _view.getUint32(8, true), _struct.LastAccessTime.LowDateTime = _view.getUint32(12, true), _struct.LastAccessTime.HighDateTime = _view.getUint32(16, true), _struct.LastWriteTime.LowDateTime = _view.getUint32(20, true), _struct.LastWriteTime.HighDateTime = _view.getUint32(24, true), _struct.FileSizeHigh = _view.getUint32(28, true), _struct.FileSizeLow = _view.getUint32(32, true), _struct.Reserved0 = _view.getUint32(36, true), _struct.Reserved1 = _view.getUint32(40, true), _struct.FileName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 44, _array.buffer.byteLength)), _struct.AlternateFileName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 564, _array.buffer.byteLength));
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var FindClose = go$pkg.FindClose = function(handle) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procFindClose.Addr(), 1, (handle >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetFileInformationByHandle = go$pkg.GetFileInformationByHandle = function(handle, data) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(52);
		_tuple = Syscall(procGetFileInformationByHandle.Addr(), 2, (handle >>> 0), _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = data, _view = new DataView(_array.buffer, _array.byteOffset), _struct.FileAttributes = _view.getUint32(0, true), _struct.CreationTime.LowDateTime = _view.getUint32(4, true), _struct.CreationTime.HighDateTime = _view.getUint32(8, true), _struct.LastAccessTime.LowDateTime = _view.getUint32(12, true), _struct.LastAccessTime.HighDateTime = _view.getUint32(16, true), _struct.LastWriteTime.LowDateTime = _view.getUint32(20, true), _struct.LastWriteTime.HighDateTime = _view.getUint32(24, true), _struct.VolumeSerialNumber = _view.getUint32(28, true), _struct.FileSizeHigh = _view.getUint32(32, true), _struct.FileSizeLow = _view.getUint32(36, true), _struct.NumberOfLinks = _view.getUint32(40, true), _struct.FileIndexHigh = _view.getUint32(44, true), _struct.FileIndexLow = _view.getUint32(48, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetCurrentDirectory = go$pkg.GetCurrentDirectory = function(buflen, buf) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall(procGetCurrentDirectoryW.Addr(), 2, (buflen >>> 0), buf, 0), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var SetCurrentDirectory = go$pkg.SetCurrentDirectory = function(path) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procSetCurrentDirectoryW.Addr(), 1, path, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CreateDirectory = go$pkg.CreateDirectory = function(path, sa) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(12);
		_tuple = Syscall(procCreateDirectoryW.Addr(), 2, path, _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = sa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Length = _view.getUint32(0, true), _struct.SecurityDescriptor = _view.getUintptr(4, true), _struct.InheritHandle = _view.getUint32(8, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var RemoveDirectory = go$pkg.RemoveDirectory = function(path) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procRemoveDirectoryW.Addr(), 1, path, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var DeleteFile = go$pkg.DeleteFile = function(path) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procDeleteFileW.Addr(), 1, path, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var MoveFile = go$pkg.MoveFile = function(from, to) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procMoveFileW.Addr(), 2, from, to, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetComputerName = go$pkg.GetComputerName = function(buf, n) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procGetComputerNameW.Addr(), 2, buf, n, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var SetEndOfFile = go$pkg.SetEndOfFile = function(handle) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procSetEndOfFile.Addr(), 1, (handle >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetSystemTimeAsFileTime = go$pkg.GetSystemTimeAsFileTime = function(time) {
		var _array, _struct, _view;
		_array = new Uint8Array(8);
		Syscall(procGetSystemTimeAsFileTime.Addr(), 1, _array, 0, 0);
		_struct = time, _view = new DataView(_array.buffer, _array.byteOffset), _struct.LowDateTime = _view.getUint32(0, true), _struct.HighDateTime = _view.getUint32(4, true);
		return;
	};
	var GetTimeZoneInformation = go$pkg.GetTimeZoneInformation = function(tzi) {
		var rc, err, _tuple, _array, _struct, _view, r0, e1;
		rc = 0;
		err = null;
		_array = new Uint8Array(172);
		_tuple = Syscall(procGetTimeZoneInformation.Addr(), 1, _array, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		_struct = tzi, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Bias = _view.getInt32(0, true), _struct.StandardName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 4, _array.buffer.byteLength)), _struct.StandardDate.Year = _view.getUint16(68, true), _struct.StandardDate.Month = _view.getUint16(70, true), _struct.StandardDate.DayOfWeek = _view.getUint16(72, true), _struct.StandardDate.Day = _view.getUint16(74, true), _struct.StandardDate.Hour = _view.getUint16(76, true), _struct.StandardDate.Minute = _view.getUint16(78, true), _struct.StandardDate.Second = _view.getUint16(80, true), _struct.StandardDate.Milliseconds = _view.getUint16(82, true), _struct.StandardBias = _view.getInt32(84, true), _struct.DaylightName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 88, _array.buffer.byteLength)), _struct.DaylightDate.Year = _view.getUint16(152, true), _struct.DaylightDate.Month = _view.getUint16(154, true), _struct.DaylightDate.DayOfWeek = _view.getUint16(156, true), _struct.DaylightDate.Day = _view.getUint16(158, true), _struct.DaylightDate.Hour = _view.getUint16(160, true), _struct.DaylightDate.Minute = _view.getUint16(162, true), _struct.DaylightDate.Second = _view.getUint16(164, true), _struct.DaylightDate.Milliseconds = _view.getUint16(166, true), _struct.DaylightBias = _view.getInt32(168, true);
		rc = (r0 >>> 0);
		if (rc === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [rc, err];
	};
	var CreateIoCompletionPort = go$pkg.CreateIoCompletionPort = function(filehandle, cphandle, key, threadcnt) {
		var handle, err, _tuple, r0, e1;
		handle = 0;
		err = null;
		_tuple = Syscall6(procCreateIoCompletionPort.Addr(), 4, (filehandle >>> 0), (cphandle >>> 0), (key >>> 0), (threadcnt >>> 0), 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		handle = (r0 >>> 0);
		if (handle === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var GetQueuedCompletionStatus = go$pkg.GetQueuedCompletionStatus = function(cphandle, qty, key, overlapped, timeout) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procGetQueuedCompletionStatus.Addr(), 5, (cphandle >>> 0), qty, key, overlapped, (timeout >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var PostQueuedCompletionStatus = go$pkg.PostQueuedCompletionStatus = function(cphandle, qty, key, overlapped) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall6(procPostQueuedCompletionStatus.Addr(), 4, (cphandle >>> 0), (qty >>> 0), (key >>> 0), _array, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CancelIo = go$pkg.CancelIo = function(s) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procCancelIo.Addr(), 1, (s >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CancelIoEx = go$pkg.CancelIoEx = function(s, o) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall(procCancelIoEx.Addr(), 2, (s >>> 0), _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = o, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CreateProcess = go$pkg.CreateProcess = function(appName, commandLine, procSecurity, threadSecurity, inheritHandles, creationFlags, env, currentDir, startupInfo, outProcInfo) {
		var err, _p0, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, _array$3, _struct$3, _view$3, r1, e1;
		err = null;
		_p0 = 0;
		if (inheritHandles) {
			_p0 = 1;
		} else {
			_p0 = 0;
		}
		_array = new Uint8Array(12);
		_array$1 = new Uint8Array(12);
		_struct = procSecurity, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Length = _view.getUint32(0, true), _struct.SecurityDescriptor = _view.getUintptr(4, true), _struct.InheritHandle = _view.getUint32(8, true);
		_array$2 = new Uint8Array(68);
		_struct$1 = threadSecurity, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Length = _view$1.getUint32(0, true), _struct$1.SecurityDescriptor = _view$1.getUintptr(4, true), _struct$1.InheritHandle = _view$1.getUint32(8, true);
		_array$3 = new Uint8Array(16);
		_struct$2 = startupInfo, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Cb = _view$2.getUint32(0, true), _struct$2.X = _view$2.getUint32(16, true), _struct$2.Y = _view$2.getUint32(20, true), _struct$2.XSize = _view$2.getUint32(24, true), _struct$2.YSize = _view$2.getUint32(28, true), _struct$2.XCountChars = _view$2.getUint32(32, true), _struct$2.YCountChars = _view$2.getUint32(36, true), _struct$2.FillAttribute = _view$2.getUint32(40, true), _struct$2.Flags = _view$2.getUint32(44, true), _struct$2.ShowWindow = _view$2.getUint16(48, true), _struct$2._$13 = _view$2.getUint16(50, true), _struct$2.StdInput = _view$2.getUintptr(56, true), _struct$2.StdOutput = _view$2.getUintptr(60, true), _struct$2.StdErr = _view$2.getUintptr(64, true);
		_tuple = Syscall12(procCreateProcessW.Addr(), 10, appName, commandLine, _array, _array$1, (_p0 >>> 0), (creationFlags >>> 0), env, currentDir, _array$2, _array$3, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$3 = outProcInfo, _view$3 = new DataView(_array$3.buffer, _array$3.byteOffset), _struct$3.Process = _view$3.getUintptr(0, true), _struct$3.Thread = _view$3.getUintptr(4, true), _struct$3.ProcessId = _view$3.getUint32(8, true), _struct$3.ThreadId = _view$3.getUint32(12, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var OpenProcess = go$pkg.OpenProcess = function(da, inheritHandle, pid) {
		var handle, err, _p0, _tuple, r0, e1;
		handle = 0;
		err = null;
		_p0 = 0;
		if (inheritHandle) {
			_p0 = 1;
		} else {
			_p0 = 0;
		}
		_tuple = Syscall(procOpenProcess.Addr(), 3, (da >>> 0), (_p0 >>> 0), (pid >>> 0)), r0 = _tuple[0], e1 = _tuple[2];
		handle = (r0 >>> 0);
		if (handle === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var TerminateProcess = go$pkg.TerminateProcess = function(handle, exitcode) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procTerminateProcess.Addr(), 2, (handle >>> 0), (exitcode >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetExitCodeProcess = go$pkg.GetExitCodeProcess = function(handle, exitcode) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procGetExitCodeProcess.Addr(), 2, (handle >>> 0), exitcode, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetStartupInfo = go$pkg.GetStartupInfo = function(startupInfo) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(68);
		_tuple = Syscall(procGetStartupInfoW.Addr(), 1, _array, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = startupInfo, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Cb = _view.getUint32(0, true), _struct.X = _view.getUint32(16, true), _struct.Y = _view.getUint32(20, true), _struct.XSize = _view.getUint32(24, true), _struct.YSize = _view.getUint32(28, true), _struct.XCountChars = _view.getUint32(32, true), _struct.YCountChars = _view.getUint32(36, true), _struct.FillAttribute = _view.getUint32(40, true), _struct.Flags = _view.getUint32(44, true), _struct.ShowWindow = _view.getUint16(48, true), _struct._$13 = _view.getUint16(50, true), _struct.StdInput = _view.getUintptr(56, true), _struct.StdOutput = _view.getUintptr(60, true), _struct.StdErr = _view.getUintptr(64, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetCurrentProcess = go$pkg.GetCurrentProcess = function() {
		var pseudoHandle, err, _tuple, r0, e1;
		pseudoHandle = 0;
		err = null;
		_tuple = Syscall(procGetCurrentProcess.Addr(), 0, 0, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		pseudoHandle = (r0 >>> 0);
		if (pseudoHandle === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [pseudoHandle, err];
	};
	var GetProcessTimes = go$pkg.GetProcessTimes = function(handle, creationTime, exitTime, kernelTime, userTime) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, _array$3, _struct$3, _view$3, r1, e1;
		err = null;
		_array = new Uint8Array(8);
		_array$1 = new Uint8Array(8);
		_struct = creationTime, _view = new DataView(_array.buffer, _array.byteOffset), _struct.LowDateTime = _view.getUint32(0, true), _struct.HighDateTime = _view.getUint32(4, true);
		_array$2 = new Uint8Array(8);
		_struct$1 = exitTime, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.LowDateTime = _view$1.getUint32(0, true), _struct$1.HighDateTime = _view$1.getUint32(4, true);
		_array$3 = new Uint8Array(8);
		_struct$2 = kernelTime, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.LowDateTime = _view$2.getUint32(0, true), _struct$2.HighDateTime = _view$2.getUint32(4, true);
		_tuple = Syscall6(procGetProcessTimes.Addr(), 5, (handle >>> 0), _array, _array$1, _array$2, _array$3, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$3 = userTime, _view$3 = new DataView(_array$3.buffer, _array$3.byteOffset), _struct$3.LowDateTime = _view$3.getUint32(0, true), _struct$3.HighDateTime = _view$3.getUint32(4, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var DuplicateHandle = go$pkg.DuplicateHandle = function(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions) {
		var err, _p0, _tuple, r1, e1;
		err = null;
		_p0 = 0;
		if (bInheritHandle) {
			_p0 = 1;
		} else {
			_p0 = 0;
		}
		_tuple = Syscall9(procDuplicateHandle.Addr(), 7, (hSourceProcessHandle >>> 0), (hSourceHandle >>> 0), (hTargetProcessHandle >>> 0), lpTargetHandle, (dwDesiredAccess >>> 0), (_p0 >>> 0), (dwOptions >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WaitForSingleObject = go$pkg.WaitForSingleObject = function(handle, waitMilliseconds) {
		var event, err, _tuple, r0, e1;
		event = 0;
		err = null;
		_tuple = Syscall(procWaitForSingleObject.Addr(), 2, (handle >>> 0), (waitMilliseconds >>> 0), 0), r0 = _tuple[0], e1 = _tuple[2];
		event = (r0 >>> 0);
		if (event === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [event, err];
	};
	var GetTempPath = go$pkg.GetTempPath = function(buflen, buf) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall(procGetTempPathW.Addr(), 2, (buflen >>> 0), buf, 0), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var CreatePipe = go$pkg.CreatePipe = function(readhandle, writehandle, sa, size) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(12);
		_tuple = Syscall6(procCreatePipe.Addr(), 4, readhandle, writehandle, _array, (size >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = sa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Length = _view.getUint32(0, true), _struct.SecurityDescriptor = _view.getUintptr(4, true), _struct.InheritHandle = _view.getUint32(8, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetFileType = go$pkg.GetFileType = function(filehandle) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall(procGetFileType.Addr(), 1, (filehandle >>> 0), 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var CryptAcquireContext = go$pkg.CryptAcquireContext = function(provhandle, container, provider, provtype, flags) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procCryptAcquireContextW.Addr(), 5, provhandle, container, provider, (provtype >>> 0), (flags >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CryptReleaseContext = go$pkg.CryptReleaseContext = function(provhandle, flags) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procCryptReleaseContext.Addr(), 2, (provhandle >>> 0), (flags >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CryptGenRandom = go$pkg.CryptGenRandom = function(provhandle, buflen, buf) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procCryptGenRandom.Addr(), 3, (provhandle >>> 0), (buflen >>> 0), buf), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetEnvironmentStrings = go$pkg.GetEnvironmentStrings = function() {
		var envs, err, _tuple, r0, e1;
		envs = (go$ptrType(Go$Uint16)).nil;
		err = null;
		_tuple = Syscall(procGetEnvironmentStringsW.Addr(), 0, 0, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		envs = r0;
		if (go$pointerIsEqual(envs, (go$ptrType(Go$Uint16)).nil)) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [envs, err];
	};
	var FreeEnvironmentStrings = go$pkg.FreeEnvironmentStrings = function(envs) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procFreeEnvironmentStringsW.Addr(), 1, envs, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetEnvironmentVariable = go$pkg.GetEnvironmentVariable = function(name, buffer, size) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall(procGetEnvironmentVariableW.Addr(), 3, name, buffer, (size >>> 0)), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var SetEnvironmentVariable = go$pkg.SetEnvironmentVariable = function(name, value) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procSetEnvironmentVariableW.Addr(), 2, name, value, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var SetFileTime = go$pkg.SetFileTime = function(handle, ctime, atime, wtime) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, r1, e1;
		err = null;
		_array = new Uint8Array(8);
		_array$1 = new Uint8Array(8);
		_struct = ctime, _view = new DataView(_array.buffer, _array.byteOffset), _struct.LowDateTime = _view.getUint32(0, true), _struct.HighDateTime = _view.getUint32(4, true);
		_array$2 = new Uint8Array(8);
		_struct$1 = atime, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.LowDateTime = _view$1.getUint32(0, true), _struct$1.HighDateTime = _view$1.getUint32(4, true);
		_tuple = Syscall6(procSetFileTime.Addr(), 4, (handle >>> 0), _array, _array$1, _array$2, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$2 = wtime, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.LowDateTime = _view$2.getUint32(0, true), _struct$2.HighDateTime = _view$2.getUint32(4, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetFileAttributes = go$pkg.GetFileAttributes = function(name) {
		var attrs, err, _tuple, r0, e1;
		attrs = 0;
		err = null;
		_tuple = Syscall(procGetFileAttributesW.Addr(), 1, name, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		attrs = (r0 >>> 0);
		if (attrs === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [attrs, err];
	};
	var SetFileAttributes = go$pkg.SetFileAttributes = function(name, attrs) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procSetFileAttributesW.Addr(), 2, name, (attrs >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetFileAttributesEx = go$pkg.GetFileAttributesEx = function(name, level, info) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procGetFileAttributesExW.Addr(), 3, name, (level >>> 0), info), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetCommandLine = go$pkg.GetCommandLine = function() {
		var cmd, _tuple, r0;
		cmd = (go$ptrType(Go$Uint16)).nil;
		_tuple = Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0), r0 = _tuple[0];
		cmd = r0;
		return cmd;
	};
	var CommandLineToArgv = go$pkg.CommandLineToArgv = function(cmd, argc) {
		var argv, err, _tuple, r0, e1;
		argv = (go$ptrType((go$arrayType((go$ptrType((go$arrayType(Go$Uint16, 8192)))), 8192)))).nil;
		err = null;
		_tuple = Syscall(procCommandLineToArgvW.Addr(), 2, cmd, argc, 0), r0 = _tuple[0], e1 = _tuple[2];
		argv = r0;
		if (go$arrayIsEqual(argv, (go$ptrType((go$arrayType((go$ptrType((go$arrayType(Go$Uint16, 8192)))), 8192)))).nil)) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [argv, err];
	};
	var LocalFree = go$pkg.LocalFree = function(hmem) {
		var handle, err, _tuple, r0, e1;
		handle = 0;
		err = null;
		_tuple = Syscall(procLocalFree.Addr(), 1, (hmem >>> 0), 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		handle = (r0 >>> 0);
		if (!((handle === 0))) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var SetHandleInformation = go$pkg.SetHandleInformation = function(handle, mask, flags) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procSetHandleInformation.Addr(), 3, (handle >>> 0), (mask >>> 0), (flags >>> 0)), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var FlushFileBuffers = go$pkg.FlushFileBuffers = function(handle) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procFlushFileBuffers.Addr(), 1, (handle >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetFullPathName = go$pkg.GetFullPathName = function(path, buflen, buf, fname) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall6(procGetFullPathNameW.Addr(), 4, path, (buflen >>> 0), buf, fname, 0, 0), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var GetLongPathName = go$pkg.GetLongPathName = function(path, buf, buflen) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall(procGetLongPathNameW.Addr(), 3, path, buf, (buflen >>> 0)), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var GetShortPathName = go$pkg.GetShortPathName = function(longpath, shortpath, buflen) {
		var n, err, _tuple, r0, e1;
		n = 0;
		err = null;
		_tuple = Syscall(procGetShortPathNameW.Addr(), 3, longpath, shortpath, (buflen >>> 0)), r0 = _tuple[0], e1 = _tuple[2];
		n = (r0 >>> 0);
		if (n === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var CreateFileMapping = go$pkg.CreateFileMapping = function(fhandle, sa, prot, maxSizeHigh, maxSizeLow, name) {
		var handle, err, _tuple, _array, _struct, _view, r0, e1;
		handle = 0;
		err = null;
		_array = new Uint8Array(12);
		_tuple = Syscall6(procCreateFileMappingW.Addr(), 6, (fhandle >>> 0), _array, (prot >>> 0), (maxSizeHigh >>> 0), (maxSizeLow >>> 0), name), r0 = _tuple[0], e1 = _tuple[2];
		_struct = sa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Length = _view.getUint32(0, true), _struct.SecurityDescriptor = _view.getUintptr(4, true), _struct.InheritHandle = _view.getUint32(8, true);
		handle = (r0 >>> 0);
		if (handle === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var MapViewOfFile = go$pkg.MapViewOfFile = function(handle, access, offsetHigh, offsetLow, length) {
		var addr, err, _tuple, r0, e1;
		addr = 0;
		err = null;
		_tuple = Syscall6(procMapViewOfFile.Addr(), 5, (handle >>> 0), (access >>> 0), (offsetHigh >>> 0), (offsetLow >>> 0), length, 0), r0 = _tuple[0], e1 = _tuple[2];
		addr = r0;
		if (addr === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [addr, err];
	};
	var UnmapViewOfFile = go$pkg.UnmapViewOfFile = function(addr) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procUnmapViewOfFile.Addr(), 1, addr, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var FlushViewOfFile = go$pkg.FlushViewOfFile = function(addr, length) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procFlushViewOfFile.Addr(), 2, addr, length, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var VirtualLock = go$pkg.VirtualLock = function(addr, length) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procVirtualLock.Addr(), 2, addr, length, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var VirtualUnlock = go$pkg.VirtualUnlock = function(addr, length) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procVirtualUnlock.Addr(), 2, addr, length, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var TransmitFile = go$pkg.TransmitFile = function(s, handle, bytesToWrite, bytsPerSend, overlapped, transmitFileBuf, flags) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_array$1 = new Uint8Array(16);
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		_tuple = Syscall9(procTransmitFile.Addr(), 7, (s >>> 0), (handle >>> 0), (bytesToWrite >>> 0), (bytsPerSend >>> 0), _array, _array$1, (flags >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$1 = transmitFileBuf, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Head = _view$1.getUintptr(0, true), _struct$1.HeadLength = _view$1.getUint32(4, true), _struct$1.Tail = _view$1.getUintptr(8, true), _struct$1.TailLength = _view$1.getUint32(12, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var ReadDirectoryChanges = go$pkg.ReadDirectoryChanges = function(handle, buf, buflen, watchSubTree, mask, retlen, overlapped, completionRoutine) {
		var err, _p0, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_p0 = 0;
		if (watchSubTree) {
			_p0 = 1;
		} else {
			_p0 = 0;
		}
		_array = new Uint8Array(20);
		_tuple = Syscall9(procReadDirectoryChangesW.Addr(), 8, (handle >>> 0), buf, (buflen >>> 0), (_p0 >>> 0), (mask >>> 0), retlen, _array, completionRoutine, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CertOpenSystemStore = go$pkg.CertOpenSystemStore = function(hprov, name) {
		var store, err, _tuple, r0, e1;
		store = 0;
		err = null;
		_tuple = Syscall(procCertOpenSystemStoreW.Addr(), 2, (hprov >>> 0), name, 0), r0 = _tuple[0], e1 = _tuple[2];
		store = (r0 >>> 0);
		if (store === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [store, err];
	};
	var CertOpenStore = go$pkg.CertOpenStore = function(storeProvider, msgAndCertEncodingType, cryptProv, flags, para) {
		var handle, err, _tuple, r0, e1;
		handle = 0;
		err = null;
		_tuple = Syscall6(procCertOpenStore.Addr(), 5, storeProvider, (msgAndCertEncodingType >>> 0), cryptProv, (flags >>> 0), para, 0), r0 = _tuple[0], e1 = _tuple[2];
		handle = (r0 >>> 0);
		if (handle === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var CertEnumCertificatesInStore = go$pkg.CertEnumCertificatesInStore = function(store, prevContext) {
		var context, err, _tuple, _array, _struct, _view, r0, e1, _array$1, _struct$1, _view$1;
		context = (go$ptrType(CertContext)).nil;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall(procCertEnumCertificatesInStore.Addr(), 2, (store >>> 0), _array, 0), r0 = _tuple[0], e1 = _tuple[2];
		_struct = prevContext, _view = new DataView(_array.buffer, _array.byteOffset), _struct.EncodingType = _view.getUint32(0, true), _struct.Length = _view.getUint32(8, true), _struct.CertInfo = _view.getUintptr(12, true), _struct.Store = _view.getUintptr(16, true);
		context = (_array$1 = r0, _struct$1 = new CertContext.Ptr(), _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.EncodingType = _view$1.getUint32(0, true), _struct$1.Length = _view$1.getUint32(8, true), _struct$1.CertInfo = _view$1.getUintptr(12, true), _struct$1.Store = _view$1.getUintptr(16, true), _struct$1);
		if (context === (go$ptrType(CertContext)).nil) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [context, err];
	};
	var CertAddCertificateContextToStore = go$pkg.CertAddCertificateContextToStore = function(store, certContext, addDisposition, storeContext) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall6(procCertAddCertificateContextToStore.Addr(), 4, (store >>> 0), _array, (addDisposition >>> 0), storeContext, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = certContext, _view = new DataView(_array.buffer, _array.byteOffset), _struct.EncodingType = _view.getUint32(0, true), _struct.Length = _view.getUint32(8, true), _struct.CertInfo = _view.getUintptr(12, true), _struct.Store = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CertCloseStore = go$pkg.CertCloseStore = function(store, flags) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procCertCloseStore.Addr(), 2, (store >>> 0), (flags >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CertGetCertificateChain = go$pkg.CertGetCertificateChain = function(engine, leaf, time, additionalStore, para, flags, reserved, chainCtx) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_array$1 = new Uint8Array(8);
		_struct = leaf, _view = new DataView(_array.buffer, _array.byteOffset), _struct.EncodingType = _view.getUint32(0, true), _struct.Length = _view.getUint32(8, true), _struct.CertInfo = _view.getUintptr(12, true), _struct.Store = _view.getUintptr(16, true);
		_array$2 = new Uint8Array(44);
		_struct$1 = time, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.LowDateTime = _view$1.getUint32(0, true), _struct$1.HighDateTime = _view$1.getUint32(4, true);
		_tuple = Syscall9(procCertGetCertificateChain.Addr(), 8, (engine >>> 0), _array, _array$1, (additionalStore >>> 0), _array$2, (flags >>> 0), reserved, chainCtx, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$2 = para, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Size = _view$2.getUint32(0, true), _struct$2.RequestedUsage.Type = _view$2.getUint32(4, true), _struct$2.RequestedUsage.Usage.Length = _view$2.getUint32(8, true), _struct$2.RequstedIssuancePolicy.Type = _view$2.getUint32(16, true), _struct$2.RequstedIssuancePolicy.Usage.Length = _view$2.getUint32(20, true), _struct$2.URLRetrievalTimeout = _view$2.getUint32(28, true), _struct$2.CheckRevocationFreshnessTime = _view$2.getUint32(32, true), _struct$2.RevocationFreshnessTime = _view$2.getUint32(36, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CertFreeCertificateChain = go$pkg.CertFreeCertificateChain = function(ctx) {
		var _array, _struct, _view;
		_array = new Uint8Array(36);
		Syscall(procCertFreeCertificateChain.Addr(), 1, _array, 0, 0);
		_struct = ctx, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Size = _view.getUint32(0, true), _struct.TrustStatus.ErrorStatus = _view.getUint32(4, true), _struct.TrustStatus.InfoStatus = _view.getUint32(8, true), _struct.ChainCount = _view.getUint32(12, true), _struct.LowerQualityChainCount = _view.getUint32(20, true), _struct.HasRevocationFreshnessTime = _view.getUint32(28, true), _struct.RevocationFreshnessTime = _view.getUint32(32, true);
		return;
	};
	var CertCreateCertificateContext = go$pkg.CertCreateCertificateContext = function(certEncodingType, certEncoded, encodedLen) {
		var context, err, _tuple, r0, e1, _array, _struct, _view;
		context = (go$ptrType(CertContext)).nil;
		err = null;
		_tuple = Syscall(procCertCreateCertificateContext.Addr(), 3, (certEncodingType >>> 0), certEncoded, (encodedLen >>> 0)), r0 = _tuple[0], e1 = _tuple[2];
		context = (_array = r0, _struct = new CertContext.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct.EncodingType = _view.getUint32(0, true), _struct.Length = _view.getUint32(8, true), _struct.CertInfo = _view.getUintptr(12, true), _struct.Store = _view.getUintptr(16, true), _struct);
		if (context === (go$ptrType(CertContext)).nil) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [context, err];
	};
	var CertFreeCertificateContext = go$pkg.CertFreeCertificateContext = function(ctx) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall(procCertFreeCertificateContext.Addr(), 1, _array, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = ctx, _view = new DataView(_array.buffer, _array.byteOffset), _struct.EncodingType = _view.getUint32(0, true), _struct.Length = _view.getUint32(8, true), _struct.CertInfo = _view.getUintptr(12, true), _struct.Store = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var CertVerifyCertificateChainPolicy = go$pkg.CertVerifyCertificateChainPolicy = function(policyOID, chain, para, status) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, r1, e1;
		err = null;
		_array = new Uint8Array(36);
		_array$1 = new Uint8Array(12);
		_struct = chain, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Size = _view.getUint32(0, true), _struct.TrustStatus.ErrorStatus = _view.getUint32(4, true), _struct.TrustStatus.InfoStatus = _view.getUint32(8, true), _struct.ChainCount = _view.getUint32(12, true), _struct.LowerQualityChainCount = _view.getUint32(20, true), _struct.HasRevocationFreshnessTime = _view.getUint32(28, true), _struct.RevocationFreshnessTime = _view.getUint32(32, true);
		_array$2 = new Uint8Array(20);
		_struct$1 = para, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Size = _view$1.getUint32(0, true), _struct$1.Flags = _view$1.getUint32(4, true), _struct$1.ExtraPolicyPara = _view$1.getUintptr(8, true);
		_tuple = Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, policyOID, _array, _array$1, _array$2, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$2 = status, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Size = _view$2.getUint32(0, true), _struct$2.Error = _view$2.getUint32(4, true), _struct$2.ChainIndex = _view$2.getUint32(8, true), _struct$2.ElementIndex = _view$2.getUint32(12, true), _struct$2.ExtraPolicyStatus = _view$2.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var RegOpenKeyEx = go$pkg.RegOpenKeyEx = function(key, subkey, options, desiredAccess, result) {
		var regerrno, _tuple, r0;
		regerrno = null;
		_tuple = Syscall6(procRegOpenKeyExW.Addr(), 5, (key >>> 0), subkey, (options >>> 0), (desiredAccess >>> 0), result, 0), r0 = _tuple[0];
		if (!((r0 === 0))) {
			regerrno = new Errno((r0 >>> 0));
		}
		return regerrno;
	};
	var RegCloseKey = go$pkg.RegCloseKey = function(key) {
		var regerrno, _tuple, r0;
		regerrno = null;
		_tuple = Syscall(procRegCloseKey.Addr(), 1, (key >>> 0), 0, 0), r0 = _tuple[0];
		if (!((r0 === 0))) {
			regerrno = new Errno((r0 >>> 0));
		}
		return regerrno;
	};
	var RegQueryInfoKey = go$pkg.RegQueryInfoKey = function(key, class$1, classLen, reserved, subkeysLen, maxSubkeyLen, maxClassLen, valuesLen, maxValueNameLen, maxValueLen, saLen, lastWriteTime) {
		var regerrno, _tuple, _array, _struct, _view, r0;
		regerrno = null;
		_array = new Uint8Array(8);
		_tuple = Syscall12(procRegQueryInfoKeyW.Addr(), 12, (key >>> 0), class$1, classLen, reserved, subkeysLen, maxSubkeyLen, maxClassLen, valuesLen, maxValueNameLen, maxValueLen, saLen, _array), r0 = _tuple[0];
		_struct = lastWriteTime, _view = new DataView(_array.buffer, _array.byteOffset), _struct.LowDateTime = _view.getUint32(0, true), _struct.HighDateTime = _view.getUint32(4, true);
		if (!((r0 === 0))) {
			regerrno = new Errno((r0 >>> 0));
		}
		return regerrno;
	};
	var RegEnumKeyEx = go$pkg.RegEnumKeyEx = function(key, index, name, nameLen, reserved, class$1, classLen, lastWriteTime) {
		var regerrno, _tuple, _array, _struct, _view, r0;
		regerrno = null;
		_array = new Uint8Array(8);
		_tuple = Syscall9(procRegEnumKeyExW.Addr(), 8, (key >>> 0), (index >>> 0), name, nameLen, reserved, class$1, classLen, _array, 0), r0 = _tuple[0];
		_struct = lastWriteTime, _view = new DataView(_array.buffer, _array.byteOffset), _struct.LowDateTime = _view.getUint32(0, true), _struct.HighDateTime = _view.getUint32(4, true);
		if (!((r0 === 0))) {
			regerrno = new Errno((r0 >>> 0));
		}
		return regerrno;
	};
	var RegQueryValueEx = go$pkg.RegQueryValueEx = function(key, name, reserved, valtype, buf, buflen) {
		var regerrno, _tuple, r0;
		regerrno = null;
		_tuple = Syscall6(procRegQueryValueExW.Addr(), 6, (key >>> 0), name, reserved, valtype, buf, buflen), r0 = _tuple[0];
		if (!((r0 === 0))) {
			regerrno = new Errno((r0 >>> 0));
		}
		return regerrno;
	};
	var getCurrentProcessId = function() {
		var pid, _tuple, r0;
		pid = 0;
		_tuple = Syscall(procGetCurrentProcessId.Addr(), 0, 0, 0, 0), r0 = _tuple[0];
		pid = (r0 >>> 0);
		return pid;
	};
	var GetConsoleMode = go$pkg.GetConsoleMode = function(console, mode) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procGetConsoleMode.Addr(), 2, (console >>> 0), mode, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WriteConsole = go$pkg.WriteConsole = function(console, buf, towrite, written, reserved) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procWriteConsoleW.Addr(), 5, (console >>> 0), buf, (towrite >>> 0), written, reserved, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var ReadConsole = go$pkg.ReadConsole = function(console, buf, toread, read, inputControl) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procReadConsoleW.Addr(), 5, (console >>> 0), buf, (toread >>> 0), read, inputControl, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WSAStartup = go$pkg.WSAStartup = function(verreq, data) {
		var sockerr, _tuple, _array, _struct, _view, r0;
		sockerr = null;
		_array = new Uint8Array(398);
		_tuple = Syscall(procWSAStartup.Addr(), 2, (verreq >>> 0), _array, 0), r0 = _tuple[0];
		_struct = data, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Version = _view.getUint16(0, true), _struct.HighVersion = _view.getUint16(2, true), _struct.MaxSockets = _view.getUint16(4, true), _struct.MaxUdpDg = _view.getUint16(6, true), _struct.Description = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 12, _array.buffer.byteLength)), _struct.SystemStatus = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 269, _array.buffer.byteLength));
		if (!((r0 === 0))) {
			sockerr = new Errno((r0 >>> 0));
		}
		return sockerr;
	};
	var WSACleanup = go$pkg.WSACleanup = function() {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procWSACleanup.Addr(), 0, 0, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WSAIoctl = go$pkg.WSAIoctl = function(s, iocc, inbuf, cbif, outbuf, cbob, cbbr, overlapped, completionRoutine) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall9(procWSAIoctl.Addr(), 9, (s >>> 0), (iocc >>> 0), inbuf, (cbif >>> 0), outbuf, (cbob >>> 0), cbbr, _array, completionRoutine), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var socket = function(af, typ, protocol) {
		var handle, err, _tuple, r0, e1;
		handle = 0;
		err = null;
		_tuple = Syscall(procsocket.Addr(), 3, (af >>> 0), (typ >>> 0), (protocol >>> 0)), r0 = _tuple[0], e1 = _tuple[2];
		handle = (r0 >>> 0);
		if (handle === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [handle, err];
	};
	var Setsockopt = go$pkg.Setsockopt = function(s, level, optname, optval, optlen) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procsetsockopt.Addr(), 5, (s >>> 0), (level >>> 0), (optname >>> 0), optval, (optlen >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var Getsockopt = go$pkg.Getsockopt = function(s, level, optname, optval, optlen) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procgetsockopt.Addr(), 5, (s >>> 0), (level >>> 0), (optname >>> 0), optval, optlen, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var bind = function(s, name, namelen) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procbind.Addr(), 3, (s >>> 0), name, (namelen >>> 0)), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var connect = function(s, name, namelen) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procconnect.Addr(), 3, (s >>> 0), name, (namelen >>> 0)), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var getsockname = function(s, rsa, addrlen) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(112);
		_tuple = Syscall(procgetsockname.Addr(), 3, (s >>> 0), _array, addrlen), r1 = _tuple[0], e1 = _tuple[2];
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new (go$nativeArray("Int8"))(_array.buffer, go$min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new (go$nativeArray("Int8"))(_array.buffer, go$min(_array.byteOffset + 16, _array.buffer.byteLength));
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var getpeername = function(s, rsa, addrlen) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(112);
		_tuple = Syscall(procgetpeername.Addr(), 3, (s >>> 0), _array, addrlen), r1 = _tuple[0], e1 = _tuple[2];
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new (go$nativeArray("Int8"))(_array.buffer, go$min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new (go$nativeArray("Int8"))(_array.buffer, go$min(_array.byteOffset + 16, _array.buffer.byteLength));
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var listen = function(s, backlog) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(proclisten.Addr(), 2, (s >>> 0), (backlog >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var shutdown = function(s, how) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procshutdown.Addr(), 2, (s >>> 0), (how >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var Closesocket = go$pkg.Closesocket = function(s) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procclosesocket.Addr(), 1, (s >>> 0), 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var AcceptEx = go$pkg.AcceptEx = function(ls, as, buf, rxdatalen, laddrlen, raddrlen, recvd, overlapped) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(20);
		_tuple = Syscall9(procAcceptEx.Addr(), 8, (ls >>> 0), (as >>> 0), buf, (rxdatalen >>> 0), (laddrlen >>> 0), (raddrlen >>> 0), recvd, _array, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = overlapped, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Internal = _view.getUintptr(0, true), _struct.InternalHigh = _view.getUintptr(4, true), _struct.Offset = _view.getUint32(8, true), _struct.OffsetHigh = _view.getUint32(12, true), _struct.HEvent = _view.getUintptr(16, true);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetAcceptExSockaddrs = go$pkg.GetAcceptExSockaddrs = function(buf, rxdatalen, laddrlen, raddrlen, lrsa, lrsalen, rrsa, rrsalen) {
		Syscall9(procGetAcceptExSockaddrs.Addr(), 8, buf, (rxdatalen >>> 0), (laddrlen >>> 0), (raddrlen >>> 0), lrsa, lrsalen, rrsa, rrsalen, 0);
		return;
	};
	var WSARecv = go$pkg.WSARecv = function(s, bufs, bufcnt, recvd, flags, overlapped, croutine) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, r1, e1;
		err = null;
		_array = new Uint8Array(8);
		_array$1 = new Uint8Array(20);
		_struct = bufs, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Len = _view.getUint32(0, true);
		_tuple = Syscall9(procWSARecv.Addr(), 7, (s >>> 0), _array, (bufcnt >>> 0), recvd, flags, _array$1, croutine, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$1 = overlapped, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Internal = _view$1.getUintptr(0, true), _struct$1.InternalHigh = _view$1.getUintptr(4, true), _struct$1.Offset = _view$1.getUint32(8, true), _struct$1.OffsetHigh = _view$1.getUint32(12, true), _struct$1.HEvent = _view$1.getUintptr(16, true);
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WSASend = go$pkg.WSASend = function(s, bufs, bufcnt, sent, flags, overlapped, croutine) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, r1, e1;
		err = null;
		_array = new Uint8Array(8);
		_array$1 = new Uint8Array(20);
		_struct = bufs, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Len = _view.getUint32(0, true);
		_tuple = Syscall9(procWSASend.Addr(), 7, (s >>> 0), _array, (bufcnt >>> 0), sent, (flags >>> 0), _array$1, croutine, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct$1 = overlapped, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Internal = _view$1.getUintptr(0, true), _struct$1.InternalHigh = _view$1.getUintptr(4, true), _struct$1.Offset = _view$1.getUint32(8, true), _struct$1.OffsetHigh = _view$1.getUint32(12, true), _struct$1.HEvent = _view$1.getUintptr(16, true);
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WSARecvFrom = go$pkg.WSARecvFrom = function(s, bufs, bufcnt, recvd, flags, from, fromlen, overlapped, croutine) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, r1, e1;
		err = null;
		_array = new Uint8Array(8);
		_array$1 = new Uint8Array(112);
		_struct = bufs, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Len = _view.getUint32(0, true);
		_array$2 = new Uint8Array(20);
		_struct$1 = from, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Addr.Family = _view$1.getUint16(0, true), _struct$1.Addr.Data = new (go$nativeArray("Int8"))(_array$1.buffer, go$min(_array$1.byteOffset + 2, _array$1.buffer.byteLength)), _struct$1.Pad = new (go$nativeArray("Int8"))(_array$1.buffer, go$min(_array$1.byteOffset + 16, _array$1.buffer.byteLength));
		_tuple = Syscall9(procWSARecvFrom.Addr(), 9, (s >>> 0), _array, (bufcnt >>> 0), recvd, flags, _array$1, fromlen, _array$2, croutine), r1 = _tuple[0], e1 = _tuple[2];
		_struct$2 = overlapped, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Internal = _view$2.getUintptr(0, true), _struct$2.InternalHigh = _view$2.getUintptr(4, true), _struct$2.Offset = _view$2.getUint32(8, true), _struct$2.OffsetHigh = _view$2.getUint32(12, true), _struct$2.HEvent = _view$2.getUintptr(16, true);
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WSASendTo = go$pkg.WSASendTo = function(s, bufs, bufcnt, sent, flags, to, tolen, overlapped, croutine) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, _array$2, _struct$2, _view$2, r1, e1;
		err = null;
		_array = new Uint8Array(8);
		_array$1 = new Uint8Array(112);
		_struct = bufs, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Len = _view.getUint32(0, true);
		_array$2 = new Uint8Array(20);
		_struct$1 = to, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Addr.Family = _view$1.getUint16(0, true), _struct$1.Addr.Data = new (go$nativeArray("Int8"))(_array$1.buffer, go$min(_array$1.byteOffset + 2, _array$1.buffer.byteLength)), _struct$1.Pad = new (go$nativeArray("Int8"))(_array$1.buffer, go$min(_array$1.byteOffset + 16, _array$1.buffer.byteLength));
		_tuple = Syscall9(procWSASendTo.Addr(), 9, (s >>> 0), _array, (bufcnt >>> 0), sent, (flags >>> 0), _array$1, (tolen >>> 0), _array$2, croutine), r1 = _tuple[0], e1 = _tuple[2];
		_struct$2 = overlapped, _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Internal = _view$2.getUintptr(0, true), _struct$2.InternalHigh = _view$2.getUintptr(4, true), _struct$2.Offset = _view$2.getUint32(8, true), _struct$2.OffsetHigh = _view$2.getUint32(12, true), _struct$2.HEvent = _view$2.getUintptr(16, true);
		if (r1 === 4294967295) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetHostByName = go$pkg.GetHostByName = function(name) {
		var h, err, _p0, _tuple, _tuple$1, r0, e1, _array, _struct, _view;
		h = (go$ptrType(Hostent)).nil;
		err = null;
		_p0 = (go$ptrType(Go$Uint8)).nil;
		_tuple = BytePtrFromString(name), _p0 = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [h, err];
		}
		_tuple$1 = Syscall(procgethostbyname.Addr(), 1, _p0, 0, 0), r0 = _tuple$1[0], e1 = _tuple$1[2];
		h = (_array = r0, _struct = new Hostent.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct.AddrType = _view.getUint16(8, true), _struct.Length = _view.getUint16(10, true), _struct);
		if (h === (go$ptrType(Hostent)).nil) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [h, err];
	};
	var GetServByName = go$pkg.GetServByName = function(name, proto) {
		var s, err, _p0, _tuple, _p1, _tuple$1, _tuple$2, r0, e1, _array, _struct, _view;
		s = (go$ptrType(Servent)).nil;
		err = null;
		_p0 = (go$ptrType(Go$Uint8)).nil;
		_tuple = BytePtrFromString(name), _p0 = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [s, err];
		}
		_p1 = (go$ptrType(Go$Uint8)).nil;
		_tuple$1 = BytePtrFromString(proto), _p1 = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [s, err];
		}
		_tuple$2 = Syscall(procgetservbyname.Addr(), 2, _p0, _p1, 0), r0 = _tuple$2[0], e1 = _tuple$2[2];
		s = (_array = r0, _struct = new Servent.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct.Port = _view.getUint16(12, true), _struct);
		if (s === (go$ptrType(Servent)).nil) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [s, err];
	};
	var Ntohs = go$pkg.Ntohs = function(netshort) {
		var u, _tuple, r0;
		u = 0;
		_tuple = Syscall(procntohs.Addr(), 1, (netshort >>> 0), 0, 0), r0 = _tuple[0];
		u = (r0 << 16 >>> 16);
		return u;
	};
	var GetProtoByName = go$pkg.GetProtoByName = function(name) {
		var p, err, _p0, _tuple, _tuple$1, r0, e1, _array, _struct, _view;
		p = (go$ptrType(Protoent)).nil;
		err = null;
		_p0 = (go$ptrType(Go$Uint8)).nil;
		_tuple = BytePtrFromString(name), _p0 = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [p, err];
		}
		_tuple$1 = Syscall(procgetprotobyname.Addr(), 1, _p0, 0, 0), r0 = _tuple$1[0], e1 = _tuple$1[2];
		p = (_array = r0, _struct = new Protoent.Ptr(), _view = new DataView(_array.buffer, _array.byteOffset), _struct.Proto = _view.getUint16(8, true), _struct);
		if (p === (go$ptrType(Protoent)).nil) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [p, err];
	};
	var DnsQuery = go$pkg.DnsQuery = function(name, qtype, options, extra, qrs, pr) {
		var status, _p0, _tuple, _tuple$1, r0;
		status = null;
		_p0 = (go$ptrType(Go$Uint16)).nil;
		_tuple = UTF16PtrFromString(name), _p0 = _tuple[0], status = _tuple[1];
		if (!(go$interfaceIsEqual(status, null))) {
			return status;
		}
		_tuple$1 = Syscall6(procDnsQuery_W.Addr(), 6, _p0, (qtype >>> 0), (options >>> 0), extra, qrs, pr), r0 = _tuple$1[0];
		if (!((r0 === 0))) {
			status = new Errno((r0 >>> 0));
		}
		return status;
	};
	var DnsRecordListFree = go$pkg.DnsRecordListFree = function(rl, freetype) {
		var _array, _struct, _view;
		_array = new Uint8Array(64);
		Syscall(procDnsRecordListFree.Addr(), 2, _array, (freetype >>> 0), 0);
		_struct = rl, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Type = _view.getUint16(8, true), _struct.Length = _view.getUint16(10, true), _struct.Dw = _view.getUint32(12, true), _struct.Ttl = _view.getUint32(16, true), _struct.Reserved = _view.getUint32(20, true), _struct.Data = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 24, _array.buffer.byteLength));
		return;
	};
	var GetAddrInfoW = go$pkg.GetAddrInfoW = function(nodename, servicename, hints, result) {
		var sockerr, _tuple, _array, _struct, _view, r0;
		sockerr = null;
		_array = new Uint8Array(32);
		_tuple = Syscall6(procGetAddrInfoW.Addr(), 4, nodename, servicename, _array, result, 0, 0), r0 = _tuple[0];
		_struct = hints, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Flags = _view.getInt32(0, true), _struct.Family = _view.getInt32(4, true), _struct.Socktype = _view.getInt32(8, true), _struct.Protocol = _view.getInt32(12, true), _struct.Addrlen = _view.getUintptr(16, true), _struct.Addr = _view.getUintptr(24, true);
		if (!((r0 === 0))) {
			sockerr = new Errno((r0 >>> 0));
		}
		return sockerr;
	};
	var FreeAddrInfoW = go$pkg.FreeAddrInfoW = function(addrinfo) {
		var _array, _struct, _view;
		_array = new Uint8Array(32);
		Syscall(procFreeAddrInfoW.Addr(), 1, _array, 0, 0);
		_struct = addrinfo, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Flags = _view.getInt32(0, true), _struct.Family = _view.getInt32(4, true), _struct.Socktype = _view.getInt32(8, true), _struct.Protocol = _view.getInt32(12, true), _struct.Addrlen = _view.getUintptr(16, true), _struct.Addr = _view.getUintptr(24, true);
		return;
	};
	var GetIfEntry = go$pkg.GetIfEntry = function(pIfRow) {
		var errcode, _tuple, _array, _struct, _view, r0;
		errcode = null;
		_array = new Uint8Array(860);
		_tuple = Syscall(procGetIfEntry.Addr(), 1, _array, 0, 0), r0 = _tuple[0];
		_struct = pIfRow, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Name = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Index = _view.getUint32(512, true), _struct.Type = _view.getUint32(516, true), _struct.Mtu = _view.getUint32(520, true), _struct.Speed = _view.getUint32(524, true), _struct.PhysAddrLen = _view.getUint32(528, true), _struct.PhysAddr = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 532, _array.buffer.byteLength)), _struct.AdminStatus = _view.getUint32(540, true), _struct.OperStatus = _view.getUint32(544, true), _struct.LastChange = _view.getUint32(548, true), _struct.InOctets = _view.getUint32(552, true), _struct.InUcastPkts = _view.getUint32(556, true), _struct.InNUcastPkts = _view.getUint32(560, true), _struct.InDiscards = _view.getUint32(564, true), _struct.InErrors = _view.getUint32(568, true), _struct.InUnknownProtos = _view.getUint32(572, true), _struct.OutOctets = _view.getUint32(576, true), _struct.OutUcastPkts = _view.getUint32(580, true), _struct.OutNUcastPkts = _view.getUint32(584, true), _struct.OutDiscards = _view.getUint32(588, true), _struct.OutErrors = _view.getUint32(592, true), _struct.OutQLen = _view.getUint32(596, true), _struct.DescrLen = _view.getUint32(600, true), _struct.Descr = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 604, _array.buffer.byteLength));
		if (!((r0 === 0))) {
			errcode = new Errno((r0 >>> 0));
		}
		return errcode;
	};
	var GetAdaptersInfo = go$pkg.GetAdaptersInfo = function(ai, ol) {
		var errcode, _tuple, _array, _struct, _view, r0;
		errcode = null;
		_array = new Uint8Array(648);
		_tuple = Syscall(procGetAdaptersInfo.Addr(), 2, _array, ol, 0), r0 = _tuple[0];
		_struct = ai, _view = new DataView(_array.buffer, _array.byteOffset), _struct.ComboIndex = _view.getUint32(4, true), _struct.AdapterName = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 8, _array.buffer.byteLength)), _struct.Description = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 268, _array.buffer.byteLength)), _struct.AddressLength = _view.getUint32(400, true), _struct.Address = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 404, _array.buffer.byteLength)), _struct.Index = _view.getUint32(412, true), _struct.Type = _view.getUint32(416, true), _struct.DhcpEnabled = _view.getUint32(420, true), _struct.IpAddressList.IpAddress.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 432, _array.buffer.byteLength)), _struct.IpAddressList.IpMask.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 448, _array.buffer.byteLength)), _struct.IpAddressList.Context = _view.getUint32(464, true), _struct.GatewayList.IpAddress.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 472, _array.buffer.byteLength)), _struct.GatewayList.IpMask.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 488, _array.buffer.byteLength)), _struct.GatewayList.Context = _view.getUint32(504, true), _struct.DhcpServer.IpAddress.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 512, _array.buffer.byteLength)), _struct.DhcpServer.IpMask.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 528, _array.buffer.byteLength)), _struct.DhcpServer.Context = _view.getUint32(544, true), _struct.PrimaryWinsServer.IpAddress.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 556, _array.buffer.byteLength)), _struct.PrimaryWinsServer.IpMask.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 572, _array.buffer.byteLength)), _struct.PrimaryWinsServer.Context = _view.getUint32(588, true), _struct.SecondaryWinsServer.IpAddress.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 596, _array.buffer.byteLength)), _struct.SecondaryWinsServer.IpMask.String = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 612, _array.buffer.byteLength)), _struct.SecondaryWinsServer.Context = _view.getUint32(628, true), _struct.LeaseObtained = new Go$Int64(_view.getUint32(636, true), _view.getUint32(632, true)), _struct.LeaseExpires = new Go$Int64(_view.getUint32(644, true), _view.getUint32(640, true));
		if (!((r0 === 0))) {
			errcode = new Errno((r0 >>> 0));
		}
		return errcode;
	};
	var SetFileCompletionNotificationModes = go$pkg.SetFileCompletionNotificationModes = function(handle, flags) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procSetFileCompletionNotificationModes.Addr(), 2, (handle >>> 0), (flags >>> 0), 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var WSAEnumProtocols = go$pkg.WSAEnumProtocols = function(protocols, protocolBuffer, bufferLength) {
		var n, err, _tuple, _array, _struct, _view, r0, e1;
		n = 0;
		err = null;
		_array = new Uint8Array(628);
		_tuple = Syscall(procWSAEnumProtocolsW.Addr(), 3, protocols, _array, bufferLength), r0 = _tuple[0], e1 = _tuple[2];
		_struct = protocolBuffer, _view = new DataView(_array.buffer, _array.byteOffset), _struct.ServiceFlags1 = _view.getUint32(0, true), _struct.ServiceFlags2 = _view.getUint32(4, true), _struct.ServiceFlags3 = _view.getUint32(8, true), _struct.ServiceFlags4 = _view.getUint32(12, true), _struct.ProviderFlags = _view.getUint32(16, true), _struct.ProviderId.Data1 = _view.getUint32(20, true), _struct.ProviderId.Data2 = _view.getUint16(24, true), _struct.ProviderId.Data3 = _view.getUint16(26, true), _struct.ProviderId.Data4 = new (go$nativeArray("Uint8"))(_array.buffer, go$min(_array.byteOffset + 28, _array.buffer.byteLength)), _struct.CatalogEntryId = _view.getUint32(36, true), _struct.ProtocolChain.ChainLen = _view.getInt32(40, true), _struct.ProtocolChain.ChainEntries = new (go$nativeArray("Uint32"))(_array.buffer, go$min(_array.byteOffset + 44, _array.buffer.byteLength)), _struct.Version = _view.getInt32(72, true), _struct.AddressFamily = _view.getInt32(76, true), _struct.MaxSockAddr = _view.getInt32(80, true), _struct.MinSockAddr = _view.getInt32(84, true), _struct.SocketType = _view.getInt32(88, true), _struct.Protocol = _view.getInt32(92, true), _struct.ProtocolMaxOffset = _view.getInt32(96, true), _struct.NetworkByteOrder = _view.getInt32(100, true), _struct.SecurityScheme = _view.getInt32(104, true), _struct.MessageSize = _view.getUint32(108, true), _struct.ProviderReserved = _view.getUint32(112, true), _struct.ProtocolName = new (go$nativeArray("Uint16"))(_array.buffer, go$min(_array.byteOffset + 116, _array.buffer.byteLength));
		n = (r0 >> 0);
		if (n === -1) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return [n, err];
	};
	var TranslateName = go$pkg.TranslateName = function(accName, accNameFormat, desiredNameFormat, translatedName, nSize) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procTranslateNameW.Addr(), 5, accName, (accNameFormat >>> 0), (desiredNameFormat >>> 0), translatedName, nSize, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (((r1 & 255) >>> 0) === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetUserNameEx = go$pkg.GetUserNameEx = function(nameFormat, nameBuffre, nSize) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procGetUserNameExW.Addr(), 3, (nameFormat >>> 0), nameBuffre, nSize), r1 = _tuple[0], e1 = _tuple[2];
		if (((r1 & 255) >>> 0) === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var NetUserGetInfo = go$pkg.NetUserGetInfo = function(serverName, userName, level, buf) {
		var neterr, _tuple, r0;
		neterr = null;
		_tuple = Syscall6(procNetUserGetInfo.Addr(), 4, serverName, userName, (level >>> 0), buf, 0, 0), r0 = _tuple[0];
		if (!((r0 === 0))) {
			neterr = new Errno((r0 >>> 0));
		}
		return neterr;
	};
	var NetGetJoinInformation = go$pkg.NetGetJoinInformation = function(server, name, bufType) {
		var neterr, _tuple, r0;
		neterr = null;
		_tuple = Syscall(procNetGetJoinInformation.Addr(), 3, server, name, bufType), r0 = _tuple[0];
		if (!((r0 === 0))) {
			neterr = new Errno((r0 >>> 0));
		}
		return neterr;
	};
	var NetApiBufferFree = go$pkg.NetApiBufferFree = function(buf) {
		var neterr, _tuple, r0;
		neterr = null;
		_tuple = Syscall(procNetApiBufferFree.Addr(), 1, buf, 0, 0), r0 = _tuple[0];
		if (!((r0 === 0))) {
			neterr = new Errno((r0 >>> 0));
		}
		return neterr;
	};
	var LookupAccountSid = go$pkg.LookupAccountSid = function(systemName, sid, name, nameLen, refdDomainName, refdDomainNameLen, use) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(0);
		_tuple = Syscall9(procLookupAccountSidW.Addr(), 7, systemName, _array, name, nameLen, refdDomainName, refdDomainNameLen, use, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = sid, _view = new DataView(_array.buffer, _array.byteOffset);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var LookupAccountName = go$pkg.LookupAccountName = function(systemName, accountName, sid, sidLen, refdDomainName, refdDomainNameLen, use) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(0);
		_tuple = Syscall9(procLookupAccountNameW.Addr(), 7, systemName, accountName, _array, sidLen, refdDomainName, refdDomainNameLen, use, 0, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = sid, _view = new DataView(_array.buffer, _array.byteOffset);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var ConvertSidToStringSid = go$pkg.ConvertSidToStringSid = function(sid, stringSid) {
		var err, _tuple, _array, _struct, _view, r1, e1;
		err = null;
		_array = new Uint8Array(0);
		_tuple = Syscall(procConvertSidToStringSidW.Addr(), 2, _array, stringSid, 0), r1 = _tuple[0], e1 = _tuple[2];
		_struct = sid, _view = new DataView(_array.buffer, _array.byteOffset);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var ConvertStringSidToSid = go$pkg.ConvertStringSidToSid = function(stringSid, sid) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procConvertStringSidToSidW.Addr(), 2, stringSid, sid, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetLengthSid = go$pkg.GetLengthSid = function(sid) {
		var len, _tuple, _array, _struct, _view, r0;
		len = 0;
		_array = new Uint8Array(0);
		_tuple = Syscall(procGetLengthSid.Addr(), 1, _array, 0, 0), r0 = _tuple[0];
		_struct = sid, _view = new DataView(_array.buffer, _array.byteOffset);
		len = (r0 >>> 0);
		return len;
	};
	var CopySid = go$pkg.CopySid = function(destSidLen, destSid, srcSid) {
		var err, _tuple, _array, _struct, _view, _array$1, _struct$1, _view$1, r1, e1;
		err = null;
		_array = new Uint8Array(0);
		_array$1 = new Uint8Array(0);
		_struct = destSid, _view = new DataView(_array.buffer, _array.byteOffset);
		_tuple = Syscall(procCopySid.Addr(), 3, (destSidLen >>> 0), _array, _array$1), r1 = _tuple[0], e1 = _tuple[2];
		_struct$1 = srcSid, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset);
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var OpenProcessToken = go$pkg.OpenProcessToken = function(h, access, token) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procOpenProcessToken.Addr(), 3, (h >>> 0), (access >>> 0), token), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetTokenInformation = go$pkg.GetTokenInformation = function(t, infoClass, info, infoLen, returnedLen) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall6(procGetTokenInformation.Addr(), 5, (t >>> 0), (infoClass >>> 0), info, (infoLen >>> 0), returnedLen, 0), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	var GetUserProfileDirectory = go$pkg.GetUserProfileDirectory = function(t, dir, dirLen) {
		var err, _tuple, r1, e1;
		err = null;
		_tuple = Syscall(procGetUserProfileDirectoryW.Addr(), 3, (t >>> 0), dir, dirLen), r1 = _tuple[0], e1 = _tuple[2];
		if (r1 === 0) {
			if (!((e1 === 0))) {
				err = new Errno(e1);
			} else {
				err = new Errno(536870951);
			}
		}
		return err;
	};
	Timeval.Ptr.prototype.Nanoseconds = function() {
		var tv, x, x$1;
		tv = this;
		return go$mul64(((x = go$mul64(new Go$Int64(0, tv.Sec), new Go$Int64(0, 1000000)), x$1 = new Go$Int64(0, tv.Usec), new Go$Int64(x.high + x$1.high, x.low + x$1.low))), new Go$Int64(0, 1000));
	};
	Timeval.prototype.Nanoseconds = function() { return this.go$val.Nanoseconds(); };
	var NsecToTimeval = go$pkg.NsecToTimeval = function(nsec) {
		var tv, x, x$1, _struct;
		tv = new Timeval.Ptr();
		tv.Sec = ((x = go$div64(nsec, new Go$Int64(0, 1000000000), false), x.low + ((x.high >> 31) * 4294967296)) >> 0);
		tv.Usec = ((x$1 = go$div64(go$div64(nsec, new Go$Int64(0, 1000000000), true), new Go$Int64(0, 1000), false), x$1.low + ((x$1.high >> 31) * 4294967296)) >> 0);
		return (_struct = tv, new Timeval.Ptr(_struct.Sec, _struct.Usec));
	};
	Filetime.Ptr.prototype.Nanoseconds = function() {
		var ft, x, x$1, nsec;
		ft = this;
		nsec = (x = go$shiftLeft64(new Go$Int64(0, ft.HighDateTime), 32), x$1 = new Go$Int64(0, ft.LowDateTime), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
		nsec = new Go$Int64(nsec.high - 27111902, nsec.low - 3577643008);
		nsec = go$mul64(nsec, new Go$Int64(0, 100));
		return nsec;
	};
	Filetime.prototype.Nanoseconds = function() { return this.go$val.Nanoseconds(); };
	var NsecToFiletime = go$pkg.NsecToFiletime = function(nsec) {
		var ft, x, _struct, _struct$1;
		ft = new Filetime.Ptr();
		nsec = go$div64(nsec, new Go$Int64(0, 100), false);
		nsec = new Go$Int64(nsec.high + 27111902, nsec.low + 3577643008);
		ft.LowDateTime = (new Go$Int64(nsec.high & 0, (nsec.low & 4294967295) >>> 0).low >>> 0);
		ft.HighDateTime = ((x = go$shiftRightInt64(nsec, 32), new Go$Int64(x.high & 0, (x.low & 4294967295) >>> 0)).low >>> 0);
		ft = (_struct = ft, new Filetime.Ptr(_struct.LowDateTime, _struct.HighDateTime));
		return (_struct$1 = ft, new Filetime.Ptr(_struct$1.LowDateTime, _struct$1.HighDateTime));
	};
	var copyFindData = function(dst, src) {
		var _struct, _struct$1, _struct$2;
		dst.FileAttributes = src.FileAttributes;
		dst.CreationTime = (_struct = src.CreationTime, new Filetime.Ptr(_struct.LowDateTime, _struct.HighDateTime));
		dst.LastAccessTime = (_struct$1 = src.LastAccessTime, new Filetime.Ptr(_struct$1.LowDateTime, _struct$1.HighDateTime));
		dst.LastWriteTime = (_struct$2 = src.LastWriteTime, new Filetime.Ptr(_struct$2.LowDateTime, _struct$2.HighDateTime));
		dst.FileSizeHigh = src.FileSizeHigh;
		dst.FileSizeLow = src.FileSizeLow;
		dst.Reserved0 = src.Reserved0;
		dst.Reserved1 = src.Reserved1;
		go$copySlice(new (go$sliceType(Go$Uint16))(dst.FileName), new (go$sliceType(Go$Uint16))(src.FileName));
		go$copySlice(new (go$sliceType(Go$Uint16))(dst.AlternateFileName), new (go$sliceType(Go$Uint16))(src.AlternateFileName));
	};
	go$pkg.init = function() {
		go$pkg.ForkLock = new sync.RWMutex.Ptr();
		zeroProcAttr = new ProcAttr.Ptr();
		zeroSysProcAttr = new SysProcAttr.Ptr();
		_zero = 0;
		ioSync = new Go$Int64(0, 0);
		go$pkg.SocketDisableIPv6 = false;
		connectExFunc = new (go$structType([["once", "syscall", sync.Once, ""], ["addr", "syscall", Go$Uintptr, ""], ["err", "syscall", go$error, ""]])).Ptr(new sync.Once.Ptr(), 0, null);

			if (go$pkg.Syscall15 !== undefined) { // windows
				Syscall = Syscall6 = Syscall9 = Syscall12 = Syscall15 = go$pkg.Syscall = go$pkg.Syscall6 = go$pkg.Syscall9 = go$pkg.Syscall12 = go$pkg.Syscall15 = loadlibrary = getprocaddress = function() { throw "Syscalls not available." };
				getStdHandle = GetCommandLine = go$pkg.GetCommandLine = function() {};
				CommandLineToArgv = go$pkg.CommandLineToArgv = function() { return [null, {}]; };
				Getenv = go$pkg.Getenv = function(key) { return ["", false]; };
				GetTimeZoneInformation = go$pkg.GetTimeZoneInformation = function() { return [undefined, true]; };
			} else if (typeof process === "undefined") {
				go$pkg.go$setSyscall = function(f) {
					Syscall = Syscall6 = RawSyscall = RawSyscall6 = go$pkg.Syscall = go$pkg.Syscall6 = go$pkg.RawSyscall = go$pkg.RawSyscall6 = f;
				}
				go$pkg.go$setSyscall(function() { throw "Syscalls not available." });
				envs = new (go$sliceType(Go$String))(new Array(0));
			} else {
				var syscall = require("syscall");
				Syscall = go$pkg.Syscall = syscall.Syscall;
				Syscall6 = go$pkg.Syscall6 = syscall.Syscall6;
				RawSyscall = go$pkg.RawSyscall = syscall.Syscall;
				RawSyscall6 = go$pkg.RawSyscall6 = syscall.Syscall6;
				BytePtrFromString = go$pkg.BytePtrFromString = function(s) { return [go$stringToBytes(s, true), null]; };

				var envkeys = Object.keys(process.env);
				envs = new (go$sliceType(Go$String))(new Array(envkeys.length));
				var i;
				for(i = 0; i < envkeys.length; i++) {
					envs.array[i] = envkeys[i] + "=" + process.env[envkeys[i]];
				}
			}
				modkernel32 = NewLazyDLL("kernel32.dll");
		procSetHandleInformation = modkernel32.NewProc("SetHandleInformation");
		procGetStdHandle = modkernel32.NewProc("GetStdHandle");
		go$pkg.Stdin = getStdHandle(-10);
		go$pkg.Stdout = getStdHandle(-11);
		go$pkg.Stderr = getStdHandle(-12);
		errors = go$toNativeArray("String", ["argument list too long", "permission denied", "address already in use", "cannot assign requested address", "advertise error", "address family not supported by protocol", "resource temporarily unavailable", "operation already in progress", "invalid exchange", "bad file descriptor", "file descriptor in bad state", "bad message", "invalid request descriptor", "invalid request code", "invalid slot", "bad font file format", "device or resource busy", "operation canceled", "no child processes", "channel number out of range", "communication error on send", "software caused connection abort", "connection refused", "connection reset by peer", "resource deadlock avoided", "resource deadlock avoided", "destination address required", "numerical argument out of domain", "RFS specific error", "disk quota exceeded", "file exists", "bad address", "file too large", "host is down", "no route to host", "identifier removed", "invalid or incomplete multibyte or wide character", "operation now in progress", "interrupted system call", "invalid argument", "input/output error", "transport endpoint is already connected", "is a directory", "is a named type file", "key has expired", "key was rejected by service", "key has been revoked", "level 2 halted", "level 2 not synchronized", "level 3 halted", "level 3 reset", "can not access a needed shared library", "accessing a corrupted shared library", "cannot exec a shared library directly", "attempting to link in too many shared libraries", ".lib section in a.out corrupted", "link number out of range", "too many levels of symbolic links", "wrong medium type", "too many open files", "too many links", "message too long", "multihop attempted", "file name too long", "no XENIX semaphores available", "network is down", "network dropped connection on reset", "network is unreachable", "too many open files in system", "no anode", "no buffer space available", "no CSI structure available", "no data available", "no such device", "exec format error", "required key not available", "no locks available", "link has been severed", "no medium found", "cannot allocate memory", "no message of desired type", "machine is not on the network", "package not installed", "protocol not available", "no space left on device", "out of streams resources", "device not a stream", "function not implemented", "block device required", "transport endpoint is not connected", "directory not empty", "not a XENIX named type file", "state not recoverable", "socket operation on non-socket", "operation not supported", "inappropriate ioctl for device", "name not unique on network", "no such device or address", "operation not supported", "value too large for defined data type", "owner died", "operation not permitted", "protocol family not supported", "broken pipe", "protocol error", "protocol not supported", "protocol wrong type for socket", "numerical result out of range", "remote address changed", "object is remote", "remote I/O error", "interrupted system call should be restarted", "read-only file system", "cannot send after transport endpoint shutdown", "socket type not supported", "illegal seek", "no such process", "srmount error", "stale NFS file handle", "streams pipe error", "timer expired", "connection timed out", "too many references: cannot splice", "text file busy", "structure needs cleaning", "protocol driver not attached", "too many users", "resource temporarily unavailable", "invalid cross-device link", "exchange full", "not supported by windows"]);
		modadvapi32 = NewLazyDLL("advapi32.dll");
		modshell32 = NewLazyDLL("shell32.dll");
		modmswsock = NewLazyDLL("mswsock.dll");
		modcrypt32 = NewLazyDLL("crypt32.dll");
		modws2_32 = NewLazyDLL("ws2_32.dll");
		moddnsapi = NewLazyDLL("dnsapi.dll");
		modiphlpapi = NewLazyDLL("iphlpapi.dll");
		modsecur32 = NewLazyDLL("secur32.dll");
		modnetapi32 = NewLazyDLL("netapi32.dll");
		moduserenv = NewLazyDLL("userenv.dll");
		procGetLastError = modkernel32.NewProc("GetLastError");
		procLoadLibraryW = modkernel32.NewProc("LoadLibraryW");
		procFreeLibrary = modkernel32.NewProc("FreeLibrary");
		procGetProcAddress = modkernel32.NewProc("GetProcAddress");
		procGetVersion = modkernel32.NewProc("GetVersion");
		procFormatMessageW = modkernel32.NewProc("FormatMessageW");
		procExitProcess = modkernel32.NewProc("ExitProcess");
		procCreateFileW = modkernel32.NewProc("CreateFileW");
		procReadFile = modkernel32.NewProc("ReadFile");
		procWriteFile = modkernel32.NewProc("WriteFile");
		procSetFilePointer = modkernel32.NewProc("SetFilePointer");
		procCloseHandle = modkernel32.NewProc("CloseHandle");
		procFindFirstFileW = modkernel32.NewProc("FindFirstFileW");
		procFindNextFileW = modkernel32.NewProc("FindNextFileW");
		procFindClose = modkernel32.NewProc("FindClose");
		procGetFileInformationByHandle = modkernel32.NewProc("GetFileInformationByHandle");
		procGetCurrentDirectoryW = modkernel32.NewProc("GetCurrentDirectoryW");
		procSetCurrentDirectoryW = modkernel32.NewProc("SetCurrentDirectoryW");
		procCreateDirectoryW = modkernel32.NewProc("CreateDirectoryW");
		procRemoveDirectoryW = modkernel32.NewProc("RemoveDirectoryW");
		procDeleteFileW = modkernel32.NewProc("DeleteFileW");
		procMoveFileW = modkernel32.NewProc("MoveFileW");
		procGetComputerNameW = modkernel32.NewProc("GetComputerNameW");
		procSetEndOfFile = modkernel32.NewProc("SetEndOfFile");
		procGetSystemTimeAsFileTime = modkernel32.NewProc("GetSystemTimeAsFileTime");
		procGetTimeZoneInformation = modkernel32.NewProc("GetTimeZoneInformation");
		procCreateIoCompletionPort = modkernel32.NewProc("CreateIoCompletionPort");
		procGetQueuedCompletionStatus = modkernel32.NewProc("GetQueuedCompletionStatus");
		procPostQueuedCompletionStatus = modkernel32.NewProc("PostQueuedCompletionStatus");
		procCancelIo = modkernel32.NewProc("CancelIo");
		procCancelIoEx = modkernel32.NewProc("CancelIoEx");
		procCreateProcessW = modkernel32.NewProc("CreateProcessW");
		procOpenProcess = modkernel32.NewProc("OpenProcess");
		procTerminateProcess = modkernel32.NewProc("TerminateProcess");
		procGetExitCodeProcess = modkernel32.NewProc("GetExitCodeProcess");
		procGetStartupInfoW = modkernel32.NewProc("GetStartupInfoW");
		procGetCurrentProcess = modkernel32.NewProc("GetCurrentProcess");
		procGetProcessTimes = modkernel32.NewProc("GetProcessTimes");
		procDuplicateHandle = modkernel32.NewProc("DuplicateHandle");
		procWaitForSingleObject = modkernel32.NewProc("WaitForSingleObject");
		procGetTempPathW = modkernel32.NewProc("GetTempPathW");
		procCreatePipe = modkernel32.NewProc("CreatePipe");
		procGetFileType = modkernel32.NewProc("GetFileType");
		procCryptAcquireContextW = modadvapi32.NewProc("CryptAcquireContextW");
		procCryptReleaseContext = modadvapi32.NewProc("CryptReleaseContext");
		procCryptGenRandom = modadvapi32.NewProc("CryptGenRandom");
		procGetEnvironmentStringsW = modkernel32.NewProc("GetEnvironmentStringsW");
		procFreeEnvironmentStringsW = modkernel32.NewProc("FreeEnvironmentStringsW");
		procGetEnvironmentVariableW = modkernel32.NewProc("GetEnvironmentVariableW");
		procSetEnvironmentVariableW = modkernel32.NewProc("SetEnvironmentVariableW");
		procSetFileTime = modkernel32.NewProc("SetFileTime");
		procGetFileAttributesW = modkernel32.NewProc("GetFileAttributesW");
		procSetFileAttributesW = modkernel32.NewProc("SetFileAttributesW");
		procGetFileAttributesExW = modkernel32.NewProc("GetFileAttributesExW");
		procGetCommandLineW = modkernel32.NewProc("GetCommandLineW");
		procCommandLineToArgvW = modshell32.NewProc("CommandLineToArgvW");
		procLocalFree = modkernel32.NewProc("LocalFree");
		procFlushFileBuffers = modkernel32.NewProc("FlushFileBuffers");
		procGetFullPathNameW = modkernel32.NewProc("GetFullPathNameW");
		procGetLongPathNameW = modkernel32.NewProc("GetLongPathNameW");
		procGetShortPathNameW = modkernel32.NewProc("GetShortPathNameW");
		procCreateFileMappingW = modkernel32.NewProc("CreateFileMappingW");
		procMapViewOfFile = modkernel32.NewProc("MapViewOfFile");
		procUnmapViewOfFile = modkernel32.NewProc("UnmapViewOfFile");
		procFlushViewOfFile = modkernel32.NewProc("FlushViewOfFile");
		procVirtualLock = modkernel32.NewProc("VirtualLock");
		procVirtualUnlock = modkernel32.NewProc("VirtualUnlock");
		procTransmitFile = modmswsock.NewProc("TransmitFile");
		procReadDirectoryChangesW = modkernel32.NewProc("ReadDirectoryChangesW");
		procCertOpenSystemStoreW = modcrypt32.NewProc("CertOpenSystemStoreW");
		procCertOpenStore = modcrypt32.NewProc("CertOpenStore");
		procCertEnumCertificatesInStore = modcrypt32.NewProc("CertEnumCertificatesInStore");
		procCertAddCertificateContextToStore = modcrypt32.NewProc("CertAddCertificateContextToStore");
		procCertCloseStore = modcrypt32.NewProc("CertCloseStore");
		procCertGetCertificateChain = modcrypt32.NewProc("CertGetCertificateChain");
		procCertFreeCertificateChain = modcrypt32.NewProc("CertFreeCertificateChain");
		procCertCreateCertificateContext = modcrypt32.NewProc("CertCreateCertificateContext");
		procCertFreeCertificateContext = modcrypt32.NewProc("CertFreeCertificateContext");
		procCertVerifyCertificateChainPolicy = modcrypt32.NewProc("CertVerifyCertificateChainPolicy");
		procRegOpenKeyExW = modadvapi32.NewProc("RegOpenKeyExW");
		procRegCloseKey = modadvapi32.NewProc("RegCloseKey");
		procRegQueryInfoKeyW = modadvapi32.NewProc("RegQueryInfoKeyW");
		procRegEnumKeyExW = modadvapi32.NewProc("RegEnumKeyExW");
		procRegQueryValueExW = modadvapi32.NewProc("RegQueryValueExW");
		procGetCurrentProcessId = modkernel32.NewProc("GetCurrentProcessId");
		procGetConsoleMode = modkernel32.NewProc("GetConsoleMode");
		procWriteConsoleW = modkernel32.NewProc("WriteConsoleW");
		procReadConsoleW = modkernel32.NewProc("ReadConsoleW");
		procWSAStartup = modws2_32.NewProc("WSAStartup");
		procWSACleanup = modws2_32.NewProc("WSACleanup");
		procWSAIoctl = modws2_32.NewProc("WSAIoctl");
		procsocket = modws2_32.NewProc("socket");
		procsetsockopt = modws2_32.NewProc("setsockopt");
		procgetsockopt = modws2_32.NewProc("getsockopt");
		procbind = modws2_32.NewProc("bind");
		procconnect = modws2_32.NewProc("connect");
		procgetsockname = modws2_32.NewProc("getsockname");
		procgetpeername = modws2_32.NewProc("getpeername");
		proclisten = modws2_32.NewProc("listen");
		procshutdown = modws2_32.NewProc("shutdown");
		procclosesocket = modws2_32.NewProc("closesocket");
		procAcceptEx = modmswsock.NewProc("AcceptEx");
		procGetAcceptExSockaddrs = modmswsock.NewProc("GetAcceptExSockaddrs");
		procWSARecv = modws2_32.NewProc("WSARecv");
		procWSASend = modws2_32.NewProc("WSASend");
		procWSARecvFrom = modws2_32.NewProc("WSARecvFrom");
		procWSASendTo = modws2_32.NewProc("WSASendTo");
		procgethostbyname = modws2_32.NewProc("gethostbyname");
		procgetservbyname = modws2_32.NewProc("getservbyname");
		procntohs = modws2_32.NewProc("ntohs");
		procgetprotobyname = modws2_32.NewProc("getprotobyname");
		procDnsQuery_W = moddnsapi.NewProc("DnsQuery_W");
		procDnsRecordListFree = moddnsapi.NewProc("DnsRecordListFree");
		procGetAddrInfoW = modws2_32.NewProc("GetAddrInfoW");
		procFreeAddrInfoW = modws2_32.NewProc("FreeAddrInfoW");
		procGetIfEntry = modiphlpapi.NewProc("GetIfEntry");
		procGetAdaptersInfo = modiphlpapi.NewProc("GetAdaptersInfo");
		procSetFileCompletionNotificationModes = modkernel32.NewProc("SetFileCompletionNotificationModes");
		procWSAEnumProtocolsW = modws2_32.NewProc("WSAEnumProtocolsW");
		procTranslateNameW = modsecur32.NewProc("TranslateNameW");
		procGetUserNameExW = modsecur32.NewProc("GetUserNameExW");
		procNetUserGetInfo = modnetapi32.NewProc("NetUserGetInfo");
		procNetGetJoinInformation = modnetapi32.NewProc("NetGetJoinInformation");
		procNetApiBufferFree = modnetapi32.NewProc("NetApiBufferFree");
		procLookupAccountSidW = modadvapi32.NewProc("LookupAccountSidW");
		procLookupAccountNameW = modadvapi32.NewProc("LookupAccountNameW");
		procConvertSidToStringSidW = modadvapi32.NewProc("ConvertSidToStringSidW");
		procConvertStringSidToSidW = modadvapi32.NewProc("ConvertStringSidToSidW");
		procGetLengthSid = modadvapi32.NewProc("GetLengthSid");
		procCopySid = modadvapi32.NewProc("CopySid");
		procOpenProcessToken = modadvapi32.NewProc("OpenProcessToken");
		procGetTokenInformation = modadvapi32.NewProc("GetTokenInformation");
		procGetUserProfileDirectoryW = moduserenv.NewProc("GetUserProfileDirectoryW");
		signals = go$toNativeArray("String", ["", "hangup", "interrupt", "quit", "illegal instruction", "trace/breakpoint trap", "aborted", "bus error", "floating point exception", "killed", "user defined signal 1", "segmentation fault", "user defined signal 2", "broken pipe", "alarm clock", "terminated"]);
		go$pkg.OID_PKIX_KP_SERVER_AUTH = new (go$sliceType(Go$Uint8))(go$stringToBytes("1.3.6.1.5.5.7.3.1\x00"));
		go$pkg.OID_SERVER_GATED_CRYPTO = new (go$sliceType(Go$Uint8))(go$stringToBytes("1.3.6.1.4.1.311.10.3.3\x00"));
		go$pkg.OID_SGC_NETSCAPE = new (go$sliceType(Go$Uint8))(go$stringToBytes("2.16.840.1.113730.4.1\x00"));
		go$pkg.WSAID_CONNECTEX = new GUID.Ptr(631375801, 56819, 18016, go$toNativeArray("Uint8", [142, 233, 118, 229, 140, 116, 6, 62]));
	};
	return go$pkg;
})();
go$packages["time"] = (function() {
	var go$pkg = {};
	var errors = go$packages["errors"];
	var syscall = go$packages["syscall"];
	var sync = go$packages["sync"];
	var runtime = go$packages["runtime"];
	var ParseError;
	ParseError = go$newType(0, "Struct", "time.ParseError", "ParseError", "time", function(Layout_, Value_, LayoutElem_, ValueElem_, Message_) {
		this.go$val = this;
		this.Layout = Layout_ !== undefined ? Layout_ : "";
		this.Value = Value_ !== undefined ? Value_ : "";
		this.LayoutElem = LayoutElem_ !== undefined ? LayoutElem_ : "";
		this.ValueElem = ValueElem_ !== undefined ? ValueElem_ : "";
		this.Message = Message_ !== undefined ? Message_ : "";
	});
	go$pkg.ParseError = ParseError;
	var runtimeTimer;
	runtimeTimer = go$newType(0, "Struct", "time.runtimeTimer", "runtimeTimer", "time", function(i_, when_, period_, f_, arg_) {
		this.go$val = this;
		this.i = i_ !== undefined ? i_ : 0;
		this.when = when_ !== undefined ? when_ : new Go$Int64(0, 0);
		this.period = period_ !== undefined ? period_ : new Go$Int64(0, 0);
		this.f = f_ !== undefined ? f_ : go$throwNilPointerError;
		this.arg = arg_ !== undefined ? arg_ : null;
	});
	go$pkg.runtimeTimer = runtimeTimer;
	var Timer;
	Timer = go$newType(0, "Struct", "time.Timer", "Timer", "time", function(C_, r_) {
		this.go$val = this;
		this.C = C_ !== undefined ? C_ : (go$chanType(Time, false, true)).nil;
		this.r = r_ !== undefined ? r_ : new runtimeTimer.Ptr();
	});
	go$pkg.Timer = Timer;
	var Ticker;
	Ticker = go$newType(0, "Struct", "time.Ticker", "Ticker", "time", function(C_, r_) {
		this.go$val = this;
		this.C = C_ !== undefined ? C_ : (go$chanType(Time, false, true)).nil;
		this.r = r_ !== undefined ? r_ : new runtimeTimer.Ptr();
	});
	go$pkg.Ticker = Ticker;
	var Time;
	Time = go$newType(0, "Struct", "time.Time", "Time", "time", function(sec_, nsec_, loc_) {
		this.go$val = this;
		this.sec = sec_ !== undefined ? sec_ : new Go$Int64(0, 0);
		this.nsec = nsec_ !== undefined ? nsec_ : 0;
		this.loc = loc_ !== undefined ? loc_ : (go$ptrType(Location)).nil;
	});
	go$pkg.Time = Time;
	var Month;
	Month = go$newType(4, "Int", "time.Month", "Month", "time", null);
	go$pkg.Month = Month;
	var Weekday;
	Weekday = go$newType(4, "Int", "time.Weekday", "Weekday", "time", null);
	go$pkg.Weekday = Weekday;
	var Duration;
	Duration = go$newType(8, "Int64", "time.Duration", "Duration", "time", null);
	go$pkg.Duration = Duration;
	var Location;
	Location = go$newType(0, "Struct", "time.Location", "Location", "time", function(name_, zone_, tx_, cacheStart_, cacheEnd_, cacheZone_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.zone = zone_ !== undefined ? zone_ : (go$sliceType(zone)).nil;
		this.tx = tx_ !== undefined ? tx_ : (go$sliceType(zoneTrans)).nil;
		this.cacheStart = cacheStart_ !== undefined ? cacheStart_ : new Go$Int64(0, 0);
		this.cacheEnd = cacheEnd_ !== undefined ? cacheEnd_ : new Go$Int64(0, 0);
		this.cacheZone = cacheZone_ !== undefined ? cacheZone_ : (go$ptrType(zone)).nil;
	});
	go$pkg.Location = Location;
	var zone;
	zone = go$newType(0, "Struct", "time.zone", "zone", "time", function(name_, offset_, isDST_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.offset = offset_ !== undefined ? offset_ : 0;
		this.isDST = isDST_ !== undefined ? isDST_ : false;
	});
	go$pkg.zone = zone;
	var zoneTrans;
	zoneTrans = go$newType(0, "Struct", "time.zoneTrans", "zoneTrans", "time", function(when_, index_, isstd_, isutc_) {
		this.go$val = this;
		this.when = when_ !== undefined ? when_ : new Go$Int64(0, 0);
		this.index = index_ !== undefined ? index_ : 0;
		this.isstd = isstd_ !== undefined ? isstd_ : false;
		this.isutc = isutc_ !== undefined ? isutc_ : false;
	});
	go$pkg.zoneTrans = zoneTrans;
	var abbr;
	abbr = go$newType(0, "Struct", "time.abbr", "abbr", "time", function(std_, dst_) {
		this.go$val = this;
		this.std = std_ !== undefined ? std_ : "";
		this.dst = dst_ !== undefined ? dst_ : "";
	});
	go$pkg.abbr = abbr;
	var data;
	data = go$newType(0, "Struct", "time.data", "data", "time", function(p_, error_) {
		this.go$val = this;
		this.p = p_ !== undefined ? p_ : (go$sliceType(Go$Uint8)).nil;
		this.error = error_ !== undefined ? error_ : false;
	});
	go$pkg.data = data;
	ParseError.init([["Layout", "", Go$String, ""], ["Value", "", Go$String, ""], ["LayoutElem", "", Go$String, ""], ["ValueElem", "", Go$String, ""], ["Message", "", Go$String, ""]]);
	(go$ptrType(ParseError)).methods = [["Error", "", [], [Go$String], false]];
	runtimeTimer.init([["i", "time", Go$Int32, ""], ["when", "time", Go$Int64, ""], ["period", "time", Go$Int64, ""], ["f", "time", (go$funcType([Go$Int64, go$emptyInterface], [], false)), ""], ["arg", "time", go$emptyInterface, ""]]);
	Timer.init([["C", "", (go$chanType(Time, false, true)), ""], ["r", "time", runtimeTimer, ""]]);
	(go$ptrType(Timer)).methods = [["Reset", "", [Duration], [Go$Bool], false], ["Stop", "", [], [Go$Bool], false]];
	Ticker.init([["C", "", (go$chanType(Time, false, true)), ""], ["r", "time", runtimeTimer, ""]]);
	(go$ptrType(Ticker)).methods = [["Stop", "", [], [], false]];
	Time.init([["sec", "time", Go$Int64, ""], ["nsec", "time", Go$Uintptr, ""], ["loc", "time", (go$ptrType(Location)), ""]]);
	Time.methods = [["Add", "", [Duration], [Time], false], ["AddDate", "", [Go$Int, Go$Int, Go$Int], [Time], false], ["After", "", [Time], [Go$Bool], false], ["Before", "", [Time], [Go$Bool], false], ["Clock", "", [], [Go$Int, Go$Int, Go$Int], false], ["Date", "", [], [Go$Int, Month, Go$Int], false], ["Day", "", [], [Go$Int], false], ["Equal", "", [Time], [Go$Bool], false], ["Format", "", [Go$String], [Go$String], false], ["GobEncode", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["Hour", "", [], [Go$Int], false], ["ISOWeek", "", [], [Go$Int, Go$Int], false], ["In", "", [(go$ptrType(Location))], [Time], false], ["IsZero", "", [], [Go$Bool], false], ["Local", "", [], [Time], false], ["Location", "", [], [(go$ptrType(Location))], false], ["MarshalBinary", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["MarshalJSON", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["MarshalText", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["Minute", "", [], [Go$Int], false], ["Month", "", [], [Month], false], ["Nanosecond", "", [], [Go$Int], false], ["Round", "", [Duration], [Time], false], ["Second", "", [], [Go$Int], false], ["String", "", [], [Go$String], false], ["Sub", "", [Time], [Duration], false], ["Truncate", "", [Duration], [Time], false], ["UTC", "", [], [Time], false], ["Unix", "", [], [Go$Int64], false], ["UnixNano", "", [], [Go$Int64], false], ["Weekday", "", [], [Weekday], false], ["Year", "", [], [Go$Int], false], ["YearDay", "", [], [Go$Int], false], ["Zone", "", [], [Go$String, Go$Int], false], ["abs", "time", [], [Go$Uint64], false], ["date", "time", [Go$Bool], [Go$Int, Month, Go$Int, Go$Int], false], ["locabs", "time", [], [Go$String, Go$Int, Go$Uint64], false]];
	(go$ptrType(Time)).methods = [["Add", "", [Duration], [Time], false], ["AddDate", "", [Go$Int, Go$Int, Go$Int], [Time], false], ["After", "", [Time], [Go$Bool], false], ["Before", "", [Time], [Go$Bool], false], ["Clock", "", [], [Go$Int, Go$Int, Go$Int], false], ["Date", "", [], [Go$Int, Month, Go$Int], false], ["Day", "", [], [Go$Int], false], ["Equal", "", [Time], [Go$Bool], false], ["Format", "", [Go$String], [Go$String], false], ["GobDecode", "", [(go$sliceType(Go$Uint8))], [go$error], false], ["GobEncode", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["Hour", "", [], [Go$Int], false], ["ISOWeek", "", [], [Go$Int, Go$Int], false], ["In", "", [(go$ptrType(Location))], [Time], false], ["IsZero", "", [], [Go$Bool], false], ["Local", "", [], [Time], false], ["Location", "", [], [(go$ptrType(Location))], false], ["MarshalBinary", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["MarshalJSON", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["MarshalText", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["Minute", "", [], [Go$Int], false], ["Month", "", [], [Month], false], ["Nanosecond", "", [], [Go$Int], false], ["Round", "", [Duration], [Time], false], ["Second", "", [], [Go$Int], false], ["String", "", [], [Go$String], false], ["Sub", "", [Time], [Duration], false], ["Truncate", "", [Duration], [Time], false], ["UTC", "", [], [Time], false], ["Unix", "", [], [Go$Int64], false], ["UnixNano", "", [], [Go$Int64], false], ["UnmarshalBinary", "", [(go$sliceType(Go$Uint8))], [go$error], false], ["UnmarshalJSON", "", [(go$sliceType(Go$Uint8))], [go$error], false], ["UnmarshalText", "", [(go$sliceType(Go$Uint8))], [go$error], false], ["Weekday", "", [], [Weekday], false], ["Year", "", [], [Go$Int], false], ["YearDay", "", [], [Go$Int], false], ["Zone", "", [], [Go$String, Go$Int], false], ["abs", "time", [], [Go$Uint64], false], ["date", "time", [Go$Bool], [Go$Int, Month, Go$Int, Go$Int], false], ["locabs", "time", [], [Go$String, Go$Int, Go$Uint64], false]];
	Month.methods = [["String", "", [], [Go$String], false]];
	(go$ptrType(Month)).methods = [["String", "", [], [Go$String], false]];
	Weekday.methods = [["String", "", [], [Go$String], false]];
	(go$ptrType(Weekday)).methods = [["String", "", [], [Go$String], false]];
	Duration.methods = [["Hours", "", [], [Go$Float64], false], ["Minutes", "", [], [Go$Float64], false], ["Nanoseconds", "", [], [Go$Int64], false], ["Seconds", "", [], [Go$Float64], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Duration)).methods = [["Hours", "", [], [Go$Float64], false], ["Minutes", "", [], [Go$Float64], false], ["Nanoseconds", "", [], [Go$Int64], false], ["Seconds", "", [], [Go$Float64], false], ["String", "", [], [Go$String], false]];
	Location.init([["name", "time", Go$String, ""], ["zone", "time", (go$sliceType(zone)), ""], ["tx", "time", (go$sliceType(zoneTrans)), ""], ["cacheStart", "time", Go$Int64, ""], ["cacheEnd", "time", Go$Int64, ""], ["cacheZone", "time", (go$ptrType(zone)), ""]]);
	(go$ptrType(Location)).methods = [["String", "", [], [Go$String], false], ["get", "time", [], [(go$ptrType(Location))], false], ["lookup", "time", [Go$Int64], [Go$String, Go$Int, Go$Bool, Go$Int64, Go$Int64], false], ["lookupName", "time", [Go$String, Go$Int64], [Go$Int, Go$Bool, Go$Bool], false]];
	zone.init([["name", "time", Go$String, ""], ["offset", "time", Go$Int, ""], ["isDST", "time", Go$Bool, ""]]);
	zoneTrans.init([["when", "time", Go$Int64, ""], ["index", "time", Go$Uint8, ""], ["isstd", "time", Go$Bool, ""], ["isutc", "time", Go$Bool, ""]]);
	abbr.init([["std", "time", Go$String, ""], ["dst", "time", Go$String, ""]]);
	data.init([["p", "time", (go$sliceType(Go$Uint8)), ""], ["error", "time", Go$Bool, ""]]);
	(go$ptrType(data)).methods = [["big4", "time", [], [Go$Uint32, Go$Bool], false], ["byte", "time", [], [Go$Uint8, Go$Bool], false], ["read", "time", [Go$Int], [(go$sliceType(Go$Uint8))], false]];
	var std0x, longDayNames, shortDayNames, shortMonthNames, longMonthNames, atoiError, errBad, errLeadingInt, unitMap, months, days, daysBefore, utcLoc, localLoc, localOnce, zoneinfo, abbrs, badData, usPacific, aus;
	var startsWithLowerCase = function(str) {
		var c;
		if (str.length === 0) {
			return false;
		}
		c = str.charCodeAt(0);
		return 97 <= c && c <= 122;
	};
	var nextStdChunk = function(layout) {
		var prefix, std, suffix, i, c, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, _tuple$18, _tuple$19, _tuple$20, _tuple$21, _tuple$22, _tuple$23, _tuple$24, ch, j, std$1, _tuple$25, _tuple$26;
		prefix = "";
		std = 0;
		suffix = "";
		i = 0;
		while (i < layout.length) {
			c = (layout.charCodeAt(i) >> 0);
			_ref = c;
			if (_ref === 74) {
				if (layout.length >= (i + 3 >> 0) && layout.substring(i, (i + 3 >> 0)) === "Jan") {
					if (layout.length >= (i + 7 >> 0) && layout.substring(i, (i + 7 >> 0)) === "January") {
						_tuple = [layout.substring(0, i), 257, layout.substring((i + 7 >> 0))], prefix = _tuple[0], std = _tuple[1], suffix = _tuple[2];
						return [prefix, std, suffix];
					}
					if (!startsWithLowerCase(layout.substring((i + 3 >> 0)))) {
						_tuple$1 = [layout.substring(0, i), 258, layout.substring((i + 3 >> 0))], prefix = _tuple$1[0], std = _tuple$1[1], suffix = _tuple$1[2];
						return [prefix, std, suffix];
					}
				}
			} else if (_ref === 77) {
				if (layout.length >= (i + 3 >> 0)) {
					if (layout.substring(i, (i + 3 >> 0)) === "Mon") {
						if (layout.length >= (i + 6 >> 0) && layout.substring(i, (i + 6 >> 0)) === "Monday") {
							_tuple$2 = [layout.substring(0, i), 261, layout.substring((i + 6 >> 0))], prefix = _tuple$2[0], std = _tuple$2[1], suffix = _tuple$2[2];
							return [prefix, std, suffix];
						}
						if (!startsWithLowerCase(layout.substring((i + 3 >> 0)))) {
							_tuple$3 = [layout.substring(0, i), 262, layout.substring((i + 3 >> 0))], prefix = _tuple$3[0], std = _tuple$3[1], suffix = _tuple$3[2];
							return [prefix, std, suffix];
						}
					}
					if (layout.substring(i, (i + 3 >> 0)) === "MST") {
						_tuple$4 = [layout.substring(0, i), 21, layout.substring((i + 3 >> 0))], prefix = _tuple$4[0], std = _tuple$4[1], suffix = _tuple$4[2];
						return [prefix, std, suffix];
					}
				}
			} else if (_ref === 48) {
				if (layout.length >= (i + 2 >> 0) && 49 <= layout.charCodeAt((i + 1 >> 0)) && layout.charCodeAt((i + 1 >> 0)) <= 54) {
					_tuple$5 = [layout.substring(0, i), std0x[(layout.charCodeAt((i + 1 >> 0)) - 49 << 24 >>> 24)], layout.substring((i + 2 >> 0))], prefix = _tuple$5[0], std = _tuple$5[1], suffix = _tuple$5[2];
					return [prefix, std, suffix];
				}
			} else if (_ref === 49) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 53)) {
					_tuple$6 = [layout.substring(0, i), 522, layout.substring((i + 2 >> 0))], prefix = _tuple$6[0], std = _tuple$6[1], suffix = _tuple$6[2];
					return [prefix, std, suffix];
				}
				_tuple$7 = [layout.substring(0, i), 259, layout.substring((i + 1 >> 0))], prefix = _tuple$7[0], std = _tuple$7[1], suffix = _tuple$7[2];
				return [prefix, std, suffix];
			} else if (_ref === 50) {
				if (layout.length >= (i + 4 >> 0) && layout.substring(i, (i + 4 >> 0)) === "2006") {
					_tuple$8 = [layout.substring(0, i), 273, layout.substring((i + 4 >> 0))], prefix = _tuple$8[0], std = _tuple$8[1], suffix = _tuple$8[2];
					return [prefix, std, suffix];
				}
				_tuple$9 = [layout.substring(0, i), 263, layout.substring((i + 1 >> 0))], prefix = _tuple$9[0], std = _tuple$9[1], suffix = _tuple$9[2];
				return [prefix, std, suffix];
			} else if (_ref === 95) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 50)) {
					_tuple$10 = [layout.substring(0, i), 264, layout.substring((i + 2 >> 0))], prefix = _tuple$10[0], std = _tuple$10[1], suffix = _tuple$10[2];
					return [prefix, std, suffix];
				}
			} else if (_ref === 51) {
				_tuple$11 = [layout.substring(0, i), 523, layout.substring((i + 1 >> 0))], prefix = _tuple$11[0], std = _tuple$11[1], suffix = _tuple$11[2];
				return [prefix, std, suffix];
			} else if (_ref === 52) {
				_tuple$12 = [layout.substring(0, i), 525, layout.substring((i + 1 >> 0))], prefix = _tuple$12[0], std = _tuple$12[1], suffix = _tuple$12[2];
				return [prefix, std, suffix];
			} else if (_ref === 53) {
				_tuple$13 = [layout.substring(0, i), 527, layout.substring((i + 1 >> 0))], prefix = _tuple$13[0], std = _tuple$13[1], suffix = _tuple$13[2];
				return [prefix, std, suffix];
			} else if (_ref === 80) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 77)) {
					_tuple$14 = [layout.substring(0, i), 531, layout.substring((i + 2 >> 0))], prefix = _tuple$14[0], std = _tuple$14[1], suffix = _tuple$14[2];
					return [prefix, std, suffix];
				}
			} else if (_ref === 112) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 109)) {
					_tuple$15 = [layout.substring(0, i), 532, layout.substring((i + 2 >> 0))], prefix = _tuple$15[0], std = _tuple$15[1], suffix = _tuple$15[2];
					return [prefix, std, suffix];
				}
			} else if (_ref === 45) {
				if (layout.length >= (i + 7 >> 0) && layout.substring(i, (i + 7 >> 0)) === "-070000") {
					_tuple$16 = [layout.substring(0, i), 27, layout.substring((i + 7 >> 0))], prefix = _tuple$16[0], std = _tuple$16[1], suffix = _tuple$16[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 9 >> 0) && layout.substring(i, (i + 9 >> 0)) === "-07:00:00") {
					_tuple$17 = [layout.substring(0, i), 30, layout.substring((i + 9 >> 0))], prefix = _tuple$17[0], std = _tuple$17[1], suffix = _tuple$17[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 5 >> 0) && layout.substring(i, (i + 5 >> 0)) === "-0700") {
					_tuple$18 = [layout.substring(0, i), 26, layout.substring((i + 5 >> 0))], prefix = _tuple$18[0], std = _tuple$18[1], suffix = _tuple$18[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 6 >> 0) && layout.substring(i, (i + 6 >> 0)) === "-07:00") {
					_tuple$19 = [layout.substring(0, i), 29, layout.substring((i + 6 >> 0))], prefix = _tuple$19[0], std = _tuple$19[1], suffix = _tuple$19[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 3 >> 0) && layout.substring(i, (i + 3 >> 0)) === "-07") {
					_tuple$20 = [layout.substring(0, i), 28, layout.substring((i + 3 >> 0))], prefix = _tuple$20[0], std = _tuple$20[1], suffix = _tuple$20[2];
					return [prefix, std, suffix];
				}
			} else if (_ref === 90) {
				if (layout.length >= (i + 7 >> 0) && layout.substring(i, (i + 7 >> 0)) === "Z070000") {
					_tuple$21 = [layout.substring(0, i), 23, layout.substring((i + 7 >> 0))], prefix = _tuple$21[0], std = _tuple$21[1], suffix = _tuple$21[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 9 >> 0) && layout.substring(i, (i + 9 >> 0)) === "Z07:00:00") {
					_tuple$22 = [layout.substring(0, i), 25, layout.substring((i + 9 >> 0))], prefix = _tuple$22[0], std = _tuple$22[1], suffix = _tuple$22[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 5 >> 0) && layout.substring(i, (i + 5 >> 0)) === "Z0700") {
					_tuple$23 = [layout.substring(0, i), 22, layout.substring((i + 5 >> 0))], prefix = _tuple$23[0], std = _tuple$23[1], suffix = _tuple$23[2];
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 6 >> 0) && layout.substring(i, (i + 6 >> 0)) === "Z07:00") {
					_tuple$24 = [layout.substring(0, i), 24, layout.substring((i + 6 >> 0))], prefix = _tuple$24[0], std = _tuple$24[1], suffix = _tuple$24[2];
					return [prefix, std, suffix];
				}
			} else if (_ref === 46) {
				if ((i + 1 >> 0) < layout.length && ((layout.charCodeAt((i + 1 >> 0)) === 48) || (layout.charCodeAt((i + 1 >> 0)) === 57))) {
					ch = layout.charCodeAt((i + 1 >> 0));
					j = i + 1 >> 0;
					while (j < layout.length && (layout.charCodeAt(j) === ch)) {
						j = j + 1 >> 0;
					}
					if (!isDigit(layout, j)) {
						std$1 = 31;
						if (layout.charCodeAt((i + 1 >> 0)) === 57) {
							std$1 = 32;
						}
						std$1 = std$1 | ((((j - ((i + 1 >> 0)) >> 0)) << 16 >> 0));
						_tuple$25 = [layout.substring(0, i), std$1, layout.substring(j)], prefix = _tuple$25[0], std = _tuple$25[1], suffix = _tuple$25[2];
						return [prefix, std, suffix];
					}
				}
			}
			i = i + 1 >> 0;
		}
		_tuple$26 = [layout, 0, ""], prefix = _tuple$26[0], std = _tuple$26[1], suffix = _tuple$26[2];
		return [prefix, std, suffix];
	};
	var match = function(s1, s2) {
		var i, c1, c2;
		i = 0;
		while (i < s1.length) {
			c1 = s1.charCodeAt(i);
			c2 = s2.charCodeAt(i);
			if (!((c1 === c2))) {
				c1 = (c1 | 32) >>> 0;
				c2 = (c2 | 32) >>> 0;
				if (!((c1 === c2)) || c1 < 97 || c1 > 122) {
					return false;
				}
			}
			i = i + 1 >> 0;
		}
		return true;
	};
	var lookup = function(tab, val) {
		var _ref, _i, _slice, _index, v, i;
		_ref = tab;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (val.length >= v.length && match(val.substring(0, v.length), v)) {
				return [i, val.substring(v.length), null];
			}
			_i++;
		}
		return [-1, val, errBad];
	};
	var appendUint = function(b, x, pad) {
		var _q, _r, buf, n, _r$1, _q$1;
		if (x < 10) {
			if (!((pad === 0))) {
				b = go$append(b, pad);
			}
			return go$append(b, ((48 + x >>> 0) << 24 >>> 24));
		}
		if (x < 100) {
			b = go$append(b, ((48 + (_q = x / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero")) >>> 0) << 24 >>> 24));
			b = go$append(b, ((48 + (_r = x % 10, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) >>> 0) << 24 >>> 24));
			return b;
		}
		buf = go$makeNativeArray("Uint8", 32, function() { return 0; });
		n = 32;
		if (x === 0) {
			return go$append(b, 48);
		}
		while (x >= 10) {
			n = n - 1 >> 0;
			buf[n] = (((_r$1 = x % 10, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero")) + 48 >>> 0) << 24 >>> 24);
			x = (_q$1 = x / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : go$throwRuntimeError("integer divide by zero"));
		}
		n = n - 1 >> 0;
		buf[n] = ((x + 48 >>> 0) << 24 >>> 24);
		return go$appendSlice(b, go$subslice(new (go$sliceType(Go$Uint8))(buf), n));
	};
	var atoi = function(s) {
		var x, err, neg, _tuple, q, rem, _tuple$1, _tuple$2;
		x = 0;
		err = null;
		neg = false;
		if (!(s === "") && ((s.charCodeAt(0) === 45) || (s.charCodeAt(0) === 43))) {
			neg = s.charCodeAt(0) === 45;
			s = s.substring(1);
		}
		_tuple = leadingInt(s), q = _tuple[0], rem = _tuple[1], err = _tuple[2];
		x = ((q.low + ((q.high >> 31) * 4294967296)) >> 0);
		if (!(go$interfaceIsEqual(err, null)) || !(rem === "")) {
			_tuple$1 = [0, atoiError], x = _tuple$1[0], err = _tuple$1[1];
			return [x, err];
		}
		if (neg) {
			x = -x;
		}
		_tuple$2 = [x, null], x = _tuple$2[0], err = _tuple$2[1];
		return [x, err];
	};
	var formatNano = function(b, nanosec, n, trim) {
		var u, buf, start, _r, _q;
		u = nanosec;
		buf = go$makeNativeArray("Uint8", 9, function() { return 0; });
		start = 9;
		while (start > 0) {
			start = start - 1 >> 0;
			buf[start] = (((_r = u % 10, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) + 48 >>> 0) << 24 >>> 24);
			u = (_q = u / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero"));
		}
		if (n > 9) {
			n = 9;
		}
		if (trim) {
			while (n > 0 && (buf[(n - 1 >> 0)] === 48)) {
				n = n - 1 >> 0;
			}
			if (n === 0) {
				return b;
			}
		}
		b = go$append(b, 46);
		return go$appendSlice(b, go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, n));
	};
	Time.Ptr.prototype.String = function() {
		var _struct, t;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return t.Format("2006-01-02 15:04:05.999999999 -0700 MST");
	};
	Time.prototype.String = function() { return this.go$val.String(); };
	Time.Ptr.prototype.Format = function(layout) {
		var _struct, t, _tuple, name, offset, abs, year, month, day, hour, min, sec, b, buf, max, _tuple$1, prefix, std, suffix, _tuple$2, _tuple$3, _ref, y, _r, y$1, m, s, _r$1, hr, _r$2, hr$1, _q, zone$1, absoffset, _q$1, _r$3, _r$4, _q$2, zone$2, _q$3, _r$5;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.locabs(), name = _tuple[0], offset = _tuple[1], abs = _tuple[2], year = -1, month = 0, day = 0, hour = -1, min = 0, sec = 0, b = (go$sliceType(Go$Uint8)).nil, buf = go$makeNativeArray("Uint8", 64, function() { return 0; });
		max = layout.length + 10 >> 0;
		if (max <= 64) {
			b = go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, 0);
		} else {
			b = (go$sliceType(Go$Uint8)).make(0, max, function() { return 0; });
		}
		while (!(layout === "")) {
			_tuple$1 = nextStdChunk(layout), prefix = _tuple$1[0], std = _tuple$1[1], suffix = _tuple$1[2];
			if (!(prefix === "")) {
				b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes(prefix)));
			}
			if (std === 0) {
				break;
			}
			layout = suffix;
			if (year < 0 && !(((std & 256) === 0))) {
				_tuple$2 = absDate(abs, true), year = _tuple$2[0], month = _tuple$2[1], day = _tuple$2[2];
			}
			if (hour < 0 && !(((std & 512) === 0))) {
				_tuple$3 = absClock(abs), hour = _tuple$3[0], min = _tuple$3[1], sec = _tuple$3[2];
			}
			_ref = std & 65535;
			switch (0) { default: if (_ref === 274) {
				y = year;
				if (y < 0) {
					y = -y;
				}
				b = appendUint(b, ((_r = y % 100, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) >>> 0), 48);
			} else if (_ref === 273) {
				y$1 = year;
				if (year <= -1000) {
					b = go$append(b, 45);
					y$1 = -y$1;
				} else if (year <= -100) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("-0")));
					y$1 = -y$1;
				} else if (year <= -10) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("-00")));
					y$1 = -y$1;
				} else if (year < 0) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("-000")));
					y$1 = -y$1;
				} else if (year < 10) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("000")));
				} else if (year < 100) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("00")));
				} else if (year < 1000) {
					b = go$append(b, 48);
				}
				b = appendUint(b, (y$1 >>> 0), 0);
			} else if (_ref === 258) {
				b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes((new Month(month)).String().substring(0, 3))));
			} else if (_ref === 257) {
				m = (new Month(month)).String();
				b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes(m)));
			} else if (_ref === 259) {
				b = appendUint(b, (month >>> 0), 0);
			} else if (_ref === 260) {
				b = appendUint(b, (month >>> 0), 48);
			} else if (_ref === 262) {
				b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes((new Weekday(absWeekday(abs))).String().substring(0, 3))));
			} else if (_ref === 261) {
				s = (new Weekday(absWeekday(abs))).String();
				b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes(s)));
			} else if (_ref === 263) {
				b = appendUint(b, (day >>> 0), 0);
			} else if (_ref === 264) {
				b = appendUint(b, (day >>> 0), 32);
			} else if (_ref === 265) {
				b = appendUint(b, (day >>> 0), 48);
			} else if (_ref === 522) {
				b = appendUint(b, (hour >>> 0), 48);
			} else if (_ref === 523) {
				hr = (_r$1 = hour % 12, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero"));
				if (hr === 0) {
					hr = 12;
				}
				b = appendUint(b, (hr >>> 0), 0);
			} else if (_ref === 524) {
				hr$1 = (_r$2 = hour % 12, _r$2 === _r$2 ? _r$2 : go$throwRuntimeError("integer divide by zero"));
				if (hr$1 === 0) {
					hr$1 = 12;
				}
				b = appendUint(b, (hr$1 >>> 0), 48);
			} else if (_ref === 525) {
				b = appendUint(b, (min >>> 0), 0);
			} else if (_ref === 526) {
				b = appendUint(b, (min >>> 0), 48);
			} else if (_ref === 527) {
				b = appendUint(b, (sec >>> 0), 0);
			} else if (_ref === 528) {
				b = appendUint(b, (sec >>> 0), 48);
			} else if (_ref === 531) {
				if (hour >= 12) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("PM")));
				} else {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("AM")));
				}
			} else if (_ref === 532) {
				if (hour >= 12) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("pm")));
				} else {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes("am")));
				}
			} else if (_ref === 22 || _ref === 24 || _ref === 23 || _ref === 25 || _ref === 26 || _ref === 29 || _ref === 27 || _ref === 30) {
				if ((offset === 0) && ((std === 22) || (std === 24) || (std === 23) || (std === 25))) {
					b = go$append(b, 90);
					break;
				}
				zone$1 = (_q = offset / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
				absoffset = offset;
				if (zone$1 < 0) {
					b = go$append(b, 45);
					zone$1 = -zone$1;
					absoffset = -absoffset;
				} else {
					b = go$append(b, 43);
				}
				b = appendUint(b, ((_q$1 = zone$1 / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")) >>> 0), 48);
				if ((std === 24) || (std === 29)) {
					b = go$append(b, 58);
				}
				b = appendUint(b, ((_r$3 = zone$1 % 60, _r$3 === _r$3 ? _r$3 : go$throwRuntimeError("integer divide by zero")) >>> 0), 48);
				if ((std === 23) || (std === 27) || (std === 30) || (std === 25)) {
					if ((std === 30) || (std === 25)) {
						b = go$append(b, 58);
					}
					b = appendUint(b, ((_r$4 = absoffset % 60, _r$4 === _r$4 ? _r$4 : go$throwRuntimeError("integer divide by zero")) >>> 0), 48);
				}
			} else if (_ref === 21) {
				if (!(name === "")) {
					b = go$appendSlice(b, new (go$sliceType(Go$Uint8))(go$stringToBytes(name)));
					break;
				}
				zone$2 = (_q$2 = offset / 60, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero"));
				if (zone$2 < 0) {
					b = go$append(b, 45);
					zone$2 = -zone$2;
				} else {
					b = go$append(b, 43);
				}
				b = appendUint(b, ((_q$3 = zone$2 / 60, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : go$throwRuntimeError("integer divide by zero")) >>> 0), 48);
				b = appendUint(b, ((_r$5 = zone$2 % 60, _r$5 === _r$5 ? _r$5 : go$throwRuntimeError("integer divide by zero")) >>> 0), 48);
			} else if (_ref === 31 || _ref === 32) {
				b = formatNano(b, (t.Nanosecond() >>> 0), std >> 16 >> 0, (std & 65535) === 32);
			} }
		}
		return go$bytesToString(b);
	};
	Time.prototype.Format = function(layout) { return this.go$val.Format(layout); };
	var quote = function(s) {
		return "\"" + s + "\"";
	};
	ParseError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Message === "") {
			return "parsing time " + quote(e.Value) + " as " + quote(e.Layout) + ": cannot parse " + quote(e.ValueElem) + " as " + quote(e.LayoutElem);
		}
		return "parsing time " + quote(e.Value) + e.Message;
	};
	ParseError.prototype.Error = function() { return this.go$val.Error(); };
	var isDigit = function(s, i) {
		var c;
		if (s.length <= i) {
			return false;
		}
		c = s.charCodeAt(i);
		return 48 <= c && c <= 57;
	};
	var getnum = function(s, fixed) {
		var x, x$1;
		if (!isDigit(s, 0)) {
			return [0, s, errBad];
		}
		if (!isDigit(s, 1)) {
			if (fixed) {
				return [0, s, errBad];
			}
			return [((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0), s.substring(1), null];
		}
		return [(x = ((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0), x$1 = 10, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) + ((s.charCodeAt(1) - 48 << 24 >>> 24) >> 0) >> 0, s.substring(2), null];
	};
	var cutspace = function(s) {
		while (s.length > 0 && (s.charCodeAt(0) === 32)) {
			s = s.substring(1);
		}
		return s;
	};
	var skip = function(value, prefix) {
		while (prefix.length > 0) {
			if (prefix.charCodeAt(0) === 32) {
				if (value.length > 0 && !((value.charCodeAt(0) === 32))) {
					return [value, errBad];
				}
				prefix = cutspace(prefix);
				value = cutspace(value);
				continue;
			}
			if ((value.length === 0) || !((value.charCodeAt(0) === prefix.charCodeAt(0)))) {
				return [value, errBad];
			}
			prefix = prefix.substring(1);
			value = value.substring(1);
		}
		return [value, null];
	};
	var Parse = go$pkg.Parse = function(layout, value) {
		return parse(layout, value, go$pkg.UTC, go$pkg.Local);
	};
	var ParseInLocation = go$pkg.ParseInLocation = function(layout, value, loc) {
		return parse(layout, value, loc, loc);
	};
	var parse = function(layout, value, defaultLocation, local) {
		var _tuple, alayout, avalue, rangeErrString, amSet, pmSet, year, month, day, hour, min, sec, nsec, z, zoneOffset, zoneName, err, _tuple$1, prefix, std, suffix, stdstr, _tuple$2, p, _ref, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, n, _tuple$18, _tuple$19, _ref$1, _tuple$20, _ref$2, _tuple$21, sign, hour$1, min$1, seconds, _tuple$22, _tuple$23, _tuple$24, _tuple$25, _tuple$26, _tuple$27, hr, mm, ss, _tuple$28, _tuple$29, _tuple$30, x, x$1, x$2, _ref$3, _tuple$31, n$1, ok, _tuple$32, ndigit, _tuple$33, i, _tuple$34, _struct, _struct$1, t, x$3, x$4, _tuple$35, x$5, name, offset, _struct$2, _struct$3, _struct$4, t$1, _tuple$36, x$6, offset$1, ok$1, x$7, x$8, _struct$5, _tuple$37, x$9, _struct$6, _struct$7;
		_tuple = [layout, value], alayout = _tuple[0], avalue = _tuple[1];
		rangeErrString = "";
		amSet = false;
		pmSet = false;
		year = 0, month = 1, day = 1, hour = 0, min = 0, sec = 0, nsec = 0, z = (go$ptrType(Location)).nil, zoneOffset = -1, zoneName = "";
		while (true) {
			err = null;
			_tuple$1 = nextStdChunk(layout), prefix = _tuple$1[0], std = _tuple$1[1], suffix = _tuple$1[2];
			stdstr = layout.substring(prefix.length, (layout.length - suffix.length >> 0));
			_tuple$2 = skip(value, prefix), value = _tuple$2[0], err = _tuple$2[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [new Time.Ptr(new Go$Int64(0, 0), 0, (go$ptrType(Location)).nil), new ParseError.Ptr(alayout, avalue, prefix, value, "")];
			}
			if (std === 0) {
				if (!((value.length === 0))) {
					return [new Time.Ptr(new Go$Int64(0, 0), 0, (go$ptrType(Location)).nil), new ParseError.Ptr(alayout, avalue, "", value, ": extra text: " + value)];
				}
				break;
			}
			layout = suffix;
			p = "";
			_ref = std & 65535;
			switch (0) { default: if (_ref === 274) {
				if (value.length < 2) {
					err = errBad;
					break;
				}
				_tuple$3 = [value.substring(0, 2), value.substring(2)], p = _tuple$3[0], value = _tuple$3[1];
				_tuple$4 = atoi(p), year = _tuple$4[0], err = _tuple$4[1];
				if (year >= 69) {
					year = year + 1900 >> 0;
				} else {
					year = year + 2000 >> 0;
				}
			} else if (_ref === 273) {
				if (value.length < 4 || !isDigit(value, 0)) {
					err = errBad;
					break;
				}
				_tuple$5 = [value.substring(0, 4), value.substring(4)], p = _tuple$5[0], value = _tuple$5[1];
				_tuple$6 = atoi(p), year = _tuple$6[0], err = _tuple$6[1];
			} else if (_ref === 258) {
				_tuple$7 = lookup(shortMonthNames, value), month = _tuple$7[0], value = _tuple$7[1], err = _tuple$7[2];
			} else if (_ref === 257) {
				_tuple$8 = lookup(longMonthNames, value), month = _tuple$8[0], value = _tuple$8[1], err = _tuple$8[2];
			} else if (_ref === 259 || _ref === 260) {
				_tuple$9 = getnum(value, std === 260), month = _tuple$9[0], value = _tuple$9[1], err = _tuple$9[2];
				if (month <= 0 || 12 < month) {
					rangeErrString = "month";
				}
			} else if (_ref === 262) {
				_tuple$10 = lookup(shortDayNames, value), value = _tuple$10[1], err = _tuple$10[2];
			} else if (_ref === 261) {
				_tuple$11 = lookup(longDayNames, value), value = _tuple$11[1], err = _tuple$11[2];
			} else if (_ref === 263 || _ref === 264 || _ref === 265) {
				if ((std === 264) && value.length > 0 && (value.charCodeAt(0) === 32)) {
					value = value.substring(1);
				}
				_tuple$12 = getnum(value, std === 265), day = _tuple$12[0], value = _tuple$12[1], err = _tuple$12[2];
				if (day < 0 || 31 < day) {
					rangeErrString = "day";
				}
			} else if (_ref === 522) {
				_tuple$13 = getnum(value, false), hour = _tuple$13[0], value = _tuple$13[1], err = _tuple$13[2];
				if (hour < 0 || 24 <= hour) {
					rangeErrString = "hour";
				}
			} else if (_ref === 523 || _ref === 524) {
				_tuple$14 = getnum(value, std === 524), hour = _tuple$14[0], value = _tuple$14[1], err = _tuple$14[2];
				if (hour < 0 || 12 < hour) {
					rangeErrString = "hour";
				}
			} else if (_ref === 525 || _ref === 526) {
				_tuple$15 = getnum(value, std === 526), min = _tuple$15[0], value = _tuple$15[1], err = _tuple$15[2];
				if (min < 0 || 60 <= min) {
					rangeErrString = "minute";
				}
			} else if (_ref === 527 || _ref === 528) {
				_tuple$16 = getnum(value, std === 528), sec = _tuple$16[0], value = _tuple$16[1], err = _tuple$16[2];
				if (sec < 0 || 60 <= sec) {
					rangeErrString = "second";
				}
				if (value.length >= 2 && (value.charCodeAt(0) === 46) && isDigit(value, 1)) {
					_tuple$17 = nextStdChunk(layout), std = _tuple$17[1];
					std = std & 65535;
					if ((std === 31) || (std === 32)) {
						break;
					}
					n = 2;
					while (n < value.length && isDigit(value, n)) {
						n = n + 1 >> 0;
					}
					_tuple$18 = parseNanoseconds(value, n), nsec = _tuple$18[0], rangeErrString = _tuple$18[1], err = _tuple$18[2];
					value = value.substring(n);
				}
			} else if (_ref === 531) {
				if (value.length < 2) {
					err = errBad;
					break;
				}
				_tuple$19 = [value.substring(0, 2), value.substring(2)], p = _tuple$19[0], value = _tuple$19[1];
				_ref$1 = p;
				if (_ref$1 === "PM") {
					pmSet = true;
				} else if (_ref$1 === "AM") {
					amSet = true;
				} else {
					err = errBad;
				}
			} else if (_ref === 532) {
				if (value.length < 2) {
					err = errBad;
					break;
				}
				_tuple$20 = [value.substring(0, 2), value.substring(2)], p = _tuple$20[0], value = _tuple$20[1];
				_ref$2 = p;
				if (_ref$2 === "pm") {
					pmSet = true;
				} else if (_ref$2 === "am") {
					amSet = true;
				} else {
					err = errBad;
				}
			} else if (_ref === 22 || _ref === 24 || _ref === 23 || _ref === 25 || _ref === 26 || _ref === 28 || _ref === 29 || _ref === 27 || _ref === 30) {
				if (((std === 22) || (std === 24)) && value.length >= 1 && (value.charCodeAt(0) === 90)) {
					value = value.substring(1);
					z = go$pkg.UTC;
					break;
				}
				_tuple$21 = ["", "", "", ""], sign = _tuple$21[0], hour$1 = _tuple$21[1], min$1 = _tuple$21[2], seconds = _tuple$21[3];
				if ((std === 24) || (std === 29)) {
					if (value.length < 6) {
						err = errBad;
						break;
					}
					if (!((value.charCodeAt(3) === 58))) {
						err = errBad;
						break;
					}
					_tuple$22 = [value.substring(0, 1), value.substring(1, 3), value.substring(4, 6), "00", value.substring(6)], sign = _tuple$22[0], hour$1 = _tuple$22[1], min$1 = _tuple$22[2], seconds = _tuple$22[3], value = _tuple$22[4];
				} else if (std === 28) {
					if (value.length < 3) {
						err = errBad;
						break;
					}
					_tuple$23 = [value.substring(0, 1), value.substring(1, 3), "00", "00", value.substring(3)], sign = _tuple$23[0], hour$1 = _tuple$23[1], min$1 = _tuple$23[2], seconds = _tuple$23[3], value = _tuple$23[4];
				} else if ((std === 25) || (std === 30)) {
					if (value.length < 9) {
						err = errBad;
						break;
					}
					if (!((value.charCodeAt(3) === 58)) || !((value.charCodeAt(6) === 58))) {
						err = errBad;
						break;
					}
					_tuple$24 = [value.substring(0, 1), value.substring(1, 3), value.substring(4, 6), value.substring(7, 9), value.substring(9)], sign = _tuple$24[0], hour$1 = _tuple$24[1], min$1 = _tuple$24[2], seconds = _tuple$24[3], value = _tuple$24[4];
				} else if ((std === 23) || (std === 27)) {
					if (value.length < 7) {
						err = errBad;
						break;
					}
					_tuple$25 = [value.substring(0, 1), value.substring(1, 3), value.substring(3, 5), value.substring(5, 7), value.substring(7)], sign = _tuple$25[0], hour$1 = _tuple$25[1], min$1 = _tuple$25[2], seconds = _tuple$25[3], value = _tuple$25[4];
				} else {
					if (value.length < 5) {
						err = errBad;
						break;
					}
					_tuple$26 = [value.substring(0, 1), value.substring(1, 3), value.substring(3, 5), "00", value.substring(5)], sign = _tuple$26[0], hour$1 = _tuple$26[1], min$1 = _tuple$26[2], seconds = _tuple$26[3], value = _tuple$26[4];
				}
				_tuple$27 = [0, 0, 0], hr = _tuple$27[0], mm = _tuple$27[1], ss = _tuple$27[2];
				_tuple$28 = atoi(hour$1), hr = _tuple$28[0], err = _tuple$28[1];
				if (go$interfaceIsEqual(err, null)) {
					_tuple$29 = atoi(min$1), mm = _tuple$29[0], err = _tuple$29[1];
				}
				if (go$interfaceIsEqual(err, null)) {
					_tuple$30 = atoi(seconds), ss = _tuple$30[0], err = _tuple$30[1];
				}
				zoneOffset = (x = ((x$1 = 60, (((hr >>> 16 << 16) * x$1 >> 0) + (hr << 16 >>> 16) * x$1) >> 0) + mm >> 0), x$2 = 60, (((x >>> 16 << 16) * x$2 >> 0) + (x << 16 >>> 16) * x$2) >> 0) + ss >> 0;
				_ref$3 = sign.charCodeAt(0);
				if (_ref$3 === 43) {
				} else if (_ref$3 === 45) {
					zoneOffset = -zoneOffset;
				} else {
					err = errBad;
				}
			} else if (_ref === 21) {
				if (value.length >= 3 && value.substring(0, 3) === "UTC") {
					z = go$pkg.UTC;
					value = value.substring(3);
					break;
				}
				_tuple$31 = parseTimeZone(value), n$1 = _tuple$31[0], ok = _tuple$31[1];
				if (!ok) {
					err = errBad;
					break;
				}
				_tuple$32 = [value.substring(0, n$1), value.substring(n$1)], zoneName = _tuple$32[0], value = _tuple$32[1];
			} else if (_ref === 31) {
				ndigit = 1 + ((std >> 16 >> 0)) >> 0;
				if (value.length < ndigit) {
					err = errBad;
					break;
				}
				_tuple$33 = parseNanoseconds(value, ndigit), nsec = _tuple$33[0], rangeErrString = _tuple$33[1], err = _tuple$33[2];
				value = value.substring(ndigit);
			} else if (_ref === 32) {
				if (value.length < 2 || !((value.charCodeAt(0) === 46)) || value.charCodeAt(1) < 48 || 57 < value.charCodeAt(1)) {
					break;
				}
				i = 0;
				while (i < 9 && (i + 1 >> 0) < value.length && 48 <= value.charCodeAt((i + 1 >> 0)) && value.charCodeAt((i + 1 >> 0)) <= 57) {
					i = i + 1 >> 0;
				}
				_tuple$34 = parseNanoseconds(value, 1 + i >> 0), nsec = _tuple$34[0], rangeErrString = _tuple$34[1], err = _tuple$34[2];
				value = value.substring((1 + i >> 0));
			} }
			if (!(rangeErrString === "")) {
				return [new Time.Ptr(new Go$Int64(0, 0), 0, (go$ptrType(Location)).nil), new ParseError.Ptr(alayout, avalue, stdstr, value, ": " + rangeErrString + " out of range")];
			}
			if (!(go$interfaceIsEqual(err, null))) {
				return [new Time.Ptr(new Go$Int64(0, 0), 0, (go$ptrType(Location)).nil), new ParseError.Ptr(alayout, avalue, stdstr, value, "")];
			}
		}
		if (pmSet && hour < 12) {
			hour = hour + 12 >> 0;
		} else if (amSet && (hour === 12)) {
			hour = 0;
		}
		if (!(z === (go$ptrType(Location)).nil)) {
			return [(_struct = Date(year, (month >> 0), day, hour, min, sec, nsec, z), new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc)), null];
		}
		if (!((zoneOffset === -1))) {
			t = (_struct$1 = Date(year, (month >> 0), day, hour, min, sec, nsec, go$pkg.UTC), new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
			t.sec = (x$3 = t.sec, x$4 = new Go$Int64(0, zoneOffset), new Go$Int64(x$3.high - x$4.high, x$3.low - x$4.low));
			_tuple$35 = local.lookup((x$5 = t.sec, new Go$Int64(x$5.high + -15, x$5.low + 2288912640))), name = _tuple$35[0], offset = _tuple$35[1];
			if ((offset === zoneOffset) && (zoneName === "" || name === zoneName)) {
				t.loc = local;
				return [(_struct$2 = t, new Time.Ptr(_struct$2.sec, _struct$2.nsec, _struct$2.loc)), null];
			}
			t.loc = FixedZone(zoneName, zoneOffset);
			return [(_struct$3 = t, new Time.Ptr(_struct$3.sec, _struct$3.nsec, _struct$3.loc)), null];
		}
		if (!(zoneName === "")) {
			t$1 = (_struct$4 = Date(year, (month >> 0), day, hour, min, sec, nsec, go$pkg.UTC), new Time.Ptr(_struct$4.sec, _struct$4.nsec, _struct$4.loc));
			_tuple$36 = local.lookupName(zoneName, (x$6 = t$1.sec, new Go$Int64(x$6.high + -15, x$6.low + 2288912640))), offset$1 = _tuple$36[0], ok$1 = _tuple$36[2];
			if (ok$1) {
				t$1.sec = (x$7 = t$1.sec, x$8 = new Go$Int64(0, offset$1), new Go$Int64(x$7.high - x$8.high, x$7.low - x$8.low));
				t$1.loc = local;
				return [(_struct$5 = t$1, new Time.Ptr(_struct$5.sec, _struct$5.nsec, _struct$5.loc)), null];
			}
			if (zoneName.length > 3 && zoneName.substring(0, 3) === "GMT") {
				_tuple$37 = atoi(zoneName.substring(3)), offset$1 = _tuple$37[0];
				offset$1 = (x$9 = 3600, (((offset$1 >>> 16 << 16) * x$9 >> 0) + (offset$1 << 16 >>> 16) * x$9) >> 0);
			}
			t$1.loc = FixedZone(zoneName, offset$1);
			return [(_struct$6 = t$1, new Time.Ptr(_struct$6.sec, _struct$6.nsec, _struct$6.loc)), null];
		}
		return [(_struct$7 = Date(year, (month >> 0), day, hour, min, sec, nsec, defaultLocation), new Time.Ptr(_struct$7.sec, _struct$7.nsec, _struct$7.loc)), null];
	};
	var parseTimeZone = function(value) {
		var length, ok, _tuple, _tuple$1, _tuple$2, nUpper, c, _ref, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7;
		length = 0;
		ok = false;
		if (value.length < 3) {
			_tuple = [0, false], length = _tuple[0], ok = _tuple[1];
			return [length, ok];
		}
		if (value.length >= 4 && value.substring(0, 4) === "ChST") {
			_tuple$1 = [4, true], length = _tuple$1[0], ok = _tuple$1[1];
			return [length, ok];
		}
		if (value.substring(0, 3) === "GMT") {
			length = parseGMT(value);
			_tuple$2 = [length, true], length = _tuple$2[0], ok = _tuple$2[1];
			return [length, ok];
		}
		nUpper = 0;
		nUpper = 0;
		while (nUpper < 6) {
			if (nUpper >= value.length) {
				break;
			}
			if (c = value.charCodeAt(nUpper), c < 65 || 90 < c) {
				break;
			}
			nUpper = nUpper + 1 >> 0;
		}
		_ref = nUpper;
		if (_ref === 0 || _ref === 1 || _ref === 2 || _ref === 6) {
			_tuple$3 = [0, false], length = _tuple$3[0], ok = _tuple$3[1];
			return [length, ok];
		} else if (_ref === 5) {
			if (value.charCodeAt(4) === 84) {
				_tuple$4 = [5, true], length = _tuple$4[0], ok = _tuple$4[1];
				return [length, ok];
			}
		} else if (_ref === 4) {
			if (value.charCodeAt(3) === 84) {
				_tuple$5 = [4, true], length = _tuple$5[0], ok = _tuple$5[1];
				return [length, ok];
			}
		} else if (_ref === 3) {
			_tuple$6 = [3, true], length = _tuple$6[0], ok = _tuple$6[1];
			return [length, ok];
		}
		_tuple$7 = [0, false], length = _tuple$7[0], ok = _tuple$7[1];
		return [length, ok];
	};
	var parseGMT = function(value) {
		var sign, _tuple, x, rem, err;
		value = value.substring(3);
		if (value.length === 0) {
			return 3;
		}
		sign = value.charCodeAt(0);
		if (!((sign === 45)) && !((sign === 43))) {
			return 3;
		}
		_tuple = leadingInt(value.substring(1)), x = _tuple[0], rem = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			return 3;
		}
		if (sign === 45) {
			x = new Go$Int64(-x.high, -x.low);
		}
		if ((x.high === 0 && x.low === 0) || (x.high < -1 || (x.high === -1 && x.low < 4294967282)) || (0 < x.high || (0 === x.high && 12 < x.low))) {
			return 3;
		}
		return (3 + value.length >> 0) - rem.length >> 0;
	};
	var parseNanoseconds = function(value, nbytes) {
		var ns, rangeErrString, err, _tuple, scaleDigits, i, x;
		ns = 0;
		rangeErrString = "";
		err = null;
		if (!((value.charCodeAt(0) === 46))) {
			err = errBad;
			return [ns, rangeErrString, err];
		}
		if (_tuple = atoi(value.substring(1, nbytes)), ns = _tuple[0], err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			return [ns, rangeErrString, err];
		}
		if (ns < 0 || 1000000000 <= ns) {
			rangeErrString = "fractional second";
			return [ns, rangeErrString, err];
		}
		scaleDigits = 10 - nbytes >> 0;
		i = 0;
		while (i < scaleDigits) {
			ns = (x = 10, (((ns >>> 16 << 16) * x >> 0) + (ns << 16 >>> 16) * x) >> 0);
			i = i + 1 >> 0;
		}
		return [ns, rangeErrString, err];
	};
	var leadingInt = function(s) {
		var x, rem, err, i, c, _tuple, x$1, x$2, x$3, _tuple$1;
		x = new Go$Int64(0, 0);
		rem = "";
		err = null;
		i = 0;
		while (i < s.length) {
			c = s.charCodeAt(i);
			if (c < 48 || c > 57) {
				break;
			}
			if ((x.high > 214748364 || (x.high === 214748364 && x.low >= 3435973835))) {
				_tuple = [new Go$Int64(0, 0), "", errLeadingInt], x = _tuple[0], rem = _tuple[1], err = _tuple[2];
				return [x, rem, err];
			}
			x = (x$1 = (x$2 = go$mul64(x, new Go$Int64(0, 10)), x$3 = new Go$Int64(0, c), new Go$Int64(x$2.high + x$3.high, x$2.low + x$3.low)), new Go$Int64(x$1.high - 0, x$1.low - 48));
			i = i + 1 >> 0;
		}
		_tuple$1 = [x, s.substring(i), null], x = _tuple$1[0], rem = _tuple$1[1], err = _tuple$1[2];
		return [x, rem, err];
	};
	var ParseDuration = go$pkg.ParseDuration = function(s) {
		var orig, f, neg, c, g, x, err, pl, _tuple, pre, post, pl$1, _tuple$1, scale, n, i, c$1, u, _tuple$2, _entry, unit, ok;
		orig = s;
		f = 0;
		neg = false;
		if (!(s === "")) {
			c = s.charCodeAt(0);
			if ((c === 45) || (c === 43)) {
				neg = c === 45;
				s = s.substring(1);
			}
		}
		if (s === "0") {
			return [new Duration(0, 0), null];
		}
		if (s === "") {
			return [new Duration(0, 0), errors.New("time: invalid duration " + orig)];
		}
		while (!(s === "")) {
			g = 0;
			x = new Go$Int64(0, 0);
			err = null;
			if (!((s.charCodeAt(0) === 46) || (48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57))) {
				return [new Duration(0, 0), errors.New("time: invalid duration " + orig)];
			}
			pl = s.length;
			_tuple = leadingInt(s), x = _tuple[0], s = _tuple[1], err = _tuple[2];
			if (!(go$interfaceIsEqual(err, null))) {
				return [new Duration(0, 0), errors.New("time: invalid duration " + orig)];
			}
			g = go$flatten64(x);
			pre = !((pl === s.length));
			post = false;
			if (!(s === "") && (s.charCodeAt(0) === 46)) {
				s = s.substring(1);
				pl$1 = s.length;
				_tuple$1 = leadingInt(s), x = _tuple$1[0], s = _tuple$1[1], err = _tuple$1[2];
				if (!(go$interfaceIsEqual(err, null))) {
					return [new Duration(0, 0), errors.New("time: invalid duration " + orig)];
				}
				scale = 1;
				n = pl$1 - s.length >> 0;
				while (n > 0) {
					scale = scale * 10;
					n = n - 1 >> 0;
				}
				g = g + (go$flatten64(x) / scale);
				post = !((pl$1 === s.length));
			}
			if (!pre && !post) {
				return [new Duration(0, 0), errors.New("time: invalid duration " + orig)];
			}
			i = 0;
			while (i < s.length) {
				c$1 = s.charCodeAt(i);
				if ((c$1 === 46) || (48 <= c$1 && c$1 <= 57)) {
					break;
				}
				i = i + 1 >> 0;
			}
			if (i === 0) {
				return [new Duration(0, 0), errors.New("time: missing unit in duration " + orig)];
			}
			u = s.substring(0, i);
			s = s.substring(i);
			_tuple$2 = (_entry = unitMap[u], _entry !== undefined ? [_entry.v, true] : [0, false]), unit = _tuple$2[0], ok = _tuple$2[1];
			if (!ok) {
				return [new Duration(0, 0), errors.New("time: unknown unit " + u + " in duration " + orig)];
			}
			f = f + (g * unit);
		}
		if (neg) {
			f = -f;
		}
		return [new Duration(0, f), null];
	};
	var Sleep = go$pkg.Sleep = function() { go$notSupported("time.Sleep (use time.AfterFunc instead)") };
	var nano = function() {
		var _tuple, sec, nsec, x, x$1;
		_tuple = now(), sec = _tuple[0], nsec = _tuple[1];
		return (x = go$mul64(sec, new Go$Int64(0, 1000000000)), x$1 = new Go$Int64(0, nsec), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
	};
	var when = function(d) {
		var x, x$1, t;
		if ((d.high < 0 || (d.high === 0 && d.low <= 0))) {
			return nano();
		}
		t = (x = nano(), x$1 = new Go$Int64(d.high, d.low), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
		if ((t.high < 0 || (t.high === 0 && t.low < 0))) {
			t = new Go$Int64(2147483647, 4294967295);
		}
		return t;
	};
	var startTimer = function() {
		throw go$panic("Native function not implemented: startTimer");
	};
	var stopTimer = function() {
		throw go$panic("Native function not implemented: stopTimer");
	};
	Timer.Ptr.prototype.Stop = function() {
		var t;
		t = this;
		return stopTimer(t.r);
	};
	Timer.prototype.Stop = function() { return this.go$val.Stop(); };
	var NewTimer = go$pkg.NewTimer = function() { go$notSupported("time.NewTimer (use time.AfterFunc instead)") };
	Timer.Ptr.prototype.Reset = function(d) {
		var t, w, active;
		t = this;
		w = when(d);
		active = stopTimer(t.r);
		t.r.when = w;
		startTimer(t.r);
		return active;
	};
	Timer.prototype.Reset = function(d) { return this.go$val.Reset(d); };
	var sendTime = function(now$1, c) {
		go$notSupported("select")
	};
	var After = go$pkg.After = function() { go$notSupported("time.After (use time.AfterFunc instead)") };
	var AfterFunc = go$pkg.AfterFunc = function(d, f) {
			setTimeout(f, go$div64(d, new Duration(0, 1000000)).low);
			return null;
		};
	var goFunc = function(now$1, arg) {
		go$notSupported("go")
	};
	var interrupt = function() {
	};
	var readFile = function(name) {
		var _tuple, f, err, buf, ret, n, _tuple$1;
		var go$deferred = [];
		try {
			_tuple = syscall.Open(name, 0, 0), f = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [(go$sliceType(Go$Uint8)).nil, err];
			}
			go$deferred.push({ recv: syscall, method: "Close", args: [f] });
			buf = go$makeNativeArray("Uint8", 4096, function() { return 0; }), ret = (go$sliceType(Go$Uint8)).nil, n = 0;
			while (true) {
				_tuple$1 = syscall.Read(f, new (go$sliceType(Go$Uint8))(buf)), n = _tuple$1[0], err = _tuple$1[1];
				if (n > 0) {
					ret = go$appendSlice(ret, go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, n));
				}
				if ((n === 0) || !(go$interfaceIsEqual(err, null))) {
					break;
				}
			}
			return [ret, err];
		} catch(go$err) {
			go$pushErr(go$err);
			return [(go$sliceType(Go$Uint8)).nil, null];
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var open = function(name) {
		var _tuple, fd, err;
		_tuple = syscall.Open(name, 0, 0), fd = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [0, err];
		}
		return [(fd >>> 0), null];
	};
	var closefd = function(fd) {
		syscall.Close((fd >>> 0));
	};
	var preadn = function(fd, buf, off) {
		var whence, err, _tuple, _tuple$1, m, err$1;
		whence = 0;
		if (off < 0) {
			whence = 2;
		}
		if (_tuple = syscall.Seek((fd >>> 0), new Go$Int64(0, off), whence), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			return err;
		}
		while (buf.length > 0) {
			_tuple$1 = syscall.Read((fd >>> 0), buf), m = _tuple$1[0], err$1 = _tuple$1[1];
			if (m <= 0) {
				if (go$interfaceIsEqual(err$1, null)) {
					return errors.New("short read");
				}
				return err$1;
			}
			buf = go$subslice(buf, m);
		}
		return null;
	};
	var NewTicker = go$pkg.NewTicker = function(d) {
		var c, x, x$1, t;
		if ((d.high < 0 || (d.high === 0 && d.low <= 0))) {
			throw go$panic(errors.New("non-positive interval for NewTicker"));
		}
		c = new (go$chanType(Time, false, false))();
		t = new Ticker.Ptr(c, new runtimeTimer.Ptr(0, (x = nano(), x$1 = new Go$Int64(d.high, d.low), new Go$Int64(x.high + x$1.high, x.low + x$1.low)), new Go$Int64(d.high, d.low), sendTime, c));
		startTimer(t.r);
		return t;
	};
	Ticker.Ptr.prototype.Stop = function() {
		var t;
		t = this;
		stopTimer(t.r);
	};
	Ticker.prototype.Stop = function() { return this.go$val.Stop(); };
	var Tick = go$pkg.Tick = function() { go$notSupported("time.Tick (use time.AfterFunc instead)") };
	Time.Ptr.prototype.After = function(u) {
		var _struct, t, x, x$1, x$2, x$3;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (x = t.sec, x$1 = u.sec, (x.high > x$1.high || (x.high === x$1.high && x.low > x$1.low))) || (x$2 = t.sec, x$3 = u.sec, (x$2.high === x$3.high && x$2.low === x$3.low)) && t.nsec > u.nsec;
	};
	Time.prototype.After = function(u) { return this.go$val.After(u); };
	Time.Ptr.prototype.Before = function(u) {
		var _struct, t, x, x$1, x$2, x$3;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (x = t.sec, x$1 = u.sec, (x.high < x$1.high || (x.high === x$1.high && x.low < x$1.low))) || (x$2 = t.sec, x$3 = u.sec, (x$2.high === x$3.high && x$2.low === x$3.low)) && t.nsec < u.nsec;
	};
	Time.prototype.Before = function(u) { return this.go$val.Before(u); };
	Time.Ptr.prototype.Equal = function(u) {
		var _struct, t, x, x$1;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (x = t.sec, x$1 = u.sec, (x.high === x$1.high && x.low === x$1.low)) && (t.nsec === u.nsec);
	};
	Time.prototype.Equal = function(u) { return this.go$val.Equal(u); };
	Month.prototype.String = function() {
		var m;
		m = this.go$val;
		return months[(m - 1 >> 0)];
	};
	go$ptrType(Month).prototype.String = function() { return new Month(this.go$get()).String(); };
	Weekday.prototype.String = function() {
		var d;
		d = this.go$val;
		return days[d];
	};
	go$ptrType(Weekday).prototype.String = function() { return new Weekday(this.go$get()).String(); };
	Time.Ptr.prototype.IsZero = function() {
		var _struct, t, x;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (x = t.sec, (x.high === 0 && x.low === 0)) && (t.nsec === 0);
	};
	Time.prototype.IsZero = function() { return this.go$val.IsZero(); };
	Time.Ptr.prototype.abs = function() {
		var _struct, t, l, x, sec, x$1, x$2, x$3, _tuple, offset, x$4, x$5;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		l = t.loc;
		if (l === (go$ptrType(Location)).nil || l === localLoc) {
			l = l.get();
		}
		sec = (x = t.sec, new Go$Int64(x.high + -15, x.low + 2288912640));
		if (!(l === utcLoc)) {
			if (!(l.cacheZone === (go$ptrType(zone)).nil) && (x$1 = l.cacheStart, (x$1.high < sec.high || (x$1.high === sec.high && x$1.low <= sec.low))) && (x$2 = l.cacheEnd, (sec.high < x$2.high || (sec.high === x$2.high && sec.low < x$2.low)))) {
				sec = (x$3 = new Go$Int64(0, l.cacheZone.offset), new Go$Int64(sec.high + x$3.high, sec.low + x$3.low));
			} else {
				_tuple = l.lookup(sec), offset = _tuple[1];
				sec = (x$4 = new Go$Int64(0, offset), new Go$Int64(sec.high + x$4.high, sec.low + x$4.low));
			}
		}
		return (x$5 = new Go$Int64(sec.high + 2147483646, sec.low + 450480384), new Go$Uint64(x$5.high, x$5.low));
	};
	Time.prototype.abs = function() { return this.go$val.abs(); };
	Time.Ptr.prototype.locabs = function() {
		var name, offset, abs, _struct, t, l, x, sec, x$1, x$2, _tuple, x$3, x$4;
		name = "";
		offset = 0;
		abs = new Go$Uint64(0, 0);
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		l = t.loc;
		if (l === (go$ptrType(Location)).nil || l === localLoc) {
			l = l.get();
		}
		sec = (x = t.sec, new Go$Int64(x.high + -15, x.low + 2288912640));
		if (!(l === utcLoc)) {
			if (!(l.cacheZone === (go$ptrType(zone)).nil) && (x$1 = l.cacheStart, (x$1.high < sec.high || (x$1.high === sec.high && x$1.low <= sec.low))) && (x$2 = l.cacheEnd, (sec.high < x$2.high || (sec.high === x$2.high && sec.low < x$2.low)))) {
				name = l.cacheZone.name;
				offset = l.cacheZone.offset;
			} else {
				_tuple = l.lookup(sec), name = _tuple[0], offset = _tuple[1];
			}
			sec = (x$3 = new Go$Int64(0, offset), new Go$Int64(sec.high + x$3.high, sec.low + x$3.low));
		} else {
			name = "UTC";
		}
		abs = (x$4 = new Go$Int64(sec.high + 2147483646, sec.low + 450480384), new Go$Uint64(x$4.high, x$4.low));
		return [name, offset, abs];
	};
	Time.prototype.locabs = function() { return this.go$val.locabs(); };
	Time.Ptr.prototype.Date = function() {
		var year, month, day, _struct, t, _tuple;
		year = 0;
		month = 0;
		day = 0;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.date(true), year = _tuple[0], month = _tuple[1], day = _tuple[2];
		return [year, month, day];
	};
	Time.prototype.Date = function() { return this.go$val.Date(); };
	Time.Ptr.prototype.Year = function() {
		var _struct, t, _tuple, year;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.date(false), year = _tuple[0];
		return year;
	};
	Time.prototype.Year = function() { return this.go$val.Year(); };
	Time.Ptr.prototype.Month = function() {
		var _struct, t, _tuple, month;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.date(true), month = _tuple[1];
		return month;
	};
	Time.prototype.Month = function() { return this.go$val.Month(); };
	Time.Ptr.prototype.Day = function() {
		var _struct, t, _tuple, day;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.date(true), day = _tuple[2];
		return day;
	};
	Time.prototype.Day = function() { return this.go$val.Day(); };
	Time.Ptr.prototype.Weekday = function() {
		var _struct, t;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return absWeekday(t.abs());
	};
	Time.prototype.Weekday = function() { return this.go$val.Weekday(); };
	var absWeekday = function(abs) {
		var sec, _q;
		sec = go$div64((new Go$Uint64(abs.high + 0, abs.low + 86400)), new Go$Uint64(0, 604800), true);
		return ((_q = (sec.low >> 0) / 86400, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0);
	};
	Time.Ptr.prototype.ISOWeek = function() {
		var year, week, _struct, t, _tuple, month, day, yday, _r, wday, _q, _r$1, jan1wday, dec31wday, _r$2;
		year = 0;
		week = 0;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.date(true), year = _tuple[0], month = _tuple[1], day = _tuple[2], yday = _tuple[3];
		wday = (_r = ((t.Weekday() + 6 >> 0) >> 0) % 7, _r === _r ? _r : go$throwRuntimeError("integer divide by zero"));
		week = (_q = (((yday - wday >> 0) + 7 >> 0)) / 7, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		jan1wday = (_r$1 = (((wday - yday >> 0) + 371 >> 0)) % 7, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero"));
		if (1 <= jan1wday && jan1wday <= 3) {
			week = week + 1 >> 0;
		}
		if (week === 0) {
			year = year - 1 >> 0;
			week = 52;
			if ((jan1wday === 4) || ((jan1wday === 5) && isLeap(year))) {
				week = week + 1 >> 0;
			}
		}
		if ((month === 12) && day >= 29 && wday < 3) {
			if (dec31wday = (_r$2 = (((wday + 31 >> 0) - day >> 0)) % 7, _r$2 === _r$2 ? _r$2 : go$throwRuntimeError("integer divide by zero")), 0 <= dec31wday && dec31wday <= 2) {
				year = year + 1 >> 0;
				week = 1;
			}
		}
		return [year, week];
	};
	Time.prototype.ISOWeek = function() { return this.go$val.ISOWeek(); };
	Time.Ptr.prototype.Clock = function() {
		var hour, min, sec, _struct, t, _tuple;
		hour = 0;
		min = 0;
		sec = 0;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = absClock(t.abs()), hour = _tuple[0], min = _tuple[1], sec = _tuple[2];
		return [hour, min, sec];
	};
	Time.prototype.Clock = function() { return this.go$val.Clock(); };
	var absClock = function(abs) {
		var hour, min, sec, _q, _q$1;
		hour = 0;
		min = 0;
		sec = 0;
		sec = (go$div64(abs, new Go$Uint64(0, 86400), true).low >> 0);
		hour = (_q = sec / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		sec = sec - (((((hour >>> 16 << 16) * 3600 >> 0) + (hour << 16 >>> 16) * 3600) >> 0)) >> 0;
		min = (_q$1 = sec / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
		sec = sec - (((((min >>> 16 << 16) * 60 >> 0) + (min << 16 >>> 16) * 60) >> 0)) >> 0;
		return [hour, min, sec];
	};
	Time.Ptr.prototype.Hour = function() {
		var _struct, t, _q;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (_q = (go$div64(t.abs(), new Go$Uint64(0, 86400), true).low >> 0) / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
	};
	Time.prototype.Hour = function() { return this.go$val.Hour(); };
	Time.Ptr.prototype.Minute = function() {
		var _struct, t, _q;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (_q = (go$div64(t.abs(), new Go$Uint64(0, 3600), true).low >> 0) / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
	};
	Time.prototype.Minute = function() { return this.go$val.Minute(); };
	Time.Ptr.prototype.Second = function() {
		var _struct, t;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (go$div64(t.abs(), new Go$Uint64(0, 60), true).low >> 0);
	};
	Time.prototype.Second = function() { return this.go$val.Second(); };
	Time.Ptr.prototype.Nanosecond = function() {
		var _struct, t;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (t.nsec >> 0);
	};
	Time.prototype.Nanosecond = function() { return this.go$val.Nanosecond(); };
	Time.Ptr.prototype.YearDay = function() {
		var _struct, t, _tuple, yday;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.date(false), yday = _tuple[3];
		return yday + 1 >> 0;
	};
	Time.prototype.YearDay = function() { return this.go$val.YearDay(); };
	Duration.prototype.String = function() {
		var d, buf, w, u, neg, prec, unit, _tuple, _tuple$1;
		d = this;
		buf = go$makeNativeArray("Uint8", 32, function() { return 0; });
		w = 32;
		u = new Go$Uint64(d.high, d.low);
		neg = (d.high < 0 || (d.high === 0 && d.low < 0));
		if (neg) {
			u = new Go$Uint64(-u.high, -u.low);
		}
		if ((u.high < 0 || (u.high === 0 && u.low < 1000000000))) {
			prec = 0, unit = 0;
			if ((u.high === 0 && u.low === 0)) {
				return "0";
			} else if ((u.high < 0 || (u.high === 0 && u.low < 1000))) {
				prec = 0;
				unit = 110;
			} else if ((u.high < 0 || (u.high === 0 && u.low < 1000000))) {
				prec = 3;
				unit = 117;
			} else {
				prec = 6;
				unit = 109;
			}
			w = w - 2 >> 0;
			buf[w] = unit;
			buf[w + 1 >> 0] = 115;
			_tuple = fmtFrac(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w), u, prec), w = _tuple[0], u = _tuple[1];
			w = fmtInt(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w), u);
		} else {
			w = w - 1 >> 0;
			buf[w] = 115;
			_tuple$1 = fmtFrac(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w), u, 9), w = _tuple$1[0], u = _tuple$1[1];
			w = fmtInt(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w), go$div64(u, new Go$Uint64(0, 60), true));
			u = go$div64(u, new Go$Uint64(0, 60), false);
			if ((u.high > 0 || (u.high === 0 && u.low > 0))) {
				w = w - 1 >> 0;
				buf[w] = 109;
				w = fmtInt(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w), go$div64(u, new Go$Uint64(0, 60), true));
				u = go$div64(u, new Go$Uint64(0, 60), false);
				if ((u.high > 0 || (u.high === 0 && u.low > 0))) {
					w = w - 1 >> 0;
					buf[w] = 104;
					w = fmtInt(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w), u);
				}
			}
		}
		if (neg) {
			w = w - 1 >> 0;
			buf[w] = 45;
		}
		return go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(buf), w));
	};
	go$ptrType(Duration).prototype.String = function() { return this.go$get().String(); };
	var fmtFrac = function(buf, v, prec) {
		var nw, nv, w, print, i, digit, _slice, _index, _slice$1, _index$1, _tuple;
		nw = 0;
		nv = new Go$Uint64(0, 0);
		w = buf.length;
		print = false;
		i = 0;
		while (i < prec) {
			digit = go$div64(v, new Go$Uint64(0, 10), true);
			print = print || !((digit.high === 0 && digit.low === 0));
			if (print) {
				w = w - 1 >> 0;
				_slice = buf, _index = w, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (digit.low << 24 >>> 24) + 48 << 24 >>> 24) : go$throwRuntimeError("index out of range");
			}
			v = go$div64(v, new Go$Uint64(0, 10), false);
			i = i + 1 >> 0;
		}
		if (print) {
			w = w - 1 >> 0;
			_slice$1 = buf, _index$1 = w, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 46) : go$throwRuntimeError("index out of range");
		}
		_tuple = [w, v], nw = _tuple[0], nv = _tuple[1];
		return [nw, nv];
	};
	var fmtInt = function(buf, v) {
		var w, _slice, _index, _slice$1, _index$1;
		w = buf.length;
		if ((v.high === 0 && v.low === 0)) {
			w = w - 1 >> 0;
			_slice = buf, _index = w, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 48) : go$throwRuntimeError("index out of range");
		} else {
			while ((v.high > 0 || (v.high === 0 && v.low > 0))) {
				w = w - 1 >> 0;
				_slice$1 = buf, _index$1 = w, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (go$div64(v, new Go$Uint64(0, 10), true).low << 24 >>> 24) + 48 << 24 >>> 24) : go$throwRuntimeError("index out of range");
				v = go$div64(v, new Go$Uint64(0, 10), false);
			}
		}
		return w;
	};
	Duration.prototype.Nanoseconds = function() {
		var d;
		d = this;
		return new Go$Int64(d.high, d.low);
	};
	go$ptrType(Duration).prototype.Nanoseconds = function() { return this.go$get().Nanoseconds(); };
	Duration.prototype.Seconds = function() {
		var d, sec, nsec;
		d = this;
		sec = go$div64(d, new Duration(0, 1000000000), false);
		nsec = go$div64(d, new Duration(0, 1000000000), true);
		return go$flatten64(sec) + go$flatten64(nsec) * 1e-09;
	};
	go$ptrType(Duration).prototype.Seconds = function() { return this.go$get().Seconds(); };
	Duration.prototype.Minutes = function() {
		var d, min, nsec;
		d = this;
		min = go$div64(d, new Duration(13, 4165425152), false);
		nsec = go$div64(d, new Duration(13, 4165425152), true);
		return go$flatten64(min) + go$flatten64(nsec) * 1.6666666666666667e-11;
	};
	go$ptrType(Duration).prototype.Minutes = function() { return this.go$get().Minutes(); };
	Duration.prototype.Hours = function() {
		var d, hour, nsec;
		d = this;
		hour = go$div64(d, new Duration(838, 817405952), false);
		nsec = go$div64(d, new Duration(838, 817405952), true);
		return go$flatten64(hour) + go$flatten64(nsec) * 2.777777777777778e-13;
	};
	go$ptrType(Duration).prototype.Hours = function() { return this.go$get().Hours(); };
	Time.Ptr.prototype.Add = function(d) {
		var _struct, t, x, x$1, x$2, x$3, nsec, x$4, x$5, _struct$1;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		t.sec = (x = t.sec, x$1 = (x$2 = go$div64(d, new Duration(0, 1000000000), false), new Go$Int64(x$2.high, x$2.low)), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
		nsec = (t.nsec >> 0) + ((x$3 = go$div64(d, new Duration(0, 1000000000), true), x$3.low + ((x$3.high >> 31) * 4294967296)) >> 0) >> 0;
		if (nsec >= 1000000000) {
			t.sec = (x$4 = t.sec, new Go$Int64(x$4.high + 0, x$4.low + 1));
			nsec = nsec - 1000000000 >> 0;
		} else if (nsec < 0) {
			t.sec = (x$5 = t.sec, new Go$Int64(x$5.high - 0, x$5.low - 1));
			nsec = nsec + 1000000000 >> 0;
		}
		t.nsec = (nsec >>> 0);
		return (_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
	};
	Time.prototype.Add = function(d) { return this.go$val.Add(d); };
	Time.Ptr.prototype.Sub = function(u) {
		var _struct, t, x, x$1, x$2, x$3, x$4, d, _struct$1, _struct$2;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		d = (x = go$mul64((x$1 = (x$2 = t.sec, x$3 = u.sec, new Go$Int64(x$2.high - x$3.high, x$2.low - x$3.low)), new Duration(x$1.high, x$1.low)), new Duration(0, 1000000000)), x$4 = new Duration(0, ((t.nsec >> 0) - (u.nsec >> 0) >> 0)), new Duration(x.high + x$4.high, x.low + x$4.low));
		if (u.Add(d).Equal((_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc)))) {
			return d;
		} else if (t.Before((_struct$2 = u, new Time.Ptr(_struct$2.sec, _struct$2.nsec, _struct$2.loc)))) {
			return new Duration(-2147483648, 0);
		} else {
			return new Duration(2147483647, 4294967295);
		}
	};
	Time.prototype.Sub = function(u) { return this.go$val.Sub(u); };
	var Since = go$pkg.Since = function(t) {
		var _struct;
		return Now().Sub((_struct = t, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc)));
	};
	Time.Ptr.prototype.AddDate = function(years, months$1, days$1) {
		var _struct, t, _tuple, year, month, day, _tuple$1, hour, min, sec, _struct$1;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.Date(), year = _tuple[0], month = _tuple[1], day = _tuple[2];
		_tuple$1 = t.Clock(), hour = _tuple$1[0], min = _tuple$1[1], sec = _tuple$1[2];
		return (_struct$1 = Date(year + years >> 0, month + (months$1 >> 0) >> 0, day + days$1 >> 0, hour, min, sec, (t.nsec >> 0), t.loc), new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
	};
	Time.prototype.AddDate = function(years, months$1, days$1) { return this.go$val.AddDate(years, months$1, days$1); };
	Time.Ptr.prototype.date = function(full) {
		var year, month, day, yday, _struct, t, _tuple;
		year = 0;
		month = 0;
		day = 0;
		yday = 0;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = absDate(t.abs(), full), year = _tuple[0], month = _tuple[1], day = _tuple[2], yday = _tuple[3];
		return [year, month, day, yday];
	};
	Time.prototype.date = function(full) { return this.go$val.date(full); };
	var absDate = function(abs, full) {
		var year, month, day, yday, d, n, y, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x$10, _q, end, begin;
		year = 0;
		month = 0;
		day = 0;
		yday = 0;
		d = go$div64(abs, new Go$Uint64(0, 86400), false);
		n = go$div64(d, new Go$Uint64(0, 146097), false);
		y = go$mul64(new Go$Uint64(0, 400), n);
		d = (x = go$mul64(new Go$Uint64(0, 146097), n), new Go$Uint64(d.high - x.high, d.low - x.low));
		n = go$div64(d, new Go$Uint64(0, 36524), false);
		n = (x$1 = go$shiftRightUint64(n, 2), new Go$Uint64(n.high - x$1.high, n.low - x$1.low));
		y = (x$2 = go$mul64(new Go$Uint64(0, 100), n), new Go$Uint64(y.high + x$2.high, y.low + x$2.low));
		d = (x$3 = go$mul64(new Go$Uint64(0, 36524), n), new Go$Uint64(d.high - x$3.high, d.low - x$3.low));
		n = go$div64(d, new Go$Uint64(0, 1461), false);
		y = (x$4 = go$mul64(new Go$Uint64(0, 4), n), new Go$Uint64(y.high + x$4.high, y.low + x$4.low));
		d = (x$5 = go$mul64(new Go$Uint64(0, 1461), n), new Go$Uint64(d.high - x$5.high, d.low - x$5.low));
		n = go$div64(d, new Go$Uint64(0, 365), false);
		n = (x$6 = go$shiftRightUint64(n, 2), new Go$Uint64(n.high - x$6.high, n.low - x$6.low));
		y = (x$7 = n, new Go$Uint64(y.high + x$7.high, y.low + x$7.low));
		d = (x$8 = go$mul64(new Go$Uint64(0, 365), n), new Go$Uint64(d.high - x$8.high, d.low - x$8.low));
		year = ((x$9 = (x$10 = new Go$Int64(y.high, y.low), new Go$Int64(x$10.high + -69, x$10.low + 4075721025)), x$9.low + ((x$9.high >> 31) * 4294967296)) >> 0);
		yday = (d.low >> 0);
		if (!full) {
			return [year, month, day, yday];
		}
		day = yday;
		if (isLeap(year)) {
			if (day > 59) {
				day = day - 1 >> 0;
			} else if (day === 59) {
				month = 2;
				day = 29;
				return [year, month, day, yday];
			}
		}
		month = ((_q = day / 31, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0);
		end = (daysBefore[(month + 1 >> 0)] >> 0);
		begin = 0;
		if (day >= end) {
			month = month + 1 >> 0;
			begin = end;
		} else {
			begin = (daysBefore[month] >> 0);
		}
		month = month + 1 >> 0;
		day = (day - begin >> 0) + 1 >> 0;
		return [year, month, day, yday];
	};
	var daysIn = function(m, year) {
		if ((m === 2) && isLeap(year)) {
			return 29;
		}
		return ((daysBefore[m] - daysBefore[(m - 1 >> 0)] >> 0) >> 0);
	};
	var now = go$now;
	var Now = go$pkg.Now = function() {
		var _tuple, sec, nsec;
		_tuple = now(), sec = _tuple[0], nsec = _tuple[1];
		return new Time.Ptr(new Go$Int64(sec.high + 14, sec.low + 2006054656), (nsec >>> 0), go$pkg.Local);
	};
	Time.Ptr.prototype.UTC = function() {
		var _struct, t, _struct$1;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		t.loc = go$pkg.UTC;
		return (_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
	};
	Time.prototype.UTC = function() { return this.go$val.UTC(); };
	Time.Ptr.prototype.Local = function() {
		var _struct, t, _struct$1;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		t.loc = go$pkg.Local;
		return (_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
	};
	Time.prototype.Local = function() { return this.go$val.Local(); };
	Time.Ptr.prototype.In = function(loc) {
		var _struct, t, _struct$1;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		if (loc === (go$ptrType(Location)).nil) {
			throw go$panic(new Go$String("time: missing Location in call to Time.In"));
		}
		t.loc = loc;
		return (_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
	};
	Time.prototype.In = function(loc) { return this.go$val.In(loc); };
	Time.Ptr.prototype.Location = function() {
		var _struct, t, l;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		l = t.loc;
		if (l === (go$ptrType(Location)).nil) {
			l = go$pkg.UTC;
		}
		return l;
	};
	Time.prototype.Location = function() { return this.go$val.Location(); };
	Time.Ptr.prototype.Zone = function() {
		var name, offset, _struct, t, _tuple, x;
		name = "";
		offset = 0;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		_tuple = t.loc.lookup((x = t.sec, new Go$Int64(x.high + -15, x.low + 2288912640))), name = _tuple[0], offset = _tuple[1];
		return [name, offset];
	};
	Time.prototype.Zone = function() { return this.go$val.Zone(); };
	Time.Ptr.prototype.Unix = function() {
		var _struct, t, x;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (x = t.sec, new Go$Int64(x.high + -15, x.low + 2288912640));
	};
	Time.prototype.Unix = function() { return this.go$val.Unix(); };
	Time.Ptr.prototype.UnixNano = function() {
		var _struct, t, x, x$1, x$2, x$3;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return (x = go$mul64(((x$1 = t.sec, new Go$Int64(x$1.high + -15, x$1.low + 2288912640))), new Go$Int64(0, 1000000000)), x$2 = (x$3 = t.nsec, new Go$Int64(0, x$3.constructor === Number ? x$3 : 1)), new Go$Int64(x.high + x$2.high, x.low + x$2.low));
	};
	Time.prototype.UnixNano = function() { return this.go$val.UnixNano(); };
	Time.Ptr.prototype.MarshalBinary = function() {
		var _struct, t, offsetMin, _tuple, offset, _r, _q, enc;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		offsetMin = 0;
		if (t.Location() === utcLoc) {
			offsetMin = -1;
		} else {
			_tuple = t.Zone(), offset = _tuple[1];
			if (!(((_r = offset % 60, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0))) {
				return [(go$sliceType(Go$Uint8)).nil, errors.New("Time.MarshalBinary: zone offset has fractional minute")];
			}
			offset = (_q = offset / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
			if (offset < -32768 || (offset === -1) || offset > 32767) {
				return [(go$sliceType(Go$Uint8)).nil, errors.New("Time.MarshalBinary: unexpected zone offset")];
			}
			offsetMin = (offset << 16 >> 16);
		}
		enc = new (go$sliceType(Go$Uint8))([1, (go$shiftRightInt64(t.sec, 56).low << 24 >>> 24), (go$shiftRightInt64(t.sec, 48).low << 24 >>> 24), (go$shiftRightInt64(t.sec, 40).low << 24 >>> 24), (go$shiftRightInt64(t.sec, 32).low << 24 >>> 24), (go$shiftRightInt64(t.sec, 24).low << 24 >>> 24), (go$shiftRightInt64(t.sec, 16).low << 24 >>> 24), (go$shiftRightInt64(t.sec, 8).low << 24 >>> 24), (t.sec.low << 24 >>> 24), ((t.nsec >>> 24 >>> 0) << 24 >>> 24), ((t.nsec >>> 16 >>> 0) << 24 >>> 24), ((t.nsec >>> 8 >>> 0) << 24 >>> 24), (t.nsec << 24 >>> 24), ((offsetMin >> 8 << 16 >> 16) << 24 >>> 24), (offsetMin << 24 >>> 24)]);
		return [enc, null];
	};
	Time.prototype.MarshalBinary = function() { return this.go$val.MarshalBinary(); };
	Time.Ptr.prototype.UnmarshalBinary = function(data$1) {
		var t, buf, _slice, _index, x, x$1, x$2, x$3, x$4, x$5, x$6, _slice$1, _index$1, x$7, _slice$2, _index$2, x$8, _slice$3, _index$3, x$9, _slice$4, _index$4, x$10, _slice$5, _index$5, x$11, _slice$6, _index$6, x$12, _slice$7, _index$7, x$13, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10, _slice$11, _index$11, _slice$12, _index$12, x$14, _slice$13, _index$13, _slice$14, _index$14, x$15, offset, localoff, _tuple, x$16;
		t = this;
		buf = data$1;
		if (buf.length === 0) {
			return errors.New("Time.UnmarshalBinary: no data");
		}
		if (!(((_slice = buf, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 1))) {
			return errors.New("Time.UnmarshalBinary: unsupported version");
		}
		if (!((buf.length === 15))) {
			return errors.New("Time.UnmarshalBinary: invalid length");
		}
		buf = go$subslice(buf, 1);
		t.sec = (x = (x$1 = (x$2 = (x$3 = (x$4 = (x$5 = (x$6 = new Go$Int64(0, (_slice$1 = buf, _index$1 = 7, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))), x$7 = go$shiftLeft64(new Go$Int64(0, (_slice$2 = buf, _index$2 = 6, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))), 8), new Go$Int64(x$6.high | x$7.high, (x$6.low | x$7.low) >>> 0)), x$8 = go$shiftLeft64(new Go$Int64(0, (_slice$3 = buf, _index$3 = 5, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"))), 16), new Go$Int64(x$5.high | x$8.high, (x$5.low | x$8.low) >>> 0)), x$9 = go$shiftLeft64(new Go$Int64(0, (_slice$4 = buf, _index$4 = 4, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"))), 24), new Go$Int64(x$4.high | x$9.high, (x$4.low | x$9.low) >>> 0)), x$10 = go$shiftLeft64(new Go$Int64(0, (_slice$5 = buf, _index$5 = 3, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"))), 32), new Go$Int64(x$3.high | x$10.high, (x$3.low | x$10.low) >>> 0)), x$11 = go$shiftLeft64(new Go$Int64(0, (_slice$6 = buf, _index$6 = 2, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range"))), 40), new Go$Int64(x$2.high | x$11.high, (x$2.low | x$11.low) >>> 0)), x$12 = go$shiftLeft64(new Go$Int64(0, (_slice$7 = buf, _index$7 = 1, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range"))), 48), new Go$Int64(x$1.high | x$12.high, (x$1.low | x$12.low) >>> 0)), x$13 = go$shiftLeft64(new Go$Int64(0, (_slice$8 = buf, _index$8 = 0, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range"))), 56), new Go$Int64(x.high | x$13.high, (x.low | x$13.low) >>> 0));
		buf = go$subslice(buf, 8);
		t.nsec = ((((((_slice$9 = buf, _index$9 = 3, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")) >> 0) | (((_slice$10 = buf, _index$10 = 2, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")) >> 0) << 8 >> 0)) | (((_slice$11 = buf, _index$11 = 1, (_index$11 >= 0 && _index$11 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$11] : go$throwRuntimeError("index out of range")) >> 0) << 16 >> 0)) | (((_slice$12 = buf, _index$12 = 0, (_index$12 >= 0 && _index$12 < _slice$12.length) ? _slice$12.array[_slice$12.offset + _index$12] : go$throwRuntimeError("index out of range")) >> 0) << 24 >> 0)) >>> 0);
		buf = go$subslice(buf, 4);
		offset = (x$14 = ((((_slice$13 = buf, _index$13 = 1, (_index$13 >= 0 && _index$13 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$13] : go$throwRuntimeError("index out of range")) << 16 >> 16) | (((_slice$14 = buf, _index$14 = 0, (_index$14 >= 0 && _index$14 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$14] : go$throwRuntimeError("index out of range")) << 16 >> 16) << 8 << 16 >> 16)) >> 0), x$15 = 60, (((x$14 >>> 16 << 16) * x$15 >> 0) + (x$14 << 16 >>> 16) * x$15) >> 0);
		if (offset === -60) {
			t.loc = utcLoc;
		} else if (_tuple = go$pkg.Local.lookup((x$16 = t.sec, new Go$Int64(x$16.high + -15, x$16.low + 2288912640))), localoff = _tuple[1], offset === localoff) {
			t.loc = go$pkg.Local;
		} else {
			t.loc = FixedZone("", offset);
		}
		return null;
	};
	Time.prototype.UnmarshalBinary = function(data$1) { return this.go$val.UnmarshalBinary(data$1); };
	Time.Ptr.prototype.GobEncode = function() {
		var _struct, t;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		return t.MarshalBinary();
	};
	Time.prototype.GobEncode = function() { return this.go$val.GobEncode(); };
	Time.Ptr.prototype.GobDecode = function(data$1) {
		var t;
		t = this;
		return t.UnmarshalBinary(data$1);
	};
	Time.prototype.GobDecode = function(data$1) { return this.go$val.GobDecode(data$1); };
	Time.Ptr.prototype.MarshalJSON = function() {
		var _struct, t, y;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		if (y = t.Year(), y < 0 || y >= 10000) {
			return [(go$sliceType(Go$Uint8)).nil, errors.New("Time.MarshalJSON: year outside of range [0,9999]")];
		}
		return [new (go$sliceType(Go$Uint8))(go$stringToBytes(t.Format("\"2006-01-02T15:04:05.999999999Z07:00\""))), null];
	};
	Time.prototype.MarshalJSON = function() { return this.go$val.MarshalJSON(); };
	Time.Ptr.prototype.UnmarshalJSON = function(data$1) {
		var err, t, _tuple, _struct, l, r;
		err = null;
		t = this;
		_tuple = Parse("\"2006-01-02T15:04:05Z07:00\"", go$bytesToString(data$1)), l = t, r = (_struct = _tuple[0], new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc)), l.sec = r.sec, l.nsec = r.nsec, l.loc = r.loc, err = _tuple[1];
		return err;
	};
	Time.prototype.UnmarshalJSON = function(data$1) { return this.go$val.UnmarshalJSON(data$1); };
	Time.Ptr.prototype.MarshalText = function() {
		var _struct, t, y;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		if (y = t.Year(), y < 0 || y >= 10000) {
			return [(go$sliceType(Go$Uint8)).nil, errors.New("Time.MarshalText: year outside of range [0,9999]")];
		}
		return [new (go$sliceType(Go$Uint8))(go$stringToBytes(t.Format("2006-01-02T15:04:05.999999999Z07:00"))), null];
	};
	Time.prototype.MarshalText = function() { return this.go$val.MarshalText(); };
	Time.Ptr.prototype.UnmarshalText = function(data$1) {
		var err, t, _tuple, _struct, l, r;
		err = null;
		t = this;
		_tuple = Parse("2006-01-02T15:04:05Z07:00", go$bytesToString(data$1)), l = t, r = (_struct = _tuple[0], new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc)), l.sec = r.sec, l.nsec = r.nsec, l.loc = r.loc, err = _tuple[1];
		return err;
	};
	Time.prototype.UnmarshalText = function(data$1) { return this.go$val.UnmarshalText(data$1); };
	var Unix = go$pkg.Unix = function(sec, nsec) {
		var n, x, x$1;
		if ((nsec.high < 0 || (nsec.high === 0 && nsec.low < 0)) || (nsec.high > 0 || (nsec.high === 0 && nsec.low >= 1000000000))) {
			n = go$div64(nsec, new Go$Int64(0, 1000000000), false);
			sec = (x = n, new Go$Int64(sec.high + x.high, sec.low + x.low));
			nsec = (x$1 = go$mul64(n, new Go$Int64(0, 1000000000)), new Go$Int64(nsec.high - x$1.high, nsec.low - x$1.low));
			if ((nsec.high < 0 || (nsec.high === 0 && nsec.low < 0))) {
				nsec = new Go$Int64(nsec.high + 0, nsec.low + 1000000000);
				sec = new Go$Int64(sec.high - 0, sec.low - 1);
			}
		}
		return new Time.Ptr(new Go$Int64(sec.high + 14, sec.low + 2006054656), (nsec.low >>> 0), go$pkg.Local);
	};
	var isLeap = function(year) {
		var _r, _r$1, _r$2;
		return ((_r = year % 4, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0) && (!(((_r$1 = year % 100, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero")) === 0)) || ((_r$2 = year % 400, _r$2 === _r$2 ? _r$2 : go$throwRuntimeError("integer divide by zero")) === 0));
	};
	var norm = function(hi, lo, base) {
		var nhi, nlo, _q, n, _q$1, n$1, _tuple;
		nhi = 0;
		nlo = 0;
		if (lo < 0) {
			n = (_q = ((-lo - 1 >> 0)) / base, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) + 1 >> 0;
			hi = hi - (n) >> 0;
			lo = lo + (((((n >>> 16 << 16) * base >> 0) + (n << 16 >>> 16) * base) >> 0)) >> 0;
		}
		if (lo >= base) {
			n$1 = (_q$1 = lo / base, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
			hi = hi + (n$1) >> 0;
			lo = lo - (((((n$1 >>> 16 << 16) * base >> 0) + (n$1 << 16 >>> 16) * base) >> 0)) >> 0;
		}
		_tuple = [hi, lo], nhi = _tuple[0], nlo = _tuple[1];
		return [nhi, nlo];
	};
	var Date = go$pkg.Date = function(year, month, day, hour, min, sec, nsec, loc) {
		var m, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, x, x$1, y, n, x$2, d, x$3, x$4, x$5, x$6, x$7, x$8, x$9, abs, x$10, x$11, unix, _tuple$5, offset, start, end, x$12, utc, _tuple$6, _tuple$7, x$13;
		if (loc === (go$ptrType(Location)).nil) {
			throw go$panic(new Go$String("time: missing Location in call to Date"));
		}
		m = (month >> 0) - 1 >> 0;
		_tuple = norm(year, m, 12), year = _tuple[0], m = _tuple[1];
		month = (m >> 0) + 1 >> 0;
		_tuple$1 = norm(sec, nsec, 1000000000), sec = _tuple$1[0], nsec = _tuple$1[1];
		_tuple$2 = norm(min, sec, 60), min = _tuple$2[0], sec = _tuple$2[1];
		_tuple$3 = norm(hour, min, 60), hour = _tuple$3[0], min = _tuple$3[1];
		_tuple$4 = norm(day, hour, 24), day = _tuple$4[0], hour = _tuple$4[1];
		y = (x = (x$1 = new Go$Int64(0, year), new Go$Int64(x$1.high - -69, x$1.low - 4075721025)), new Go$Uint64(x.high, x.low));
		n = go$div64(y, new Go$Uint64(0, 400), false);
		y = (x$2 = go$mul64(new Go$Uint64(0, 400), n), new Go$Uint64(y.high - x$2.high, y.low - x$2.low));
		d = go$mul64(new Go$Uint64(0, 146097), n);
		n = go$div64(y, new Go$Uint64(0, 100), false);
		y = (x$3 = go$mul64(new Go$Uint64(0, 100), n), new Go$Uint64(y.high - x$3.high, y.low - x$3.low));
		d = (x$4 = go$mul64(new Go$Uint64(0, 36524), n), new Go$Uint64(d.high + x$4.high, d.low + x$4.low));
		n = go$div64(y, new Go$Uint64(0, 4), false);
		y = (x$5 = go$mul64(new Go$Uint64(0, 4), n), new Go$Uint64(y.high - x$5.high, y.low - x$5.low));
		d = (x$6 = go$mul64(new Go$Uint64(0, 1461), n), new Go$Uint64(d.high + x$6.high, d.low + x$6.low));
		n = y;
		d = (x$7 = go$mul64(new Go$Uint64(0, 365), n), new Go$Uint64(d.high + x$7.high, d.low + x$7.low));
		d = (x$8 = new Go$Uint64(0, daysBefore[(month - 1 >> 0)]), new Go$Uint64(d.high + x$8.high, d.low + x$8.low));
		if (isLeap(year) && month >= 3) {
			d = new Go$Uint64(d.high + 0, d.low + 1);
		}
		d = (x$9 = new Go$Uint64(0, (day - 1 >> 0)), new Go$Uint64(d.high + x$9.high, d.low + x$9.low));
		abs = go$mul64(d, new Go$Uint64(0, 86400));
		abs = (x$10 = new Go$Uint64(0, ((((((hour >>> 16 << 16) * 3600 >> 0) + (hour << 16 >>> 16) * 3600) >> 0) + ((((min >>> 16 << 16) * 60 >> 0) + (min << 16 >>> 16) * 60) >> 0) >> 0) + sec >> 0)), new Go$Uint64(abs.high + x$10.high, abs.low + x$10.low));
		unix = (x$11 = new Go$Int64(abs.high, abs.low), new Go$Int64(x$11.high + -2147483647, x$11.low + 3844486912));
		_tuple$5 = loc.lookup(unix), offset = _tuple$5[1], start = _tuple$5[3], end = _tuple$5[4];
		if (!((offset === 0))) {
			utc = (x$12 = new Go$Int64(0, offset), new Go$Int64(unix.high - x$12.high, unix.low - x$12.low));
			if ((utc.high < start.high || (utc.high === start.high && utc.low < start.low))) {
				_tuple$6 = loc.lookup(new Go$Int64(start.high - 0, start.low - 1)), offset = _tuple$6[1];
			} else if ((utc.high > end.high || (utc.high === end.high && utc.low >= end.low))) {
				_tuple$7 = loc.lookup(end), offset = _tuple$7[1];
			}
			unix = (x$13 = new Go$Int64(0, offset), new Go$Int64(unix.high - x$13.high, unix.low - x$13.low));
		}
		return new Time.Ptr(new Go$Int64(unix.high + 14, unix.low + 2006054656), (nsec >>> 0), loc);
	};
	Time.Ptr.prototype.Truncate = function(d) {
		var _struct, t, _struct$1, _tuple, _struct$2, r, _struct$3;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		if ((d.high < 0 || (d.high === 0 && d.low <= 0))) {
			return (_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
		}
		_tuple = div((_struct$2 = t, new Time.Ptr(_struct$2.sec, _struct$2.nsec, _struct$2.loc)), d), r = _tuple[1];
		return (_struct$3 = t.Add(new Duration(-r.high, -r.low)), new Time.Ptr(_struct$3.sec, _struct$3.nsec, _struct$3.loc));
	};
	Time.prototype.Truncate = function(d) { return this.go$val.Truncate(d); };
	Time.Ptr.prototype.Round = function(d) {
		var _struct, t, _struct$1, _tuple, _struct$2, r, x, _struct$3, _struct$4;
		t = (_struct = this, new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		if ((d.high < 0 || (d.high === 0 && d.low <= 0))) {
			return (_struct$1 = t, new Time.Ptr(_struct$1.sec, _struct$1.nsec, _struct$1.loc));
		}
		_tuple = div((_struct$2 = t, new Time.Ptr(_struct$2.sec, _struct$2.nsec, _struct$2.loc)), d), r = _tuple[1];
		if ((x = new Duration(r.high + r.high, r.low + r.low), (x.high < d.high || (x.high === d.high && x.low < d.low)))) {
			return (_struct$3 = t.Add(new Duration(-r.high, -r.low)), new Time.Ptr(_struct$3.sec, _struct$3.nsec, _struct$3.loc));
		}
		return (_struct$4 = t.Add(new Duration(d.high - r.high, d.low - r.low)), new Time.Ptr(_struct$4.sec, _struct$4.nsec, _struct$4.loc));
	};
	Time.prototype.Round = function(d) { return this.go$val.Round(d); };
	var div = function(t, d) {
		var qmod2, r, neg, nsec, x, x$1, x$2, x$3, x$4, _q, _r, x$5, d1, x$6, x$7, x$8, x$9, x$10, sec, tmp, u1, u0, _tuple, u0x, x$11, _tuple$1, d1$1, x$12, d0, _tuple$2, x$13, x$14, x$15;
		qmod2 = 0;
		r = new Duration(0, 0);
		neg = false;
		nsec = (t.nsec >> 0);
		if ((x = t.sec, (x.high < 0 || (x.high === 0 && x.low < 0)))) {
			neg = true;
			t.sec = (x$1 = t.sec, new Go$Int64(-x$1.high, -x$1.low));
			nsec = -nsec;
			if (nsec < 0) {
				nsec = nsec + 1000000000 >> 0;
				t.sec = (x$2 = t.sec, new Go$Int64(x$2.high - 0, x$2.low - 1));
			}
		}
		if ((d.high < 0 || (d.high === 0 && d.low < 1000000000)) && (x$3 = go$div64(new Duration(0, 1000000000), (new Duration(d.high + d.high, d.low + d.low)), true), (x$3.high === 0 && x$3.low === 0))) {
			qmod2 = ((_q = nsec / ((d.low + ((d.high >> 31) * 4294967296)) >> 0), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0) & 1;
			r = new Duration(0, (_r = nsec % ((d.low + ((d.high >> 31) * 4294967296)) >> 0), _r === _r ? _r : go$throwRuntimeError("integer divide by zero")));
		} else if ((x$4 = go$div64(d, new Duration(0, 1000000000), true), (x$4.high === 0 && x$4.low === 0))) {
			d1 = (x$5 = go$div64(d, new Duration(0, 1000000000), false), new Go$Int64(x$5.high, x$5.low));
			qmod2 = ((x$6 = go$div64(t.sec, d1, false), x$6.low + ((x$6.high >> 31) * 4294967296)) >> 0) & 1;
			r = (x$7 = go$mul64((x$8 = go$div64(t.sec, d1, true), new Duration(x$8.high, x$8.low)), new Duration(0, 1000000000)), x$9 = new Duration(0, nsec), new Duration(x$7.high + x$9.high, x$7.low + x$9.low));
		} else {
			sec = (x$10 = t.sec, new Go$Uint64(x$10.high, x$10.low));
			tmp = go$mul64((go$shiftRightUint64(sec, 32)), new Go$Uint64(0, 1000000000));
			u1 = go$shiftRightUint64(tmp, 32);
			u0 = go$shiftLeft64(tmp, 32);
			tmp = go$mul64(new Go$Uint64(sec.high & 0, (sec.low & 4294967295) >>> 0), new Go$Uint64(0, 1000000000));
			_tuple = [u0, new Go$Uint64(u0.high + tmp.high, u0.low + tmp.low)], u0x = _tuple[0], u0 = _tuple[1];
			if ((u0.high < u0x.high || (u0.high === u0x.high && u0.low < u0x.low))) {
				u1 = new Go$Uint64(u1.high + 0, u1.low + 1);
			}
			_tuple$1 = [u0, (x$11 = new Go$Uint64(0, nsec), new Go$Uint64(u0.high + x$11.high, u0.low + x$11.low))], u0x = _tuple$1[0], u0 = _tuple$1[1];
			if ((u0.high < u0x.high || (u0.high === u0x.high && u0.low < u0x.low))) {
				u1 = new Go$Uint64(u1.high + 0, u1.low + 1);
			}
			d1$1 = new Go$Uint64(d.high, d.low);
			while (!((x$12 = go$shiftRightUint64(d1$1, 63), (x$12.high === 0 && x$12.low === 1)))) {
				d1$1 = go$shiftLeft64(d1$1, 1);
			}
			d0 = new Go$Uint64(0, 0);
			while (true) {
				qmod2 = 0;
				if ((u1.high > d1$1.high || (u1.high === d1$1.high && u1.low > d1$1.low)) || (u1.high === d1$1.high && u1.low === d1$1.low) && (u0.high > d0.high || (u0.high === d0.high && u0.low >= d0.low))) {
					qmod2 = 1;
					_tuple$2 = [u0, new Go$Uint64(u0.high - d0.high, u0.low - d0.low)], u0x = _tuple$2[0], u0 = _tuple$2[1];
					if ((u0.high > u0x.high || (u0.high === u0x.high && u0.low > u0x.low))) {
						u1 = new Go$Uint64(u1.high - 0, u1.low - 1);
					}
					u1 = (x$13 = d1$1, new Go$Uint64(u1.high - x$13.high, u1.low - x$13.low));
				}
				if ((d1$1.high === 0 && d1$1.low === 0) && (x$14 = new Go$Uint64(d.high, d.low), (d0.high === x$14.high && d0.low === x$14.low))) {
					break;
				}
				d0 = go$shiftRightUint64(d0, 1);
				d0 = (x$15 = go$shiftLeft64((new Go$Uint64(d1$1.high & 0, (d1$1.low & 1) >>> 0)), 63), new Go$Uint64(d0.high | x$15.high, (d0.low | x$15.low) >>> 0));
				d1$1 = go$shiftRightUint64(d1$1, 1);
			}
			r = new Duration(u0.high, u0.low);
		}
		if (neg && !((r.high === 0 && r.low === 0))) {
			qmod2 = (qmod2 ^ 1) >> 0;
			r = new Duration(d.high - r.high, d.low - r.low);
		}
		return [qmod2, r];
	};
	Location.Ptr.prototype.get = function() {
		var l;
		l = this;
		if (l === (go$ptrType(Location)).nil) {
			return utcLoc;
		}
		if (l === localLoc) {
			localOnce.Do(initLocal);
		}
		return l;
	};
	Location.prototype.get = function() { return this.go$val.get(); };
	Location.Ptr.prototype.String = function() {
		var l;
		l = this;
		return l.get().name;
	};
	Location.prototype.String = function() { return this.go$val.String(); };
	var FixedZone = go$pkg.FixedZone = function(name, offset) {
		var l, _slice, _index;
		l = new Location.Ptr(name, new (go$sliceType(zone))([new zone.Ptr(name, offset, false)]), new (go$sliceType(zoneTrans))([new zoneTrans.Ptr(new Go$Int64(-2147483648, 0), 0, false, false)]), new Go$Int64(-2147483648, 0), new Go$Int64(2147483647, 4294967295), (go$ptrType(zone)).nil);
		l.cacheZone = (_slice = l.zone, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		return l;
	};
	Location.Ptr.prototype.lookup = function(sec) {
		var name, offset, isDST, start, end, l, zone$1, x, x$1, tx, lo, hi, _q, m, _slice, _index, lim, _slice$1, _index$1, _slice$2, _index$2, zone$2, _slice$3, _index$3;
		name = "";
		offset = 0;
		isDST = false;
		start = new Go$Int64(0, 0);
		end = new Go$Int64(0, 0);
		l = this;
		l = l.get();
		if (l.tx.length === 0) {
			name = "UTC";
			offset = 0;
			isDST = false;
			start = new Go$Int64(-2147483648, 0);
			end = new Go$Int64(2147483647, 4294967295);
			return [name, offset, isDST, start, end];
		}
		if (zone$1 = l.cacheZone, !(zone$1 === (go$ptrType(zone)).nil) && (x = l.cacheStart, (x.high < sec.high || (x.high === sec.high && x.low <= sec.low))) && (x$1 = l.cacheEnd, (sec.high < x$1.high || (sec.high === x$1.high && sec.low < x$1.low)))) {
			name = zone$1.name;
			offset = zone$1.offset;
			isDST = zone$1.isDST;
			start = l.cacheStart;
			end = l.cacheEnd;
			return [name, offset, isDST, start, end];
		}
		tx = l.tx;
		end = new Go$Int64(2147483647, 4294967295);
		lo = 0;
		hi = tx.length;
		while ((hi - lo >> 0) > 1) {
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			lim = (_slice = tx, _index = m, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).when;
			if ((sec.high < lim.high || (sec.high === lim.high && sec.low < lim.low))) {
				end = lim;
				hi = m;
			} else {
				lo = m;
			}
		}
		zone$2 = (_slice$1 = l.zone, _index$1 = (_slice$2 = tx, _index$2 = lo, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).index, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
		name = zone$2.name;
		offset = zone$2.offset;
		isDST = zone$2.isDST;
		start = (_slice$3 = tx, _index$3 = lo, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).when;
		return [name, offset, isDST, start, end];
	};
	Location.prototype.lookup = function(sec) { return this.go$val.lookup(sec); };
	Location.Ptr.prototype.lookupName = function(name, unix) {
		var offset, isDST, ok, l, _ref, _i, i, _slice, _index, zone$1, _tuple, x, nam, offset$1, isDST$1, _tuple$1, _ref$1, _i$1, i$1, _slice$1, _index$1, zone$2, _tuple$2;
		offset = 0;
		isDST = false;
		ok = false;
		l = this;
		l = l.get();
		_ref = l.zone;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			zone$1 = (_slice = l.zone, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (zone$1.name === name) {
				_tuple = l.lookup((x = new Go$Int64(0, zone$1.offset), new Go$Int64(unix.high - x.high, unix.low - x.low))), nam = _tuple[0], offset$1 = _tuple[1], isDST$1 = _tuple[2];
				if (nam === zone$1.name) {
					_tuple$1 = [offset$1, isDST$1, true], offset = _tuple$1[0], isDST = _tuple$1[1], ok = _tuple$1[2];
					return [offset, isDST, ok];
				}
			}
			_i++;
		}
		_ref$1 = l.zone;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			i$1 = _i$1;
			zone$2 = (_slice$1 = l.zone, _index$1 = i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			if (zone$2.name === name) {
				_tuple$2 = [zone$2.offset, zone$2.isDST, true], offset = _tuple$2[0], isDST = _tuple$2[1], ok = _tuple$2[2];
				return [offset, isDST, ok];
			}
			_i$1++;
		}
		return [offset, isDST, ok];
	};
	Location.prototype.lookupName = function(name, unix) { return this.go$val.lookupName(name, unix); };
	var LoadLocation = go$pkg.LoadLocation = function(name) {
		var err, _tuple, z;
		if (name === "" || name === "UTC") {
			return [go$pkg.UTC, null];
		}
		if (name === "Local") {
			return [go$pkg.Local, null];
		}
		if (!(zoneinfo === "")) {
			if (_tuple = loadZoneFile(zoneinfo, name), z = _tuple[0], err = _tuple[1], go$interfaceIsEqual(err, null)) {
				z.name = name;
				return [z, null];
			}
		}
		return loadLocation(name);
	};
	data.Ptr.prototype.read = function(n) {
		var d, p;
		d = this;
		if (d.p.length < n) {
			d.p = (go$sliceType(Go$Uint8)).nil;
			d.error = true;
			return (go$sliceType(Go$Uint8)).nil;
		}
		p = go$subslice(d.p, 0, n);
		d.p = go$subslice(d.p, n);
		return p;
	};
	data.prototype.read = function(n) { return this.go$val.read(n); };
	data.Ptr.prototype.big4 = function() {
		var n, ok, d, p, _tuple, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _tuple$1;
		n = 0;
		ok = false;
		d = this;
		p = d.read(4);
		if (p.length < 4) {
			d.error = true;
			_tuple = [0, false], n = _tuple[0], ok = _tuple[1];
			return [n, ok];
		}
		_tuple$1 = [((((((((_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >>> 0) << 24 >>> 0) | (((_slice$1 = p, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >>> 0) << 16 >>> 0)) >>> 0) | (((_slice$2 = p, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) >>> 0) << 8 >>> 0)) >>> 0) | ((_slice$3 = p, _index$3 = 3, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) >>> 0)) >>> 0, true], n = _tuple$1[0], ok = _tuple$1[1];
		return [n, ok];
	};
	data.prototype.big4 = function() { return this.go$val.big4(); };
	data.Ptr.prototype.byte$ = function() {
		var n, ok, d, p, _tuple, _slice, _index, _tuple$1;
		n = 0;
		ok = false;
		d = this;
		p = d.read(1);
		if (p.length < 1) {
			d.error = true;
			_tuple = [0, false], n = _tuple[0], ok = _tuple[1];
			return [n, ok];
		}
		_tuple$1 = [(_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), true], n = _tuple$1[0], ok = _tuple$1[1];
		return [n, ok];
	};
	data.prototype.byte$ = function() { return this.go$val.byte$(); };
	var byteString = function(p) {
		var i, _slice, _index;
		i = 0;
		while (i < p.length) {
			if ((_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 0) {
				return go$bytesToString(go$subslice(p, 0, i));
			}
			i = i + 1 >> 0;
		}
		return go$bytesToString(p);
	};
	var loadZoneData = function(bytes) {
		var l, err, d, magic, _tuple, p, _slice, _index, _slice$1, _index$1, _tuple$1, n, i, _tuple$2, nn, ok, _tuple$3, x, x$1, txtimes, txzones, x$2, x$3, zonedata, abbrev$1, x$4, x$5, isstd, isutc, _tuple$4, zone$1, _ref, _i, i$1, ok$1, n$1, _tuple$5, _tuple$6, _slice$2, _index$2, b, _tuple$7, _tuple$8, _slice$3, _index$3, _tuple$9, _tuple$10, _slice$4, _index$4, tx, _ref$1, _i$1, i$2, ok$2, n$2, _tuple$11, _tuple$12, _slice$5, _index$5, _slice$6, _index$6, _tuple$13, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10, _slice$11, _index$11, _slice$12, _index$12, _tuple$14, sec, _ref$2, _i$2, i$3, x$6, _slice$13, _index$13, x$7, _slice$14, _index$14, _slice$15, _index$15, _slice$16, _index$16, _slice$17, _index$17, _slice$18, _index$18, _tuple$15;
		l = (go$ptrType(Location)).nil;
		err = null;
		d = new data.Ptr(bytes, false);
		if (magic = d.read(4), !(go$bytesToString(magic) === "TZif")) {
			_tuple = [(go$ptrType(Location)).nil, badData], l = _tuple[0], err = _tuple[1];
			return [l, err];
		}
		p = (go$sliceType(Go$Uint8)).nil;
		if (p = d.read(16), !((p.length === 16)) || !(((_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 0)) && !(((_slice$1 = p, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 50))) {
			_tuple$1 = [(go$ptrType(Location)).nil, badData], l = _tuple$1[0], err = _tuple$1[1];
			return [l, err];
		}
		n = go$makeNativeArray("Int", 6, function() { return 0; });
		i = 0;
		while (i < 6) {
			_tuple$2 = d.big4(), nn = _tuple$2[0], ok = _tuple$2[1];
			if (!ok) {
				_tuple$3 = [(go$ptrType(Location)).nil, badData], l = _tuple$3[0], err = _tuple$3[1];
				return [l, err];
			}
			n[i] = (nn >> 0);
			i = i + 1 >> 0;
		}
		txtimes = new data.Ptr(d.read((x = n[3], x$1 = 4, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0)), false);
		txzones = d.read(n[3]);
		zonedata = new data.Ptr(d.read((x$2 = n[4], x$3 = 6, (((x$2 >>> 16 << 16) * x$3 >> 0) + (x$2 << 16 >>> 16) * x$3) >> 0)), false);
		abbrev$1 = d.read(n[5]);
		d.read((x$4 = n[2], x$5 = 8, (((x$4 >>> 16 << 16) * x$5 >> 0) + (x$4 << 16 >>> 16) * x$5) >> 0));
		isstd = d.read(n[1]);
		isutc = d.read(n[0]);
		if (d.error) {
			_tuple$4 = [(go$ptrType(Location)).nil, badData], l = _tuple$4[0], err = _tuple$4[1];
			return [l, err];
		}
		zone$1 = (go$sliceType(zone)).make(n[4], 0, function() { return new zone.Ptr(); });
		_ref = zone$1;
		_i = 0;
		while (_i < _ref.length) {
			i$1 = _i;
			ok$1 = false;
			n$1 = 0;
			if (_tuple$5 = zonedata.big4(), n$1 = _tuple$5[0], ok$1 = _tuple$5[1], !ok$1) {
				_tuple$6 = [(go$ptrType(Location)).nil, badData], l = _tuple$6[0], err = _tuple$6[1];
				return [l, err];
			}
			(_slice$2 = zone$1, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).offset = ((n$1 >> 0) >> 0);
			b = 0;
			if (_tuple$7 = zonedata.byte$(), b = _tuple$7[0], ok$1 = _tuple$7[1], !ok$1) {
				_tuple$8 = [(go$ptrType(Location)).nil, badData], l = _tuple$8[0], err = _tuple$8[1];
				return [l, err];
			}
			(_slice$3 = zone$1, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).isDST = !((b === 0));
			if (_tuple$9 = zonedata.byte$(), b = _tuple$9[0], ok$1 = _tuple$9[1], !ok$1 || (b >> 0) >= abbrev$1.length) {
				_tuple$10 = [(go$ptrType(Location)).nil, badData], l = _tuple$10[0], err = _tuple$10[1];
				return [l, err];
			}
			(_slice$4 = zone$1, _index$4 = i$1, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).name = byteString(go$subslice(abbrev$1, b));
			_i++;
		}
		tx = (go$sliceType(zoneTrans)).make(n[3], 0, function() { return new zoneTrans.Ptr(); });
		_ref$1 = tx;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			i$2 = _i$1;
			ok$2 = false;
			n$2 = 0;
			if (_tuple$11 = txtimes.big4(), n$2 = _tuple$11[0], ok$2 = _tuple$11[1], !ok$2) {
				_tuple$12 = [(go$ptrType(Location)).nil, badData], l = _tuple$12[0], err = _tuple$12[1];
				return [l, err];
			}
			(_slice$5 = tx, _index$5 = i$2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).when = new Go$Int64(0, (n$2 >> 0));
			if (((_slice$6 = txzones, _index$6 = i$2, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")) >> 0) >= zone$1.length) {
				_tuple$13 = [(go$ptrType(Location)).nil, badData], l = _tuple$13[0], err = _tuple$13[1];
				return [l, err];
			}
			(_slice$8 = tx, _index$8 = i$2, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")).index = (_slice$7 = txzones, _index$7 = i$2, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range"));
			if (i$2 < isstd.length) {
				(_slice$10 = tx, _index$10 = i$2, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")).isstd = !(((_slice$9 = isstd, _index$9 = i$2, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")) === 0));
			}
			if (i$2 < isutc.length) {
				(_slice$12 = tx, _index$12 = i$2, (_index$12 >= 0 && _index$12 < _slice$12.length) ? _slice$12.array[_slice$12.offset + _index$12] : go$throwRuntimeError("index out of range")).isutc = !(((_slice$11 = isutc, _index$11 = i$2, (_index$11 >= 0 && _index$11 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$11] : go$throwRuntimeError("index out of range")) === 0));
			}
			_i$1++;
		}
		if (tx.length === 0) {
			tx = go$append(tx, new zoneTrans.Ptr(new Go$Int64(-2147483648, 0), 0, false, false));
		}
		l = new Location.Ptr("", zone$1, tx, new Go$Int64(0, 0), new Go$Int64(0, 0), (go$ptrType(zone)).nil);
		_tuple$14 = now(), sec = _tuple$14[0];
		_ref$2 = tx;
		_i$2 = 0;
		while (_i$2 < _ref$2.length) {
			i$3 = _i$2;
			if ((x$6 = (_slice$13 = tx, _index$13 = i$3, (_index$13 >= 0 && _index$13 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$13] : go$throwRuntimeError("index out of range")).when, (x$6.high < sec.high || (x$6.high === sec.high && x$6.low <= sec.low))) && (((i$3 + 1 >> 0) === tx.length) || (x$7 = (_slice$14 = tx, _index$14 = (i$3 + 1 >> 0), (_index$14 >= 0 && _index$14 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$14] : go$throwRuntimeError("index out of range")).when, (sec.high < x$7.high || (sec.high === x$7.high && sec.low < x$7.low))))) {
				l.cacheStart = (_slice$15 = tx, _index$15 = i$3, (_index$15 >= 0 && _index$15 < _slice$15.length) ? _slice$15.array[_slice$15.offset + _index$15] : go$throwRuntimeError("index out of range")).when;
				l.cacheEnd = new Go$Int64(2147483647, 4294967295);
				if ((i$3 + 1 >> 0) < tx.length) {
					l.cacheEnd = (_slice$16 = tx, _index$16 = (i$3 + 1 >> 0), (_index$16 >= 0 && _index$16 < _slice$16.length) ? _slice$16.array[_slice$16.offset + _index$16] : go$throwRuntimeError("index out of range")).when;
				}
				l.cacheZone = (_slice$17 = l.zone, _index$17 = (_slice$18 = tx, _index$18 = i$3, (_index$18 >= 0 && _index$18 < _slice$18.length) ? _slice$18.array[_slice$18.offset + _index$18] : go$throwRuntimeError("index out of range")).index, (_index$17 >= 0 && _index$17 < _slice$17.length) ? _slice$17.array[_slice$17.offset + _index$17] : go$throwRuntimeError("index out of range"));
			}
			_i$2++;
		}
		_tuple$15 = [l, null], l = _tuple$15[0], err = _tuple$15[1];
		return [l, err];
	};
	var loadZoneFile = function(dir, name) {
		var l, err, _tuple, _tuple$1, buf, _tuple$2;
		l = (go$ptrType(Location)).nil;
		err = null;
		if (dir.length > 4 && dir.substring((dir.length - 4 >> 0)) === ".zip") {
			_tuple = loadZoneZip(dir, name), l = _tuple[0], err = _tuple[1];
			return [l, err];
		}
		if (!(dir === "")) {
			name = dir + "/" + name;
		}
		_tuple$1 = readFile(name), buf = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [l, err];
		}
		_tuple$2 = loadZoneData(buf), l = _tuple$2[0], err = _tuple$2[1];
		return [l, err];
	};
	var get4 = function(b) {
		var _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		if (b.length < 4) {
			return 0;
		}
		return ((((_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0) | (((_slice$1 = b, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >> 0) << 8 >> 0)) | (((_slice$2 = b, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) >> 0) << 16 >> 0)) | (((_slice$3 = b, _index$3 = 3, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) >> 0) << 24 >> 0);
	};
	var get2 = function(b) {
		var _slice, _index, _slice$1, _index$1;
		if (b.length < 2) {
			return 0;
		}
		return ((_slice = b, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0) | (((_slice$1 = b, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >> 0) << 8 >> 0);
	};
	var loadZoneZip = function(zipfile, name) {
		var l, err, _tuple, fd, _tuple$1, buf, err$1, _tuple$2, n, size, off, err$2, _tuple$3, i, meth, size$1, namelen, xlen, fclen, off$1, zname, _tuple$4, err$3, _tuple$5, err$4, _tuple$6, _tuple$7, _tuple$8;
		l = (go$ptrType(Location)).nil;
		err = null;
		var go$deferred = [];
		try {
			_tuple = open(zipfile), fd = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$1 = [(go$ptrType(Location)).nil, errors.New("open " + zipfile + ": " + err.Error())], l = _tuple$1[0], err = _tuple$1[1];
				return [l, err];
			}
			go$deferred.push({ fun: closefd, args: [fd] });
			buf = (go$sliceType(Go$Uint8)).make(22, 0, function() { return 0; });
			if (err$1 = preadn(fd, buf, -22), !(go$interfaceIsEqual(err$1, null)) || !((get4(buf) === 101010256))) {
				_tuple$2 = [(go$ptrType(Location)).nil, errors.New("corrupt zip file " + zipfile)], l = _tuple$2[0], err = _tuple$2[1];
				return [l, err];
			}
			n = get2(go$subslice(buf, 10));
			size = get4(go$subslice(buf, 12));
			off = get4(go$subslice(buf, 16));
			buf = (go$sliceType(Go$Uint8)).make(size, 0, function() { return 0; });
			if (err$2 = preadn(fd, buf, off), !(go$interfaceIsEqual(err$2, null))) {
				_tuple$3 = [(go$ptrType(Location)).nil, errors.New("corrupt zip file " + zipfile)], l = _tuple$3[0], err = _tuple$3[1];
				return [l, err];
			}
			i = 0;
			while (i < n) {
				if (!((get4(buf) === 33639248))) {
					break;
				}
				meth = get2(go$subslice(buf, 10));
				size$1 = get4(go$subslice(buf, 24));
				namelen = get2(go$subslice(buf, 28));
				xlen = get2(go$subslice(buf, 30));
				fclen = get2(go$subslice(buf, 32));
				off$1 = get4(go$subslice(buf, 42));
				zname = go$subslice(buf, 46, (46 + namelen >> 0));
				buf = go$subslice(buf, (((46 + namelen >> 0) + xlen >> 0) + fclen >> 0));
				if (!(go$bytesToString(zname) === name)) {
					i = i + 1 >> 0;
					continue;
				}
				if (!((meth === 0))) {
					_tuple$4 = [(go$ptrType(Location)).nil, errors.New("unsupported compression for " + name + " in " + zipfile)], l = _tuple$4[0], err = _tuple$4[1];
					return [l, err];
				}
				buf = (go$sliceType(Go$Uint8)).make(30 + namelen >> 0, 0, function() { return 0; });
				if (err$3 = preadn(fd, buf, off$1), !(go$interfaceIsEqual(err$3, null)) || !((get4(buf) === 67324752)) || !((get2(go$subslice(buf, 8)) === meth)) || !((get2(go$subslice(buf, 26)) === namelen)) || !(go$bytesToString(go$subslice(buf, 30, (30 + namelen >> 0))) === name)) {
					_tuple$5 = [(go$ptrType(Location)).nil, errors.New("corrupt zip file " + zipfile)], l = _tuple$5[0], err = _tuple$5[1];
					return [l, err];
				}
				xlen = get2(go$subslice(buf, 28));
				buf = (go$sliceType(Go$Uint8)).make(size$1, 0, function() { return 0; });
				if (err$4 = preadn(fd, buf, ((off$1 + 30 >> 0) + namelen >> 0) + xlen >> 0), !(go$interfaceIsEqual(err$4, null))) {
					_tuple$6 = [(go$ptrType(Location)).nil, errors.New("corrupt zip file " + zipfile)], l = _tuple$6[0], err = _tuple$6[1];
					return [l, err];
				}
				_tuple$7 = loadZoneData(buf), l = _tuple$7[0], err = _tuple$7[1];
				return [l, err];
			}
			_tuple$8 = [(go$ptrType(Location)).nil, errors.New("cannot find " + name + " in zip file " + zipfile)], l = _tuple$8[0], err = _tuple$8[1];
			return [l, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [l, err];
		}
	};
	var getKeyValue = function(kh, kname) {
		var buf, typ, n, _tuple, p, err, v, v$1;
		buf = go$makeNativeArray("Uint16", 50, function() { return 0; });
		typ = 0;
		n = 100;
		_tuple = syscall.UTF16PtrFromString(kname), p = _tuple[0];
		if (err = syscall.RegQueryValueEx(kh, p, (go$ptrType(Go$Uint32)).nil, new (go$ptrType(Go$Uint32))(function() { return typ; }, function(v) { typ = v; }), go$sliceToArray(new (go$sliceType(Go$Uint8))(buf)), new (go$ptrType(Go$Uint32))(function() { return n; }, function(v$1) { n = v$1; })), !(go$interfaceIsEqual(err, null))) {
			return ["", err];
		}
		if (!((typ === 1))) {
			return ["", errors.New("Key is not string")];
		}
		return [syscall.UTF16ToString(new (go$sliceType(Go$Uint16))(buf)), null];
	};
	var matchZoneKey = function(zones, kname, stdname, dstname) {
		var matched, err2, h, _tuple, p, err, v, _tuple$1, _tuple$2, s, err$1, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8;
		matched = false;
		err2 = null;
		var go$deferred = [];
		try {
			h = 0;
			_tuple = syscall.UTF16PtrFromString(kname), p = _tuple[0];
			if (err = syscall.RegOpenKeyEx(zones, p, 0, 131097, new (go$ptrType(syscall.Handle))(function() { return h; }, function(v) { h = v; })), !(go$interfaceIsEqual(err, null))) {
				_tuple$1 = [false, err], matched = _tuple$1[0], err2 = _tuple$1[1];
				return [matched, err2];
			}
			go$deferred.push({ recv: syscall, method: "RegCloseKey", args: [h] });
			_tuple$2 = getKeyValue(h, "Std"), s = _tuple$2[0], err$1 = _tuple$2[1];
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$3 = [false, err$1], matched = _tuple$3[0], err2 = _tuple$3[1];
				return [matched, err2];
			}
			if (!(s === stdname)) {
				_tuple$4 = [false, null], matched = _tuple$4[0], err2 = _tuple$4[1];
				return [matched, err2];
			}
			_tuple$5 = getKeyValue(h, "Dlt"), s = _tuple$5[0], err$1 = _tuple$5[1];
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$6 = [false, err$1], matched = _tuple$6[0], err2 = _tuple$6[1];
				return [matched, err2];
			}
			if (!(s === dstname)) {
				_tuple$7 = [false, null], matched = _tuple$7[0], err2 = _tuple$7[1];
				return [matched, err2];
			}
			_tuple$8 = [true, null], matched = _tuple$8[0], err2 = _tuple$8[1];
			return [matched, err2];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [matched, err2];
		}
	};
	var toEnglishName = function(stdname, dstname) {
		var zones, _tuple, p, err, v, count, err$1, v$1, buf, i, n, v$2, v$3, kname, _tuple$1, matched, err$2;
		var go$deferred = [];
		try {
			zones = 0;
			_tuple = syscall.UTF16PtrFromString("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"), p = _tuple[0];
			if (err = syscall.RegOpenKeyEx(2147483650, p, 0, 131097, new (go$ptrType(syscall.Handle))(function() { return zones; }, function(v) { zones = v; })), !(go$interfaceIsEqual(err, null))) {
				return ["", err];
			}
			go$deferred.push({ recv: syscall, method: "RegCloseKey", args: [zones] });
			count = 0;
			if (err$1 = syscall.RegQueryInfoKey(zones, (go$ptrType(Go$Uint16)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint32)).nil, new (go$ptrType(Go$Uint32))(function() { return count; }, function(v$1) { count = v$1; }), (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(syscall.Filetime)).nil), !(go$interfaceIsEqual(err$1, null))) {
				return ["", err$1];
			}
			buf = go$makeNativeArray("Uint16", 50, function() { return 0; });
			i = 0;
			while (i < count) {
				n = [undefined];
				n[0] = 50;
				if (!(go$interfaceIsEqual(syscall.RegEnumKeyEx(zones, i, (function(n) { return new (go$ptrType(Go$Uint16))(function() { return buf[0]; }, function(v$2) { buf[0] = v$2; }); })(n), (function(n) { return new (go$ptrType(Go$Uint32))(function() { return n[0]; }, function(v$3) { n[0] = v$3; }); })(n), (go$ptrType(Go$Uint32)).nil, (go$ptrType(Go$Uint16)).nil, (go$ptrType(Go$Uint32)).nil, (go$ptrType(syscall.Filetime)).nil), null))) {
					i = i + 1 >>> 0;
					continue;
				}
				kname = syscall.UTF16ToString(new (go$sliceType(Go$Uint16))(buf));
				_tuple$1 = matchZoneKey(zones, kname, stdname, dstname), matched = _tuple$1[0], err$2 = _tuple$1[1];
				if (go$interfaceIsEqual(err$2, null) && matched) {
					return [kname, null];
				}
				i = i + 1 >>> 0;
			}
			return ["", errors.New("English name for time zone \"" + stdname + "\" not found in registry")];
		} catch(go$err) {
			go$pushErr(go$err);
			return ["", null];
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var extractCAPS = function(desc) {
		var short$1, _ref, _i, _rune, c;
		short$1 = (go$sliceType(Go$Int32)).nil;
		_ref = desc;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			c = _rune[0];
			if (65 <= c && c <= 90) {
				short$1 = go$append(short$1, c);
			}
			_i += _rune[1];
		}
		return go$runesToString(short$1);
	};
	var abbrev = function(z) {
		var std, dst, stdName, _tuple, _entry, _struct, a, ok, dstName, _tuple$1, englishName, err, _tuple$2, _entry$1, _struct$1, _tuple$3, _tuple$4, _tuple$5;
		std = "";
		dst = "";
		stdName = syscall.UTF16ToString(new (go$sliceType(Go$Uint16))(z.StandardName));
		_tuple = (_entry = abbrs[stdName], _entry !== undefined ? [_entry.v, true] : [new abbr.Ptr(), false]), a = (_struct = _tuple[0], new abbr.Ptr(_struct.std, _struct.dst)), ok = _tuple[1];
		if (!ok) {
			dstName = syscall.UTF16ToString(new (go$sliceType(Go$Uint16))(z.DaylightName));
			_tuple$1 = toEnglishName(stdName, dstName), englishName = _tuple$1[0], err = _tuple$1[1];
			if (go$interfaceIsEqual(err, null)) {
				_tuple$2 = (_entry$1 = abbrs[englishName], _entry$1 !== undefined ? [_entry$1.v, true] : [new abbr.Ptr(), false]), a = (_struct$1 = _tuple$2[0], new abbr.Ptr(_struct$1.std, _struct$1.dst)), ok = _tuple$2[1];
				if (ok) {
					_tuple$3 = [a.std, a.dst], std = _tuple$3[0], dst = _tuple$3[1];
					return [std, dst];
				}
			}
			_tuple$4 = [extractCAPS(stdName), extractCAPS(dstName)], std = _tuple$4[0], dst = _tuple$4[1];
			return [std, dst];
		}
		_tuple$5 = [a.std, a.dst], std = _tuple$5[0], dst = _tuple$5[1];
		return [std, dst];
	};
	var pseudoUnix = function(year, d) {
		var day, _struct, t, i, week, x, x$1, x$2, x$3;
		day = 1;
		t = (_struct = Date(year, (d.Month >> 0), day, (d.Hour >> 0), (d.Minute >> 0), (d.Second >> 0), 0, go$pkg.UTC), new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		i = (d.DayOfWeek >> 0) - (t.Weekday() >> 0) >> 0;
		if (i < 0) {
			i = i + 7 >> 0;
		}
		day = day + (i) >> 0;
		if (week = (d.Day >> 0) - 1 >> 0, week < 4) {
			day = day + ((x = 7, (((week >>> 16 << 16) * x >> 0) + (week << 16 >>> 16) * x) >> 0)) >> 0;
		} else {
			day = day + 28 >> 0;
			if (day > daysIn((d.Month >> 0), year)) {
				day = day - 7 >> 0;
			}
		}
		return (x$1 = (x$2 = t.sec, x$3 = go$mul64(new Go$Int64(0, (day - 1 >> 0)), new Go$Int64(0, 86400)), new Go$Int64(x$2.high + x$3.high, x$2.low + x$3.low)), new Go$Int64(x$1.high + -15, x$1.low + 2288912640));
	};
	var initLocalFromTZI = function(i) {
		var l, nzone, _tuple, stdname, dstname, _slice, _index, std, x, x$1, _slice$1, _index$1, _slice$2, _index$2, x$2, x$3, _slice$3, _index$3, dst, x$4, x$5, d0, d1, i0, i1, _tuple$1, _tuple$2, _struct, t, year, txi, y, _slice$4, _index$4, tx, x$6, x$7, _slice$5, _index$5, _slice$6, _index$6, x$8, x$9, _slice$7, _index$7;
		l = localLoc;
		nzone = 1;
		if (i.StandardDate.Month > 0) {
			nzone = nzone + 1 >> 0;
		}
		l.zone = (go$sliceType(zone)).make(nzone, 0, function() { return new zone.Ptr(); });
		_tuple = abbrev(i), stdname = _tuple[0], dstname = _tuple[1];
		std = (_slice = l.zone, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		std.name = stdname;
		if (nzone === 1) {
			std.offset = (x = -(i.Bias >> 0), x$1 = 60, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
			l.cacheStart = new Go$Int64(-2147483648, 0);
			l.cacheEnd = new Go$Int64(2147483647, 4294967295);
			l.cacheZone = std;
			l.tx = (go$sliceType(zoneTrans)).make(1, 0, function() { return new zoneTrans.Ptr(); });
			(_slice$1 = l.tx, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).when = l.cacheStart;
			(_slice$2 = l.tx, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).index = 0;
			return;
		}
		std.offset = (x$2 = -((i.Bias + i.StandardBias >> 0) >> 0), x$3 = 60, (((x$2 >>> 16 << 16) * x$3 >> 0) + (x$2 << 16 >>> 16) * x$3) >> 0);
		dst = (_slice$3 = l.zone, _index$3 = 1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
		dst.name = dstname;
		dst.offset = (x$4 = -((i.Bias + i.DaylightBias >> 0) >> 0), x$5 = 60, (((x$4 >>> 16 << 16) * x$5 >> 0) + (x$4 << 16 >>> 16) * x$5) >> 0);
		dst.isDST = true;
		d0 = i.StandardDate;
		d1 = i.DaylightDate;
		i0 = 0;
		i1 = 1;
		if (d0.Month > d1.Month) {
			_tuple$1 = [d1, d0], d0 = _tuple$1[0], d1 = _tuple$1[1];
			_tuple$2 = [i1, i0], i0 = _tuple$2[0], i1 = _tuple$2[1];
		}
		l.tx = (go$sliceType(zoneTrans)).make(400, 0, function() { return new zoneTrans.Ptr(); });
		t = (_struct = Now().UTC(), new Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
		year = t.Year();
		txi = 0;
		y = year - 100 >> 0;
		while (y < (year + 100 >> 0)) {
			tx = (_slice$4 = l.tx, _index$4 = txi, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
			tx.when = (x$6 = pseudoUnix(y, d0), x$7 = new Go$Int64(0, (_slice$5 = l.zone, _index$5 = i1, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).offset), new Go$Int64(x$6.high - x$7.high, x$6.low - x$7.low));
			tx.index = (i0 << 24 >>> 24);
			txi = txi + 1 >> 0;
			tx = (_slice$6 = l.tx, _index$6 = txi, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range"));
			tx.when = (x$8 = pseudoUnix(y, d1), x$9 = new Go$Int64(0, (_slice$7 = l.zone, _index$7 = i0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).offset), new Go$Int64(x$8.high - x$9.high, x$8.low - x$9.low));
			tx.index = (i1 << 24 >>> 24);
			txi = txi + 1 >> 0;
			y = y + 1 >> 0;
		}
	};
	var initTestingZone = function() {
		initLocalFromTZI(usPacific);
	};
	var initAusTestingZone = function() {
		initLocalFromTZI(aus);
	};
	var initLocal = function() {
		var i, err, _tuple;
		i = new syscall.Timezoneinformation.Ptr();
		if (_tuple = syscall.GetTimeZoneInformation(i), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			localLoc.name = "UTC";
			return;
		}
		initLocalFromTZI(i);
	};
	var loadLocation = function(name) {
		var err, _tuple, z;
		if (_tuple = loadZoneFile(runtime.GOROOT() + "\\lib\\time\\zoneinfo.zip", name), z = _tuple[0], err = _tuple[1], go$interfaceIsEqual(err, null)) {
			z.name = name;
			return [z, null];
		}
		return [(go$ptrType(Location)).nil, errors.New("unknown time zone " + name)];
	};
	var forceZipFileForTesting = function(zipOnly) {
	};
	go$pkg.init = function() {
		localLoc = new Location.Ptr();
		localOnce = new sync.Once.Ptr();
		var _map, _key, _tuple, _map$1, _key$1;
		std0x = go$toNativeArray("Int", [260, 265, 524, 526, 528, 274]);
		longDayNames = new (go$sliceType(Go$String))(["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
		shortDayNames = new (go$sliceType(Go$String))(["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]);
		shortMonthNames = new (go$sliceType(Go$String))(["---", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]);
		longMonthNames = new (go$sliceType(Go$String))(["---", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]);
		atoiError = errors.New("time: invalid number");
		errBad = errors.New("bad value for field");
		errLeadingInt = errors.New("time: bad [0-9]*");
		unitMap = (_map = new Go$Map(), _key = "ns", _map[_key] = { k: _key, v: 1 }, _key = "us", _map[_key] = { k: _key, v: 1000 }, _key = "\xC2\xB5s", _map[_key] = { k: _key, v: 1000 }, _key = "\xCE\xBCs", _map[_key] = { k: _key, v: 1000 }, _key = "ms", _map[_key] = { k: _key, v: 1e+06 }, _key = "s", _map[_key] = { k: _key, v: 1e+09 }, _key = "m", _map[_key] = { k: _key, v: 6e+10 }, _key = "h", _map[_key] = { k: _key, v: 3.6e+12 }, _map);
		months = go$toNativeArray("String", ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]);
		days = go$toNativeArray("String", ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
		daysBefore = go$toNativeArray("Int32", [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]);
		utcLoc = new Location.Ptr("UTC", (go$sliceType(zone)).nil, (go$sliceType(zoneTrans)).nil, new Go$Int64(0, 0), new Go$Int64(0, 0), (go$ptrType(zone)).nil);
		go$pkg.UTC = utcLoc;
		go$pkg.Local = localLoc;
		_tuple = syscall.Getenv("ZONEINFO"), zoneinfo = _tuple[0];
		abbrs = (_map$1 = new Go$Map(), _key$1 = "Egypt Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EET") }, _key$1 = "Morocco Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("WET", "WEST") }, _key$1 = "South Africa Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("SAST", "SAST") }, _key$1 = "W. Central Africa Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("WAT", "WAT") }, _key$1 = "E. Africa Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EAT", "EAT") }, _key$1 = "Namibia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("WAT", "WAST") }, _key$1 = "Alaskan Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AKST", "AKDT") }, _key$1 = "Paraguay Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("PYT", "PYST") }, _key$1 = "Bahia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("BRT", "BRST") }, _key$1 = "SA Pacific Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("COT", "COT") }, _key$1 = "Argentina Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("ART", "ART") }, _key$1 = "Venezuela Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("VET", "VET") }, _key$1 = "SA Eastern Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GFT", "GFT") }, _key$1 = "Central Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CDT") }, _key$1 = "Mountain Standard Time (Mexico)", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MST", "MDT") }, _key$1 = "Central Brazilian Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AMT", "AMST") }, _key$1 = "Mountain Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MST", "MDT") }, _key$1 = "Greenland Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("WGT", "WGST") }, _key$1 = "Central America Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CST") }, _key$1 = "Atlantic Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AST", "ADT") }, _key$1 = "US Eastern Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EST", "EDT") }, _key$1 = "SA Western Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("BOT", "BOT") }, _key$1 = "Pacific Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("PST", "PDT") }, _key$1 = "Central Standard Time (Mexico)", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CDT") }, _key$1 = "Montevideo Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("UYT", "UYST") }, _key$1 = "Eastern Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EST", "EDT") }, _key$1 = "US Mountain Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MST", "MST") }, _key$1 = "Canada Central Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CST") }, _key$1 = "Pacific Standard Time (Mexico)", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("PST", "PDT") }, _key$1 = "Pacific SA Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CLT", "CLST") }, _key$1 = "E. South America Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("BRT", "BRST") }, _key$1 = "Newfoundland Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("NST", "NDT") }, _key$1 = "Central Asia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("ALMT", "ALMT") }, _key$1 = "Jordan Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "Arabic Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AST", "AST") }, _key$1 = "Azerbaijan Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AZT", "AZST") }, _key$1 = "SE Asia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("ICT", "ICT") }, _key$1 = "Middle East Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "India Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("IST", "IST") }, _key$1 = "Sri Lanka Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("IST", "IST") }, _key$1 = "Syria Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "Bangladesh Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("BDT", "BDT") }, _key$1 = "Arabian Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GST", "GST") }, _key$1 = "North Asia East Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("IRKT", "IRKT") }, _key$1 = "Israel Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("IST", "IDT") }, _key$1 = "Afghanistan Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AFT", "AFT") }, _key$1 = "Pakistan Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("PKT", "PKT") }, _key$1 = "Nepal Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("NPT", "NPT") }, _key$1 = "North Asia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("KRAT", "KRAT") }, _key$1 = "Magadan Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MAGT", "MAGT") }, _key$1 = "E. Europe Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "N. Central Asia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("NOVT", "NOVT") }, _key$1 = "Myanmar Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MMT", "MMT") }, _key$1 = "Arab Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AST", "AST") }, _key$1 = "Korea Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("KST", "KST") }, _key$1 = "China Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CST") }, _key$1 = "Singapore Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("SGT", "SGT") }, _key$1 = "Taipei Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CST") }, _key$1 = "West Asia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("UZT", "UZT") }, _key$1 = "Georgian Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GET", "GET") }, _key$1 = "Iran Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("IRST", "IRDT") }, _key$1 = "Tokyo Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("JST", "JST") }, _key$1 = "Ulaanbaatar Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("ULAT", "ULAT") }, _key$1 = "Vladivostok Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("VLAT", "VLAT") }, _key$1 = "Yakutsk Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("YAKT", "YAKT") }, _key$1 = "Ekaterinburg Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("YEKT", "YEKT") }, _key$1 = "Caucasus Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AMT", "AMT") }, _key$1 = "Azores Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("AZOT", "AZOST") }, _key$1 = "Cape Verde Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CVT", "CVT") }, _key$1 = "Greenwich Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT", "GMT") }, _key$1 = "Cen. Australia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CST") }, _key$1 = "E. Australia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EST", "EST") }, _key$1 = "AUS Central Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CST", "CST") }, _key$1 = "Tasmania Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EST", "EST") }, _key$1 = "W. Australia Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("WST", "WST") }, _key$1 = "AUS Eastern Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EST", "EST") }, _key$1 = "UTC", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT", "GMT") }, _key$1 = "UTC-11", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT+11", "GMT+11") }, _key$1 = "Dateline Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT+12", "GMT+12") }, _key$1 = "UTC-02", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT+2", "GMT+2") }, _key$1 = "UTC+12", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT-12", "GMT-12") }, _key$1 = "W. Europe Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CET", "CEST") }, _key$1 = "GTB Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "Central Europe Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CET", "CEST") }, _key$1 = "Turkey Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "Kaliningrad Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("FET", "FET") }, _key$1 = "FLE Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("EET", "EEST") }, _key$1 = "GMT Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("GMT", "BST") }, _key$1 = "Russian Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MSK", "MSK") }, _key$1 = "Romance Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CET", "CEST") }, _key$1 = "Central European Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("CET", "CEST") }, _key$1 = "Mauritius Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("MUT", "MUT") }, _key$1 = "Samoa Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("WST", "WST") }, _key$1 = "New Zealand Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("NZST", "NZDT") }, _key$1 = "Fiji Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("FJT", "FJT") }, _key$1 = "Central Pacific Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("SBT", "SBT") }, _key$1 = "Hawaiian Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("HST", "HST") }, _key$1 = "West Pacific Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("PGT", "PGT") }, _key$1 = "Tonga Standard Time", _map$1[_key$1] = { k: _key$1, v: new abbr.Ptr("TOT", "TOT") }, _map$1);
		badData = errors.New("malformed time zone information");
		usPacific = new syscall.Timezoneinformation.Ptr(480, go$toNativeArray("Uint16", [80, 97, 99, 105, 102, 105, 99, 32, 83, 116, 97, 110, 100, 97, 114, 100, 32, 84, 105, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new syscall.Systemtime.Ptr(0, 11, 0, 1, 2, 0, 0, 0), 0, go$toNativeArray("Uint16", [80, 97, 99, 105, 102, 105, 99, 32, 68, 97, 121, 108, 105, 103, 104, 116, 32, 84, 105, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new syscall.Systemtime.Ptr(0, 3, 0, 2, 2, 0, 0, 0), -60);
		aus = new syscall.Timezoneinformation.Ptr(-600, go$toNativeArray("Uint16", [65, 85, 83, 32, 69, 97, 115, 116, 101, 114, 110, 32, 83, 116, 97, 110, 100, 97, 114, 100, 32, 84, 105, 109, 101, 0, 0, 0, 0, 0, 0, 0]), new syscall.Systemtime.Ptr(0, 4, 0, 1, 3, 0, 0, 0), 0, go$toNativeArray("Uint16", [65, 85, 83, 32, 69, 97, 115, 116, 101, 114, 110, 32, 68, 97, 121, 108, 105, 103, 104, 116, 32, 84, 105, 109, 101, 0, 0, 0, 0, 0, 0, 0]), new syscall.Systemtime.Ptr(0, 10, 0, 1, 2, 0, 0, 0), -60);
	};
	return go$pkg;
})();
go$packages["os"] = (function() {
	var go$pkg = {};
	var time = go$packages["time"];
	var syscall = go$packages["syscall"];
	var errors = go$packages["errors"];
	var runtime = go$packages["runtime"];
	var atomic = go$packages["sync/atomic"];
	var io = go$packages["io"];
	var sync = go$packages["sync"];
	var utf16 = go$packages["unicode/utf16"];
	var utf8 = go$packages["unicode/utf8"];
	var PathError;
	PathError = go$newType(0, "Struct", "os.PathError", "PathError", "os", function(Op_, Path_, Err_) {
		this.go$val = this;
		this.Op = Op_ !== undefined ? Op_ : "";
		this.Path = Path_ !== undefined ? Path_ : "";
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.PathError = PathError;
	var SyscallError;
	SyscallError = go$newType(0, "Struct", "os.SyscallError", "SyscallError", "os", function(Syscall_, Err_) {
		this.go$val = this;
		this.Syscall = Syscall_ !== undefined ? Syscall_ : "";
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.SyscallError = SyscallError;
	var Process;
	Process = go$newType(0, "Struct", "os.Process", "Process", "os", function(Pid_, handle_, isdone_) {
		this.go$val = this;
		this.Pid = Pid_ !== undefined ? Pid_ : 0;
		this.handle = handle_ !== undefined ? handle_ : 0;
		this.isdone = isdone_ !== undefined ? isdone_ : 0;
	});
	go$pkg.Process = Process;
	var ProcAttr;
	ProcAttr = go$newType(0, "Struct", "os.ProcAttr", "ProcAttr", "os", function(Dir_, Env_, Files_, Sys_) {
		this.go$val = this;
		this.Dir = Dir_ !== undefined ? Dir_ : "";
		this.Env = Env_ !== undefined ? Env_ : (go$sliceType(Go$String)).nil;
		this.Files = Files_ !== undefined ? Files_ : (go$sliceType((go$ptrType(File)))).nil;
		this.Sys = Sys_ !== undefined ? Sys_ : (go$ptrType(syscall.SysProcAttr)).nil;
	});
	go$pkg.ProcAttr = ProcAttr;
	var Signal;
	Signal = go$newType(0, "Interface", "os.Signal", "Signal", "os", null);
	go$pkg.Signal = Signal;
	var ProcessState;
	ProcessState = go$newType(0, "Struct", "os.ProcessState", "ProcessState", "os", function(pid_, status_, rusage_) {
		this.go$val = this;
		this.pid = pid_ !== undefined ? pid_ : 0;
		this.status = status_ !== undefined ? status_ : new syscall.WaitStatus.Ptr();
		this.rusage = rusage_ !== undefined ? rusage_ : (go$ptrType(syscall.Rusage)).nil;
	});
	go$pkg.ProcessState = ProcessState;
	var LinkError;
	LinkError = go$newType(0, "Struct", "os.LinkError", "LinkError", "os", function(Op_, Old_, New_, Err_) {
		this.go$val = this;
		this.Op = Op_ !== undefined ? Op_ : "";
		this.Old = Old_ !== undefined ? Old_ : "";
		this.New = New_ !== undefined ? New_ : "";
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.LinkError = LinkError;
	var File;
	File = go$newType(0, "Struct", "os.File", "File", "os", function(file_) {
		this.go$val = this;
		this.file = file_ !== undefined ? file_ : (go$ptrType(file)).nil;
	});
	File.prototype.close = function() { return this.go$val.close(); };
	File.Ptr.prototype.close = function() { return this.file.close(); };
	File.prototype.isdir = function() { return this.go$val.isdir(); };
	File.Ptr.prototype.isdir = function() { return this.file.isdir(); };
	go$pkg.File = File;
	var file;
	file = go$newType(0, "Struct", "os.file", "file", "os", function(fd_, name_, dirinfo_, l_, isConsole_, lastbits_, readbuf_) {
		this.go$val = this;
		this.fd = fd_ !== undefined ? fd_ : 0;
		this.name = name_ !== undefined ? name_ : "";
		this.dirinfo = dirinfo_ !== undefined ? dirinfo_ : (go$ptrType(dirInfo)).nil;
		this.l = l_ !== undefined ? l_ : new sync.Mutex.Ptr();
		this.isConsole = isConsole_ !== undefined ? isConsole_ : false;
		this.lastbits = lastbits_ !== undefined ? lastbits_ : (go$sliceType(Go$Uint8)).nil;
		this.readbuf = readbuf_ !== undefined ? readbuf_ : (go$sliceType(Go$Int32)).nil;
	});
	go$pkg.file = file;
	var dirInfo;
	dirInfo = go$newType(0, "Struct", "os.dirInfo", "dirInfo", "os", function(data_, needdata_, path_, isempty_) {
		this.go$val = this;
		this.data = data_ !== undefined ? data_ : new syscall.Win32finddata.Ptr();
		this.needdata = needdata_ !== undefined ? needdata_ : false;
		this.path = path_ !== undefined ? path_ : "";
		this.isempty = isempty_ !== undefined ? isempty_ : false;
	});
	go$pkg.dirInfo = dirInfo;
	var FileInfo;
	FileInfo = go$newType(0, "Interface", "os.FileInfo", "FileInfo", "os", null);
	go$pkg.FileInfo = FileInfo;
	var FileMode;
	FileMode = go$newType(4, "Uint32", "os.FileMode", "FileMode", "os", null);
	go$pkg.FileMode = FileMode;
	var fileStat;
	fileStat = go$newType(0, "Struct", "os.fileStat", "fileStat", "os", function(name_, sys_, Mutex_, path_, vol_, idxhi_, idxlo_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.sys = sys_ !== undefined ? sys_ : new syscall.Win32FileAttributeData.Ptr();
		this.Mutex = Mutex_ !== undefined ? Mutex_ : new sync.Mutex.Ptr();
		this.path = path_ !== undefined ? path_ : "";
		this.vol = vol_ !== undefined ? vol_ : 0;
		this.idxhi = idxhi_ !== undefined ? idxhi_ : 0;
		this.idxlo = idxlo_ !== undefined ? idxlo_ : 0;
	});
	fileStat.prototype.Lock = function() { return this.go$val.Lock(); };
	fileStat.Ptr.prototype.Lock = function() { return this.Mutex.Lock(); };
	fileStat.prototype.Unlock = function() { return this.go$val.Unlock(); };
	fileStat.Ptr.prototype.Unlock = function() { return this.Mutex.Unlock(); };
	go$pkg.fileStat = fileStat;
	PathError.init([["Op", "", Go$String, ""], ["Path", "", Go$String, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(PathError)).methods = [["Error", "", [], [Go$String], false]];
	SyscallError.init([["Syscall", "", Go$String, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(SyscallError)).methods = [["Error", "", [], [Go$String], false]];
	Process.init([["Pid", "", Go$Int, ""], ["handle", "os", Go$Uintptr, ""], ["isdone", "os", Go$Uint32, ""]]);
	(go$ptrType(Process)).methods = [["Kill", "", [], [go$error], false], ["Release", "", [], [go$error], false], ["Signal", "", [Signal], [go$error], false], ["Wait", "", [], [(go$ptrType(ProcessState)), go$error], false], ["done", "os", [], [Go$Bool], false], ["kill", "os", [], [go$error], false], ["release", "os", [], [go$error], false], ["setDone", "os", [], [], false], ["signal", "os", [Signal], [go$error], false], ["wait", "os", [], [(go$ptrType(ProcessState)), go$error], false]];
	ProcAttr.init([["Dir", "", Go$String, ""], ["Env", "", (go$sliceType(Go$String)), ""], ["Files", "", (go$sliceType((go$ptrType(File)))), ""], ["Sys", "", (go$ptrType(syscall.SysProcAttr)), ""]]);
	Signal.init([["Signal", "", (go$funcType([], [], false))], ["String", "", (go$funcType([], [Go$String], false))]]);
	ProcessState.init([["pid", "os", Go$Int, ""], ["status", "os", syscall.WaitStatus, ""], ["rusage", "os", (go$ptrType(syscall.Rusage)), ""]]);
	(go$ptrType(ProcessState)).methods = [["Exited", "", [], [Go$Bool], false], ["Pid", "", [], [Go$Int], false], ["String", "", [], [Go$String], false], ["Success", "", [], [Go$Bool], false], ["Sys", "", [], [go$emptyInterface], false], ["SysUsage", "", [], [go$emptyInterface], false], ["SystemTime", "", [], [time.Duration], false], ["UserTime", "", [], [time.Duration], false], ["exited", "os", [], [Go$Bool], false], ["success", "os", [], [Go$Bool], false], ["sys", "os", [], [go$emptyInterface], false], ["sysUsage", "os", [], [go$emptyInterface], false], ["systemTime", "os", [], [time.Duration], false], ["userTime", "os", [], [time.Duration], false]];
	LinkError.init([["Op", "", Go$String, ""], ["Old", "", Go$String, ""], ["New", "", Go$String, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(LinkError)).methods = [["Error", "", [], [Go$String], false]];
	File.init([["", "os", (go$ptrType(file)), ""]]);
	File.methods = [["close", "os", [], [go$error], false], ["isdir", "os", [], [Go$Bool], false]];
	(go$ptrType(File)).methods = [["Chdir", "", [], [go$error], false], ["Chmod", "", [FileMode], [go$error], false], ["Chown", "", [Go$Int, Go$Int], [go$error], false], ["Close", "", [], [go$error], false], ["Fd", "", [], [Go$Uintptr], false], ["Name", "", [], [Go$String], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["Readdir", "", [Go$Int], [(go$sliceType(FileInfo)), go$error], false], ["Readdirnames", "", [Go$Int], [(go$sliceType(Go$String)), go$error], false], ["Seek", "", [Go$Int64, Go$Int], [Go$Int64, go$error], false], ["Stat", "", [], [FileInfo, go$error], false], ["Sync", "", [], [go$error], false], ["Truncate", "", [Go$Int64], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["WriteAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["WriteString", "", [Go$String], [Go$Int, go$error], false], ["close", "os", [], [go$error], false], ["isdir", "os", [], [Go$Bool], false], ["pread", "os", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["pwrite", "os", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false], ["read", "os", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["readConsole", "os", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["readdir", "os", [Go$Int], [(go$sliceType(FileInfo)), go$error], false], ["readdirnames", "os", [Go$Int], [(go$sliceType(Go$String)), go$error], false], ["seek", "os", [Go$Int64, Go$Int], [Go$Int64, go$error], false], ["write", "os", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["writeConsole", "os", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	file.init([["fd", "os", syscall.Handle, ""], ["name", "os", Go$String, ""], ["dirinfo", "os", (go$ptrType(dirInfo)), ""], ["l", "os", sync.Mutex, ""], ["isConsole", "os", Go$Bool, ""], ["lastbits", "os", (go$sliceType(Go$Uint8)), ""], ["readbuf", "os", (go$sliceType(Go$Int32)), ""]]);
	(go$ptrType(file)).methods = [["close", "os", [], [go$error], false], ["isdir", "os", [], [Go$Bool], false]];
	dirInfo.init([["data", "os", syscall.Win32finddata, ""], ["needdata", "os", Go$Bool, ""], ["path", "os", Go$String, ""], ["isempty", "os", Go$Bool, ""]]);
	FileInfo.init([["IsDir", "", (go$funcType([], [Go$Bool], false))], ["ModTime", "", (go$funcType([], [time.Time], false))], ["Mode", "", (go$funcType([], [FileMode], false))], ["Name", "", (go$funcType([], [Go$String], false))], ["Size", "", (go$funcType([], [Go$Int64], false))], ["Sys", "", (go$funcType([], [go$emptyInterface], false))]]);
	FileMode.methods = [["IsDir", "", [], [Go$Bool], false], ["IsRegular", "", [], [Go$Bool], false], ["Perm", "", [], [FileMode], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(FileMode)).methods = [["IsDir", "", [], [Go$Bool], false], ["IsRegular", "", [], [Go$Bool], false], ["Perm", "", [], [FileMode], false], ["String", "", [], [Go$String], false]];
	fileStat.init([["name", "os", Go$String, ""], ["sys", "os", syscall.Win32FileAttributeData, ""], ["", "", sync.Mutex, ""], ["path", "os", Go$String, ""], ["vol", "os", Go$Uint32, ""], ["idxhi", "os", Go$Uint32, ""], ["idxlo", "os", Go$Uint32, ""]]);
	(go$ptrType(fileStat)).methods = [["IsDir", "", [], [Go$Bool], false], ["Lock", "", [], [], false], ["ModTime", "", [], [time.Time], false], ["Mode", "", [], [FileMode], false], ["Name", "", [], [Go$String], false], ["Size", "", [], [Go$Int64], false], ["Sys", "", [], [go$emptyInterface], false], ["Unlock", "", [], [], false], ["loadFileId", "os", [], [go$error], false]];
	var lstat, getwdCache, useSyscallwd, devNullStat;
	File.Ptr.prototype.readdirnames = function(n) {
		var names, err, file$1, _tuple, fis, _ref, _i, _slice, _index, fi, i, _slice$1, _index$1, _tuple$1;
		names = (go$sliceType(Go$String)).nil;
		err = null;
		file$1 = this;
		_tuple = file$1.Readdir(n), fis = _tuple[0], err = _tuple[1];
		names = (go$sliceType(Go$String)).make(fis.length, 0, function() { return ""; });
		_ref = fis;
		_i = 0;
		while (_i < _ref.length) {
			fi = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			_slice$1 = names, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = fi.Name()) : go$throwRuntimeError("index out of range");
			_i++;
		}
		_tuple$1 = [names, err], names = _tuple$1[0], err = _tuple$1[1];
		return [names, err];
	};
	File.prototype.readdirnames = function(n) { return this.go$val.readdirnames(n); };
	var FindProcess = go$pkg.FindProcess = function(pid) {
		var p, err, _tuple;
		p = (go$ptrType(Process)).nil;
		err = null;
		_tuple = findProcess(pid), p = _tuple[0], err = _tuple[1];
		return [p, err];
	};
	var StartProcess = go$pkg.StartProcess = function(name, argv, attr) {
		return startProcess(name, argv, attr);
	};
	Process.Ptr.prototype.Release = function() {
		var p;
		p = this;
		return p.release();
	};
	Process.prototype.Release = function() { return this.go$val.Release(); };
	Process.Ptr.prototype.Kill = function() {
		var p;
		p = this;
		return p.kill();
	};
	Process.prototype.Kill = function() { return this.go$val.Kill(); };
	Process.Ptr.prototype.Wait = function() {
		var p;
		p = this;
		return p.wait();
	};
	Process.prototype.Wait = function() { return this.go$val.Wait(); };
	Process.Ptr.prototype.Signal = function(sig) {
		var p;
		p = this;
		return p.signal(sig);
	};
	Process.prototype.Signal = function(sig) { return this.go$val.Signal(sig); };
	ProcessState.Ptr.prototype.UserTime = function() {
		var p;
		p = this;
		return p.userTime();
	};
	ProcessState.prototype.UserTime = function() { return this.go$val.UserTime(); };
	ProcessState.Ptr.prototype.SystemTime = function() {
		var p;
		p = this;
		return p.systemTime();
	};
	ProcessState.prototype.SystemTime = function() { return this.go$val.SystemTime(); };
	ProcessState.Ptr.prototype.Exited = function() {
		var p;
		p = this;
		return p.exited();
	};
	ProcessState.prototype.Exited = function() { return this.go$val.Exited(); };
	ProcessState.Ptr.prototype.Success = function() {
		var p;
		p = this;
		return p.success();
	};
	ProcessState.prototype.Success = function() { return this.go$val.Success(); };
	ProcessState.Ptr.prototype.Sys = function() {
		var p;
		p = this;
		return p.sys();
	};
	ProcessState.prototype.Sys = function() { return this.go$val.Sys(); };
	ProcessState.Ptr.prototype.SysUsage = function() {
		var p;
		p = this;
		return p.sysUsage();
	};
	ProcessState.prototype.SysUsage = function() { return this.go$val.SysUsage(); };
	var Hostname = go$pkg.Hostname = function() {
		var name, err, _tuple;
		name = "";
		err = null;
		_tuple = hostname(), name = _tuple[0], err = _tuple[1];
		return [name, err];
	};
	File.Ptr.prototype.Readdir = function(n) {
		var fi, err, f, _tuple, _tuple$1;
		fi = (go$sliceType(FileInfo)).nil;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [(go$sliceType(FileInfo)).nil, go$pkg.ErrInvalid], fi = _tuple[0], err = _tuple[1];
			return [fi, err];
		}
		_tuple$1 = f.readdir(n), fi = _tuple$1[0], err = _tuple$1[1];
		return [fi, err];
	};
	File.prototype.Readdir = function(n) { return this.go$val.Readdir(n); };
	File.Ptr.prototype.Readdirnames = function(n) {
		var names, err, f, _tuple, _tuple$1;
		names = (go$sliceType(Go$String)).nil;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [(go$sliceType(Go$String)).nil, go$pkg.ErrInvalid], names = _tuple[0], err = _tuple[1];
			return [names, err];
		}
		_tuple$1 = f.readdirnames(n), names = _tuple$1[0], err = _tuple$1[1];
		return [names, err];
	};
	File.prototype.Readdirnames = function(n) { return this.go$val.Readdirnames(n); };
	var Expand = go$pkg.Expand = function(s, mapping) {
		var x, x$1, buf, i, j, _tuple, name, w;
		buf = (go$sliceType(Go$Uint8)).make(0, (x = 2, x$1 = s.length, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0), function() { return 0; });
		i = 0;
		j = 0;
		while (j < s.length) {
			if ((s.charCodeAt(j) === 36) && (j + 1 >> 0) < s.length) {
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes(s.substring(i, j))));
				_tuple = getShellName(s.substring((j + 1 >> 0))), name = _tuple[0], w = _tuple[1];
				buf = go$appendSlice(buf, new (go$sliceType(Go$Uint8))(go$stringToBytes(mapping(name))));
				j = j + (w) >> 0;
				i = j + 1 >> 0;
			}
			j = j + 1 >> 0;
		}
		return go$bytesToString(buf) + s.substring(i);
	};
	var ExpandEnv = go$pkg.ExpandEnv = function(s) {
		return Expand(s, Getenv);
	};
	var isShellSpecialVar = function(c) {
		var _ref;
		_ref = c;
		if (_ref === 42 || _ref === 35 || _ref === 36 || _ref === 64 || _ref === 33 || _ref === 63 || _ref === 48 || _ref === 49 || _ref === 50 || _ref === 51 || _ref === 52 || _ref === 53 || _ref === 54 || _ref === 55 || _ref === 56 || _ref === 57) {
			return true;
		}
		return false;
	};
	var isAlphaNum = function(c) {
		return (c === 95) || 48 <= c && c <= 57 || 97 <= c && c <= 122 || 65 <= c && c <= 90;
	};
	var getShellName = function(s) {
		var i, i$1;
		if (s.charCodeAt(0) === 123) {
			if (s.length > 2 && isShellSpecialVar(s.charCodeAt(1)) && (s.charCodeAt(2) === 125)) {
				return [s.substring(1, 2), 3];
			}
			i = 1;
			while (i < s.length) {
				if (s.charCodeAt(i) === 125) {
					return [s.substring(1, i), i + 1 >> 0];
				}
				i = i + 1 >> 0;
			}
			return ["", 1];
		} else if (isShellSpecialVar(s.charCodeAt(0))) {
			return [s.substring(0, 1), 1];
		}
		i$1 = 0;
		i$1 = 0;
		while (i$1 < s.length && isAlphaNum(s.charCodeAt(i$1))) {
			i$1 = i$1 + 1 >> 0;
		}
		return [s.substring(0, i$1), i$1];
	};
	var Getenv = go$pkg.Getenv = function(key) {
		var _tuple, v;
		_tuple = syscall.Getenv(key), v = _tuple[0];
		return v;
	};
	var Setenv = go$pkg.Setenv = function(key, value) {
		var err;
		err = syscall.Setenv(key, value);
		if (!(go$interfaceIsEqual(err, null))) {
			return NewSyscallError("setenv", err);
		}
		return null;
	};
	var Clearenv = go$pkg.Clearenv = function() {
		syscall.Clearenv();
	};
	var Environ = go$pkg.Environ = function() {
		return syscall.Environ();
	};
	PathError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.Op + " " + e.Path + ": " + e.Err.Error();
	};
	PathError.prototype.Error = function() { return this.go$val.Error(); };
	SyscallError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.Syscall + ": " + e.Err.Error();
	};
	SyscallError.prototype.Error = function() { return this.go$val.Error(); };
	var NewSyscallError = go$pkg.NewSyscallError = function(syscall$1, err) {
		if (go$interfaceIsEqual(err, null)) {
			return null;
		}
		return new SyscallError.Ptr(syscall$1, err);
	};
	var IsExist = go$pkg.IsExist = function(err) {
		return isExist(err);
	};
	var IsNotExist = go$pkg.IsNotExist = function(err) {
		return isNotExist(err);
	};
	var IsPermission = go$pkg.IsPermission = function(err) {
		return isPermission(err);
	};
	var isExist = function(err) {
		var pe, _ref, _type;
		_ref = err;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === null) {
			pe = _ref;
			return false;
		} else if (_type === (go$ptrType(PathError))) {
			pe = _ref.go$val;
			err = pe.Err;
		} else if (_type === (go$ptrType(LinkError))) {
			pe = _ref.go$val;
			err = pe.Err;
		}
		return go$interfaceIsEqual(err, new syscall.Errno(183)) || go$interfaceIsEqual(err, new syscall.Errno(80)) || go$interfaceIsEqual(err, go$pkg.ErrExist);
	};
	var isNotExist = function(err) {
		var pe, _ref, _type;
		_ref = err;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === null) {
			pe = _ref;
			return false;
		} else if (_type === (go$ptrType(PathError))) {
			pe = _ref.go$val;
			err = pe.Err;
		} else if (_type === (go$ptrType(LinkError))) {
			pe = _ref.go$val;
			err = pe.Err;
		}
		return go$interfaceIsEqual(err, new syscall.Errno(2)) || go$interfaceIsEqual(err, new syscall.Errno(3)) || go$interfaceIsEqual(err, go$pkg.ErrNotExist);
	};
	var isPermission = function(err) {
		var pe, _ref, _type;
		_ref = err;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === null) {
			pe = _ref;
			return false;
		} else if (_type === (go$ptrType(PathError))) {
			pe = _ref.go$val;
			err = pe.Err;
		} else if (_type === (go$ptrType(LinkError))) {
			pe = _ref.go$val;
			err = pe.Err;
		}
		return go$interfaceIsEqual(err, new syscall.Errno(5)) || go$interfaceIsEqual(err, go$pkg.ErrPermission);
	};
	var newProcess = function(pid, handle) {
		var p;
		p = new Process.Ptr(pid, handle, 0);
		runtime.SetFinalizer(p, new (go$funcType([(go$ptrType(Process))], [go$error], false))((function(recv) { return recv.Release(); })));
		return p;
	};
	Process.Ptr.prototype.setDone = function() {
		var p, v;
		p = this;
		atomic.StoreUint32(new (go$ptrType(Go$Uint32))(function() { return p.isdone; }, function(v) { p.isdone = v; }), 1);
	};
	Process.prototype.setDone = function() { return this.go$val.setDone(); };
	Process.Ptr.prototype.done = function() {
		var p, v;
		p = this;
		return atomic.LoadUint32(new (go$ptrType(Go$Uint32))(function() { return p.isdone; }, function(v) { p.isdone = v; })) > 0;
	};
	Process.prototype.done = function() { return this.go$val.done(); };
	var Getpid = go$pkg.Getpid = function() {
		return syscall.Getpid();
	};
	var Getppid = go$pkg.Getppid = function() {
		return syscall.Getppid();
	};
	var startProcess = function(name, argv, attr) {
		var p, err, err$1, _tuple, pe, _tuple$1, sysattr, _ref, _i, _slice, _index, f, _tuple$2, pid, h, e, _tuple$3, _tuple$4;
		p = (go$ptrType(Process)).nil;
		err = null;
		if (!(attr === (go$ptrType(ProcAttr)).nil) && attr.Sys === (go$ptrType(syscall.SysProcAttr)).nil && !(attr.Dir === "")) {
			if (_tuple = Stat(attr.Dir), err$1 = _tuple[1], !(go$interfaceIsEqual(err$1, null))) {
				pe = (err$1 !== null && err$1.constructor === (go$ptrType(PathError)) ? err$1.go$val : go$typeAssertionFailed(err$1, (go$ptrType(PathError))));
				pe.Op = "chdir";
				_tuple$1 = [(go$ptrType(Process)).nil, pe], p = _tuple$1[0], err = _tuple$1[1];
				return [p, err];
			}
		}
		sysattr = new syscall.ProcAttr.Ptr(attr.Dir, attr.Env, (go$sliceType(Go$Uintptr)).nil, attr.Sys);
		if (sysattr.Env === (go$sliceType(Go$String)).nil) {
			sysattr.Env = Environ();
		}
		_ref = attr.Files;
		_i = 0;
		while (_i < _ref.length) {
			f = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			sysattr.Files = go$append(sysattr.Files, f.Fd());
			_i++;
		}
		_tuple$2 = syscall.StartProcess(name, argv, sysattr), pid = _tuple$2[0], h = _tuple$2[1], e = _tuple$2[2];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$3 = [(go$ptrType(Process)).nil, new PathError.Ptr("fork/exec", name, e)], p = _tuple$3[0], err = _tuple$3[1];
			return [p, err];
		}
		_tuple$4 = [newProcess(pid, h), null], p = _tuple$4[0], err = _tuple$4[1];
		return [p, err];
	};
	Process.Ptr.prototype.kill = function() {
		var p;
		p = this;
		return p.Signal(go$pkg.Kill);
	};
	Process.prototype.kill = function() { return this.go$val.kill(); };
	ProcessState.Ptr.prototype.Pid = function() {
		var p;
		p = this;
		return p.pid;
	};
	ProcessState.prototype.Pid = function() { return this.go$val.Pid(); };
	ProcessState.Ptr.prototype.exited = function() {
		var p;
		p = this;
		return p.status.Exited();
	};
	ProcessState.prototype.exited = function() { return this.go$val.exited(); };
	ProcessState.Ptr.prototype.success = function() {
		var p;
		p = this;
		return p.status.ExitStatus() === 0;
	};
	ProcessState.prototype.success = function() { return this.go$val.success(); };
	ProcessState.Ptr.prototype.sys = function() {
		var p, x;
		p = this;
		return (x = p.status, new x.constructor.Struct(x));
	};
	ProcessState.prototype.sys = function() { return this.go$val.sys(); };
	ProcessState.Ptr.prototype.sysUsage = function() {
		var p;
		p = this;
		return p.rusage;
	};
	ProcessState.prototype.sysUsage = function() { return this.go$val.sysUsage(); };
	var itod = function(i) {
		var u, b, bp;
		if (i === 0) {
			return "0";
		}
		u = new Go$Uint64(0, i);
		if (i < 0) {
			u = new Go$Uint64(-u.high, -u.low);
		}
		b = go$makeNativeArray("Uint8", 32, function() { return 0; });
		bp = 32;
		while ((u.high > 0 || (u.high === 0 && u.low > 0))) {
			bp = bp - 1 >> 0;
			b[bp] = (go$div64(u, new Go$Uint64(0, 10), true).low << 24 >>> 24) + 48 << 24 >>> 24;
			u = go$div64(u, new Go$Uint64(0, 10), false);
		}
		if (i < 0) {
			bp = bp - 1 >> 0;
			b[bp] = 45;
		}
		return go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(b), bp));
	};
	ProcessState.Ptr.prototype.String = function() {
		var p, x, _struct, status, res;
		p = this;
		if (p === (go$ptrType(ProcessState)).nil) {
			return "<nil>";
		}
		status = (_struct = (x = p.Sys(), (x !== null && x.constructor === syscall.WaitStatus ? x.go$val : go$typeAssertionFailed(x, syscall.WaitStatus))), new syscall.WaitStatus.Ptr(_struct.ExitCode));
		res = "";
		if (status.Exited()) {
			res = "exit status " + itod(status.ExitStatus());
		} else if (status.Signaled()) {
			res = "signal: " + (new syscall.Signal(status.Signal())).String();
		} else if (status.Stopped()) {
			res = "stop signal: " + (new syscall.Signal(status.StopSignal())).String();
			if ((status.StopSignal() === 5) && !((status.TrapCause() === 0))) {
				res = res + (" (trap " + itod(status.TrapCause()) + ")");
			}
		} else if (status.Continued()) {
			res = "continued";
		}
		if (status.CoreDump()) {
			res = res + " (core dumped)";
		}
		return res;
	};
	ProcessState.prototype.String = function() { return this.go$val.String(); };
	Process.Ptr.prototype.wait = function() {
		var ps, err, p, _tuple, s, e, _ref, _tuple$1, _tuple$2, ec, v, _tuple$3, u, _tuple$4, _tuple$5;
		ps = (go$ptrType(ProcessState)).nil;
		err = null;
		var go$deferred = [];
		try {
			p = this;
			_tuple = syscall.WaitForSingleObject((p.handle >>> 0), 4294967295), s = _tuple[0], e = _tuple[1];
			_ref = s;
			switch (0) { default: if (_ref === 0) {
				break;
			} else if (_ref === 4294967295) {
				_tuple$1 = [(go$ptrType(ProcessState)).nil, NewSyscallError("WaitForSingleObject", e)], ps = _tuple$1[0], err = _tuple$1[1];
				return [ps, err];
			} else {
				_tuple$2 = [(go$ptrType(ProcessState)).nil, errors.New("os: unexpected result from WaitForSingleObject")], ps = _tuple$2[0], err = _tuple$2[1];
				return [ps, err];
			} }
			ec = 0;
			e = syscall.GetExitCodeProcess((p.handle >>> 0), new (go$ptrType(Go$Uint32))(function() { return ec; }, function(v) { ec = v; }));
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$3 = [(go$ptrType(ProcessState)).nil, NewSyscallError("GetExitCodeProcess", e)], ps = _tuple$3[0], err = _tuple$3[1];
				return [ps, err];
			}
			u = new syscall.Rusage.Ptr();
			e = syscall.GetProcessTimes((p.handle >>> 0), u.CreationTime, u.ExitTime, u.KernelTime, u.UserTime);
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$4 = [(go$ptrType(ProcessState)).nil, NewSyscallError("GetProcessTimes", e)], ps = _tuple$4[0], err = _tuple$4[1];
				return [ps, err];
			}
			p.setDone();
			go$deferred.push({ recv: time, method: "Sleep", args: [new time.Duration(0, 5000000)] });
			go$deferred.push({ recv: p, method: "Release", args: [] });
			_tuple$5 = [new ProcessState.Ptr(p.Pid, new syscall.WaitStatus.Ptr(ec), u), null], ps = _tuple$5[0], err = _tuple$5[1];
			return [ps, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [ps, err];
		}
	};
	Process.prototype.wait = function() { return this.go$val.wait(); };
	var terminateProcess = function(pid, exitcode) {
		var _tuple, h, e;
		var go$deferred = [];
		try {
			_tuple = syscall.OpenProcess(1, false, (pid >>> 0)), h = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				return NewSyscallError("OpenProcess", e);
			}
			go$deferred.push({ recv: syscall, method: "CloseHandle", args: [h] });
			e = syscall.TerminateProcess(h, (exitcode >>> 0));
			return NewSyscallError("TerminateProcess", e);
		} catch(go$err) {
			go$pushErr(go$err);
			return null;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	Process.Ptr.prototype.signal = function(sig) {
		var p;
		p = this;
		if (p.done()) {
			return errors.New("os: process already finished");
		}
		if (go$interfaceIsEqual(sig, go$pkg.Kill)) {
			return terminateProcess(p.Pid, 1);
		}
		return new syscall.Errno(536871042);
	};
	Process.prototype.signal = function(sig) { return this.go$val.signal(sig); };
	Process.Ptr.prototype.release = function() {
		var p, e;
		p = this;
		if (p.handle === 4294967295) {
			return new syscall.Errno(536870951);
		}
		e = syscall.CloseHandle((p.handle >>> 0));
		if (!(go$interfaceIsEqual(e, null))) {
			return NewSyscallError("CloseHandle", e);
		}
		p.handle = 4294967295;
		runtime.SetFinalizer(p, null);
		return null;
	};
	Process.prototype.release = function() { return this.go$val.release(); };
	var findProcess = function(pid) {
		var p, err, _tuple, h, e, _tuple$1, _tuple$2;
		p = (go$ptrType(Process)).nil;
		err = null;
		_tuple = syscall.OpenProcess(1180672, false, (pid >>> 0)), h = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$1 = [(go$ptrType(Process)).nil, NewSyscallError("OpenProcess", e)], p = _tuple$1[0], err = _tuple$1[1];
			return [p, err];
		}
		_tuple$2 = [newProcess(pid, (h >>> 0)), null], p = _tuple$2[0], err = _tuple$2[1];
		return [p, err];
	};
	var ftToDuration = function(ft) {
		var x, x$1, n, x$2;
		n = (x = go$shiftLeft64(new Go$Int64(0, ft.HighDateTime), 32), x$1 = new Go$Int64(0, ft.LowDateTime), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
		return go$mul64((x$2 = go$mul64(n, new Go$Int64(0, 100)), new time.Duration(x$2.high, x$2.low)), new time.Duration(0, 1));
	};
	ProcessState.Ptr.prototype.userTime = function() {
		var p;
		p = this;
		return ftToDuration(p.rusage.UserTime);
	};
	ProcessState.prototype.userTime = function() { return this.go$val.userTime(); };
	ProcessState.Ptr.prototype.systemTime = function() {
		var p;
		p = this;
		return ftToDuration(p.rusage.KernelTime);
	};
	ProcessState.prototype.systemTime = function() { return this.go$val.systemTime(); };
	File.Ptr.prototype.Name = function() {
		var f;
		f = this;
		return f.file.name;
	};
	File.prototype.Name = function() { return this.go$val.Name(); };
	LinkError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.Op + " " + e.Old + " " + e.New + ": " + e.Err.Error();
	};
	LinkError.prototype.Error = function() { return this.go$val.Error(); };
	File.Ptr.prototype.Read = function(b) {
		var n, err, f, _tuple, _tuple$1, e, _tuple$2, _tuple$3;
		n = 0;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [0, go$pkg.ErrInvalid], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		_tuple$1 = f.read(b), n = _tuple$1[0], e = _tuple$1[1];
		if (n < 0) {
			n = 0;
		}
		if ((n === 0) && b.length > 0 && go$interfaceIsEqual(e, null)) {
			_tuple$2 = [0, io.EOF], n = _tuple$2[0], err = _tuple$2[1];
			return [n, err];
		}
		if (!(go$interfaceIsEqual(e, null))) {
			err = new PathError.Ptr("read", f.file.name, e);
		}
		_tuple$3 = [n, err], n = _tuple$3[0], err = _tuple$3[1];
		return [n, err];
	};
	File.prototype.Read = function(b) { return this.go$val.Read(b); };
	File.Ptr.prototype.ReadAt = function(b, off) {
		var n, err, f, _tuple, _tuple$1, m, e, _tuple$2, x;
		n = 0;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [0, go$pkg.ErrInvalid], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		while (b.length > 0) {
			_tuple$1 = f.pread(b, off), m = _tuple$1[0], e = _tuple$1[1];
			if ((m === 0) && go$interfaceIsEqual(e, null)) {
				_tuple$2 = [n, io.EOF], n = _tuple$2[0], err = _tuple$2[1];
				return [n, err];
			}
			if (!(go$interfaceIsEqual(e, null))) {
				err = new PathError.Ptr("read", f.file.name, e);
				break;
			}
			n = n + (m) >> 0;
			b = go$subslice(b, m);
			off = (x = new Go$Int64(0, m), new Go$Int64(off.high + x.high, off.low + x.low));
		}
		return [n, err];
	};
	File.prototype.ReadAt = function(b, off) { return this.go$val.ReadAt(b, off); };
	File.Ptr.prototype.Write = function(b) {
		var n, err, f, _tuple, _tuple$1, e, _tuple$2;
		n = 0;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [0, go$pkg.ErrInvalid], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		_tuple$1 = f.write(b), n = _tuple$1[0], e = _tuple$1[1];
		if (n < 0) {
			n = 0;
		}
		epipecheck(f, e);
		if (!(go$interfaceIsEqual(e, null))) {
			err = new PathError.Ptr("write", f.file.name, e);
		}
		_tuple$2 = [n, err], n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	File.prototype.Write = function(b) { return this.go$val.Write(b); };
	File.Ptr.prototype.WriteAt = function(b, off) {
		var n, err, f, _tuple, _tuple$1, m, e, x;
		n = 0;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [0, go$pkg.ErrInvalid], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		while (b.length > 0) {
			_tuple$1 = f.pwrite(b, off), m = _tuple$1[0], e = _tuple$1[1];
			if (!(go$interfaceIsEqual(e, null))) {
				err = new PathError.Ptr("write", f.file.name, e);
				break;
			}
			n = n + (m) >> 0;
			b = go$subslice(b, m);
			off = (x = new Go$Int64(0, m), new Go$Int64(off.high + x.high, off.low + x.low));
		}
		return [n, err];
	};
	File.prototype.WriteAt = function(b, off) { return this.go$val.WriteAt(b, off); };
	File.Ptr.prototype.Seek = function(offset, whence) {
		var ret, err, f, _tuple, _tuple$1, r, e, _tuple$2, _tuple$3;
		ret = new Go$Int64(0, 0);
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [new Go$Int64(0, 0), go$pkg.ErrInvalid], ret = _tuple[0], err = _tuple[1];
			return [ret, err];
		}
		_tuple$1 = f.seek(offset, whence), r = _tuple$1[0], e = _tuple$1[1];
		if (go$interfaceIsEqual(e, null) && !(f.file.dirinfo === (go$ptrType(dirInfo)).nil) && !((r.high === 0 && r.low === 0))) {
			e = new syscall.Errno(536870954);
		}
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$2 = [new Go$Int64(0, 0), new PathError.Ptr("seek", f.file.name, e)], ret = _tuple$2[0], err = _tuple$2[1];
			return [ret, err];
		}
		_tuple$3 = [r, null], ret = _tuple$3[0], err = _tuple$3[1];
		return [ret, err];
	};
	File.prototype.Seek = function(offset, whence) { return this.go$val.Seek(offset, whence); };
	File.Ptr.prototype.WriteString = function(s) {
		var ret, err, f, _tuple, _tuple$1;
		ret = 0;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			_tuple = [0, go$pkg.ErrInvalid], ret = _tuple[0], err = _tuple[1];
			return [ret, err];
		}
		_tuple$1 = f.Write(new (go$sliceType(Go$Uint8))(go$stringToBytes(s))), ret = _tuple$1[0], err = _tuple$1[1];
		return [ret, err];
	};
	File.prototype.WriteString = function(s) { return this.go$val.WriteString(s); };
	var Mkdir = go$pkg.Mkdir = function(name, perm) {
		var e;
		e = syscall.Mkdir(name, syscallMode(perm));
		if (!(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("mkdir", name, e);
		}
		return null;
	};
	var Chdir = go$pkg.Chdir = function(dir) {
		var e;
		if (e = syscall.Chdir(dir), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chdir", dir, e);
		}
		return null;
	};
	File.Ptr.prototype.Chdir = function() {
		var f, e;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			return go$pkg.ErrInvalid;
		}
		if (e = syscall.Fchdir(f.file.fd), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chdir", f.file.name, e);
		}
		return null;
	};
	File.prototype.Chdir = function() { return this.go$val.Chdir(); };
	var Open = go$pkg.Open = function(name) {
		var file$1, err, _tuple;
		file$1 = (go$ptrType(File)).nil;
		err = null;
		_tuple = OpenFile(name, 0, 0), file$1 = _tuple[0], err = _tuple[1];
		return [file$1, err];
	};
	var Create = go$pkg.Create = function(name) {
		var file$1, err, _tuple;
		file$1 = (go$ptrType(File)).nil;
		err = null;
		_tuple = OpenFile(name, 578, 438), file$1 = _tuple[0], err = _tuple[1];
		return [file$1, err];
	};
	var sigpipe = function() {
		throw go$panic("Native function not implemented: sigpipe");
	};
	var Link = go$pkg.Link = function(oldname, newname) {
		var e;
		e = syscall.Link(oldname, newname);
		if (!(go$interfaceIsEqual(e, null))) {
			return new LinkError.Ptr("link", oldname, newname, e);
		}
		return null;
	};
	var Symlink = go$pkg.Symlink = function(oldname, newname) {
		var e;
		e = syscall.Symlink(oldname, newname);
		if (!(go$interfaceIsEqual(e, null))) {
			return new LinkError.Ptr("symlink", oldname, newname, e);
		}
		return null;
	};
	var Readlink = go$pkg.Readlink = function(name) {
		var len, x, b, _tuple, n, e;
		len = 128;
		while (true) {
			b = (go$sliceType(Go$Uint8)).make(len, 0, function() { return 0; });
			_tuple = syscall.Readlink(name, b), n = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				return ["", new PathError.Ptr("readlink", name, e)];
			}
			if (n < len) {
				return [go$bytesToString(go$subslice(b, 0, n)), null];
			}
			len = (x = 2, (((len >>> 16 << 16) * x >> 0) + (len << 16 >>> 16) * x) >> 0);
		}
	};
	var Rename = go$pkg.Rename = function(oldname, newname) {
		var e;
		e = syscall.Rename(oldname, newname);
		if (!(go$interfaceIsEqual(e, null))) {
			return new LinkError.Ptr("rename", oldname, newname, e);
		}
		return null;
	};
	var syscallMode = function(i) {
		var o;
		o = 0;
		o = (o | (((new FileMode(i)).Perm() >>> 0))) >>> 0;
		if (!((((i & 8388608) >>> 0) === 0))) {
			o = (o | 2048) >>> 0;
		}
		if (!((((i & 4194304) >>> 0) === 0))) {
			o = (o | 1024) >>> 0;
		}
		if (!((((i & 1048576) >>> 0) === 0))) {
			o = (o | 512) >>> 0;
		}
		return o;
	};
	var Chmod = go$pkg.Chmod = function(name, mode) {
		var e;
		if (e = syscall.Chmod(name, syscallMode(mode)), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chmod", name, e);
		}
		return null;
	};
	File.Ptr.prototype.Chmod = function(mode) {
		var f, e;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			return go$pkg.ErrInvalid;
		}
		if (e = syscall.Fchmod(f.file.fd, syscallMode(mode)), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chmod", f.file.name, e);
		}
		return null;
	};
	File.prototype.Chmod = function(mode) { return this.go$val.Chmod(mode); };
	var Chown = go$pkg.Chown = function(name, uid, gid) {
		var e;
		if (e = syscall.Chown(name, uid, gid), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chown", name, e);
		}
		return null;
	};
	var Lchown = go$pkg.Lchown = function(name, uid, gid) {
		var e;
		if (e = syscall.Lchown(name, uid, gid), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("lchown", name, e);
		}
		return null;
	};
	File.Ptr.prototype.Chown = function(uid, gid) {
		var f, e;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			return go$pkg.ErrInvalid;
		}
		if (e = syscall.Fchown(f.file.fd, uid, gid), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chown", f.file.name, e);
		}
		return null;
	};
	File.prototype.Chown = function(uid, gid) { return this.go$val.Chown(uid, gid); };
	File.Ptr.prototype.Truncate = function(size) {
		var f, e;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			return go$pkg.ErrInvalid;
		}
		if (e = syscall.Ftruncate(f.file.fd, size), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("truncate", f.file.name, e);
		}
		return null;
	};
	File.prototype.Truncate = function(size) { return this.go$val.Truncate(size); };
	File.Ptr.prototype.Sync = function() {
		var err, f, e;
		err = null;
		f = this;
		if (f === (go$ptrType(File)).nil) {
			err = new syscall.Errno(536870951);
			return err;
		}
		if (e = syscall.Fsync(f.file.fd), !(go$interfaceIsEqual(e, null))) {
			err = NewSyscallError("fsync", e);
			return err;
		}
		err = null;
		return err;
	};
	File.prototype.Sync = function() { return this.go$val.Sync(); };
	var Chtimes = go$pkg.Chtimes = function(name, atime$1, mtime) {
		var utimes, _struct, _struct$1, e;
		utimes = go$makeNativeArray("Struct", 2, function() { return new syscall.Timespec.Ptr(); });
		utimes[0] = (_struct = syscall.NsecToTimespec(atime$1.UnixNano()), new syscall.Timespec.Ptr(_struct.Sec, _struct.Nsec));
		utimes[1] = (_struct$1 = syscall.NsecToTimespec(mtime.UnixNano()), new syscall.Timespec.Ptr(_struct$1.Sec, _struct$1.Nsec));
		if (e = syscall.UtimesNano(name, go$subslice(new (go$sliceType(syscall.Timespec))(utimes), 0)), !(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("chtimes", name, e);
		}
		return null;
	};
	File.Ptr.prototype.Fd = function() {
		var file$1;
		file$1 = this;
		if (file$1 === (go$ptrType(File)).nil) {
			return 4294967295;
		}
		return (file$1.file.fd >>> 0);
	};
	File.prototype.Fd = function() { return this.go$val.Fd(); };
	var newFile = function(h, name) {
		var f, m, v;
		f = new File.Ptr(new file.Ptr(h, name, (go$ptrType(dirInfo)).nil, new sync.Mutex.Ptr(), false, (go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Int32)).nil));
		m = 0;
		if (go$interfaceIsEqual(syscall.GetConsoleMode(f.file.fd, new (go$ptrType(Go$Uint32))(function() { return m; }, function(v) { m = v; })), null)) {
			f.file.isConsole = true;
		}
		runtime.SetFinalizer(f.file, new (go$funcType([(go$ptrType(file))], [go$error], false))((function(recv) { return recv.close(); })));
		return f;
	};
	var NewFile = go$pkg.NewFile = function(fd, name) {
		var h;
		h = (fd >>> 0);
		if (h === 4294967295) {
			return (go$ptrType(File)).nil;
		}
		return newFile(h, name);
	};
	var epipecheck = function(file$1, e) {
	};
	file.Ptr.prototype.isdir = function() {
		var f;
		f = this;
		return !(f === (go$ptrType(file)).nil) && !(f.dirinfo === (go$ptrType(dirInfo)).nil);
	};
	file.prototype.isdir = function() { return this.go$val.isdir(); };
	var openFile = function(name, flag, perm) {
		var file$1, err, _tuple, r, e, _tuple$1, _tuple$2;
		file$1 = (go$ptrType(File)).nil;
		err = null;
		_tuple = syscall.Open(name, flag | 524288, syscallMode(perm)), r = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$1 = [(go$ptrType(File)).nil, e], file$1 = _tuple$1[0], err = _tuple$1[1];
			return [file$1, err];
		}
		_tuple$2 = [NewFile((r >>> 0), name), null], file$1 = _tuple$2[0], err = _tuple$2[1];
		return [file$1, err];
	};
	var openDir = function(name) {
		var file$1, err, _tuple, maskp, e, _tuple$1, d, _tuple$2, r, _tuple$3, fa, _tuple$4, namep, e$1, _tuple$5, _tuple$6, _tuple$7, _tuple$8, cwd, f, _tuple$9;
		file$1 = (go$ptrType(File)).nil;
		err = null;
		_tuple = syscall.UTF16PtrFromString(name + "\\*"), maskp = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$1 = [(go$ptrType(File)).nil, e], file$1 = _tuple$1[0], err = _tuple$1[1];
			return [file$1, err];
		}
		d = new dirInfo.Ptr();
		_tuple$2 = syscall.FindFirstFile(maskp, d.data), r = _tuple$2[0], e = _tuple$2[1];
		if (!(go$interfaceIsEqual(e, null))) {
			if (!(go$interfaceIsEqual(e, new syscall.Errno(2)))) {
				_tuple$3 = [(go$ptrType(File)).nil, e], file$1 = _tuple$3[0], err = _tuple$3[1];
				return [file$1, err];
			}
			fa = new syscall.Win32FileAttributeData.Ptr();
			_tuple$4 = syscall.UTF16PtrFromString(name), namep = _tuple$4[0], e$1 = _tuple$4[1];
			if (!(go$interfaceIsEqual(e$1, null))) {
				_tuple$5 = [(go$ptrType(File)).nil, e$1], file$1 = _tuple$5[0], err = _tuple$5[1];
				return [file$1, err];
			}
			e$1 = syscall.GetFileAttributesEx(namep, 0, fa);
			if (!(go$interfaceIsEqual(e$1, null))) {
				_tuple$6 = [(go$ptrType(File)).nil, e$1], file$1 = _tuple$6[0], err = _tuple$6[1];
				return [file$1, err];
			}
			if (((fa.FileAttributes & 16) >>> 0) === 0) {
				_tuple$7 = [(go$ptrType(File)).nil, e$1], file$1 = _tuple$7[0], err = _tuple$7[1];
				return [file$1, err];
			}
			d.isempty = true;
		}
		d.path = name;
		if (!isAbs(d.path)) {
			_tuple$8 = Getwd(), cwd = _tuple$8[0];
			d.path = cwd + "\\" + d.path;
		}
		f = newFile(r, name);
		f.file.dirinfo = d;
		_tuple$9 = [f, null], file$1 = _tuple$9[0], err = _tuple$9[1];
		return [file$1, err];
	};
	var OpenFile = go$pkg.OpenFile = function(name, flag, perm) {
		var file$1, err, _tuple, _tuple$1, r, e, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6;
		file$1 = (go$ptrType(File)).nil;
		err = null;
		if (name === "") {
			_tuple = [(go$ptrType(File)).nil, new PathError.Ptr("open", name, new syscall.Errno(2))], file$1 = _tuple[0], err = _tuple[1];
			return [file$1, err];
		}
		_tuple$1 = openDir(name), r = _tuple$1[0], e = _tuple$1[1];
		if (go$interfaceIsEqual(e, null)) {
			if (!(((flag & 1) === 0)) || !(((flag & 2) === 0))) {
				r.Close();
				_tuple$2 = [(go$ptrType(File)).nil, new PathError.Ptr("open", name, new syscall.Errno(536870954))], file$1 = _tuple$2[0], err = _tuple$2[1];
				return [file$1, err];
			}
			_tuple$3 = [r, null], file$1 = _tuple$3[0], err = _tuple$3[1];
			return [file$1, err];
		}
		_tuple$4 = openFile(name, flag, perm), r = _tuple$4[0], e = _tuple$4[1];
		if (go$interfaceIsEqual(e, null)) {
			_tuple$5 = [r, null], file$1 = _tuple$5[0], err = _tuple$5[1];
			return [file$1, err];
		}
		_tuple$6 = [(go$ptrType(File)).nil, new PathError.Ptr("open", name, e)], file$1 = _tuple$6[0], err = _tuple$6[1];
		return [file$1, err];
	};
	File.Ptr.prototype.Close = function() {
		var file$1;
		file$1 = this;
		if (file$1 === (go$ptrType(File)).nil) {
			return go$pkg.ErrInvalid;
		}
		return file$1.file.close();
	};
	File.prototype.Close = function() { return this.go$val.Close(); };
	file.Ptr.prototype.close = function() {
		var file$1, e, err;
		file$1 = this;
		if (file$1 === (go$ptrType(file)).nil) {
			return new syscall.Errno(536870951);
		}
		if (file$1.isdir() && file$1.dirinfo.isempty) {
			return null;
		}
		if (file$1.fd === 4294967295) {
			return new syscall.Errno(536870951);
		}
		e = null;
		if (file$1.isdir()) {
			e = syscall.FindClose(file$1.fd);
		} else {
			e = syscall.CloseHandle(file$1.fd);
		}
		err = null;
		if (!(go$interfaceIsEqual(e, null))) {
			err = new PathError.Ptr("close", file$1.name, e);
		}
		file$1.fd = 4294967295;
		runtime.SetFinalizer(file$1, null);
		return err;
	};
	file.prototype.close = function() { return this.go$val.close(); };
	File.Ptr.prototype.readdir = function(n) {
		var fi, err, file$1, _tuple, _tuple$1, _tuple$2, wantAll, size, d, e, name, _struct, _struct$1, _struct$2, f, _tuple$3, _tuple$4;
		fi = (go$sliceType(FileInfo)).nil;
		err = null;
		file$1 = this;
		if (file$1 === (go$ptrType(File)).nil) {
			_tuple = [(go$sliceType(FileInfo)).nil, new syscall.Errno(536870951)], fi = _tuple[0], err = _tuple[1];
			return [fi, err];
		}
		if (!file$1.file.isdir()) {
			_tuple$1 = [(go$sliceType(FileInfo)).nil, new PathError.Ptr("Readdir", file$1.file.name, new syscall.Errno(3))], fi = _tuple$1[0], err = _tuple$1[1];
			return [fi, err];
		}
		if (!file$1.file.dirinfo.isempty && (file$1.file.fd === 4294967295)) {
			_tuple$2 = [(go$sliceType(FileInfo)).nil, new syscall.Errno(536870951)], fi = _tuple$2[0], err = _tuple$2[1];
			return [fi, err];
		}
		wantAll = n <= 0;
		size = n;
		if (wantAll) {
			n = -1;
			size = 100;
		}
		fi = (go$sliceType(FileInfo)).make(0, size, function() { return null; });
		d = file$1.file.dirinfo.data;
		while (!((n === 0)) && !file$1.file.dirinfo.isempty) {
			if (file$1.file.dirinfo.needdata) {
				e = syscall.FindNextFile(file$1.file.fd, d);
				if (!(go$interfaceIsEqual(e, null))) {
					if (go$interfaceIsEqual(e, new syscall.Errno(18))) {
						break;
					} else {
						err = new PathError.Ptr("FindNextFile", file$1.file.name, e);
						if (!wantAll) {
							fi = (go$sliceType(FileInfo)).nil;
						}
						return [fi, err];
					}
				}
			}
			file$1.file.dirinfo.needdata = true;
			name = syscall.UTF16ToString(go$subslice(new (go$sliceType(Go$Uint16))(d.FileName), 0));
			if (name === "." || name === "..") {
				continue;
			}
			f = new fileStat.Ptr(name, new syscall.Win32FileAttributeData.Ptr(d.FileAttributes, (_struct = d.CreationTime, new syscall.Filetime.Ptr(_struct.LowDateTime, _struct.HighDateTime)), (_struct$1 = d.LastAccessTime, new syscall.Filetime.Ptr(_struct$1.LowDateTime, _struct$1.HighDateTime)), (_struct$2 = d.LastWriteTime, new syscall.Filetime.Ptr(_struct$2.LowDateTime, _struct$2.HighDateTime)), d.FileSizeHigh, d.FileSizeLow), new sync.Mutex.Ptr(), file$1.file.dirinfo.path + "\\" + name, 0, 0, 0);
			n = n - 1 >> 0;
			fi = go$append(fi, f);
		}
		if (!wantAll && (fi.length === 0)) {
			_tuple$3 = [fi, io.EOF], fi = _tuple$3[0], err = _tuple$3[1];
			return [fi, err];
		}
		_tuple$4 = [fi, null], fi = _tuple$4[0], err = _tuple$4[1];
		return [fi, err];
	};
	File.prototype.readdir = function(n) { return this.go$val.readdir(n); };
	File.Ptr.prototype.readConsole = function(b) {
		var n, err, f, _tuple, numBytes, wchars, p, v, _slice, _index, _slice$1, _index$1, nw, v$1, err$1, _tuple$1, _ref, _i, _slice$2, _index$2, r, i, _tuple$2, nr, _tuple$3;
		n = 0;
		err = null;
		f = this;
		if (b.length === 0) {
			_tuple = [0, null], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (f.file.readbuf.length === 0) {
			numBytes = b.length;
			if (numBytes > 16000) {
				numBytes = 16000;
			}
			wchars = (go$sliceType(Go$Uint16)).make(numBytes, 0, function() { return 0; });
			p = (go$ptrType(Go$Uint16)).nil;
			if (b.length > 0) {
				p = new (go$ptrType(Go$Uint16))(function() { return (_slice = wchars, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = wchars, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); });
			}
			nw = 0;
			err$1 = syscall.ReadConsole(f.file.fd, p, (wchars.length >>> 0), new (go$ptrType(Go$Uint32))(function() { return nw; }, function(v$1) { nw = v$1; }), (go$ptrType(Go$Uint8)).nil);
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$1 = [0, err$1], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
			f.file.readbuf = utf16.Decode(go$subslice(wchars, 0, nw));
		}
		_ref = f.file.readbuf;
		_i = 0;
		while (_i < _ref.length) {
			r = (_slice$2 = _ref, _index$2 = _i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (utf8.RuneLen(r) > b.length) {
				f.file.readbuf = go$subslice(f.file.readbuf, i);
				_tuple$2 = [n, null], n = _tuple$2[0], err = _tuple$2[1];
				return [n, err];
			}
			nr = utf8.EncodeRune(b, r);
			b = go$subslice(b, nr);
			n = n + (nr) >> 0;
			_i++;
		}
		f.file.readbuf = (go$sliceType(Go$Int32)).nil;
		_tuple$3 = [n, null], n = _tuple$3[0], err = _tuple$3[1];
		return [n, err];
	};
	File.prototype.readConsole = function(b) { return this.go$val.readConsole(b); };
	File.Ptr.prototype.read = function(b) {
		var n, err, f, _tuple, _tuple$1;
		n = 0;
		err = null;
		var go$deferred = [];
		try {
			f = this;
			f.file.l.Lock();
			go$deferred.push({ recv: f.file.l, method: "Unlock", args: [] });
			if (f.file.isConsole) {
				_tuple = f.readConsole(b), n = _tuple[0], err = _tuple[1];
				return [n, err];
			}
			_tuple$1 = syscall.Read(f.file.fd, b), n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [n, err];
		}
	};
	File.prototype.read = function(b) { return this.go$val.read(b); };
	File.Ptr.prototype.pread = function(b, off) {
		var n, err, f, _tuple, curoffset, e, _tuple$1, o, done, v, _tuple$2, _tuple$3, _tuple$4;
		n = 0;
		err = null;
		var go$deferred = [];
		try {
			f = this;
			f.file.l.Lock();
			go$deferred.push({ recv: f.file.l, method: "Unlock", args: [] });
			_tuple = syscall.Seek(f.file.fd, new Go$Int64(0, 0), 1), curoffset = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$1 = [0, e], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
			go$deferred.push({ recv: syscall, method: "Seek", args: [f.file.fd, curoffset, 0] });
			o = new syscall.Overlapped.Ptr(0, 0, (off.low >>> 0), (go$shiftRightInt64(off, 32).low >>> 0), 0);
			done = 0;
			e = syscall.ReadFile(f.file.fd, b, new (go$ptrType(Go$Uint32))(function() { return done; }, function(v) { done = v; }), o);
			if (!(go$interfaceIsEqual(e, null))) {
				if (go$interfaceIsEqual(e, new syscall.Errno(38))) {
					_tuple$2 = [0, null], n = _tuple$2[0], err = _tuple$2[1];
					return [n, err];
				}
				_tuple$3 = [0, e], n = _tuple$3[0], err = _tuple$3[1];
				return [n, err];
			}
			_tuple$4 = [(done >> 0), null], n = _tuple$4[0], err = _tuple$4[1];
			return [n, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [n, err];
		}
	};
	File.prototype.pread = function(b, off) { return this.go$val.pread(b, off); };
	File.Ptr.prototype.writeConsole = function(b) {
		var n, err, f, runes, _tuple, r, l, m, chunk, uint16s, written, v, _slice, _index, _slice$1, _index$1, v$1, _tuple$1, _tuple$2;
		n = 0;
		err = null;
		f = this;
		n = b.length;
		runes = (go$sliceType(Go$Int32)).make(0, 256, function() { return 0; });
		if (f.file.lastbits.length > 0) {
			b = go$appendSlice(f.file.lastbits, b);
			f.file.lastbits = (go$sliceType(Go$Uint8)).nil;
		}
		while (b.length >= 4 || utf8.FullRune(b)) {
			_tuple = utf8.DecodeRune(b), r = _tuple[0], l = _tuple[1];
			runes = go$append(runes, r);
			b = go$subslice(b, l);
		}
		if (b.length > 0) {
			f.file.lastbits = (go$sliceType(Go$Uint8)).make(b.length, 0, function() { return 0; });
			go$copySlice(f.file.lastbits, b);
		}
		while (runes.length > 0) {
			m = runes.length;
			if (m > 16000) {
				m = 16000;
			}
			chunk = go$subslice(runes, 0, m);
			runes = go$subslice(runes, m);
			uint16s = utf16.Encode(chunk);
			while (uint16s.length > 0) {
				written = [undefined];
				written[0] = 0;
				err = syscall.WriteConsole(f.file.fd, (function(written) { return new (go$ptrType(Go$Uint16))(function() { return (_slice = uint16s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = uint16s, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); }); })(written), (uint16s.length >>> 0), (function(written) { return new (go$ptrType(Go$Uint32))(function() { return written[0]; }, function(v$1) { written[0] = v$1; }); })(written), (go$ptrType(Go$Uint8)).nil);
				if (!(go$interfaceIsEqual(err, null))) {
					_tuple$1 = [0, null], n = _tuple$1[0], err = _tuple$1[1];
					return [n, err];
				}
				uint16s = go$subslice(uint16s, written[0]);
			}
		}
		_tuple$2 = [n, null], n = _tuple$2[0], err = _tuple$2[1];
		return [n, err];
	};
	File.prototype.writeConsole = function(b) { return this.go$val.writeConsole(b); };
	File.Ptr.prototype.write = function(b) {
		var n, err, f, _tuple, _tuple$1;
		n = 0;
		err = null;
		var go$deferred = [];
		try {
			f = this;
			f.file.l.Lock();
			go$deferred.push({ recv: f.file.l, method: "Unlock", args: [] });
			if (f.file.isConsole) {
				_tuple = f.writeConsole(b), n = _tuple[0], err = _tuple[1];
				return [n, err];
			}
			_tuple$1 = syscall.Write(f.file.fd, b), n = _tuple$1[0], err = _tuple$1[1];
			return [n, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [n, err];
		}
	};
	File.prototype.write = function(b) { return this.go$val.write(b); };
	File.Ptr.prototype.pwrite = function(b, off) {
		var n, err, f, _tuple, curoffset, e, _tuple$1, o, done, v, _tuple$2, _tuple$3;
		n = 0;
		err = null;
		var go$deferred = [];
		try {
			f = this;
			f.file.l.Lock();
			go$deferred.push({ recv: f.file.l, method: "Unlock", args: [] });
			_tuple = syscall.Seek(f.file.fd, new Go$Int64(0, 0), 1), curoffset = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$1 = [0, e], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
			go$deferred.push({ recv: syscall, method: "Seek", args: [f.file.fd, curoffset, 0] });
			o = new syscall.Overlapped.Ptr(0, 0, (off.low >>> 0), (go$shiftRightInt64(off, 32).low >>> 0), 0);
			done = 0;
			e = syscall.WriteFile(f.file.fd, b, new (go$ptrType(Go$Uint32))(function() { return done; }, function(v) { done = v; }), o);
			if (!(go$interfaceIsEqual(e, null))) {
				_tuple$2 = [0, e], n = _tuple$2[0], err = _tuple$2[1];
				return [n, err];
			}
			_tuple$3 = [(done >> 0), null], n = _tuple$3[0], err = _tuple$3[1];
			return [n, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [n, err];
		}
	};
	File.prototype.pwrite = function(b, off) { return this.go$val.pwrite(b, off); };
	File.Ptr.prototype.seek = function(offset, whence) {
		var ret, err, f, _tuple;
		ret = new Go$Int64(0, 0);
		err = null;
		var go$deferred = [];
		try {
			f = this;
			f.file.l.Lock();
			go$deferred.push({ recv: f.file.l, method: "Unlock", args: [] });
			_tuple = syscall.Seek(f.file.fd, offset, whence), ret = _tuple[0], err = _tuple[1];
			return [ret, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [ret, err];
		}
	};
	File.prototype.seek = function(offset, whence) { return this.go$val.seek(offset, whence); };
	var Truncate = go$pkg.Truncate = function(name, size) {
		var _tuple, f, e, e1;
		var go$deferred = [];
		try {
			_tuple = OpenFile(name, 65, 438), f = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				return e;
			}
			go$deferred.push({ recv: f, method: "Close", args: [] });
			e1 = f.Truncate(size);
			if (!(go$interfaceIsEqual(e1, null))) {
				return e1;
			}
			return null;
		} catch(go$err) {
			go$pushErr(go$err);
			return null;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	var Remove = go$pkg.Remove = function(name) {
		var _tuple, p, e, e1, _tuple$1, a, e2;
		_tuple = syscall.UTF16PtrFromString(name), p = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			return new PathError.Ptr("remove", name, e);
		}
		e = syscall.DeleteFile(p);
		if (go$interfaceIsEqual(e, null)) {
			return null;
		}
		e1 = syscall.RemoveDirectory(p);
		if (go$interfaceIsEqual(e1, null)) {
			return null;
		}
		if (!(go$interfaceIsEqual(e1, e))) {
			_tuple$1 = syscall.GetFileAttributes(p), a = _tuple$1[0], e2 = _tuple$1[1];
			if (!(go$interfaceIsEqual(e2, null))) {
				e = e2;
			} else {
				if (!((((a & 16) >>> 0) === 0))) {
					e = e1;
				}
			}
		}
		return new PathError.Ptr("remove", name, e);
	};
	var Pipe = go$pkg.Pipe = function() {
		var r, w, err, p, e, _tuple, _tuple$1;
		r = (go$ptrType(File)).nil;
		w = (go$ptrType(File)).nil;
		err = null;
		p = go$makeNativeArray("Uintptr", 2, function() { return 0; });
		syscall.ForkLock.RLock();
		e = syscall.Pipe(go$subslice(new (go$sliceType(syscall.Handle))(p), 0));
		if (!(go$interfaceIsEqual(e, null))) {
			syscall.ForkLock.RUnlock();
			_tuple = [(go$ptrType(File)).nil, (go$ptrType(File)).nil, NewSyscallError("pipe", e)], r = _tuple[0], w = _tuple[1], err = _tuple[2];
			return [r, w, err];
		}
		syscall.CloseOnExec(p[0]);
		syscall.CloseOnExec(p[1]);
		syscall.ForkLock.RUnlock();
		_tuple$1 = [NewFile((p[0] >>> 0), "|0"), NewFile((p[1] >>> 0), "|1"), null], r = _tuple$1[0], w = _tuple$1[1], err = _tuple$1[2];
		return [r, w, err];
	};
	var TempDir = go$pkg.TempDir = function() {
		var dirw, _tuple, v, _slice, _index, _slice$1, _index$1, n, _tuple$1, v$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4;
		dirw = (go$sliceType(Go$Uint16)).make(260, 0, function() { return 0; });
		_tuple = syscall.GetTempPath((dirw.length >>> 0), new (go$ptrType(Go$Uint16))(function() { return (_slice = dirw, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")); }, function(v) { _slice$1 = dirw, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = v) : go$throwRuntimeError("index out of range"); })), n = _tuple[0];
		if (n > (dirw.length >>> 0)) {
			dirw = (go$sliceType(Go$Uint16)).make(n, 0, function() { return 0; });
			_tuple$1 = syscall.GetTempPath((dirw.length >>> 0), new (go$ptrType(Go$Uint16))(function() { return (_slice$2 = dirw, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")); }, function(v$1) { _slice$3 = dirw, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = v$1) : go$throwRuntimeError("index out of range"); })), n = _tuple$1[0];
			if (n > (dirw.length >>> 0)) {
				n = 0;
			}
		}
		if (n > 0 && ((_slice$4 = dirw, _index$4 = (n - 1 >>> 0), (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")) === 92)) {
			n = n - 1 >>> 0;
		}
		return go$runesToString(utf16.Decode(go$subslice(dirw, 0, n)));
	};
	var Getwd = go$pkg.Getwd = function() {
		var pwd, err, _tuple, s, e, _tuple$1, _tuple$2, dot, _tuple$3, _tuple$4, d, err$1, _tuple$5, _tuple$6, d$1, err$2, _tuple$7, _tuple$8, root, _tuple$9, _tuple$10, parent, _tuple$11, _tuple$12, fd, err$3, _tuple$13, _tuple$14, names, err$4, _tuple$15, _ref, _i, _slice, _index, name, _tuple$16, d$2, _tuple$17, pd, _tuple$18, _tuple$19;
		pwd = "";
		err = null;
		_tuple = syscall.Getwd(), s = _tuple[0], e = _tuple[1];
		if (useSyscallwd(e)) {
			_tuple$1 = [s, NewSyscallError("getwd", e)], pwd = _tuple$1[0], err = _tuple$1[1];
			return [pwd, err];
		}
		_tuple$2 = Stat("."), dot = _tuple$2[0], err = _tuple$2[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$3 = ["", err], pwd = _tuple$3[0], err = _tuple$3[1];
			return [pwd, err];
		}
		pwd = Getenv("PWD");
		if (pwd.length > 0 && (pwd.charCodeAt(0) === 47)) {
			_tuple$4 = Stat(pwd), d = _tuple$4[0], err$1 = _tuple$4[1];
			if (go$interfaceIsEqual(err$1, null) && SameFile(dot, d)) {
				_tuple$5 = [pwd, null], pwd = _tuple$5[0], err = _tuple$5[1];
				return [pwd, err];
			}
		}
		getwdCache.Mutex.Lock();
		pwd = getwdCache.dir;
		getwdCache.Mutex.Unlock();
		if (pwd.length > 0) {
			_tuple$6 = Stat(pwd), d$1 = _tuple$6[0], err$2 = _tuple$6[1];
			if (go$interfaceIsEqual(err$2, null) && SameFile(dot, d$1)) {
				_tuple$7 = [pwd, null], pwd = _tuple$7[0], err = _tuple$7[1];
				return [pwd, err];
			}
		}
		_tuple$8 = Stat("/"), root = _tuple$8[0], err = _tuple$8[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$9 = ["", err], pwd = _tuple$9[0], err = _tuple$9[1];
			return [pwd, err];
		}
		if (SameFile(root, dot)) {
			_tuple$10 = ["/", null], pwd = _tuple$10[0], err = _tuple$10[1];
			return [pwd, err];
		}
		pwd = "";
		parent = "..";
		while (true) {
			if (parent.length >= 1024) {
				_tuple$11 = ["", new syscall.Errno(536870975)], pwd = _tuple$11[0], err = _tuple$11[1];
				return [pwd, err];
			}
			_tuple$12 = Open(parent), fd = _tuple$12[0], err$3 = _tuple$12[1];
			if (!(go$interfaceIsEqual(err$3, null))) {
				_tuple$13 = ["", err$3], pwd = _tuple$13[0], err = _tuple$13[1];
				return [pwd, err];
			}
			while (true) {
				_tuple$14 = fd.Readdirnames(100), names = _tuple$14[0], err$4 = _tuple$14[1];
				if (!(go$interfaceIsEqual(err$4, null))) {
					fd.Close();
					_tuple$15 = ["", err$4], pwd = _tuple$15[0], err = _tuple$15[1];
					return [pwd, err];
				}
				_ref = names;
				_i = 0;
				while (_i < _ref.length) {
					name = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
					_tuple$16 = Lstat(parent + "/" + name), d$2 = _tuple$16[0];
					if (SameFile(d$2, dot)) {
						pwd = "/" + name + pwd;
						go$notSupported("goto");
					}
					_i++;
				}
			}
			Found: _tuple$17 = fd.Stat(), pd = _tuple$17[0], err$3 = _tuple$17[1];
			if (!(go$interfaceIsEqual(err$3, null))) {
				_tuple$18 = ["", err$3], pwd = _tuple$18[0], err = _tuple$18[1];
				return [pwd, err];
			}
			fd.Close();
			if (SameFile(pd, root)) {
				break;
			}
			dot = pd;
			parent = "../" + parent;
		}
		getwdCache.Mutex.Lock();
		getwdCache.dir = pwd;
		getwdCache.Mutex.Unlock();
		_tuple$19 = [pwd, null], pwd = _tuple$19[0], err = _tuple$19[1];
		return [pwd, err];
	};
	var MkdirAll = go$pkg.MkdirAll = function(path, perm) {
		var _tuple, dir, err, i, j, _tuple$1, dir$1, err1;
		_tuple = Stat(path), dir = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			if (dir.IsDir()) {
				return null;
			}
			return new PathError.Ptr("mkdir", path, new syscall.Errno(3));
		}
		i = path.length;
		while (i > 0 && IsPathSeparator(path.charCodeAt((i - 1 >> 0)))) {
			i = i - 1 >> 0;
		}
		j = i;
		while (j > 0 && !IsPathSeparator(path.charCodeAt((j - 1 >> 0)))) {
			j = j - 1 >> 0;
		}
		if (j > 1) {
			err = MkdirAll(path.substring(0, (j - 1 >> 0)), perm);
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
		}
		err = Mkdir(path, perm);
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = Lstat(path), dir$1 = _tuple$1[0], err1 = _tuple$1[1];
			if (go$interfaceIsEqual(err1, null) && dir$1.IsDir()) {
				return null;
			}
			return err;
		}
		return null;
	};
	var RemoveAll = go$pkg.RemoveAll = function(path) {
		var err, _tuple, dir, serr, ok, serr$1, _tuple$1, _tuple$2, fd, _tuple$3, names, err1, _ref, _i, _slice, _index, name, err1$1, err1$2;
		err = Remove(path);
		if (go$interfaceIsEqual(err, null)) {
			return null;
		}
		_tuple = Lstat(path), dir = _tuple[0], serr = _tuple[1];
		if (!(go$interfaceIsEqual(serr, null))) {
			if (_tuple$1 = (serr !== null && serr.constructor === (go$ptrType(PathError)) ? [serr.go$val, true] : [(go$ptrType(PathError)).nil, false]), serr$1 = _tuple$1[0], ok = _tuple$1[1], ok && (IsNotExist(serr$1.Err) || go$interfaceIsEqual(serr$1.Err, new syscall.Errno(3)))) {
				return null;
			}
			return serr;
		}
		if (!dir.IsDir()) {
			return err;
		}
		_tuple$2 = Open(path), fd = _tuple$2[0], err = _tuple$2[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		err = null;
		while (true) {
			_tuple$3 = fd.Readdirnames(100), names = _tuple$3[0], err1 = _tuple$3[1];
			_ref = names;
			_i = 0;
			while (_i < _ref.length) {
				name = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				err1$1 = RemoveAll(path + "\\" + name);
				if (go$interfaceIsEqual(err, null)) {
					err = err1$1;
				}
				_i++;
			}
			if (go$interfaceIsEqual(err1, io.EOF)) {
				break;
			}
			if (go$interfaceIsEqual(err, null)) {
				err = err1;
			}
			if (names.length === 0) {
				break;
			}
		}
		fd.Close();
		err1$2 = Remove(path);
		if (go$interfaceIsEqual(err, null)) {
			err = err1$2;
		}
		return err;
	};
	var IsPathSeparator = go$pkg.IsPathSeparator = function(c) {
		return (c === 92) || (c === 47);
	};
	var Getuid = go$pkg.Getuid = function() {
		return syscall.Getuid();
	};
	var Geteuid = go$pkg.Geteuid = function() {
		return syscall.Geteuid();
	};
	var Getgid = go$pkg.Getgid = function() {
		return syscall.Getgid();
	};
	var Getegid = go$pkg.Getegid = function() {
		return syscall.Getegid();
	};
	var Getgroups = go$pkg.Getgroups = function() {
		var _tuple, gids, e;
		_tuple = syscall.Getgroups(), gids = _tuple[0], e = _tuple[1];
		return [gids, NewSyscallError("getgroups", e)];
	};
	var Exit = go$pkg.Exit = function(code) {
		syscall.Exit(code);
	};
	File.Ptr.prototype.Stat = function() {
		var fi, err, file$1, _tuple, _tuple$1, _tuple$2, _tuple$3, d, e, _tuple$4, _struct, _struct$1, _struct$2, _tuple$5;
		fi = null;
		err = null;
		file$1 = this;
		if (file$1 === (go$ptrType(File)).nil) {
			_tuple = [null, go$pkg.ErrInvalid], fi = _tuple[0], err = _tuple[1];
			return [fi, err];
		}
		if (file$1 === (go$ptrType(File)).nil || file$1.file.fd < 0) {
			_tuple$1 = [null, new syscall.Errno(536870951)], fi = _tuple$1[0], err = _tuple$1[1];
			return [fi, err];
		}
		if (file$1.file.isdir()) {
			_tuple$2 = Stat(file$1.file.name), fi = _tuple$2[0], err = _tuple$2[1];
			return [fi, err];
		}
		if (file$1.file.name === "NUL") {
			_tuple$3 = [devNullStat, null], fi = _tuple$3[0], err = _tuple$3[1];
			return [fi, err];
		}
		d = new syscall.ByHandleFileInformation.Ptr();
		e = syscall.GetFileInformationByHandle(file$1.file.fd, d);
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$4 = [null, new PathError.Ptr("GetFileInformationByHandle", file$1.file.name, e)], fi = _tuple$4[0], err = _tuple$4[1];
			return [fi, err];
		}
		_tuple$5 = [new fileStat.Ptr(basename(file$1.file.name), new syscall.Win32FileAttributeData.Ptr(d.FileAttributes, (_struct = d.CreationTime, new syscall.Filetime.Ptr(_struct.LowDateTime, _struct.HighDateTime)), (_struct$1 = d.LastAccessTime, new syscall.Filetime.Ptr(_struct$1.LowDateTime, _struct$1.HighDateTime)), (_struct$2 = d.LastWriteTime, new syscall.Filetime.Ptr(_struct$2.LowDateTime, _struct$2.HighDateTime)), d.FileSizeHigh, d.FileSizeLow), new sync.Mutex.Ptr(), "", d.VolumeSerialNumber, d.FileIndexHigh, d.FileIndexLow), null], fi = _tuple$5[0], err = _tuple$5[1];
		return [fi, err];
	};
	File.prototype.Stat = function() { return this.go$val.Stat(); };
	var Stat = go$pkg.Stat = function(name) {
		var fi, err, _tuple, _tuple$1, fs, _tuple$2, namep, e, _tuple$3, _tuple$4, _tuple$5, cwd, _tuple$6;
		fi = null;
		err = null;
		if (name.length === 0) {
			_tuple = [null, new PathError.Ptr("Stat", name, new syscall.Errno(3))], fi = _tuple[0], err = _tuple[1];
			return [fi, err];
		}
		if (name === "NUL") {
			_tuple$1 = [devNullStat, null], fi = _tuple$1[0], err = _tuple$1[1];
			return [fi, err];
		}
		fs = new fileStat.Ptr(basename(name), new syscall.Win32FileAttributeData.Ptr(), new sync.Mutex.Ptr(), "", 0, 0, 0);
		_tuple$2 = syscall.UTF16PtrFromString(name), namep = _tuple$2[0], e = _tuple$2[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$3 = [null, new PathError.Ptr("Stat", name, e)], fi = _tuple$3[0], err = _tuple$3[1];
			return [fi, err];
		}
		e = syscall.GetFileAttributesEx(namep, 0, fs.sys);
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$4 = [null, new PathError.Ptr("GetFileAttributesEx", name, e)], fi = _tuple$4[0], err = _tuple$4[1];
			return [fi, err];
		}
		fs.path = name;
		if (!isAbs(fs.path)) {
			_tuple$5 = Getwd(), cwd = _tuple$5[0];
			fs.path = cwd + "\\" + fs.path;
		}
		_tuple$6 = [fs, null], fi = _tuple$6[0], err = _tuple$6[1];
		return [fi, err];
	};
	var Lstat = go$pkg.Lstat = function(name) {
		var fi, err, _tuple;
		fi = null;
		err = null;
		_tuple = Stat(name), fi = _tuple[0], err = _tuple[1];
		return [fi, err];
	};
	var basename = function(name) {
		var i;
		if ((name.length === 2) && (name.charCodeAt(1) === 58)) {
			name = ".";
		} else if (name.length > 2 && (name.charCodeAt(1) === 58)) {
			name = name.substring(2);
		}
		i = name.length - 1 >> 0;
		while (i > 0 && ((name.charCodeAt(i) === 47) || (name.charCodeAt(i) === 92))) {
			name = name.substring(0, i);
			i = i - 1 >> 0;
		}
		i = i - 1 >> 0;
		while (i >= 0) {
			if ((name.charCodeAt(i) === 47) || (name.charCodeAt(i) === 92)) {
				name = name.substring((i + 1 >> 0));
				break;
			}
			i = i - 1 >> 0;
		}
		return name;
	};
	var isSlash = function(c) {
		return (c === 92) || (c === 47);
	};
	var isAbs = function(path) {
		var b, v;
		b = false;
		v = volumeName(path);
		if (v === "") {
			b = false;
			return b;
		}
		path = path.substring(v.length);
		if (path === "") {
			b = false;
			return b;
		}
		b = isSlash(path.charCodeAt(0));
		return b;
	};
	var volumeName = function(path) {
		var v, c, l, n;
		v = "";
		if (path.length < 2) {
			v = "";
			return v;
		}
		c = path.charCodeAt(0);
		if ((path.charCodeAt(1) === 58) && (48 <= c && c <= 57 || 97 <= c && c <= 122 || 65 <= c && c <= 90)) {
			v = path.substring(0, 2);
			return v;
		}
		if (l = path.length, l >= 5 && isSlash(path.charCodeAt(0)) && isSlash(path.charCodeAt(1)) && !isSlash(path.charCodeAt(2)) && !((path.charCodeAt(2) === 46))) {
			n = 3;
			while (n < (l - 1 >> 0)) {
				if (isSlash(path.charCodeAt(n))) {
					n = n + 1 >> 0;
					if (!isSlash(path.charCodeAt(n))) {
						if (path.charCodeAt(n) === 46) {
							break;
						}
						while (n < l) {
							if (isSlash(path.charCodeAt(n))) {
								break;
							}
							n = n + 1 >> 0;
						}
						v = path.substring(0, n);
						return v;
					}
					break;
				}
				n = n + 1 >> 0;
			}
		}
		v = "";
		return v;
	};
	var hostname = function() {
		var name, err, _tuple, s, e, _tuple$1, _tuple$2;
		name = "";
		err = null;
		_tuple = syscall.ComputerName(), s = _tuple[0], e = _tuple[1];
		if (!(go$interfaceIsEqual(e, null))) {
			_tuple$1 = ["", NewSyscallError("ComputerName", e)], name = _tuple$1[0], err = _tuple$1[1];
			return [name, err];
		}
		_tuple$2 = [s, null], name = _tuple$2[0], err = _tuple$2[1];
		return [name, err];
	};
	var Getpagesize = go$pkg.Getpagesize = function() {
		return syscall.Getpagesize();
	};
	FileMode.prototype.String = function() {
		var m, buf, w, _ref, _i, _rune, c, i, y, _ref$1, _i$1, _rune$1, c$1, i$1, y$1;
		m = this.go$val;
		buf = go$makeNativeArray("Uint8", 32, function() { return 0; });
		w = 0;
		_ref = "dalTLDpSugct";
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			c = _rune[0];
			i = _i;
			if (!((((m & (((y = ((31 - i >> 0) >>> 0), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0) === 0))) {
				buf[w] = (c << 24 >>> 24);
				w = w + 1 >> 0;
			}
			_i += _rune[1];
		}
		if (w === 0) {
			buf[w] = 45;
			w = w + 1 >> 0;
		}
		_ref$1 = "rwxrwxrwx";
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			_rune$1 = go$decodeRune(_ref$1, _i$1);
			c$1 = _rune$1[0];
			i$1 = _i$1;
			if (!((((m & (((y$1 = ((8 - i$1 >> 0) >>> 0), y$1 < 32 ? (1 << y$1) : 0) >>> 0))) >>> 0) === 0))) {
				buf[w] = (c$1 << 24 >>> 24);
			} else {
				buf[w] = 45;
			}
			w = w + 1 >> 0;
			_i$1 += _rune$1[1];
		}
		return go$bytesToString(go$subslice(new (go$sliceType(Go$Uint8))(buf), 0, w));
	};
	go$ptrType(FileMode).prototype.String = function() { return new FileMode(this.go$get()).String(); };
	FileMode.prototype.IsDir = function() {
		var m;
		m = this.go$val;
		return !((((m & 2147483648) >>> 0) === 0));
	};
	go$ptrType(FileMode).prototype.IsDir = function() { return new FileMode(this.go$get()).IsDir(); };
	FileMode.prototype.IsRegular = function() {
		var m;
		m = this.go$val;
		return ((m & 2399141888) >>> 0) === 0;
	};
	go$ptrType(FileMode).prototype.IsRegular = function() { return new FileMode(this.go$get()).IsRegular(); };
	FileMode.prototype.Perm = function() {
		var m;
		m = this.go$val;
		return (m & 511) >>> 0;
	};
	go$ptrType(FileMode).prototype.Perm = function() { return new FileMode(this.go$get()).Perm(); };
	fileStat.Ptr.prototype.Name = function() {
		var fs;
		fs = this;
		return fs.name;
	};
	fileStat.prototype.Name = function() { return this.go$val.Name(); };
	fileStat.Ptr.prototype.IsDir = function() {
		var fs;
		fs = this;
		return (new FileMode(fs.Mode())).IsDir();
	};
	fileStat.prototype.IsDir = function() { return this.go$val.IsDir(); };
	var SameFile = go$pkg.SameFile = function(fi1, fi2) {
		var _tuple, fs1, ok1, _tuple$1, fs2, ok2;
		_tuple = (fi1 !== null && fi1.constructor === (go$ptrType(fileStat)) ? [fi1.go$val, true] : [(go$ptrType(fileStat)).nil, false]), fs1 = _tuple[0], ok1 = _tuple[1];
		_tuple$1 = (fi2 !== null && fi2.constructor === (go$ptrType(fileStat)) ? [fi2.go$val, true] : [(go$ptrType(fileStat)).nil, false]), fs2 = _tuple$1[0], ok2 = _tuple$1[1];
		if (!ok1 || !ok2) {
			return false;
		}
		return sameFile(fs1, fs2);
	};
	fileStat.Ptr.prototype.Size = function() {
		var fs, x, x$1;
		fs = this;
		return (x = go$shiftLeft64(new Go$Int64(0, fs.sys.FileSizeHigh), 32), x$1 = new Go$Int64(0, fs.sys.FileSizeLow), new Go$Int64(x.high + x$1.high, x.low + x$1.low));
	};
	fileStat.prototype.Size = function() { return this.go$val.Size(); };
	fileStat.Ptr.prototype.Mode = function() {
		var m, fs;
		m = 0;
		fs = this;
		if (fs === devNullStat) {
			m = 69206454;
			return m;
		}
		if (!((((fs.sys.FileAttributes & 16) >>> 0) === 0))) {
			m = (m | 2147483721) >>> 0;
		}
		if (!((((fs.sys.FileAttributes & 1) >>> 0) === 0))) {
			m = (m | 292) >>> 0;
		} else {
			m = (m | 438) >>> 0;
		}
		m = m;
		return m;
	};
	fileStat.prototype.Mode = function() { return this.go$val.Mode(); };
	fileStat.Ptr.prototype.ModTime = function() {
		var fs, _struct;
		fs = this;
		return (_struct = time.Unix(new Go$Int64(0, 0), fs.sys.LastWriteTime.Nanoseconds()), new time.Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
	};
	fileStat.prototype.ModTime = function() { return this.go$val.ModTime(); };
	fileStat.Ptr.prototype.Sys = function() {
		var fs;
		fs = this;
		return fs.sys;
	};
	fileStat.prototype.Sys = function() { return this.go$val.Sys(); };
	fileStat.Ptr.prototype.loadFileId = function() {
		var fs, _tuple, pathp, err, _tuple$1, h, i;
		var go$deferred = [];
		try {
			fs = this;
			fs.Mutex.Lock();
			go$deferred.push({ recv: fs, method: "Unlock", args: [] });
			if (fs.path === "") {
				return null;
			}
			_tuple = syscall.UTF16PtrFromString(fs.path), pathp = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			_tuple$1 = syscall.CreateFile(pathp, 0, 0, (go$ptrType(syscall.SecurityAttributes)).nil, 3, 33554432, 0), h = _tuple$1[0], err = _tuple$1[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			go$deferred.push({ recv: syscall, method: "CloseHandle", args: [h] });
			i = new syscall.ByHandleFileInformation.Ptr();
			err = syscall.GetFileInformationByHandle(h, i);
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			fs.path = "";
			fs.vol = i.VolumeSerialNumber;
			fs.idxhi = i.FileIndexHigh;
			fs.idxlo = i.FileIndexLow;
			return null;
		} catch(go$err) {
			go$pushErr(go$err);
			return null;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	fileStat.prototype.loadFileId = function() { return this.go$val.loadFileId(); };
	var sameFile = function(fs1, fs2) {
		var e;
		e = fs1.loadFileId();
		if (!(go$interfaceIsEqual(e, null))) {
			return false;
		}
		e = fs2.loadFileId();
		if (!(go$interfaceIsEqual(e, null))) {
			return false;
		}
		return (fs1.vol === fs2.vol) && (fs1.idxhi === fs2.idxhi) && (fs1.idxlo === fs2.idxlo);
	};
	var atime = function(fi) {
		var x, _struct;
		return (_struct = time.Unix(new Go$Int64(0, 0), (x = fi.Sys(), (x !== null && x.constructor === (go$ptrType(syscall.Win32FileAttributeData)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(syscall.Win32FileAttributeData))))).LastAccessTime.Nanoseconds()), new time.Time.Ptr(_struct.sec, _struct.nsec, _struct.loc));
	};
	go$pkg.init = function() {
		getwdCache = new (go$structType([["", "", sync.Mutex, ""], ["dir", "os", Go$String, ""]])).Ptr(new sync.Mutex.Ptr(), "");
		go$pkg.Args = (go$sliceType(Go$String)).nil;

			go$pkg.Args = new (go$sliceType(Go$String))((typeof process !== 'undefined') ? process.argv.slice(1) : []);
			if (go$packages["syscall"].Syscall15 !== undefined) { // windows
				NewFile = go$pkg.NewFile = function() { return new File.Ptr(); };
			}
				var argc, cmd, _tuple, v, argv, e, _ref, _i, _slice, _index, v$1, i, _slice$1, _index$1;
		var go$deferred = [];
		try {
			go$pkg.ErrInvalid = errors.New("invalid argument");
			go$pkg.ErrPermission = errors.New("permission denied");
			go$pkg.ErrExist = errors.New("file already exists");
			go$pkg.ErrNotExist = errors.New("file does not exist");
			go$pkg.Interrupt = new syscall.Signal(2);
			go$pkg.Kill = new syscall.Signal(9);
			go$pkg.Stdin = NewFile((syscall.Stdin >>> 0), "/dev/stdin");
			go$pkg.Stdout = NewFile((syscall.Stdout >>> 0), "/dev/stdout");
			go$pkg.Stderr = NewFile((syscall.Stderr >>> 0), "/dev/stderr");
			useSyscallwd = (function() {
				return true;
			});
			devNullStat = new fileStat.Ptr("NUL", new syscall.Win32FileAttributeData.Ptr(), new sync.Mutex.Ptr(), "", 0, 0, 0);
			lstat = Lstat;
			argc = 0;
			cmd = syscall.GetCommandLine();
			_tuple = syscall.CommandLineToArgv(cmd, new (go$ptrType(Go$Int32))(function() { return argc; }, function(v) { argc = v; })), argv = _tuple[0], e = _tuple[1];
			if (!(go$interfaceIsEqual(e, null))) {
				return;
			}
			go$deferred.push({ recv: syscall, method: "LocalFree", args: [(argv >>> 0)] });
			go$pkg.Args = (go$sliceType(Go$String)).make(argc, 0, function() { return ""; });
			_ref = go$subslice(new (go$sliceType((go$ptrType((go$arrayType(Go$Uint16, 8192))))))((argv)), 0, argc);
			_i = 0;
			while (_i < _ref.length) {
				v$1 = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				_slice$1 = go$pkg.Args, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = syscall.UTF16ToString(new (go$sliceType(Go$Uint16))((v$1)))) : go$throwRuntimeError("index out of range");
				_i++;
			}
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	return go$pkg;
})();
go$packages["reflect"] = (function() {
	var go$pkg = {};
	var strconv = go$packages["strconv"];
	var sync = go$packages["sync"];
	var math = go$packages["math"];
	var runtime = go$packages["runtime"];
	var visit;
	visit = go$newType(0, "Struct", "reflect.visit", "visit", "reflect", function(a1_, a2_, typ_) {
		this.go$val = this;
		this.a1 = a1_ !== undefined ? a1_ : 0;
		this.a2 = a2_ !== undefined ? a2_ : 0;
		this.typ = typ_ !== undefined ? typ_ : null;
	});
	go$pkg.visit = visit;
	var makeFuncImpl;
	makeFuncImpl = go$newType(0, "Struct", "reflect.makeFuncImpl", "makeFuncImpl", "reflect", function(code_, typ_, fn_) {
		this.go$val = this;
		this.code = code_ !== undefined ? code_ : 0;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(funcType)).nil;
		this.fn = fn_ !== undefined ? fn_ : go$throwNilPointerError;
	});
	go$pkg.makeFuncImpl = makeFuncImpl;
	var methodValue;
	methodValue = go$newType(0, "Struct", "reflect.methodValue", "methodValue", "reflect", function(fn_, method_, rcvr_) {
		this.go$val = this;
		this.fn = fn_ !== undefined ? fn_ : 0;
		this.method = method_ !== undefined ? method_ : 0;
		this.rcvr = rcvr_ !== undefined ? rcvr_ : new Value.Ptr();
	});
	go$pkg.methodValue = methodValue;
	var Type;
	Type = go$newType(0, "Interface", "reflect.Type", "Type", "reflect", null);
	go$pkg.Type = Type;
	var Kind;
	Kind = go$newType(4, "Uint", "reflect.Kind", "Kind", "reflect", null);
	go$pkg.Kind = Kind;
	var rtype;
	rtype = go$newType(0, "Struct", "reflect.rtype", "rtype", "reflect", function(size_, hash_, _$2_, align_, fieldAlign_, kind_, alg_, gc_, string_, uncommonType_, ptrToThis_) {
		this.go$val = this;
		this.size = size_ !== undefined ? size_ : 0;
		this.hash = hash_ !== undefined ? hash_ : 0;
		this._$2 = _$2_ !== undefined ? _$2_ : 0;
		this.align = align_ !== undefined ? align_ : 0;
		this.fieldAlign = fieldAlign_ !== undefined ? fieldAlign_ : 0;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.alg = alg_ !== undefined ? alg_ : (go$ptrType(Go$Uintptr)).nil;
		this.gc = gc_ !== undefined ? gc_ : 0;
		this.string = string_ !== undefined ? string_ : (go$ptrType(Go$String)).nil;
		this.uncommonType = uncommonType_ !== undefined ? uncommonType_ : (go$ptrType(uncommonType)).nil;
		this.ptrToThis = ptrToThis_ !== undefined ? ptrToThis_ : (go$ptrType(rtype)).nil;
	});
	rtype.prototype.Method = function(i) { return this.go$val.Method(i); };
	rtype.Ptr.prototype.Method = function(i) { return this.uncommonType.Method(i); };
	rtype.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	rtype.Ptr.prototype.MethodByName = function(name) { return this.uncommonType.MethodByName(name); };
	rtype.prototype.Name = function() { return this.go$val.Name(); };
	rtype.Ptr.prototype.Name = function() { return this.uncommonType.Name(); };
	rtype.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	rtype.Ptr.prototype.NumMethod = function() { return this.uncommonType.NumMethod(); };
	rtype.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	rtype.Ptr.prototype.PkgPath = function() { return this.uncommonType.PkgPath(); };
	rtype.prototype.uncommon = function() { return this.go$val.uncommon(); };
	rtype.Ptr.prototype.uncommon = function() { return this.uncommonType.uncommon(); };
	go$pkg.rtype = rtype;
	var method;
	method = go$newType(0, "Struct", "reflect.method", "method", "reflect", function(name_, pkgPath_, mtyp_, typ_, ifn_, tfn_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.mtyp = mtyp_ !== undefined ? mtyp_ : (go$ptrType(rtype)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.ifn = ifn_ !== undefined ? ifn_ : 0;
		this.tfn = tfn_ !== undefined ? tfn_ : 0;
	});
	go$pkg.method = method;
	var uncommonType;
	uncommonType = go$newType(0, "Struct", "reflect.uncommonType", "uncommonType", "reflect", function(name_, pkgPath_, methods_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.methods = methods_ !== undefined ? methods_ : (go$sliceType(method)).nil;
	});
	go$pkg.uncommonType = uncommonType;
	var ChanDir;
	ChanDir = go$newType(4, "Int", "reflect.ChanDir", "ChanDir", "reflect", null);
	go$pkg.ChanDir = ChanDir;
	var arrayType;
	arrayType = go$newType(0, "Struct", "reflect.arrayType", "arrayType", "reflect", function(rtype_, elem_, slice_, len_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
		this.slice = slice_ !== undefined ? slice_ : (go$ptrType(rtype)).nil;
		this.len = len_ !== undefined ? len_ : 0;
	});
	arrayType.prototype.Align = function() { return this.go$val.Align(); };
	arrayType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	arrayType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	arrayType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	arrayType.prototype.Bits = function() { return this.go$val.Bits(); };
	arrayType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	arrayType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	arrayType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	arrayType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	arrayType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	arrayType.prototype.Elem = function() { return this.go$val.Elem(); };
	arrayType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	arrayType.prototype.Field = function(i) { return this.go$val.Field(i); };
	arrayType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	arrayType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	arrayType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	arrayType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	arrayType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	arrayType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	arrayType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	arrayType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	arrayType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	arrayType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	arrayType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	arrayType.prototype.In = function(i) { return this.go$val.In(i); };
	arrayType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	arrayType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	arrayType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	arrayType.prototype.Key = function() { return this.go$val.Key(); };
	arrayType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	arrayType.prototype.Kind = function() { return this.go$val.Kind(); };
	arrayType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	arrayType.prototype.Len = function() { return this.go$val.Len(); };
	arrayType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	arrayType.prototype.Method = function(i) { return this.go$val.Method(i); };
	arrayType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	arrayType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	arrayType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	arrayType.prototype.Name = function() { return this.go$val.Name(); };
	arrayType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	arrayType.prototype.NumField = function() { return this.go$val.NumField(); };
	arrayType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	arrayType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	arrayType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	arrayType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	arrayType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	arrayType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	arrayType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	arrayType.prototype.Out = function(i) { return this.go$val.Out(i); };
	arrayType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	arrayType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	arrayType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	arrayType.prototype.Size = function() { return this.go$val.Size(); };
	arrayType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	arrayType.prototype.String = function() { return this.go$val.String(); };
	arrayType.Ptr.prototype.String = function() { return this.rtype.String(); };
	arrayType.prototype.common = function() { return this.go$val.common(); };
	arrayType.Ptr.prototype.common = function() { return this.rtype.common(); };
	arrayType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	arrayType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	arrayType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	arrayType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.arrayType = arrayType;
	var chanType;
	chanType = go$newType(0, "Struct", "reflect.chanType", "chanType", "reflect", function(rtype_, elem_, dir_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
		this.dir = dir_ !== undefined ? dir_ : 0;
	});
	chanType.prototype.Align = function() { return this.go$val.Align(); };
	chanType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	chanType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	chanType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	chanType.prototype.Bits = function() { return this.go$val.Bits(); };
	chanType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	chanType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	chanType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	chanType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	chanType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	chanType.prototype.Elem = function() { return this.go$val.Elem(); };
	chanType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	chanType.prototype.Field = function(i) { return this.go$val.Field(i); };
	chanType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	chanType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	chanType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	chanType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	chanType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	chanType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	chanType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	chanType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	chanType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	chanType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	chanType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	chanType.prototype.In = function(i) { return this.go$val.In(i); };
	chanType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	chanType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	chanType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	chanType.prototype.Key = function() { return this.go$val.Key(); };
	chanType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	chanType.prototype.Kind = function() { return this.go$val.Kind(); };
	chanType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	chanType.prototype.Len = function() { return this.go$val.Len(); };
	chanType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	chanType.prototype.Method = function(i) { return this.go$val.Method(i); };
	chanType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	chanType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	chanType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	chanType.prototype.Name = function() { return this.go$val.Name(); };
	chanType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	chanType.prototype.NumField = function() { return this.go$val.NumField(); };
	chanType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	chanType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	chanType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	chanType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	chanType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	chanType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	chanType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	chanType.prototype.Out = function(i) { return this.go$val.Out(i); };
	chanType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	chanType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	chanType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	chanType.prototype.Size = function() { return this.go$val.Size(); };
	chanType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	chanType.prototype.String = function() { return this.go$val.String(); };
	chanType.Ptr.prototype.String = function() { return this.rtype.String(); };
	chanType.prototype.common = function() { return this.go$val.common(); };
	chanType.Ptr.prototype.common = function() { return this.rtype.common(); };
	chanType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	chanType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	chanType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	chanType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.chanType = chanType;
	var funcType;
	funcType = go$newType(0, "Struct", "reflect.funcType", "funcType", "reflect", function(rtype_, dotdotdot_, in$2_, out_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.dotdotdot = dotdotdot_ !== undefined ? dotdotdot_ : false;
		this.in$2 = in$2_ !== undefined ? in$2_ : (go$sliceType((go$ptrType(rtype)))).nil;
		this.out = out_ !== undefined ? out_ : (go$sliceType((go$ptrType(rtype)))).nil;
	});
	funcType.prototype.Align = function() { return this.go$val.Align(); };
	funcType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	funcType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	funcType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	funcType.prototype.Bits = function() { return this.go$val.Bits(); };
	funcType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	funcType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	funcType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	funcType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	funcType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	funcType.prototype.Elem = function() { return this.go$val.Elem(); };
	funcType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	funcType.prototype.Field = function(i) { return this.go$val.Field(i); };
	funcType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	funcType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	funcType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	funcType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	funcType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	funcType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	funcType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	funcType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	funcType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	funcType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	funcType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	funcType.prototype.In = function(i) { return this.go$val.In(i); };
	funcType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	funcType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	funcType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	funcType.prototype.Key = function() { return this.go$val.Key(); };
	funcType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	funcType.prototype.Kind = function() { return this.go$val.Kind(); };
	funcType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	funcType.prototype.Len = function() { return this.go$val.Len(); };
	funcType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	funcType.prototype.Method = function(i) { return this.go$val.Method(i); };
	funcType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	funcType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	funcType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	funcType.prototype.Name = function() { return this.go$val.Name(); };
	funcType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	funcType.prototype.NumField = function() { return this.go$val.NumField(); };
	funcType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	funcType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	funcType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	funcType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	funcType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	funcType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	funcType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	funcType.prototype.Out = function(i) { return this.go$val.Out(i); };
	funcType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	funcType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	funcType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	funcType.prototype.Size = function() { return this.go$val.Size(); };
	funcType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	funcType.prototype.String = function() { return this.go$val.String(); };
	funcType.Ptr.prototype.String = function() { return this.rtype.String(); };
	funcType.prototype.common = function() { return this.go$val.common(); };
	funcType.Ptr.prototype.common = function() { return this.rtype.common(); };
	funcType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	funcType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	funcType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	funcType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.funcType = funcType;
	var imethod;
	imethod = go$newType(0, "Struct", "reflect.imethod", "imethod", "reflect", function(name_, pkgPath_, typ_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
	});
	go$pkg.imethod = imethod;
	var interfaceType;
	interfaceType = go$newType(0, "Struct", "reflect.interfaceType", "interfaceType", "reflect", function(rtype_, methods_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.methods = methods_ !== undefined ? methods_ : (go$sliceType(imethod)).nil;
	});
	interfaceType.prototype.Align = function() { return this.go$val.Align(); };
	interfaceType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	interfaceType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	interfaceType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	interfaceType.prototype.Bits = function() { return this.go$val.Bits(); };
	interfaceType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	interfaceType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	interfaceType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	interfaceType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	interfaceType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	interfaceType.prototype.Elem = function() { return this.go$val.Elem(); };
	interfaceType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	interfaceType.prototype.Field = function(i) { return this.go$val.Field(i); };
	interfaceType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	interfaceType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	interfaceType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	interfaceType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	interfaceType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	interfaceType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	interfaceType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	interfaceType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	interfaceType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	interfaceType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	interfaceType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	interfaceType.prototype.In = function(i) { return this.go$val.In(i); };
	interfaceType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	interfaceType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	interfaceType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	interfaceType.prototype.Key = function() { return this.go$val.Key(); };
	interfaceType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	interfaceType.prototype.Kind = function() { return this.go$val.Kind(); };
	interfaceType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	interfaceType.prototype.Len = function() { return this.go$val.Len(); };
	interfaceType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	interfaceType.prototype.Method = function(i) { return this.go$val.Method(i); };
	interfaceType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	interfaceType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	interfaceType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	interfaceType.prototype.Name = function() { return this.go$val.Name(); };
	interfaceType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	interfaceType.prototype.NumField = function() { return this.go$val.NumField(); };
	interfaceType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	interfaceType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	interfaceType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	interfaceType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	interfaceType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	interfaceType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	interfaceType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	interfaceType.prototype.Out = function(i) { return this.go$val.Out(i); };
	interfaceType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	interfaceType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	interfaceType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	interfaceType.prototype.Size = function() { return this.go$val.Size(); };
	interfaceType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	interfaceType.prototype.String = function() { return this.go$val.String(); };
	interfaceType.Ptr.prototype.String = function() { return this.rtype.String(); };
	interfaceType.prototype.common = function() { return this.go$val.common(); };
	interfaceType.Ptr.prototype.common = function() { return this.rtype.common(); };
	interfaceType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	interfaceType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	interfaceType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	interfaceType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.interfaceType = interfaceType;
	var mapType;
	mapType = go$newType(0, "Struct", "reflect.mapType", "mapType", "reflect", function(rtype_, key_, elem_, bucket_, hmap_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.key = key_ !== undefined ? key_ : (go$ptrType(rtype)).nil;
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
		this.bucket = bucket_ !== undefined ? bucket_ : (go$ptrType(rtype)).nil;
		this.hmap = hmap_ !== undefined ? hmap_ : (go$ptrType(rtype)).nil;
	});
	mapType.prototype.Align = function() { return this.go$val.Align(); };
	mapType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	mapType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	mapType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	mapType.prototype.Bits = function() { return this.go$val.Bits(); };
	mapType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	mapType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	mapType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	mapType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	mapType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	mapType.prototype.Elem = function() { return this.go$val.Elem(); };
	mapType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	mapType.prototype.Field = function(i) { return this.go$val.Field(i); };
	mapType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	mapType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	mapType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	mapType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	mapType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	mapType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	mapType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	mapType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	mapType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	mapType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	mapType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	mapType.prototype.In = function(i) { return this.go$val.In(i); };
	mapType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	mapType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	mapType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	mapType.prototype.Key = function() { return this.go$val.Key(); };
	mapType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	mapType.prototype.Kind = function() { return this.go$val.Kind(); };
	mapType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	mapType.prototype.Len = function() { return this.go$val.Len(); };
	mapType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	mapType.prototype.Method = function(i) { return this.go$val.Method(i); };
	mapType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	mapType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	mapType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	mapType.prototype.Name = function() { return this.go$val.Name(); };
	mapType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	mapType.prototype.NumField = function() { return this.go$val.NumField(); };
	mapType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	mapType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	mapType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	mapType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	mapType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	mapType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	mapType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	mapType.prototype.Out = function(i) { return this.go$val.Out(i); };
	mapType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	mapType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	mapType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	mapType.prototype.Size = function() { return this.go$val.Size(); };
	mapType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	mapType.prototype.String = function() { return this.go$val.String(); };
	mapType.Ptr.prototype.String = function() { return this.rtype.String(); };
	mapType.prototype.common = function() { return this.go$val.common(); };
	mapType.Ptr.prototype.common = function() { return this.rtype.common(); };
	mapType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	mapType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	mapType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	mapType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.mapType = mapType;
	var ptrType;
	ptrType = go$newType(0, "Struct", "reflect.ptrType", "ptrType", "reflect", function(rtype_, elem_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
	});
	ptrType.prototype.Align = function() { return this.go$val.Align(); };
	ptrType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	ptrType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	ptrType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	ptrType.prototype.Bits = function() { return this.go$val.Bits(); };
	ptrType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	ptrType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	ptrType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	ptrType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	ptrType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	ptrType.prototype.Elem = function() { return this.go$val.Elem(); };
	ptrType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	ptrType.prototype.Field = function(i) { return this.go$val.Field(i); };
	ptrType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	ptrType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	ptrType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	ptrType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	ptrType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	ptrType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	ptrType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	ptrType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	ptrType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	ptrType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	ptrType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	ptrType.prototype.In = function(i) { return this.go$val.In(i); };
	ptrType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	ptrType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	ptrType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	ptrType.prototype.Key = function() { return this.go$val.Key(); };
	ptrType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	ptrType.prototype.Kind = function() { return this.go$val.Kind(); };
	ptrType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	ptrType.prototype.Len = function() { return this.go$val.Len(); };
	ptrType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	ptrType.prototype.Method = function(i) { return this.go$val.Method(i); };
	ptrType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	ptrType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	ptrType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	ptrType.prototype.Name = function() { return this.go$val.Name(); };
	ptrType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	ptrType.prototype.NumField = function() { return this.go$val.NumField(); };
	ptrType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	ptrType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	ptrType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	ptrType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	ptrType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	ptrType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	ptrType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	ptrType.prototype.Out = function(i) { return this.go$val.Out(i); };
	ptrType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	ptrType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	ptrType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	ptrType.prototype.Size = function() { return this.go$val.Size(); };
	ptrType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	ptrType.prototype.String = function() { return this.go$val.String(); };
	ptrType.Ptr.prototype.String = function() { return this.rtype.String(); };
	ptrType.prototype.common = function() { return this.go$val.common(); };
	ptrType.Ptr.prototype.common = function() { return this.rtype.common(); };
	ptrType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	ptrType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	ptrType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	ptrType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.ptrType = ptrType;
	var sliceType;
	sliceType = go$newType(0, "Struct", "reflect.sliceType", "sliceType", "reflect", function(rtype_, elem_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
	});
	sliceType.prototype.Align = function() { return this.go$val.Align(); };
	sliceType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	sliceType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	sliceType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	sliceType.prototype.Bits = function() { return this.go$val.Bits(); };
	sliceType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	sliceType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	sliceType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	sliceType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	sliceType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	sliceType.prototype.Elem = function() { return this.go$val.Elem(); };
	sliceType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	sliceType.prototype.Field = function(i) { return this.go$val.Field(i); };
	sliceType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	sliceType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	sliceType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	sliceType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	sliceType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	sliceType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	sliceType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	sliceType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	sliceType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	sliceType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	sliceType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	sliceType.prototype.In = function(i) { return this.go$val.In(i); };
	sliceType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	sliceType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	sliceType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	sliceType.prototype.Key = function() { return this.go$val.Key(); };
	sliceType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	sliceType.prototype.Kind = function() { return this.go$val.Kind(); };
	sliceType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	sliceType.prototype.Len = function() { return this.go$val.Len(); };
	sliceType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	sliceType.prototype.Method = function(i) { return this.go$val.Method(i); };
	sliceType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	sliceType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	sliceType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	sliceType.prototype.Name = function() { return this.go$val.Name(); };
	sliceType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	sliceType.prototype.NumField = function() { return this.go$val.NumField(); };
	sliceType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	sliceType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	sliceType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	sliceType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	sliceType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	sliceType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	sliceType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	sliceType.prototype.Out = function(i) { return this.go$val.Out(i); };
	sliceType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	sliceType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	sliceType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	sliceType.prototype.Size = function() { return this.go$val.Size(); };
	sliceType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	sliceType.prototype.String = function() { return this.go$val.String(); };
	sliceType.Ptr.prototype.String = function() { return this.rtype.String(); };
	sliceType.prototype.common = function() { return this.go$val.common(); };
	sliceType.Ptr.prototype.common = function() { return this.rtype.common(); };
	sliceType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	sliceType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	sliceType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	sliceType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.sliceType = sliceType;
	var structField;
	structField = go$newType(0, "Struct", "reflect.structField", "structField", "reflect", function(name_, pkgPath_, typ_, tag_, offset_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.tag = tag_ !== undefined ? tag_ : (go$ptrType(Go$String)).nil;
		this.offset = offset_ !== undefined ? offset_ : 0;
	});
	go$pkg.structField = structField;
	var structType;
	structType = go$newType(0, "Struct", "reflect.structType", "structType", "reflect", function(rtype_, fields_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.fields = fields_ !== undefined ? fields_ : (go$sliceType(structField)).nil;
	});
	structType.prototype.Align = function() { return this.go$val.Align(); };
	structType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	structType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	structType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	structType.prototype.Bits = function() { return this.go$val.Bits(); };
	structType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	structType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	structType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	structType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	structType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	structType.prototype.Elem = function() { return this.go$val.Elem(); };
	structType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	structType.prototype.Field = function(i) { return this.go$val.Field(i); };
	structType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	structType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	structType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	structType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	structType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	structType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	structType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	structType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	structType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	structType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	structType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	structType.prototype.In = function(i) { return this.go$val.In(i); };
	structType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	structType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	structType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	structType.prototype.Key = function() { return this.go$val.Key(); };
	structType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	structType.prototype.Kind = function() { return this.go$val.Kind(); };
	structType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	structType.prototype.Len = function() { return this.go$val.Len(); };
	structType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	structType.prototype.Method = function(i) { return this.go$val.Method(i); };
	structType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	structType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	structType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	structType.prototype.Name = function() { return this.go$val.Name(); };
	structType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	structType.prototype.NumField = function() { return this.go$val.NumField(); };
	structType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	structType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	structType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	structType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	structType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	structType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	structType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	structType.prototype.Out = function(i) { return this.go$val.Out(i); };
	structType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	structType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	structType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	structType.prototype.Size = function() { return this.go$val.Size(); };
	structType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	structType.prototype.String = function() { return this.go$val.String(); };
	structType.Ptr.prototype.String = function() { return this.rtype.String(); };
	structType.prototype.common = function() { return this.go$val.common(); };
	structType.Ptr.prototype.common = function() { return this.rtype.common(); };
	structType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	structType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	structType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	structType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
	go$pkg.structType = structType;
	var Method;
	Method = go$newType(0, "Struct", "reflect.Method", "Method", "reflect", function(Name_, PkgPath_, Type_, Func_, Index_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.PkgPath = PkgPath_ !== undefined ? PkgPath_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Func = Func_ !== undefined ? Func_ : new Value.Ptr();
		this.Index = Index_ !== undefined ? Index_ : 0;
	});
	go$pkg.Method = Method;
	var StructField;
	StructField = go$newType(0, "Struct", "reflect.StructField", "StructField", "reflect", function(Name_, PkgPath_, Type_, Tag_, Offset_, Index_, Anonymous_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.PkgPath = PkgPath_ !== undefined ? PkgPath_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Tag = Tag_ !== undefined ? Tag_ : "";
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.Index = Index_ !== undefined ? Index_ : (go$sliceType(Go$Int)).nil;
		this.Anonymous = Anonymous_ !== undefined ? Anonymous_ : false;
	});
	go$pkg.StructField = StructField;
	var StructTag;
	StructTag = go$newType(0, "String", "reflect.StructTag", "StructTag", "reflect", null);
	go$pkg.StructTag = StructTag;
	var fieldScan;
	fieldScan = go$newType(0, "Struct", "reflect.fieldScan", "fieldScan", "reflect", function(typ_, index_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(structType)).nil;
		this.index = index_ !== undefined ? index_ : (go$sliceType(Go$Int)).nil;
	});
	go$pkg.fieldScan = fieldScan;
	var ptrDataGC;
	ptrDataGC = go$newType(0, "Struct", "reflect.ptrDataGC", "ptrDataGC", "reflect", function(width_, op_, off_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
	go$pkg.ptrDataGC = ptrDataGC;
	var ptrGC;
	ptrGC = go$newType(0, "Struct", "reflect.ptrGC", "ptrGC", "reflect", function(width_, op_, off_, elemgc_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.elemgc = elemgc_ !== undefined ? elemgc_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
	go$pkg.ptrGC = ptrGC;
	var cacheKey;
	cacheKey = go$newType(0, "Struct", "reflect.cacheKey", "cacheKey", "reflect", function(kind_, t1_, t2_, extra_) {
		this.go$val = this;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.t1 = t1_ !== undefined ? t1_ : (go$ptrType(rtype)).nil;
		this.t2 = t2_ !== undefined ? t2_ : (go$ptrType(rtype)).nil;
		this.extra = extra_ !== undefined ? extra_ : 0;
	});
	go$pkg.cacheKey = cacheKey;
	var chanGC;
	chanGC = go$newType(0, "Struct", "reflect.chanGC", "chanGC", "reflect", function(width_, op_, off_, typ_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.end = end_ !== undefined ? end_ : 0;
	});
	go$pkg.chanGC = chanGC;
	var badGC;
	badGC = go$newType(0, "Struct", "reflect.badGC", "badGC", "reflect", function(width_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
	go$pkg.badGC = badGC;
	var sliceGC;
	sliceGC = go$newType(0, "Struct", "reflect.sliceGC", "sliceGC", "reflect", function(width_, op_, off_, elemgc_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.elemgc = elemgc_ !== undefined ? elemgc_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
	go$pkg.sliceGC = sliceGC;
	var sliceEmptyGC;
	sliceEmptyGC = go$newType(0, "Struct", "reflect.sliceEmptyGC", "sliceEmptyGC", "reflect", function(width_, op_, off_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
	go$pkg.sliceEmptyGC = sliceEmptyGC;
	var Value;
	Value = go$newType(0, "Struct", "reflect.Value", "Value", "reflect", function(typ_, val_, flag_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.val = val_ !== undefined ? val_ : 0;
		this.flag = flag_ !== undefined ? flag_ : 0;
	});
	Value.prototype.kind = function() { return this.go$val.kind(); };
	Value.Ptr.prototype.kind = function() { return new flag(this.flag).kind(); };
	Value.prototype.mustBe = function(expected) { return this.go$val.mustBe(expected); };
	Value.Ptr.prototype.mustBe = function(expected) { return new flag(this.flag).mustBe(expected); };
	Value.prototype.mustBeAssignable = function() { return this.go$val.mustBeAssignable(); };
	Value.Ptr.prototype.mustBeAssignable = function() { return new flag(this.flag).mustBeAssignable(); };
	Value.prototype.mustBeExported = function() { return this.go$val.mustBeExported(); };
	Value.Ptr.prototype.mustBeExported = function() { return new flag(this.flag).mustBeExported(); };
	go$pkg.Value = Value;
	var flag;
	flag = go$newType(4, "Uintptr", "reflect.flag", "flag", "reflect", null);
	go$pkg.flag = flag;
	var ValueError;
	ValueError = go$newType(0, "Struct", "reflect.ValueError", "ValueError", "reflect", function(Method_, Kind_) {
		this.go$val = this;
		this.Method = Method_ !== undefined ? Method_ : "";
		this.Kind = Kind_ !== undefined ? Kind_ : 0;
	});
	go$pkg.ValueError = ValueError;
	var iword;
	iword = go$newType(0, "UnsafePointer", "reflect.iword", "iword", "reflect", null);
	go$pkg.iword = iword;
	var emptyInterface;
	emptyInterface = go$newType(0, "Struct", "reflect.emptyInterface", "emptyInterface", "reflect", function(typ_, word_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.word = word_ !== undefined ? word_ : 0;
	});
	go$pkg.emptyInterface = emptyInterface;
	var nonEmptyInterface;
	nonEmptyInterface = go$newType(0, "Struct", "reflect.nonEmptyInterface", "nonEmptyInterface", "reflect", function(itab_, word_) {
		this.go$val = this;
		this.itab = itab_ !== undefined ? itab_ : (go$ptrType((go$structType([["ityp", "reflect", (go$ptrType(rtype)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["link", "reflect", Go$UnsafePointer, ""], ["bad", "reflect", Go$Int32, ""], ["unused", "reflect", Go$Int32, ""], ["fun", "reflect", (go$arrayType(Go$UnsafePointer, 100000)), ""]])))).nil;
		this.word = word_ !== undefined ? word_ : 0;
	});
	go$pkg.nonEmptyInterface = nonEmptyInterface;
	var StringHeader;
	StringHeader = go$newType(0, "Struct", "reflect.StringHeader", "StringHeader", "reflect", function(Data_, Len_) {
		this.go$val = this;
		this.Data = Data_ !== undefined ? Data_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
	});
	go$pkg.StringHeader = StringHeader;
	var SliceHeader;
	SliceHeader = go$newType(0, "Struct", "reflect.SliceHeader", "SliceHeader", "reflect", function(Data_, Len_, Cap_) {
		this.go$val = this;
		this.Data = Data_ !== undefined ? Data_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Cap = Cap_ !== undefined ? Cap_ : 0;
	});
	go$pkg.SliceHeader = SliceHeader;
	var runtimeSelect;
	runtimeSelect = go$newType(0, "Struct", "reflect.runtimeSelect", "runtimeSelect", "reflect", function(dir_, typ_, ch_, val_) {
		this.go$val = this;
		this.dir = dir_ !== undefined ? dir_ : 0;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.ch = ch_ !== undefined ? ch_ : 0;
		this.val = val_ !== undefined ? val_ : 0;
	});
	go$pkg.runtimeSelect = runtimeSelect;
	var SelectDir;
	SelectDir = go$newType(4, "Int", "reflect.SelectDir", "SelectDir", "reflect", null);
	go$pkg.SelectDir = SelectDir;
	var SelectCase;
	SelectCase = go$newType(0, "Struct", "reflect.SelectCase", "SelectCase", "reflect", function(Dir_, Chan_, Send_) {
		this.go$val = this;
		this.Dir = Dir_ !== undefined ? Dir_ : 0;
		this.Chan = Chan_ !== undefined ? Chan_ : new Value.Ptr();
		this.Send = Send_ !== undefined ? Send_ : new Value.Ptr();
	});
	go$pkg.SelectCase = SelectCase;
	visit.init([["a1", "reflect", Go$Uintptr, ""], ["a2", "reflect", Go$Uintptr, ""], ["typ", "reflect", Type, ""]]);
	makeFuncImpl.init([["code", "reflect", Go$Uintptr, ""], ["typ", "reflect", (go$ptrType(funcType)), ""], ["fn", "reflect", (go$funcType([(go$sliceType(Value))], [(go$sliceType(Value))], false)), ""]]);
	methodValue.init([["fn", "reflect", Go$Uintptr, ""], ["method", "reflect", Go$Int, ""], ["rcvr", "reflect", Value, ""]]);
	Type.init([["Align", "", (go$funcType([], [Go$Int], false))], ["AssignableTo", "", (go$funcType([Type], [Go$Bool], false))], ["Bits", "", (go$funcType([], [Go$Int], false))], ["ChanDir", "", (go$funcType([], [ChanDir], false))], ["ConvertibleTo", "", (go$funcType([Type], [Go$Bool], false))], ["Elem", "", (go$funcType([], [Type], false))], ["Field", "", (go$funcType([Go$Int], [StructField], false))], ["FieldAlign", "", (go$funcType([], [Go$Int], false))], ["FieldByIndex", "", (go$funcType([(go$sliceType(Go$Int))], [StructField], false))], ["FieldByName", "", (go$funcType([Go$String], [StructField, Go$Bool], false))], ["FieldByNameFunc", "", (go$funcType([(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false))], ["Implements", "", (go$funcType([Type], [Go$Bool], false))], ["In", "", (go$funcType([Go$Int], [Type], false))], ["IsVariadic", "", (go$funcType([], [Go$Bool], false))], ["Key", "", (go$funcType([], [Type], false))], ["Kind", "", (go$funcType([], [Kind], false))], ["Len", "", (go$funcType([], [Go$Int], false))], ["Method", "", (go$funcType([Go$Int], [Method], false))], ["MethodByName", "", (go$funcType([Go$String], [Method, Go$Bool], false))], ["Name", "", (go$funcType([], [Go$String], false))], ["NumField", "", (go$funcType([], [Go$Int], false))], ["NumIn", "", (go$funcType([], [Go$Int], false))], ["NumMethod", "", (go$funcType([], [Go$Int], false))], ["NumOut", "", (go$funcType([], [Go$Int], false))], ["Out", "", (go$funcType([Go$Int], [Type], false))], ["PkgPath", "", (go$funcType([], [Go$String], false))], ["Size", "", (go$funcType([], [Go$Uintptr], false))], ["String", "", (go$funcType([], [Go$String], false))], ["common", "reflect", (go$funcType([], [(go$ptrType(rtype))], false))], ["uncommon", "reflect", (go$funcType([], [(go$ptrType(uncommonType))], false))]]);
	Kind.methods = [["String", "", [], [Go$String], false]];
	(go$ptrType(Kind)).methods = [["String", "", [], [Go$String], false]];
	rtype.init([["size", "reflect", Go$Uintptr, ""], ["hash", "reflect", Go$Uint32, ""], ["_", "reflect", Go$Uint8, ""], ["align", "reflect", Go$Uint8, ""], ["fieldAlign", "reflect", Go$Uint8, ""], ["kind", "reflect", Go$Uint8, ""], ["alg", "reflect", (go$ptrType(Go$Uintptr)), ""], ["gc", "reflect", Go$UnsafePointer, ""], ["string", "reflect", (go$ptrType(Go$String)), ""], ["", "reflect", (go$ptrType(uncommonType)), ""], ["ptrToThis", "reflect", (go$ptrType(rtype)), ""]]);
	rtype.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(rtype)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	method.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["mtyp", "reflect", (go$ptrType(rtype)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["ifn", "reflect", Go$UnsafePointer, ""], ["tfn", "reflect", Go$UnsafePointer, ""]]);
	uncommonType.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["methods", "reflect", (go$sliceType(method)), ""]]);
	(go$ptrType(uncommonType)).methods = [["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumMethod", "", [], [Go$Int], false], ["PkgPath", "", [], [Go$String], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	ChanDir.methods = [["String", "", [], [Go$String], false]];
	(go$ptrType(ChanDir)).methods = [["String", "", [], [Go$String], false]];
	arrayType.init([["", "reflect", rtype, "reflect:\"array\""], ["elem", "reflect", (go$ptrType(rtype)), ""], ["slice", "reflect", (go$ptrType(rtype)), ""], ["len", "reflect", Go$Uintptr, ""]]);
	arrayType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(arrayType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	chanType.init([["", "reflect", rtype, "reflect:\"chan\""], ["elem", "reflect", (go$ptrType(rtype)), ""], ["dir", "reflect", Go$Uintptr, ""]]);
	chanType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(chanType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	funcType.init([["", "reflect", rtype, "reflect:\"func\""], ["dotdotdot", "reflect", Go$Bool, ""], ["in", "reflect", (go$sliceType((go$ptrType(rtype)))), ""], ["out", "reflect", (go$sliceType((go$ptrType(rtype)))), ""]]);
	funcType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(funcType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	imethod.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""]]);
	interfaceType.init([["", "reflect", rtype, "reflect:\"interface\""], ["methods", "reflect", (go$sliceType(imethod)), ""]]);
	interfaceType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(interfaceType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	mapType.init([["", "reflect", rtype, "reflect:\"map\""], ["key", "reflect", (go$ptrType(rtype)), ""], ["elem", "reflect", (go$ptrType(rtype)), ""], ["bucket", "reflect", (go$ptrType(rtype)), ""], ["hmap", "reflect", (go$ptrType(rtype)), ""]]);
	mapType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(mapType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	ptrType.init([["", "reflect", rtype, "reflect:\"ptr\""], ["elem", "reflect", (go$ptrType(rtype)), ""]]);
	ptrType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(ptrType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	sliceType.init([["", "reflect", rtype, "reflect:\"slice\""], ["elem", "reflect", (go$ptrType(rtype)), ""]]);
	sliceType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(sliceType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	structField.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["tag", "reflect", (go$ptrType(Go$String)), ""], ["offset", "reflect", Go$Uintptr, ""]]);
	structType.init([["", "reflect", rtype, "reflect:\"struct\""], ["fields", "reflect", (go$sliceType(structField)), ""]]);
	structType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	(go$ptrType(structType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
	Method.init([["Name", "", Go$String, ""], ["PkgPath", "", Go$String, ""], ["Type", "", Type, ""], ["Func", "", Value, ""], ["Index", "", Go$Int, ""]]);
	StructField.init([["Name", "", Go$String, ""], ["PkgPath", "", Go$String, ""], ["Type", "", Type, ""], ["Tag", "", StructTag, ""], ["Offset", "", Go$Uintptr, ""], ["Index", "", (go$sliceType(Go$Int)), ""], ["Anonymous", "", Go$Bool, ""]]);
	StructTag.methods = [["Get", "", [Go$String], [Go$String], false]];
	(go$ptrType(StructTag)).methods = [["Get", "", [Go$String], [Go$String], false]];
	fieldScan.init([["typ", "reflect", (go$ptrType(structType)), ""], ["index", "reflect", (go$sliceType(Go$Int)), ""]]);
	ptrDataGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["end", "reflect", Go$Uintptr, ""]]);
	ptrGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["elemgc", "reflect", Go$UnsafePointer, ""], ["end", "reflect", Go$Uintptr, ""]]);
	cacheKey.init([["kind", "reflect", Kind, ""], ["t1", "reflect", (go$ptrType(rtype)), ""], ["t2", "reflect", (go$ptrType(rtype)), ""], ["extra", "reflect", Go$Uintptr, ""]]);
	chanGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["end", "reflect", Go$Uintptr, ""]]);
	badGC.init([["width", "reflect", Go$Uintptr, ""], ["end", "reflect", Go$Uintptr, ""]]);
	sliceGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["elemgc", "reflect", Go$UnsafePointer, ""], ["end", "reflect", Go$Uintptr, ""]]);
	sliceEmptyGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["end", "reflect", Go$Uintptr, ""]]);
	Value.init([["typ", "reflect", (go$ptrType(rtype)), ""], ["val", "reflect", Go$UnsafePointer, ""], ["", "reflect", flag, ""]]);
	Value.methods = [["Addr", "", [], [Value], false], ["Bool", "", [], [Go$Bool], false], ["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Call", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CallSlice", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CanAddr", "", [], [Go$Bool], false], ["CanInterface", "", [], [Go$Bool], false], ["CanSet", "", [], [Go$Bool], false], ["Cap", "", [], [Go$Int], false], ["Close", "", [], [], false], ["Complex", "", [], [Go$Complex128], false], ["Convert", "", [Type], [Value], false], ["Elem", "", [], [Value], false], ["Field", "", [Go$Int], [Value], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [Value], false], ["FieldByName", "", [Go$String], [Value], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [Value], false], ["Float", "", [], [Go$Float64], false], ["Index", "", [Go$Int], [Value], false], ["Int", "", [], [Go$Int64], false], ["Interface", "", [], [go$emptyInterface], false], ["InterfaceData", "", [], [(go$arrayType(Go$Uintptr, 2))], false], ["IsNil", "", [], [Go$Bool], false], ["IsValid", "", [], [Go$Bool], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["MapIndex", "", [Value], [Value], false], ["MapKeys", "", [], [(go$sliceType(Value))], false], ["Method", "", [Go$Int], [Value], false], ["MethodByName", "", [Go$String], [Value], false], ["NumField", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["OverflowComplex", "", [Go$Complex128], [Go$Bool], false], ["OverflowFloat", "", [Go$Float64], [Go$Bool], false], ["OverflowInt", "", [Go$Int64], [Go$Bool], false], ["OverflowUint", "", [Go$Uint64], [Go$Bool], false], ["Pointer", "", [], [Go$Uintptr], false], ["Recv", "", [], [Value, Go$Bool], false], ["Send", "", [Value], [], false], ["Set", "", [Value], [], false], ["SetBool", "", [Go$Bool], [], false], ["SetBytes", "", [(go$sliceType(Go$Uint8))], [], false], ["SetCap", "", [Go$Int], [], false], ["SetComplex", "", [Go$Complex128], [], false], ["SetFloat", "", [Go$Float64], [], false], ["SetInt", "", [Go$Int64], [], false], ["SetLen", "", [Go$Int], [], false], ["SetMapIndex", "", [Value, Value], [], false], ["SetPointer", "", [Go$UnsafePointer], [], false], ["SetString", "", [Go$String], [], false], ["SetUint", "", [Go$Uint64], [], false], ["Slice", "", [Go$Int, Go$Int], [Value], false], ["Slice3", "", [Go$Int, Go$Int, Go$Int], [Value], false], ["String", "", [], [Go$String], false], ["TryRecv", "", [], [Value, Go$Bool], false], ["TrySend", "", [Value], [Go$Bool], false], ["Type", "", [], [Type], false], ["Uint", "", [], [Go$Uint64], false], ["UnsafeAddr", "", [], [Go$Uintptr], false], ["assignTo", "reflect", [Go$String, (go$ptrType(rtype)), (go$ptrType(go$emptyInterface))], [Value], false], ["call", "reflect", [Go$String, (go$sliceType(Value))], [(go$sliceType(Value))], false], ["iword", "reflect", [], [iword], false], ["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false], ["recv", "reflect", [Go$Bool], [Value, Go$Bool], false], ["runes", "reflect", [], [(go$sliceType(Go$Int32))], false], ["send", "reflect", [Value, Go$Bool], [Go$Bool], false], ["setRunes", "reflect", [(go$sliceType(Go$Int32))], [], false]];
	(go$ptrType(Value)).methods = [["Addr", "", [], [Value], false], ["Bool", "", [], [Go$Bool], false], ["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Call", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CallSlice", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CanAddr", "", [], [Go$Bool], false], ["CanInterface", "", [], [Go$Bool], false], ["CanSet", "", [], [Go$Bool], false], ["Cap", "", [], [Go$Int], false], ["Close", "", [], [], false], ["Complex", "", [], [Go$Complex128], false], ["Convert", "", [Type], [Value], false], ["Elem", "", [], [Value], false], ["Field", "", [Go$Int], [Value], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [Value], false], ["FieldByName", "", [Go$String], [Value], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [Value], false], ["Float", "", [], [Go$Float64], false], ["Index", "", [Go$Int], [Value], false], ["Int", "", [], [Go$Int64], false], ["Interface", "", [], [go$emptyInterface], false], ["InterfaceData", "", [], [(go$arrayType(Go$Uintptr, 2))], false], ["IsNil", "", [], [Go$Bool], false], ["IsValid", "", [], [Go$Bool], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["MapIndex", "", [Value], [Value], false], ["MapKeys", "", [], [(go$sliceType(Value))], false], ["Method", "", [Go$Int], [Value], false], ["MethodByName", "", [Go$String], [Value], false], ["NumField", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["OverflowComplex", "", [Go$Complex128], [Go$Bool], false], ["OverflowFloat", "", [Go$Float64], [Go$Bool], false], ["OverflowInt", "", [Go$Int64], [Go$Bool], false], ["OverflowUint", "", [Go$Uint64], [Go$Bool], false], ["Pointer", "", [], [Go$Uintptr], false], ["Recv", "", [], [Value, Go$Bool], false], ["Send", "", [Value], [], false], ["Set", "", [Value], [], false], ["SetBool", "", [Go$Bool], [], false], ["SetBytes", "", [(go$sliceType(Go$Uint8))], [], false], ["SetCap", "", [Go$Int], [], false], ["SetComplex", "", [Go$Complex128], [], false], ["SetFloat", "", [Go$Float64], [], false], ["SetInt", "", [Go$Int64], [], false], ["SetLen", "", [Go$Int], [], false], ["SetMapIndex", "", [Value, Value], [], false], ["SetPointer", "", [Go$UnsafePointer], [], false], ["SetString", "", [Go$String], [], false], ["SetUint", "", [Go$Uint64], [], false], ["Slice", "", [Go$Int, Go$Int], [Value], false], ["Slice3", "", [Go$Int, Go$Int, Go$Int], [Value], false], ["String", "", [], [Go$String], false], ["TryRecv", "", [], [Value, Go$Bool], false], ["TrySend", "", [Value], [Go$Bool], false], ["Type", "", [], [Type], false], ["Uint", "", [], [Go$Uint64], false], ["UnsafeAddr", "", [], [Go$Uintptr], false], ["assignTo", "reflect", [Go$String, (go$ptrType(rtype)), (go$ptrType(go$emptyInterface))], [Value], false], ["call", "reflect", [Go$String, (go$sliceType(Value))], [(go$sliceType(Value))], false], ["iword", "reflect", [], [iword], false], ["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false], ["recv", "reflect", [Go$Bool], [Value, Go$Bool], false], ["runes", "reflect", [], [(go$sliceType(Go$Int32))], false], ["send", "reflect", [Value, Go$Bool], [Go$Bool], false], ["setRunes", "reflect", [(go$sliceType(Go$Int32))], [], false]];
	flag.methods = [["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false]];
	(go$ptrType(flag)).methods = [["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false]];
	ValueError.init([["Method", "", Go$String, ""], ["Kind", "", Kind, ""]]);
	(go$ptrType(ValueError)).methods = [["Error", "", [], [Go$String], false]];
	emptyInterface.init([["typ", "reflect", (go$ptrType(rtype)), ""], ["word", "reflect", iword, ""]]);
	nonEmptyInterface.init([["itab", "reflect", (go$ptrType((go$structType([["ityp", "reflect", (go$ptrType(rtype)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["link", "reflect", Go$UnsafePointer, ""], ["bad", "reflect", Go$Int32, ""], ["unused", "reflect", Go$Int32, ""], ["fun", "reflect", (go$arrayType(Go$UnsafePointer, 100000)), ""]])))), ""], ["word", "reflect", iword, ""]]);
	StringHeader.init([["Data", "", Go$Uintptr, ""], ["Len", "", Go$Int, ""]]);
	SliceHeader.init([["Data", "", Go$Uintptr, ""], ["Len", "", Go$Int, ""], ["Cap", "", Go$Int, ""]]);
	runtimeSelect.init([["dir", "reflect", Go$Uintptr, ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["ch", "reflect", iword, ""], ["val", "reflect", iword, ""]]);
	SelectCase.init([["Dir", "", SelectDir, ""], ["Chan", "", Value, ""], ["Send", "", Value, ""]]);
	var kindNames, ptrMap, ptrDataGCProg, lookupCache, sliceEmptyGCProg, uint8Type, dummy;
	var deepValueEqual = function(v1, v2, visited, depth) {
		var hard, addr1, addr2, _tuple, typ, v, _entry, _key, _struct, _ref, i, _struct$1, _struct$2, i$1, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7, _struct$8, _tuple$1, i$2, n, _struct$9, _struct$10, _ref$1, _i, _slice, _index, _struct$11, k, _struct$12, _struct$13, _struct$14, _struct$15, _struct$16, _struct$17;
		if (!v1.IsValid() || !v2.IsValid()) {
			return v1.IsValid() === v2.IsValid();
		}
		if (!(go$interfaceIsEqual(v1.Type(), v2.Type()))) {
			return false;
		}
		hard = (function(k) {
			var _ref;
			_ref = k;
			if (_ref === 17 || _ref === 21 || _ref === 23 || _ref === 25) {
				return true;
			}
			return false;
		});
		if (v1.CanAddr() && v2.CanAddr() && hard(v1.Kind())) {
			addr1 = v1.UnsafeAddr();
			addr2 = v2.UnsafeAddr();
			if (addr1 > addr2) {
				_tuple = [addr2, addr1], addr1 = _tuple[0], addr2 = _tuple[1];
			}
			if (addr1 === addr2) {
				return true;
			}
			typ = v1.Type();
			v = new visit.Ptr(addr1, addr2, typ);
			if ((_entry = visited[(new visit(v)).go$key()], _entry !== undefined ? _entry.v : false)) {
				return true;
			}
			_key = (_struct = v, new visit.Ptr(_struct.a1, _struct.a2, _struct.typ)), (visited || go$throwRuntimeError("assignment to entry in nil map"))[(new visit(_key)).go$key()] = { k: _key, v: true };
		}
		_ref = v1.Kind();
		if (_ref === 17) {
			if (!((v1.Len() === v2.Len()))) {
				return false;
			}
			i = 0;
			while (i < v1.Len()) {
				if (!deepValueEqual((_struct$1 = v1.Index(i), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), (_struct$2 = v2.Index(i), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				i = i + 1 >> 0;
			}
			return true;
		} else if (_ref === 23) {
			if (!(v1.IsNil() === v2.IsNil())) {
				return false;
			}
			if (!((v1.Len() === v2.Len()))) {
				return false;
			}
			if (v1.Pointer() === v2.Pointer()) {
				return true;
			}
			i$1 = 0;
			while (i$1 < v1.Len()) {
				if (!deepValueEqual((_struct$3 = v1.Index(i$1), new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), (_struct$4 = v2.Index(i$1), new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				i$1 = i$1 + 1 >> 0;
			}
			return true;
		} else if (_ref === 20) {
			if (v1.IsNil() || v2.IsNil()) {
				return v1.IsNil() === v2.IsNil();
			}
			return deepValueEqual((_struct$5 = v1.Elem(), new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), (_struct$6 = v2.Elem(), new Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)), visited, depth + 1 >> 0);
		} else if (_ref === 22) {
			return deepValueEqual((_struct$7 = v1.Elem(), new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), (_struct$8 = v2.Elem(), new Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)), visited, depth + 1 >> 0);
		} else if (_ref === 25) {
			_tuple$1 = [0, v1.NumField()], i$2 = _tuple$1[0], n = _tuple$1[1];
			while (i$2 < n) {
				if (!deepValueEqual((_struct$9 = v1.Field(i$2), new Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag)), (_struct$10 = v2.Field(i$2), new Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				i$2 = i$2 + 1 >> 0;
			}
			return true;
		} else if (_ref === 21) {
			if (!(v1.IsNil() === v2.IsNil())) {
				return false;
			}
			if (!((v1.Len() === v2.Len()))) {
				return false;
			}
			if (v1.Pointer() === v2.Pointer()) {
				return true;
			}
			_ref$1 = v1.MapKeys();
			_i = 0;
			while (_i < _ref$1.length) {
				k = (_struct$11 = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag));
				if (!deepValueEqual((_struct$13 = v1.MapIndex((_struct$12 = k, new Value.Ptr(_struct$12.typ, _struct$12.val, _struct$12.flag))), new Value.Ptr(_struct$13.typ, _struct$13.val, _struct$13.flag)), (_struct$15 = v2.MapIndex((_struct$14 = k, new Value.Ptr(_struct$14.typ, _struct$14.val, _struct$14.flag))), new Value.Ptr(_struct$15.typ, _struct$15.val, _struct$15.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				_i++;
			}
			return true;
		} else if (_ref === 19) {
			if (v1.IsNil() && v2.IsNil()) {
				return true;
			}
			return false;
		} else {
			return go$interfaceIsEqual(valueInterface((_struct$16 = v1, new Value.Ptr(_struct$16.typ, _struct$16.val, _struct$16.flag)), false), valueInterface((_struct$17 = v2, new Value.Ptr(_struct$17.typ, _struct$17.val, _struct$17.flag)), false));
		}
	};
	var DeepEqual = go$pkg.DeepEqual = function(a1, a2) {
			if (a1 === a2) {
				return true;
			}
			if (a1 === null || a2 === null || a1.constructor !== a2.constructor) {
				return false;
			}
			return deepValueEqual(ValueOf(a1), ValueOf(a2), []);
		};
	var MakeFunc = go$pkg.MakeFunc = function(typ, fn) {
			var fv = function() {
				var args = new Go$Array(typ.NumIn()), i;
				for (i = 0; i < typ.NumIn(); i++) {
					var t = typ.In(i);
					args[i] = new Value.Ptr(t, arguments[i], t.Kind() << flagKindShift);
				}
				var resultsSlice = fn(new (go$sliceType(Value.Ptr))(args));
				switch (typ.NumOut()) {
				case 0:
					return;
				case 1:
					return resultsSlice.array[resultsSlice.offset].iword();
				default:
					var results = new Go$Array(typ.NumOut());
					for (i = 0; i < typ.NumOut(); i++) {
						results[i] = resultsSlice.array[resultsSlice.offset + i].iword();
					}
					return results;
				}
			}
		  return new Value.Ptr(typ, fv, Func << flagKindShift);
		};
	var makeFuncStub = function() {
		throw go$panic("Native function not implemented: makeFuncStub");
	};
	var makeMethodValue = function(op, v) {
			if ((v.flag & flagMethod) === 0) {
				throw go$panic("reflect: internal error: invalid use of makePartialFunc");
			}

			var tuple = methodReceiver(op, v, v.flag >> flagMethodShift);
			var fn = tuple[1];
			var rcvr = tuple[2];
			var fv = function() { return fn.apply(rcvr, arguments); };
			return new Value.Ptr(v.Type(), fv, (v.flag & flagRO) | (Func << flagKindShift));
		};
	var methodValueCall = function() {
		throw go$panic("Native function not implemented: methodValueCall");
	};
	Kind.prototype.String = function() {
		var k, _slice, _index;
		k = this.go$val;
		if ((k >> 0) < kindNames.length) {
			return (_slice = kindNames, _index = k, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		}
		return "kind" + strconv.Itoa((k >> 0));
	};
	go$ptrType(Kind).prototype.String = function() { return new Kind(this.go$get()).String(); };
	uncommonType.Ptr.prototype.uncommon = function() {
		var t;
		t = this;
		return t;
	};
	uncommonType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	uncommonType.Ptr.prototype.PkgPath = function() {
		var t;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil || go$pointerIsEqual(t.pkgPath, (go$ptrType(Go$String)).nil)) {
			return "";
		}
		return t.pkgPath.go$get();
	};
	uncommonType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	uncommonType.Ptr.prototype.Name = function() {
		var t;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil || go$pointerIsEqual(t.name, (go$ptrType(Go$String)).nil)) {
			return "";
		}
		return t.name.go$get();
	};
	uncommonType.prototype.Name = function() { return this.go$val.Name(); };
	rtype.Ptr.prototype.String = function() {
		var t;
		t = this;
		return t.string.go$get();
	};
	rtype.prototype.String = function() { return this.go$val.String(); };
	rtype.Ptr.prototype.Size = function() {
		var t;
		t = this;
		return t.size;
	};
	rtype.prototype.Size = function() { return this.go$val.Size(); };
	rtype.Ptr.prototype.Bits = function() {
		var t, k, x, x$1;
		t = this;
		if (t === (go$ptrType(rtype)).nil) {
			throw go$panic(new Go$String("reflect: Bits of nil Type"));
		}
		k = t.Kind();
		if (k < 2 || k > 16) {
			throw go$panic(new Go$String("reflect: Bits of non-arithmetic Type " + t.String()));
		}
		return (x = (t.size >> 0), x$1 = 8, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
	};
	rtype.prototype.Bits = function() { return this.go$val.Bits(); };
	rtype.Ptr.prototype.Align = function() {
		var t;
		t = this;
		return (t.align >> 0);
	};
	rtype.prototype.Align = function() { return this.go$val.Align(); };
	rtype.Ptr.prototype.FieldAlign = function() {
		var t;
		t = this;
		return (t.fieldAlign >> 0);
	};
	rtype.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	rtype.Ptr.prototype.Kind = function() {
		var t;
		t = this;
		return (((t.kind & 127) >>> 0) >>> 0);
	};
	rtype.prototype.Kind = function() { return this.go$val.Kind(); };
	rtype.Ptr.prototype.common = function() {
		var t;
		t = this;
		return t;
	};
	rtype.prototype.common = function() { return this.go$val.common(); };
	uncommonType.Ptr.prototype.Method = function(i) {
			if (this === uncommonType.Ptr.nil || i < 0 || i >= this.methods.length) {
				throw go$panic("reflect: Method index out of range");
			}
			var p = this.methods.array[i];
			var fl = Func << flagKindShift;
			var pkgPath = "";
			if (p.pkgPath.go$get !== go$throwNilPointerError) {
				pkgPath = p.pkgPath.go$get();
				fl |= flagRO;
			}
			var mt = p.typ;
			var name = p.name.go$get();
			if (go$reservedKeywords.indexOf(name) !== -1) {
				name += "$";
			}
			var fn = function(rcvr) {
				return rcvr[name].apply(rcvr, Go$Array.prototype.slice.apply(arguments, [1]));
			}
			return new Method.Ptr(p.name.go$get(), pkgPath, mt, new Value.Ptr(mt, fn, fl), i);
		};
	uncommonType.prototype.Method = function(i) { return this.go$val.Method(i); };
	uncommonType.Ptr.prototype.NumMethod = function() {
		var t;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil) {
			return 0;
		}
		return t.methods.length;
	};
	uncommonType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	uncommonType.Ptr.prototype.MethodByName = function(name) {
		var m, ok, t, _struct, _struct$1, p, _ref, _i, i, _slice, _index, _struct$2, _struct$3, _tuple, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		ok = false;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil) {
			return [(_struct = m, new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index)), ok];
		}
		p = (go$ptrType(method)).nil;
		_ref = t.methods;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			p = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!(go$pointerIsEqual(p.name, (go$ptrType(Go$String)).nil)) && p.name.go$get() === name) {
				_tuple = [(_struct$2 = t.Method(i), new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index)), true], m = _tuple[0], ok = _tuple[1];
				return [(_struct$4 = m, new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index)), ok];
			}
			_i++;
		}
		return [(_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index)), ok];
	};
	uncommonType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	rtype.Ptr.prototype.NumMethod = function() {
		var t, tt;
		t = this;
		if (t.Kind() === 20) {
			tt = t.interfaceType;
			return tt.NumMethod();
		}
		return t.uncommonType.NumMethod();
	};
	rtype.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	rtype.Ptr.prototype.Method = function(i) {
		var m, t, tt, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		t = this;
		if (t.Kind() === 20) {
			tt = t.interfaceType;
			m = (_struct = tt.Method(i), new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index));
			return (_struct$2 = m, new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index));
		}
		m = (_struct$4 = t.uncommonType.Method(i), new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index));
		return (_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index));
	};
	rtype.prototype.Method = function(i) { return this.go$val.Method(i); };
	rtype.Ptr.prototype.MethodByName = function(name) {
		var m, ok, t, tt, _tuple, _struct, _struct$1, _struct$2, _struct$3, _tuple$1, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		ok = false;
		t = this;
		if (t.Kind() === 20) {
			tt = t.interfaceType;
			_tuple = tt.MethodByName(name), m = (_struct = _tuple[0], new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index)), ok = _tuple[1];
			return [(_struct$2 = m, new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index)), ok];
		}
		_tuple$1 = t.uncommonType.MethodByName(name), m = (_struct$4 = _tuple$1[0], new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index)), ok = _tuple$1[1];
		return [(_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index)), ok];
	};
	rtype.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	rtype.Ptr.prototype.PkgPath = function() {
		var t;
		t = this;
		return t.uncommonType.PkgPath();
	};
	rtype.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	rtype.Ptr.prototype.Name = function() {
		var t;
		t = this;
		return t.uncommonType.Name();
	};
	rtype.prototype.Name = function() { return this.go$val.Name(); };
	rtype.Ptr.prototype.ChanDir = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 18))) {
			throw go$panic(new Go$String("reflect: ChanDir of non-chan type"));
		}
		tt = t.chanType;
		return (tt.dir >> 0);
	};
	rtype.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	rtype.Ptr.prototype.IsVariadic = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: IsVariadic of non-func type"));
		}
		tt = t.funcType;
		return tt.dotdotdot;
	};
	rtype.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	rtype.Ptr.prototype.Elem = function() {
		var t, _ref, tt, tt$1, tt$2, tt$3, tt$4;
		t = this;
		_ref = t.Kind();
		if (_ref === 17) {
			tt = t.arrayType;
			return toType(tt.elem);
		} else if (_ref === 18) {
			tt$1 = t.chanType;
			return toType(tt$1.elem);
		} else if (_ref === 21) {
			tt$2 = t.mapType;
			return toType(tt$2.elem);
		} else if (_ref === 22) {
			tt$3 = t.ptrType;
			return toType(tt$3.elem);
		} else if (_ref === 23) {
			tt$4 = t.sliceType;
			return toType(tt$4.elem);
		}
		throw go$panic(new Go$String("reflect: Elem of invalid type"));
	};
	rtype.prototype.Elem = function() { return this.go$val.Elem(); };
	rtype.Ptr.prototype.Field = function(i) {
		var t, tt, _struct;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: Field of non-struct type"));
		}
		tt = t.structType;
		return (_struct = tt.Field(i), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
	};
	rtype.prototype.Field = function(i) { return this.go$val.Field(i); };
	rtype.Ptr.prototype.FieldByIndex = function(index) {
		var t, tt, _struct;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: FieldByIndex of non-struct type"));
		}
		tt = t.structType;
		return (_struct = tt.FieldByIndex(index), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
	};
	rtype.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	rtype.Ptr.prototype.FieldByName = function(name) {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: FieldByName of non-struct type"));
		}
		tt = t.structType;
		return tt.FieldByName(name);
	};
	rtype.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	rtype.Ptr.prototype.FieldByNameFunc = function(match) {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: FieldByNameFunc of non-struct type"));
		}
		tt = t.structType;
		return tt.FieldByNameFunc(match);
	};
	rtype.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	rtype.Ptr.prototype.In = function(i) {
		var t, tt, _slice, _index;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: In of non-func type"));
		}
		tt = t.funcType;
		return toType((_slice = tt.in$2, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
	};
	rtype.prototype.In = function(i) { return this.go$val.In(i); };
	rtype.Ptr.prototype.Key = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 21))) {
			throw go$panic(new Go$String("reflect: Key of non-map type"));
		}
		tt = t.mapType;
		return toType(tt.key);
	};
	rtype.prototype.Key = function() { return this.go$val.Key(); };
	rtype.Ptr.prototype.Len = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 17))) {
			throw go$panic(new Go$String("reflect: Len of non-array type"));
		}
		tt = t.arrayType;
		return (tt.len >> 0);
	};
	rtype.prototype.Len = function() { return this.go$val.Len(); };
	rtype.Ptr.prototype.NumField = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: NumField of non-struct type"));
		}
		tt = t.structType;
		return tt.fields.length;
	};
	rtype.prototype.NumField = function() { return this.go$val.NumField(); };
	rtype.Ptr.prototype.NumIn = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: NumIn of non-func type"));
		}
		tt = t.funcType;
		return tt.in$2.length;
	};
	rtype.prototype.NumIn = function() { return this.go$val.NumIn(); };
	rtype.Ptr.prototype.NumOut = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: NumOut of non-func type"));
		}
		tt = t.funcType;
		return tt.out.length;
	};
	rtype.prototype.NumOut = function() { return this.go$val.NumOut(); };
	rtype.Ptr.prototype.Out = function(i) {
		var t, tt, _slice, _index;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: Out of non-func type"));
		}
		tt = t.funcType;
		return toType((_slice = tt.out, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
	};
	rtype.prototype.Out = function(i) { return this.go$val.Out(i); };
	ChanDir.prototype.String = function() {
		var d, _ref;
		d = this.go$val;
		_ref = d;
		if (_ref === 2) {
			return "chan<-";
		} else if (_ref === 1) {
			return "<-chan";
		} else if (_ref === 3) {
			return "chan";
		}
		return "ChanDir" + strconv.Itoa((d >> 0));
	};
	go$ptrType(ChanDir).prototype.String = function() { return new ChanDir(this.go$get()).String(); };
	interfaceType.Ptr.prototype.Method = function(i) {
		var m, t, _struct, _struct$1, _slice, _index, p, _struct$2, _struct$3;
		m = new Method.Ptr();
		t = this;
		if (i < 0 || i >= t.methods.length) {
			return (_struct = m, new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index));
		}
		p = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		m.Name = p.name.go$get();
		if (!(go$pointerIsEqual(p.pkgPath, (go$ptrType(Go$String)).nil))) {
			m.PkgPath = p.pkgPath.go$get();
		}
		m.Type = toType(p.typ);
		m.Index = i;
		return (_struct$2 = m, new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index));
	};
	interfaceType.prototype.Method = function(i) { return this.go$val.Method(i); };
	interfaceType.Ptr.prototype.NumMethod = function() {
		var t;
		t = this;
		return t.methods.length;
	};
	interfaceType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	interfaceType.Ptr.prototype.MethodByName = function(name) {
		var m, ok, t, _struct, _struct$1, p, _ref, _i, i, _slice, _index, _struct$2, _struct$3, _tuple, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		ok = false;
		t = this;
		if (t === (go$ptrType(interfaceType)).nil) {
			return [(_struct = m, new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index)), ok];
		}
		p = (go$ptrType(imethod)).nil;
		_ref = t.methods;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			p = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (p.name.go$get() === name) {
				_tuple = [(_struct$2 = t.Method(i), new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index)), true], m = _tuple[0], ok = _tuple[1];
				return [(_struct$4 = m, new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index)), ok];
			}
			_i++;
		}
		return [(_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index)), ok];
	};
	interfaceType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	StructTag.prototype.Get = function(key) {
		var tag, i, name, qvalue, _tuple, value;
		tag = this.go$val;
		while (!(tag === "")) {
			i = 0;
			while (i < tag.length && (tag.charCodeAt(i) === 32)) {
				i = i + 1 >> 0;
			}
			tag = tag.substring(i);
			if (tag === "") {
				break;
			}
			i = 0;
			while (i < tag.length && !((tag.charCodeAt(i) === 32)) && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34))) {
				i = i + 1 >> 0;
			}
			if ((i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {
				break;
			}
			name = tag.substring(0, i);
			tag = tag.substring((i + 1 >> 0));
			i = 1;
			while (i < tag.length && !((tag.charCodeAt(i) === 34))) {
				if (tag.charCodeAt(i) === 92) {
					i = i + 1 >> 0;
				}
				i = i + 1 >> 0;
			}
			if (i >= tag.length) {
				break;
			}
			qvalue = tag.substring(0, (i + 1 >> 0));
			tag = tag.substring((i + 1 >> 0));
			if (key === name) {
				_tuple = strconv.Unquote(qvalue), value = _tuple[0];
				return value;
			}
		}
		return "";
	};
	go$ptrType(StructTag).prototype.Get = function(key) { return new StructTag(this.go$get()).Get(key); };
	structType.Ptr.prototype.Field = function(i) {
		var f, t, _struct, _slice, _index, p, t$1, _struct$1;
		f = new StructField.Ptr();
		t = this;
		if (i < 0 || i >= t.fields.length) {
			return (_struct = f, new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
		}
		p = (_slice = t.fields, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		f.Type = toType(p.typ);
		if (!(go$pointerIsEqual(p.name, (go$ptrType(Go$String)).nil))) {
			f.Name = p.name.go$get();
		} else {
			t$1 = f.Type;
			if (t$1.Kind() === 22) {
				t$1 = t$1.Elem();
			}
			f.Name = t$1.Name();
			f.Anonymous = true;
		}
		if (!(go$pointerIsEqual(p.pkgPath, (go$ptrType(Go$String)).nil))) {
			f.PkgPath = p.pkgPath.go$get();
		}
		if (!(go$pointerIsEqual(p.tag, (go$ptrType(Go$String)).nil))) {
			f.Tag = p.tag.go$get();
		}
		f.Offset = p.offset;
		f.Index = new (go$sliceType(Go$Int))([i]);
		return (_struct$1 = f, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous));
	};
	structType.prototype.Field = function(i) { return this.go$val.Field(i); };
	structType.Ptr.prototype.FieldByIndex = function(index) {
		var f, t, _ref, _i, _slice, _index, x, i, ft, _struct, _struct$1;
		f = new StructField.Ptr();
		t = this;
		f.Type = toType(t.rtype);
		_ref = index;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (i > 0) {
				ft = f.Type;
				if ((ft.Kind() === 22) && (ft.Elem().Kind() === 25)) {
					ft = ft.Elem();
				}
				f.Type = ft;
			}
			f = (_struct = f.Type.Field(x), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
			_i++;
		}
		return (_struct$1 = f, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous));
	};
	structType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	structType.Ptr.prototype.FieldByNameFunc = function(match) {
		var result, ok, t, current, next, nextCount, _map, _key, visited, _tuple, count, _ref, _i, _slice, _index, _struct, scan, t$1, _entry, _key$1, _ref$1, _i$1, i, _slice$1, _index$1, f, fname, ntyp, _entry$1, _tuple$1, _struct$1, _struct$2, styp, _entry$2, _key$2, _map$1, _key$3, _key$4, _entry$3, _key$5, index, _struct$3;
		result = new StructField.Ptr();
		ok = false;
		t = this;
		current = new (go$sliceType(fieldScan))([]);
		next = new (go$sliceType(fieldScan))([new fieldScan.Ptr(t, (go$sliceType(Go$Int)).nil)]);
		nextCount = false;
		visited = (_map = new Go$Map(), _map);
		while (next.length > 0) {
			_tuple = [next, go$subslice(current, 0, 0)], current = _tuple[0], next = _tuple[1];
			count = nextCount;
			nextCount = false;
			_ref = current;
			_i = 0;
			while (_i < _ref.length) {
				scan = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new fieldScan.Ptr(_struct.typ, _struct.index));
				t$1 = scan.typ;
				if ((_entry = visited[t$1.go$key()], _entry !== undefined ? _entry.v : false)) {
					_i++;
					continue;
				}
				_key$1 = t$1, (visited || go$throwRuntimeError("assignment to entry in nil map"))[_key$1.go$key()] = { k: _key$1, v: true };
				_ref$1 = t$1.fields;
				_i$1 = 0;
				while (_i$1 < _ref$1.length) {
					i = _i$1;
					f = (_slice$1 = t$1.fields, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
					fname = "";
					ntyp = (go$ptrType(rtype)).nil;
					if (!(go$pointerIsEqual(f.name, (go$ptrType(Go$String)).nil))) {
						fname = f.name.go$get();
					} else {
						ntyp = f.typ;
						if (ntyp.Kind() === 22) {
							ntyp = ntyp.Elem().common();
						}
						fname = ntyp.Name();
					}
					if (match(fname)) {
						if ((_entry$1 = count[t$1.go$key()], _entry$1 !== undefined ? _entry$1.v : 0) > 1 || ok) {
							_tuple$1 = [new StructField.Ptr("", "", null, "", 0, (go$sliceType(Go$Int)).nil, false), false], result = _tuple$1[0], ok = _tuple$1[1];
							return [(_struct$1 = result, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), ok];
						}
						result = (_struct$2 = t$1.Field(i), new StructField.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, _struct$2.Tag, _struct$2.Offset, _struct$2.Index, _struct$2.Anonymous));
						result.Index = (go$sliceType(Go$Int)).nil;
						result.Index = go$appendSlice(result.Index, scan.index);
						result.Index = go$append(result.Index, i);
						ok = true;
						_i$1++;
						continue;
					}
					if (ok || ntyp === (go$ptrType(rtype)).nil || !((ntyp.Kind() === 25))) {
						_i$1++;
						continue;
					}
					styp = ntyp.structType;
					if ((_entry$2 = nextCount[styp.go$key()], _entry$2 !== undefined ? _entry$2.v : 0) > 0) {
						_key$2 = styp, (nextCount || go$throwRuntimeError("assignment to entry in nil map"))[_key$2.go$key()] = { k: _key$2, v: 2 };
						_i$1++;
						continue;
					}
					if (nextCount === false) {
						nextCount = (_map$1 = new Go$Map(), _map$1);
					}
					_key$4 = styp, (nextCount || go$throwRuntimeError("assignment to entry in nil map"))[_key$4.go$key()] = { k: _key$4, v: 1 };
					if ((_entry$3 = count[t$1.go$key()], _entry$3 !== undefined ? _entry$3.v : 0) > 1) {
						_key$5 = styp, (nextCount || go$throwRuntimeError("assignment to entry in nil map"))[_key$5.go$key()] = { k: _key$5, v: 2 };
					}
					index = (go$sliceType(Go$Int)).nil;
					index = go$appendSlice(index, scan.index);
					index = go$append(index, i);
					next = go$append(next, new fieldScan.Ptr(styp, index));
					_i$1++;
				}
				_i++;
			}
			if (ok) {
				break;
			}
		}
		return [(_struct$3 = result, new StructField.Ptr(_struct$3.Name, _struct$3.PkgPath, _struct$3.Type, _struct$3.Tag, _struct$3.Offset, _struct$3.Index, _struct$3.Anonymous)), ok];
	};
	structType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	structType.Ptr.prototype.FieldByName = function(name) {
		var f, present, t, hasAnon, _ref, _i, i, _slice, _index, tf, _struct, _tuple, _struct$1, _struct$2, _tuple$1, _struct$3, _struct$4;
		f = new StructField.Ptr();
		present = false;
		t = this;
		hasAnon = false;
		if (!(name === "")) {
			_ref = t.fields;
			_i = 0;
			while (_i < _ref.length) {
				i = _i;
				tf = (_slice = t.fields, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (go$pointerIsEqual(tf.name, (go$ptrType(Go$String)).nil)) {
					hasAnon = true;
					_i++;
					continue;
				}
				if (tf.name.go$get() === name) {
					_tuple = [(_struct = t.Field(i), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous)), true], f = _tuple[0], present = _tuple[1];
					return [(_struct$1 = f, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), present];
				}
				_i++;
			}
		}
		if (!hasAnon) {
			return [(_struct$2 = f, new StructField.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, _struct$2.Tag, _struct$2.Offset, _struct$2.Index, _struct$2.Anonymous)), present];
		}
		_tuple$1 = t.FieldByNameFunc((function(s) {
			return s === name;
		})), f = (_struct$3 = _tuple$1[0], new StructField.Ptr(_struct$3.Name, _struct$3.PkgPath, _struct$3.Type, _struct$3.Tag, _struct$3.Offset, _struct$3.Index, _struct$3.Anonymous)), present = _tuple$1[1];
		return [(_struct$4 = f, new StructField.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, _struct$4.Tag, _struct$4.Offset, _struct$4.Index, _struct$4.Anonymous)), present];
	};
	structType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	var TypeOf = go$pkg.TypeOf = function(i) {
			if (i === null) {
				return null;
			}
			if (i.constructor.kind === undefined) { // js.Object
				return Go$String.reflectType();
			}
			return i.constructor.reflectType();
		};
	var PtrTo = go$pkg.PtrTo = function(t) {
		return (t !== null && t.constructor === (go$ptrType(rtype)) ? t.go$val : go$typeAssertionFailed(t, (go$ptrType(rtype)))).ptrTo();
	};
	rtype.Ptr.prototype.ptrTo = function() {
			return go$ptrType(this.jsType).reflectType();
		};
	rtype.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	var fnv1 = function(x, list) {
		var _ref, _i, _slice, _index, b, x$1;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			x = ((x$1 = 16777619, (((x >>> 16 << 16) * x$1 >>> 0) + (x << 16 >>> 16) * x$1) >>> 0) ^ (b >>> 0)) >>> 0;
			_i++;
		}
		return x;
	};
	rtype.Ptr.prototype.Implements = function(u) {
		var t;
		t = this;
		if (go$interfaceIsEqual(u, null)) {
			throw go$panic(new Go$String("reflect: nil type passed to Type.Implements"));
		}
		if (!((u.Kind() === 20))) {
			throw go$panic(new Go$String("reflect: non-interface type passed to Type.Implements"));
		}
		return implements$1((u !== null && u.constructor === (go$ptrType(rtype)) ? u.go$val : go$typeAssertionFailed(u, (go$ptrType(rtype)))), t);
	};
	rtype.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	rtype.Ptr.prototype.AssignableTo = function(u) {
		var t, uu;
		t = this;
		if (go$interfaceIsEqual(u, null)) {
			throw go$panic(new Go$String("reflect: nil type passed to Type.AssignableTo"));
		}
		uu = (u !== null && u.constructor === (go$ptrType(rtype)) ? u.go$val : go$typeAssertionFailed(u, (go$ptrType(rtype))));
		return directlyAssignable(uu, t) || implements$1(uu, t);
	};
	rtype.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	rtype.Ptr.prototype.ConvertibleTo = function(u) {
		var t, uu;
		t = this;
		if (go$interfaceIsEqual(u, null)) {
			throw go$panic(new Go$String("reflect: nil type passed to Type.ConvertibleTo"));
		}
		uu = (u !== null && u.constructor === (go$ptrType(rtype)) ? u.go$val : go$typeAssertionFailed(u, (go$ptrType(rtype))));
		return !(convertOp(uu, t) === go$throwNilPointerError);
	};
	rtype.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	var implements$1 = function(T, V) {
		var t, v, i, j, _slice, _index, tm, _slice$1, _index$1, vm, v$1, i$1, j$1, _slice$2, _index$2, tm$1, _slice$3, _index$3, vm$1;
		if (!((T.Kind() === 20))) {
			return false;
		}
		t = T.interfaceType;
		if (t.methods.length === 0) {
			return true;
		}
		if (V.Kind() === 20) {
			v = V.interfaceType;
			i = 0;
			j = 0;
			while (j < v.methods.length) {
				tm = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				vm = (_slice$1 = v.methods, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				if (go$pointerIsEqual(vm.name, tm.name) && go$pointerIsEqual(vm.pkgPath, tm.pkgPath) && vm.typ === tm.typ) {
					if (i = i + 1 >> 0, i >= t.methods.length) {
						return true;
					}
				}
				j = j + 1 >> 0;
			}
			return false;
		}
		v$1 = V.uncommonType.uncommon();
		if (v$1 === (go$ptrType(uncommonType)).nil) {
			return false;
		}
		i$1 = 0;
		j$1 = 0;
		while (j$1 < v$1.methods.length) {
			tm$1 = (_slice$2 = t.methods, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			vm$1 = (_slice$3 = v$1.methods, _index$3 = j$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			if (go$pointerIsEqual(vm$1.name, tm$1.name) && go$pointerIsEqual(vm$1.pkgPath, tm$1.pkgPath) && vm$1.mtyp === tm$1.typ) {
				if (i$1 = i$1 + 1 >> 0, i$1 >= t.methods.length) {
					return true;
				}
			}
			j$1 = j$1 + 1 >> 0;
		}
		return false;
	};
	var directlyAssignable = function(T, V) {
		if (T === V) {
			return true;
		}
		if (!(T.Name() === "") && !(V.Name() === "") || !((T.Kind() === V.Kind()))) {
			return false;
		}
		return haveIdenticalUnderlyingType(T, V);
	};
	var haveIdenticalUnderlyingType = function(T, V) {
		var kind, _ref, t, v, _ref$1, _i, _slice, _index, typ, i, _slice$1, _index$1, _ref$2, _i$1, _slice$2, _index$2, typ$1, i$1, _slice$3, _index$3, t$1, v$1, t$2, v$2, _ref$3, _i$2, i$2, _slice$4, _index$4, tf, _slice$5, _index$5, vf;
		if (T === V) {
			return true;
		}
		kind = T.Kind();
		if (!((kind === V.Kind()))) {
			return false;
		}
		if (1 <= kind && kind <= 16 || (kind === 24) || (kind === 26)) {
			return true;
		}
		_ref = kind;
		if (_ref === 17) {
			return go$interfaceIsEqual(T.Elem(), V.Elem()) && (T.Len() === V.Len());
		} else if (_ref === 18) {
			if ((V.ChanDir() === 3) && go$interfaceIsEqual(T.Elem(), V.Elem())) {
				return true;
			}
			return (V.ChanDir() === T.ChanDir()) && go$interfaceIsEqual(T.Elem(), V.Elem());
		} else if (_ref === 19) {
			t = T.funcType;
			v = V.funcType;
			if (!(t.dotdotdot === v.dotdotdot) || !((t.in$2.length === v.in$2.length)) || !((t.out.length === v.out.length))) {
				return false;
			}
			_ref$1 = t.in$2;
			_i = 0;
			while (_i < _ref$1.length) {
				typ = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				if (!(typ === (_slice$1 = v.in$2, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")))) {
					return false;
				}
				_i++;
			}
			_ref$2 = t.out;
			_i$1 = 0;
			while (_i$1 < _ref$2.length) {
				typ$1 = (_slice$2 = _ref$2, _index$2 = _i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
				i$1 = _i$1;
				if (!(typ$1 === (_slice$3 = v.out, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")))) {
					return false;
				}
				_i$1++;
			}
			return true;
		} else if (_ref === 20) {
			t$1 = T.interfaceType;
			v$1 = V.interfaceType;
			if ((t$1.methods.length === 0) && (v$1.methods.length === 0)) {
				return true;
			}
			return false;
		} else if (_ref === 21) {
			return go$interfaceIsEqual(T.Key(), V.Key()) && go$interfaceIsEqual(T.Elem(), V.Elem());
		} else if (_ref === 22 || _ref === 23) {
			return go$interfaceIsEqual(T.Elem(), V.Elem());
		} else if (_ref === 25) {
			t$2 = T.structType;
			v$2 = V.structType;
			if (!((t$2.fields.length === v$2.fields.length))) {
				return false;
			}
			_ref$3 = t$2.fields;
			_i$2 = 0;
			while (_i$2 < _ref$3.length) {
				i$2 = _i$2;
				tf = (_slice$4 = t$2.fields, _index$4 = i$2, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
				vf = (_slice$5 = v$2.fields, _index$5 = i$2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
				if (!(go$pointerIsEqual(tf.name, vf.name)) && (go$pointerIsEqual(tf.name, (go$ptrType(Go$String)).nil) || go$pointerIsEqual(vf.name, (go$ptrType(Go$String)).nil) || !(tf.name.go$get() === vf.name.go$get()))) {
					return false;
				}
				if (!(go$pointerIsEqual(tf.pkgPath, vf.pkgPath)) && (go$pointerIsEqual(tf.pkgPath, (go$ptrType(Go$String)).nil) || go$pointerIsEqual(vf.pkgPath, (go$ptrType(Go$String)).nil) || !(tf.pkgPath.go$get() === vf.pkgPath.go$get()))) {
					return false;
				}
				if (!(tf.typ === vf.typ)) {
					return false;
				}
				if (!(go$pointerIsEqual(tf.tag, vf.tag)) && (go$pointerIsEqual(tf.tag, (go$ptrType(Go$String)).nil) || go$pointerIsEqual(vf.tag, (go$ptrType(Go$String)).nil) || !(tf.tag.go$get() === vf.tag.go$get()))) {
					return false;
				}
				if (!((tf.offset === vf.offset))) {
					return false;
				}
				_i$2++;
			}
			return true;
		}
		return false;
	};
	var typelinks = function() {
		throw go$panic("Native function not implemented: typelinks");
	};
	var typesByString = function(s) {
		var typ, _tuple, i, j, _q, h, _slice, _index, _slice$1, _index$1;
		typ = typelinks();
		_tuple = [0, typ.length], i = _tuple[0], j = _tuple[1];
		while (i < j) {
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			if (!((_slice = typ, _index = h, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).string.go$get() >= s)) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		j = i;
		while (j < typ.length && (_slice$1 = typ, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).string.go$get() === s) {
			j = j + 1 >> 0;
		}
		return go$subslice(typ, i, j);
	};
	var cacheGet = function(k) {
		var _entry, t, _entry$1;
		lookupCache.RWMutex.RLock();
		t = (_entry = lookupCache.m[(new cacheKey(k)).go$key()], _entry !== undefined ? _entry.v : (go$ptrType(rtype)).nil);
		lookupCache.RWMutex.RUnlock();
		if (!(t === (go$ptrType(rtype)).nil)) {
			return t;
		}
		lookupCache.RWMutex.Lock();
		t = (_entry$1 = lookupCache.m[(new cacheKey(k)).go$key()], _entry$1 !== undefined ? _entry$1.v : (go$ptrType(rtype)).nil);
		if (!(t === (go$ptrType(rtype)).nil)) {
			lookupCache.RWMutex.Unlock();
			return t;
		}
		if (lookupCache.m === false) {
			lookupCache.m = new Go$Map();
		}
		return null;
	};
	var cachePut = function(k, t) {
		var _key, _struct;
		_key = (_struct = k, new cacheKey.Ptr(_struct.kind, _struct.t1, _struct.t2, _struct.extra)), (lookupCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(new cacheKey(_key)).go$key()] = { k: _key, v: t };
		lookupCache.RWMutex.Unlock();
		return t;
	};
	var ChanOf = go$pkg.ChanOf = function(dir, t) {
			return go$chanType(t.jsType, dir === SendDir, dir === RecvDir).reflectType();
		};
	var ismapkey = function() {
		throw go$panic("Native function not implemented: ismapkey");
	};
	var MapOf = go$pkg.MapOf = function(key, elem) {
			switch (key.Kind()) {
			case Func:
			case Map:
			case Slice:
				throw go$panic("reflect.MapOf: invalid key type " + key.String());
			}
			return go$mapType(key.jsType, elem.jsType).reflectType();
		};
	var bucketOf = function(ktyp, etyp) {
		var x, x$1, ptrsize, gc, offset, x$2, x$3, _slice, _index, _slice$1, _index$1, b, s, v;
		if (ktyp.size > 128) {
			ktyp = (x = PtrTo(ktyp), (x !== null && x.constructor === (go$ptrType(rtype)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(rtype)))));
		}
		if (etyp.size > 128) {
			etyp = (x$1 = PtrTo(etyp), (x$1 !== null && x$1.constructor === (go$ptrType(rtype)) ? x$1.go$val : go$typeAssertionFailed(x$1, (go$ptrType(rtype)))));
		}
		ptrsize = 4;
		gc = (go$sliceType(Go$Uintptr)).make(1, 0, function() { return 0; });
		offset = 8;
		gc = go$append(gc, 1, offset, 0);
		offset = offset + (ptrsize) >>> 0;
		if (((ktyp.kind & 128) >>> 0) === 0) {
			gc = go$append(gc, 3, offset, 8, ktyp.size);
			gc = appendGCProgram(gc, ktyp);
			gc = go$append(gc, 4);
		}
		offset = offset + ((x$2 = ktyp.size, (((8 >>> 16 << 16) * x$2 >>> 0) + (8 << 16 >>> 16) * x$2) >>> 0)) >>> 0;
		if (((etyp.kind & 128) >>> 0) === 0) {
			gc = go$append(gc, 3, offset, 8, etyp.size);
			gc = appendGCProgram(gc, etyp);
			gc = go$append(gc, 4);
		}
		offset = offset + ((x$3 = etyp.size, (((8 >>> 16 << 16) * x$3 >>> 0) + (8 << 16 >>> 16) * x$3) >>> 0)) >>> 0;
		gc = go$append(gc, 0);
		_slice = gc, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = offset) : go$throwRuntimeError("index out of range");
		_slice$1 = gc, _index$1 = 3, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = go$sliceToArray(gc)) : go$throwRuntimeError("index out of range");
		b = new rtype.Ptr();
		b.size = offset;
		b.gc = go$sliceToArray(gc);
		s = "bucket(" + ktyp.string.go$get() + "," + etyp.string.go$get() + ")";
		b.string = new (go$ptrType(Go$String))(function() { return s; }, function(v) { s = v; });
		return b;
	};
	var appendGCProgram = function(gc, t) {
		var p, argcnt, _ref, i;
		p = t.gc;
		p = (p + 4 >>> 0);
		loop: while (true) {
			argcnt = 0;
			_ref = p.go$get();
			if (_ref === 0) {
				break loop;
			} else if (_ref === 4) {
				argcnt = 0;
			} else if (_ref === 2 || _ref === 7 || _ref === 8 || _ref === 9) {
				argcnt = 1;
			} else if (_ref === 1 || _ref === 5 || _ref === 6 || _ref === 10) {
				argcnt = 2;
			} else if (_ref === 3 || _ref === 11) {
				argcnt = 3;
			} else {
				throw go$panic(new Go$String("unknown GC program op for " + t.string.go$get() + ": " + strconv.FormatUint(p.go$get(), 10)));
			}
			i = 0;
			while (i < (argcnt + 1 >> 0)) {
				gc = go$append(gc, p.go$get());
				p = (p + 4 >>> 0);
				i = i + 1 >> 0;
			}
		}
		return gc;
	};
	var hMapOf = function(bucket) {
		var ptrsize, gc, offset, x, _q, x$1, x$2, _q$1, _slice, _index, h, s, v;
		ptrsize = 4;
		gc = (go$sliceType(Go$Uintptr)).make(1, 0, function() { return 0; });
		offset = 4;
		offset = offset + 4 >>> 0;
		offset = offset + 4 >>> 0;
		offset = offset + 1 >>> 0;
		offset = offset + 1 >>> 0;
		offset = offset + 1 >>> 0;
		offset = (x = (_q = ((offset + 1 >>> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero")), x$1 = 2, (((x >>> 16 << 16) * x$1 >>> 0) + (x << 16 >>> 16) * x$1) >>> 0);
		offset = offset + 2 >>> 0;
		offset = (x$2 = (_q$1 = (((offset + ptrsize >>> 0) - 1 >>> 0)) / ptrsize, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : go$throwRuntimeError("integer divide by zero")), (((x$2 >>> 16 << 16) * ptrsize >>> 0) + (x$2 << 16 >>> 16) * ptrsize) >>> 0);
		gc = go$append(gc, 1, offset, bucket.gc);
		offset = offset + (ptrsize) >>> 0;
		gc = go$append(gc, 1, offset, bucket.gc);
		offset = offset + (ptrsize) >>> 0;
		offset = offset + (ptrsize) >>> 0;
		gc = go$append(gc, 0);
		_slice = gc, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = offset) : go$throwRuntimeError("index out of range");
		h = new rtype.Ptr();
		h.size = offset;
		h.gc = go$sliceToArray(gc);
		s = "hmap(" + bucket.string.go$get() + ")";
		h.string = new (go$ptrType(Go$String))(function() { return s; }, function(v) { s = v; });
		return h;
	};
	var SliceOf = go$pkg.SliceOf = function(t) {
			return go$sliceType(t.jsType).reflectType();
		};
	var arrayOf = function(n, t) {
			return go$arrayType(t.jsType, n).reflectType();
		};
	var toType = function(t) {
		if (t === (go$ptrType(rtype)).nil) {
			return null;
		}
		return t;
	};
	var memmove = function(adst, asrc, n) {
		var dst, src, i, i$1, i$2;
		dst = adst;
		src = asrc;
		if (src < dst && (src + n >>> 0) > dst) {
			i = n;
			while (i > 0) {
				i = i - 1 >>> 0;
				(dst + i >>> 0).go$set((src + i >>> 0).go$get());
			}
		} else if (!(((((((((n | src) >>> 0) | dst) >>> 0)) & 3) >>> 0) === 0))) {
			i$1 = 0;
			while (i$1 < n) {
				(dst + i$1 >>> 0).go$set((src + i$1 >>> 0).go$get());
				i$1 = i$1 + 1 >>> 0;
			}
		} else {
			i$2 = 0;
			while (i$2 < n) {
				(dst + i$2 >>> 0).go$set((src + i$2 >>> 0).go$get());
				i$2 = i$2 + 4 >>> 0;
			}
		}
	};
	flag.prototype.kind = function() {
		var f;
		f = this.go$val;
		return (((((f >>> 4 >>> 0)) & 31) >>> 0) >>> 0);
	};
	go$ptrType(flag).prototype.kind = function() { return new flag(this.go$get()).kind(); };
	ValueError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Kind === 0) {
			return "reflect: call of " + e.Method + " on zero Value";
		}
		return "reflect: call of " + e.Method + " on " + (new Kind(e.Kind)).String() + " Value";
	};
	ValueError.prototype.Error = function() { return this.go$val.Error(); };
	var methodName = function() {
			return "?FIXME?";
		};
	Value.Ptr.prototype.iword = function() {
			if ((this.flag & flagIndir) !== 0 && this.typ.Kind() !== Array && this.typ.Kind() !== Struct) {
				return this.val.go$get();
			}
			return this.val;
		};
	Value.prototype.iword = function() { return this.go$val.iword(); };
	var loadIword = function(p, n) {
		var w, _ref, v, v$1, v$2, v$3, v$4, v$5, v$6, v$7;
		w = 0;
		_ref = n;
		if (_ref === 0) {
		} else if (_ref === 1) {
			new (go$ptrType(iword))(function() { return w; }, function(v) { w = v; }).go$set(p.go$get());
		} else if (_ref === 2) {
			new (go$ptrType(iword))(function() { return w; }, function(v$1) { w = v$1; }).go$set(p.go$get());
		} else if (_ref === 3) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$2) { w = v$2; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 4) {
			new (go$ptrType(iword))(function() { return w; }, function(v$3) { w = v$3; }).go$set(p.go$get());
		} else if (_ref === 5) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$4) { w = v$4; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 6) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$5) { w = v$5; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 7) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$6) { w = v$6; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 8) {
			new (go$ptrType(iword))(function() { return w; }, function(v$7) { w = v$7; }).go$set(p.go$get());
		} else {
			throw go$panic(new Go$String("reflect: internal error: loadIword of " + strconv.Itoa((n >> 0)) + "-byte value"));
		}
		return w;
	};
	var storeIword = function(p, w, n) {
		var _ref;
		_ref = n;
		if (_ref === 0) {
		} else if (_ref === 1) {
			p.go$set(w);
		} else if (_ref === 2) {
			p.go$set(w);
		} else if (_ref === 3) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 4) {
			p.go$set(w);
		} else if (_ref === 5) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 6) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 7) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 8) {
			p.go$set(w);
		} else {
			throw go$panic(new Go$String("reflect: internal error: storeIword of " + strconv.Itoa((n >> 0)) + "-byte value"));
		}
	};
	flag.prototype.mustBe = function(expected) {
		var f, k;
		f = this.go$val;
		k = (new flag(f)).kind();
		if (!((k === expected))) {
			throw go$panic(new ValueError.Ptr(methodName(), k));
		}
	};
	go$ptrType(flag).prototype.mustBe = function(expected) { return new flag(this.go$get()).mustBe(expected); };
	flag.prototype.mustBeExported = function() {
		var f;
		f = this.go$val;
		if (f === 0) {
			throw go$panic(new ValueError.Ptr(methodName(), 0));
		}
		if (!((((f & 1) >>> 0) === 0))) {
			throw go$panic(new Go$String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
	};
	go$ptrType(flag).prototype.mustBeExported = function() { return new flag(this.go$get()).mustBeExported(); };
	flag.prototype.mustBeAssignable = function() {
		var f;
		f = this.go$val;
		if (f === 0) {
			throw go$panic(new ValueError.Ptr(methodName(), 0));
		}
		if (!((((f & 1) >>> 0) === 0))) {
			throw go$panic(new Go$String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
		if (((f & 4) >>> 0) === 0) {
			throw go$panic(new Go$String("reflect: " + methodName() + " using unaddressable value"));
		}
	};
	go$ptrType(flag).prototype.mustBeAssignable = function() { return new flag(this.go$get()).mustBeAssignable(); };
	Value.Ptr.prototype.Addr = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (((v.flag & 4) >>> 0) === 0) {
			throw go$panic(new Go$String("reflect.Value.Addr of unaddressable value"));
		}
		return new Value.Ptr(v.typ.ptrTo(), v.val, ((((v.flag & 1) >>> 0)) | 352) >>> 0);
	};
	Value.prototype.Addr = function() { return this.go$val.Addr(); };
	Value.Ptr.prototype.Bool = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(1);
		if (!((((v.flag & 2) >>> 0) === 0))) {
			return v.val.go$get();
		}
		return v.val;
	};
	Value.prototype.Bool = function() { return this.go$val.Bool(); };
	Value.Ptr.prototype.Bytes = function() {
			this.mustBe(Slice);
			if (this.typ.Elem().Kind() !== Uint8) {
				throw go$panic("reflect.Value.Bytes of non-byte slice");
			}
			return this.iword();
		};
	Value.prototype.Bytes = function() { return this.go$val.Bytes(); };
	Value.Ptr.prototype.runes = function() {
			this.mustBe(Slice);
			if (this.typ.Elem().Kind() !== Int32) {
				throw new go$panic("reflect.Value.Bytes of non-rune slice");
			}
			return this.iword();
		};
	Value.prototype.runes = function() { return this.go$val.runes(); };
	Value.Ptr.prototype.CanAddr = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return !((((v.flag & 4) >>> 0) === 0));
	};
	Value.prototype.CanAddr = function() { return this.go$val.CanAddr(); };
	Value.Ptr.prototype.CanSet = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return ((v.flag & 5) >>> 0) === 4;
	};
	Value.prototype.CanSet = function() { return this.go$val.CanSet(); };
	Value.Ptr.prototype.Call = function(in$1) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(19);
		(new flag(v.flag)).mustBeExported();
		return v.call("Call", in$1);
	};
	Value.prototype.Call = function(in$1) { return this.go$val.Call(in$1); };
	Value.Ptr.prototype.CallSlice = function(in$1) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(19);
		(new flag(v.flag)).mustBeExported();
		return v.call("CallSlice", in$1);
	};
	Value.prototype.CallSlice = function(in$1) { return this.go$val.CallSlice(in$1); };
	Value.Ptr.prototype.call = function(op, args) {
			var t = this.typ, fn, rcvr;

			if ((this.flag & flagMethod) !== 0) {
				var tuple = methodReceiver(op, this, this.flag >> flagMethodShift);
				t = tuple[0];
				fn = tuple[1];
				rcvr = tuple[2];
			} else {
				fn = this.iword();
			}

			if (fn === go$throwNilPointerError) {
				throw go$panic("reflect.Value.Call: call of nil function");
			}

			var isSlice = (op === "CallSlice");
			var n = t.NumIn();
			if (isSlice) {
				if (!t.IsVariadic()) {
					throw go$panic("reflect: CallSlice of non-variadic function");
				}
				if (args.length < n) {
					throw go$panic("reflect: CallSlice with too few input arguments");
				}
				if (args.length > n) {
					throw go$panic("reflect: CallSlice with too many input arguments");
				}
			} else {
				if (t.IsVariadic()) {
					n--;
				}
				if (args.length < n) {
					throw go$panic("reflect: Call with too few input arguments");
				}
				if (!t.IsVariadic() && args.length > n) {
					throw go$panic("reflect: Call with too many input arguments");
				}
			}
			var i;
			for (i = 0; i < args.length; i++) {
				if (args.array[args.offset + i].Kind() === Invalid) {
					throw go$panic("reflect: " + op + " using zero Value argument");
				}
			}
			for (i = 0; i < n; i++) {
				var xt = args.array[args.offset + i].Type(), targ = t.In(i);
				if (!xt.AssignableTo(targ)) {
					throw go$panic("reflect: " + op + " using " + xt.String() + " as type " + targ.String());
				}
			}
			if (!isSlice && t.IsVariadic()) {
				var m = args.length - n;
				var slice = MakeSlice(t.In(n), m, m);
				var elem = t.In(n).Elem();
				for (i = 0; i < m; i++) {
					var x = args.array[args.offset + n + i];
					var xt = x.Type();
					if (!xt.AssignableTo(elem)) {
						throw go$panic("reflect: cannot use " + xt.String() + " as type " + elem.String() + " in " + op);
					}
					slice.Index(i).Set(x);
				}
				args = new (go$sliceType(Value))(go$sliceToArray(args).slice(0, n).concat([slice]));
			}

			if (args.length !== t.NumIn()) {
				throw go$panic("reflect.Value.Call: wrong argument count");
			}

			var argsArray = new Go$Array(t.NumIn());
			for (i = 0; i < t.NumIn(); i++) {
				argsArray[i] = args.array[args.offset + i].assignTo("reflect.Value.Call", t.In(i), go$ptrType(go$emptyInterface).nil).iword();
			}
			var results = fn.apply(rcvr, argsArray);
			if (t.NumOut() === 0) {
				results = [];
			} else if (t.NumOut() === 1) {
				results = [results];
			}
			for (i = 0; i < t.NumOut(); i++) {
				var typ = t.Out(i);
				var flag = typ.Kind() << flagKindShift;
				results[i] = new Value.Ptr(typ, results[i], flag);
			}
			return new (go$sliceType(Value))(results);
		};
	Value.prototype.call = function(op, in$1) { return this.go$val.call(op, in$1); };
	var callReflect = function(ctxt, frame) {
		var ftyp, f, ptr, off, in$1, _ref, _i, _slice, _index, arg, typ, v, _struct, out, _ref$1, _i$1, _slice$1, _index$1, arg$1, i, typ$1, _slice$2, _index$2, _struct$1, v$1, _slice$3, _index$3, addr;
		ftyp = ctxt.typ;
		f = ctxt.fn;
		ptr = frame;
		off = 0;
		in$1 = (go$sliceType(Value)).make(0, ftyp.in$2.length, function() { return new Value.Ptr(); });
		_ref = ftyp.in$2;
		_i = 0;
		while (_i < _ref.length) {
			arg = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			typ = arg;
			off = off + ((((-off >>> 0) & ((typ.align - 1 << 24 >>> 24) >>> 0)) >>> 0)) >>> 0;
			v = new Value.Ptr(typ, 0, (typ.Kind() >>> 0) << 4 >>> 0);
			if (typ.size <= 4) {
				v.val = loadIword((ptr + off >>> 0), typ.size);
			} else {
				v.val = unsafe_New(typ);
				memmove(v.val, (ptr + off >>> 0), typ.size);
				v.flag = (v.flag | 2) >>> 0;
			}
			in$1 = go$append(in$1, (_struct = v, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
			off = off + (typ.size) >>> 0;
			_i++;
		}
		out = f(in$1);
		if (!((out.length === ftyp.out.length))) {
			throw go$panic(new Go$String("reflect: wrong return count from function created by MakeFunc"));
		}
		if (ftyp.out.length > 0) {
			off = off + ((((-off >>> 0) & 3) >>> 0)) >>> 0;
			_ref$1 = ftyp.out;
			_i$1 = 0;
			while (_i$1 < _ref$1.length) {
				arg$1 = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				i = _i$1;
				typ$1 = arg$1;
				v$1 = (_struct$1 = (_slice$2 = out, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
				if (!(v$1.typ === typ$1)) {
					throw go$panic(new Go$String("reflect: function created by MakeFunc using " + funcName(f) + " returned wrong type: have " + (_slice$3 = out, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).typ.String() + " for " + typ$1.String()));
				}
				if (!((((v$1.flag & 1) >>> 0) === 0))) {
					throw go$panic(new Go$String("reflect: function created by MakeFunc using " + funcName(f) + " returned value obtained from unexported field"));
				}
				off = off + ((((-off >>> 0) & ((typ$1.align - 1 << 24 >>> 24) >>> 0)) >>> 0)) >>> 0;
				addr = (ptr + off >>> 0);
				if (((v$1.flag & 2) >>> 0) === 0) {
					storeIword(addr, v$1.val, typ$1.size);
				} else {
					memmove(addr, v$1.val, typ$1.size);
				}
				off = off + (typ$1.size) >>> 0;
				_i$1++;
			}
		}
	};
	var methodReceiver = function(op, v, i) {
			var m, t;
			if (v.typ.Kind() === Interface) {
				var tt = v.typ.interfaceType;
				if (i < 0 || i >= tt.methods.length) {
					throw go$panic("reflect: internal error: invalid method index");
				}
				if (v.IsNil()) {
					throw go$panic("reflect: " + op + " of method on nil interface value");
				}
				m = tt.methods.array[i];
				t = m.typ;
			} else {
				var ut = v.typ.uncommon();
				if (ut === uncommonType.Ptr.nil || i < 0 || i >= ut.methods.length) {
					throw go$panic("reflect: internal error: invalid method index");
				}
				m = ut.methods.array[i];
				t = m.mtyp;
			}
			if (m.pkgPath.go$get !== go$throwNilPointerError) {
				throw go$panic("reflect: " + op + " of unexported method");
			}
			var name = m.name.go$get()
			if (go$reservedKeywords.indexOf(name) !== -1) {
				name += "$";
			}
			var rcvr = v.iword();
			if (isWrapped(v.typ)) {
				rcvr = new v.typ.jsType(rcvr);
			}
			return [t, rcvr[name], rcvr];
		};
	var align = function(x, n) {
		return (((x + n >>> 0) - 1 >>> 0)) & ~((n - 1 >>> 0));
	};
	var frameSize = function(t, rcvr) {
		var total, in$1, outOffset, out, nin, i, tv, nout, i$1, tv$1;
		total = 0;
		in$1 = 0;
		outOffset = 0;
		out = 0;
		if (rcvr) {
			total = total + 4 >>> 0;
		}
		nin = t.NumIn();
		in$1 = -total >>> 0;
		i = 0;
		while (i < nin) {
			tv = t.In(i);
			total = align(total, (tv.Align() >>> 0));
			total = total + (tv.Size()) >>> 0;
			i = i + 1 >> 0;
		}
		in$1 = in$1 + (total) >>> 0;
		total = align(total, 4);
		nout = t.NumOut();
		outOffset = total;
		out = -total >>> 0;
		i$1 = 0;
		while (i$1 < nout) {
			tv$1 = t.Out(i$1);
			total = align(total, (tv$1.Align() >>> 0));
			total = total + (tv$1.Size()) >>> 0;
			i$1 = i$1 + 1 >> 0;
		}
		out = out + (total) >>> 0;
		if (total < 4) {
			total = 4;
		}
		total = align(total, 4);
		return [total, in$1, outOffset, out];
	};
	var callMethod = function(ctxt, frame) {
		var _tuple, _struct, t, fn, rcvr, _tuple$1, total, in$1, outOffset, out, _q, args, _slice, _index, base;
		_tuple = methodReceiver("call", (_struct = ctxt.rcvr, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), ctxt.method), t = _tuple[0], fn = _tuple[1], rcvr = _tuple[2];
		_tuple$1 = frameSize(t, true), total = _tuple$1[0], in$1 = _tuple$1[1], outOffset = _tuple$1[2], out = _tuple$1[3];
		args = (go$sliceType(Go$UnsafePointer)).make((_q = total / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero")), 0, function() { return 0; });
		_slice = args, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = rcvr) : go$throwRuntimeError("index out of range");
		base = go$sliceToArray(args);
		memmove((base + 4 >>> 0), frame, in$1);
		call(fn, go$sliceToArray(args), (total >>> 0));
		memmove(((frame + outOffset >>> 0) - 4 >>> 0), (base + outOffset >>> 0), out);
	};
	var funcName = function(f) {
		var pc, rf;
		pc = f;
		rf = runtime.FuncForPC(pc);
		if (!(rf === (go$ptrType(runtime.Func)).nil)) {
			return rf.Name();
		}
		return "closure";
	};
	Value.Ptr.prototype.Cap = function() {
			var k = this.kind();
			switch (k) {
			case Slice:
				return this.iword().capacity;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Cap", k));
		};
	Value.prototype.Cap = function() { return this.go$val.Cap(); };
	Value.Ptr.prototype.Close = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		chanclose(v.iword());
	};
	Value.prototype.Close = function() { return this.go$val.Close(); };
	Value.Ptr.prototype.Complex = function() {
			return this.iword();
		};
	Value.prototype.Complex = function() { return this.go$val.Complex(); };
	Value.Ptr.prototype.Elem = function() {
			switch (this.kind()) {
			case Interface:
				var val = this.iword();
				if (val === null) {
					return new Value.Ptr();
				}
				if (val.constructor.kind === undefined) { // js.Object
					return new Value.Ptr(Go$String.reflectType(), String(val), String << flagKindShift);
				}
				var typ = val.constructor.reflectType();
				var fl = this.flag & flagRO;
				fl |= typ.Kind() << flagKindShift;
				return new Value.Ptr(typ, val.go$val, fl);

			case Ptr:
				var val = this.iword();
				if (this.IsNil()) {
					return new Value.Ptr();
				}
				var tt = this.typ.ptrType;
				var fl = (this.flag & flagRO) | flagIndir | flagAddr;
				fl |= tt.elem.Kind() << flagKindShift;
				return new Value.Ptr(tt.elem, val, fl);
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Elem", this.kind()));
		};
	Value.prototype.Elem = function() { return this.go$val.Elem(); };
	Value.Ptr.prototype.Field = function(i) {
			this.mustBe(Struct);
			var tt = this.typ.structType;
			if (i < 0 || i >= tt.fields.length) {
				throw go$panic("reflect: Field index out of range");
			}
			var field = tt.fields.array[i];
			var name = fieldName(field, i);
			var typ = field.typ;
			var fl = this.flag & (flagRO | flagIndir | flagAddr);
			if (field.pkgPath.go$get !== go$throwNilPointerError) {
				fl |= flagRO;
			}
			fl |= typ.Kind() << flagKindShift;
			if ((this.flag & flagIndir) !== 0 && typ.Kind() !== Array && typ.Kind() !== Struct) {
				var struct = this.val;
				return new Value.Ptr(typ, new (go$ptrType(typ.jsType))(function() { return struct[name]; }, function(v) { struct[name] = v; }), fl);
			}
			return new Value.Ptr(typ, this.val[name], fl);
		};
	Value.prototype.Field = function(i) { return this.go$val.Field(i); };
	Value.Ptr.prototype.FieldByIndex = function(index) {
		var _struct, v, _ref, _i, _slice, _index, x, i, _struct$1, _struct$2, _struct$3;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		_ref = index;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (i > 0) {
				if ((v.Kind() === 22) && (v.Elem().Kind() === 25)) {
					v = (_struct$1 = v.Elem(), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
				}
			}
			v = (_struct$2 = v.Field(x), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
			_i++;
		}
		return (_struct$3 = v, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
	Value.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	Value.Ptr.prototype.FieldByName = function(name) {
		var _struct, v, ok, _tuple, _struct$1, f, _struct$2;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		if (_tuple = v.typ.FieldByName(name), f = (_struct$1 = _tuple[0], new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), ok = _tuple[1], ok) {
			return (_struct$2 = v.FieldByIndex(f.Index), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
	};
	Value.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	Value.Ptr.prototype.FieldByNameFunc = function(match) {
		var _struct, v, ok, _tuple, _struct$1, f, _struct$2;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		if (_tuple = v.typ.FieldByNameFunc(match), f = (_struct$1 = _tuple[0], new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), ok = _tuple[1], ok) {
			return (_struct$2 = v.FieldByIndex(f.Index), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
	};
	Value.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	Value.Ptr.prototype.Float = function() {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 13) {
			if (!((((v.flag & 2) >>> 0) === 0))) {
				return v.val.go$get();
			}
			return v.val;
		} else if (_ref === 14) {
			if (!((((v.flag & 2) >>> 0) === 0))) {
				return v.val.go$get();
			}
			return v.val;
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.Float", k));
	};
	Value.prototype.Float = function() { return this.go$val.Float(); };
	Value.Ptr.prototype.Index = function(i) {
			var k = this.kind();
			switch (k) {
			case Array:
				var tt = this.typ.arrayType;
				if (i < 0 || i >= tt.len) {
					throw go$panic("reflect: array index out of range");
				}
				var typ = tt.elem;
				var fl = this.flag & (flagRO | flagIndir | flagAddr);
				fl |= typ.Kind() << flagKindShift;
				if ((this.flag & flagIndir) !== 0 && typ.Kind() !== Array && typ.Kind() !== Struct) {
					var array = this.val;
					return new Value.Ptr(typ, new (go$ptrType(typ.jsType))(function() { return array[i]; }, function(v) { array[i] = v; }), fl);
				}
				return new Value.Ptr(typ, this.iword()[i], fl);
			case Slice:
				if (i < 0 || i >= this.iword().length) {
					throw go$panic("reflect: slice index out of range");
				}
				var typ = this.typ.sliceType.elem;
				var fl = flagAddr | flagIndir | (this.flag & flagRO);
				fl |= typ.Kind() << flagKindShift;
				i += this.iword().offset;
				var array = this.iword().array;
				if (typ.Kind() === Struct) {
					return new Value.Ptr(typ, array[i], fl);
				}
				return new Value.Ptr(typ, new (go$ptrType(typ.jsType))(function() { return array[i]; }, function(v) { array[i] = v; }), fl);
			case String:
				var string = this.iword();
				if (i < 0 || i >= string.length) {
					throw go$panic("reflect: string index out of range");
				}
				var fl = (this.flag & flagRO) | (Uint8 << flagKindShift);
				return new Value.Ptr(uint8Type, string.charCodeAt(i), fl);
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Index", k));
		};
	Value.prototype.Index = function(i) { return this.go$val.Index(i); };
	Value.Ptr.prototype.Int = function() {
		var _struct, v, k, p, v$1, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		p = 0;
		if (!((((v.flag & 2) >>> 0) === 0))) {
			p = v.val;
		} else {
			p = new (go$ptrType(Go$UnsafePointer))(function() { return v.val; }, function(v$1) { v.val = v$1; });
		}
		_ref = k;
		if (_ref === 2) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 3) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 4) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 5) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 6) {
			return p.go$get();
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.Int", k));
	};
	Value.prototype.Int = function() { return this.go$val.Int(); };
	Value.Ptr.prototype.CanInterface = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.flag === 0) {
			throw go$panic(new ValueError.Ptr("reflect.Value.CanInterface", 0));
		}
		return ((v.flag & 1) >>> 0) === 0;
	};
	Value.prototype.CanInterface = function() { return this.go$val.CanInterface(); };
	Value.Ptr.prototype.Interface = function() {
		var i, _struct, v, _struct$1;
		i = null;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		i = valueInterface((_struct$1 = v, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), true);
		return i;
	};
	Value.prototype.Interface = function() { return this.go$val.Interface(); };
	var valueInterface = function(v, safe) {
			if (v.flag === 0) {
				throw go$panic(new ValueError.Ptr("reflect.Value.Interface", 0));
			}
			if (safe && (v.flag & flagRO) !== 0) {
				throw go$panic("reflect.Value.Interface: cannot return value obtained from unexported field or method")
			}
			if ((v.flag & flagMethod) !== 0) {
				v = makeMethodValue("Interface", v);
			}
			if (isWrapped(v.typ)) {
				return new v.typ.jsType(v.iword());
			}
			return v.iword();
		};
	Value.Ptr.prototype.InterfaceData = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(20);
		return go$mapArray(v.val, function(entry) { return entry; });
	};
	Value.prototype.InterfaceData = function() { return this.go$val.InterfaceData(); };
	Value.Ptr.prototype.IsNil = function() {
			switch (this.kind()) {
			case Chan:
			case Ptr:
			case Slice:
				return this.iword() === this.typ.jsType.nil;
			case Func:
				return this.iword() === go$throwNilPointerError;
			case Map:
				return this.iword() === false;
			case Interface:
				return this.iword() === null;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.IsNil", this.kind()));
		};
	Value.prototype.IsNil = function() { return this.go$val.IsNil(); };
	Value.Ptr.prototype.IsValid = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return !((v.flag === 0));
	};
	Value.prototype.IsValid = function() { return this.go$val.IsValid(); };
	Value.Ptr.prototype.Kind = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return (new flag(v.flag)).kind();
	};
	Value.prototype.Kind = function() { return this.go$val.Kind(); };
	Value.Ptr.prototype.Len = function() {
			var k = this.kind();
			switch (k) {
			case Array:
			case Slice:
			case String:
				return this.iword().length;
			case Map:
				return go$keys(this.iword()).length;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Len", k));
		};
	Value.prototype.Len = function() { return this.go$val.Len(); };
	Value.Ptr.prototype.MapIndex = function(key) {
		var _struct, v, tt, _struct$1, _tuple, word, ok, typ, fl;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(21);
		tt = v.typ.mapType;
		key = (_struct$1 = key.assignTo("reflect.Value.MapIndex", tt.key, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		_tuple = mapaccess(v.typ, v.iword(), key.iword()), word = _tuple[0], ok = _tuple[1];
		if (!ok) {
			return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
		}
		typ = tt.elem;
		fl = ((((v.flag | key.flag) >>> 0)) & 1) >>> 0;
		if (typ.size > 4) {
			fl = (fl | 2) >>> 0;
		}
		fl = (fl | (((typ.Kind() >>> 0) << 4 >>> 0))) >>> 0;
		return new Value.Ptr(typ, word, fl);
	};
	Value.prototype.MapIndex = function(key) { return this.go$val.MapIndex(key); };
	Value.Ptr.prototype.MapKeys = function() {
		var _struct, v, tt, keyType, fl, m, mlen, it, a, i, _tuple, keyWord, ok, _slice, _index;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(21);
		tt = v.typ.mapType;
		keyType = tt.key;
		fl = (v.flag & 1) >>> 0;
		fl = (fl | (((keyType.Kind() >>> 0) << 4 >>> 0))) >>> 0;
		if (keyType.size > 4) {
			fl = (fl | 2) >>> 0;
		}
		m = v.iword();
		mlen = 0;
		if (!(m === 0)) {
			mlen = maplen(m);
		}
		it = mapiterinit(v.typ, m);
		a = (go$sliceType(Value)).make(mlen, 0, function() { return new Value.Ptr(); });
		i = 0;
		i = 0;
		while (i < a.length) {
			_tuple = mapiterkey(it), keyWord = _tuple[0], ok = _tuple[1];
			if (!ok) {
				break;
			}
			_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = new Value.Ptr(keyType, keyWord, fl)) : go$throwRuntimeError("index out of range");
			mapiternext(it);
			i = i + 1 >> 0;
		}
		return go$subslice(a, 0, i);
	};
	Value.prototype.MapKeys = function() { return this.go$val.MapKeys(); };
	Value.Ptr.prototype.Method = function(i) {
		var _struct, v, fl;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.Method", 0));
		}
		if (!((((v.flag & 8) >>> 0) === 0)) || i < 0 || i >= v.typ.NumMethod()) {
			throw go$panic(new Go$String("reflect: Method index out of range"));
		}
		if ((v.typ.Kind() === 20) && v.IsNil()) {
			throw go$panic(new Go$String("reflect: Method on nil interface value"));
		}
		fl = (v.flag & 3) >>> 0;
		fl = (fl | 304) >>> 0;
		fl = (fl | (((((i >>> 0) << 9 >>> 0) | 8) >>> 0))) >>> 0;
		return new Value.Ptr(v.typ, v.val, fl);
	};
	Value.prototype.Method = function(i) { return this.go$val.Method(i); };
	Value.Ptr.prototype.NumMethod = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.NumMethod", 0));
		}
		if (!((((v.flag & 8) >>> 0) === 0))) {
			return 0;
		}
		return v.typ.NumMethod();
	};
	Value.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	Value.Ptr.prototype.MethodByName = function(name) {
		var _struct, v, _tuple, _struct$1, _struct$2, m, ok, _struct$3;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.MethodByName", 0));
		}
		if (!((((v.flag & 8) >>> 0) === 0))) {
			return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
		}
		_tuple = v.typ.MethodByName(name), m = (_struct$1 = _tuple[0], new Method.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, (_struct$2 = _struct$1.Func, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), _struct$1.Index)), ok = _tuple[1];
		if (!ok) {
			return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
		}
		return (_struct$3 = v.Method(m.Index), new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
	Value.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	Value.Ptr.prototype.NumField = function() {
		var _struct, v, tt;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		tt = v.typ.structType;
		return tt.fields.length;
	};
	Value.prototype.NumField = function() { return this.go$val.NumField(); };
	Value.Ptr.prototype.OverflowComplex = function(x) {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 15) {
			return overflowFloat32(x.real) || overflowFloat32(x.imag);
		} else if (_ref === 16) {
			return false;
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowComplex", k));
	};
	Value.prototype.OverflowComplex = function(x) { return this.go$val.OverflowComplex(x); };
	Value.Ptr.prototype.OverflowFloat = function(x) {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 13) {
			return overflowFloat32(x);
		} else if (_ref === 14) {
			return false;
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowFloat", k));
	};
	Value.prototype.OverflowFloat = function(x) { return this.go$val.OverflowFloat(x); };
	var overflowFloat32 = function(x) {
		if (x < 0) {
			x = -x;
		}
		return 3.4028234663852886e+38 < x && x <= 1.7976931348623157e+308;
	};
	Value.Ptr.prototype.OverflowInt = function(x) {
		var _struct, v, k, _ref, x$1, x$2, bitSize, trunc;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			bitSize = (x$1 = v.typ.size, x$2 = 8, (((x$1 >>> 16 << 16) * x$2 >>> 0) + (x$1 << 16 >>> 16) * x$2) >>> 0);
			trunc = go$shiftRightInt64((go$shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.high === trunc.high && x.low === trunc.low));
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowInt", k));
	};
	Value.prototype.OverflowInt = function(x) { return this.go$val.OverflowInt(x); };
	Value.Ptr.prototype.OverflowUint = function(x) {
		var _struct, v, k, _ref, x$1, x$2, bitSize, trunc;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 7 || _ref === 12 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11) {
			bitSize = (x$1 = v.typ.size, x$2 = 8, (((x$1 >>> 16 << 16) * x$2 >>> 0) + (x$1 << 16 >>> 16) * x$2) >>> 0);
			trunc = go$shiftRightUint64((go$shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.high === trunc.high && x.low === trunc.low));
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowUint", k));
	};
	Value.prototype.OverflowUint = function(x) { return this.go$val.OverflowUint(x); };
	Value.Ptr.prototype.Pointer = function() {
			var k = this.kind();
			switch (k) {
			case Chan:
			case Map:
			case Ptr:
			case Slice:
			case UnsafePointer:
				if (this.IsNil()) {
					return 0;
				}
				return this.iword();
			case Func:
				if (this.IsNil()) {
					return 0;
				}
				return 1;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Pointer", k));
		};
	Value.prototype.Pointer = function() { return this.go$val.Pointer(); };
	Value.Ptr.prototype.Recv = function() {
		var x, ok, _struct, v, _tuple, _struct$1, _struct$2;
		x = new Value.Ptr();
		ok = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		_tuple = v.recv(false), x = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), ok = _tuple[1];
		return [(_struct$2 = x, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), ok];
	};
	Value.prototype.Recv = function() { return this.go$val.Recv(); };
	Value.Ptr.prototype.recv = function(nb) {
		var val, ok, _struct, v, tt, _tuple, word, selected, typ, fl, _struct$1;
		val = new Value.Ptr();
		ok = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		tt = v.typ.chanType;
		if (((tt.dir >> 0) & 1) === 0) {
			throw go$panic(new Go$String("reflect: recv on send-only channel"));
		}
		_tuple = chanrecv(v.typ, v.iword(), nb), word = _tuple[0], selected = _tuple[1], ok = _tuple[2];
		if (selected) {
			typ = tt.elem;
			fl = (typ.Kind() >>> 0) << 4 >>> 0;
			if (typ.size > 4) {
				fl = (fl | 2) >>> 0;
			}
			val = new Value.Ptr(typ, word, fl);
		}
		return [(_struct$1 = val, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), ok];
	};
	Value.prototype.recv = function(nb) { return this.go$val.recv(nb); };
	Value.Ptr.prototype.Send = function(x) {
		var _struct, v, _struct$1;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		v.send((_struct$1 = x, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), false);
	};
	Value.prototype.Send = function(x) { return this.go$val.Send(x); };
	Value.Ptr.prototype.send = function(x, nb) {
		var selected, _struct, v, tt, _struct$1;
		selected = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		tt = v.typ.chanType;
		if (((tt.dir >> 0) & 2) === 0) {
			throw go$panic(new Go$String("reflect: send on recv-only channel"));
		}
		(new flag(x.flag)).mustBeExported();
		x = (_struct$1 = x.assignTo("reflect.Value.Send", tt.elem, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		selected = chansend(v.typ, v.iword(), x.iword(), nb);
		return selected;
	};
	Value.prototype.send = function(x, nb) { return this.go$val.send(x, nb); };
	Value.Ptr.prototype.Set = function(x) {
			this.mustBeAssignable();
			x.mustBeExported();
			if ((this.flag & flagIndir) !== 0) {
				switch (this.typ.Kind()) {
				case Array:
					go$copyArray(this.val, x.val);
					return;
				case Interface:
					this.val.go$set(valueInterface(x, false));
					return;
				case Struct:
					copyStruct(this.val, x.val, this.typ);
					return;
				default:
					this.val.go$set(x.iword());
					return;
				}
			}
			this.val = x.val;
		};
	Value.prototype.Set = function(x) { return this.go$val.Set(x); };
	Value.Ptr.prototype.SetBool = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(1);
		v.val.go$set(x);
	};
	Value.prototype.SetBool = function(x) { return this.go$val.SetBool(x); };
	Value.Ptr.prototype.SetBytes = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(23);
		if (!((v.typ.Elem().Kind() === 8))) {
			throw go$panic(new Go$String("reflect.Value.SetBytes of non-byte slice"));
		}
		v.val.go$set(x);
	};
	Value.prototype.SetBytes = function(x) { return this.go$val.SetBytes(x); };
	Value.Ptr.prototype.setRunes = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(23);
		if (!((v.typ.Elem().Kind() === 5))) {
			throw go$panic(new Go$String("reflect.Value.setRunes of non-rune slice"));
		}
		v.val.go$set(x);
	};
	Value.prototype.setRunes = function(x) { return this.go$val.setRunes(x); };
	Value.Ptr.prototype.SetComplex = function(x) {
			this.mustBeAssignable();
			var k = this.kind();
			switch (k) {
			case Complex64:
			case Complex128:
				this.val.go$set(new this.typ.jsType(x.real, x.imag));
				return;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.SetComplex", k));
		};
	Value.prototype.SetComplex = function(x) { return this.go$val.SetComplex(x); };
	Value.Ptr.prototype.SetFloat = function(x) {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 13) {
			v.val.go$set(x);
		} else if (_ref === 14) {
			v.val.go$set(x);
		} else {
			throw go$panic(new ValueError.Ptr("reflect.Value.SetFloat", k));
		}
	};
	Value.prototype.SetFloat = function(x) { return this.go$val.SetFloat(x); };
	Value.Ptr.prototype.SetInt = function(x) {
			this.mustBeAssignable();
			var k = this.kind();
			switch (k) {
			case Int:
			case Int8:
			case Int16:
			case Int32:
				this.val.go$set(go$flatten64(x));
				return;
			case Int64:
				this.val.go$set(new this.typ.jsType(x.high, x.low));
				return;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.SetInt", k));
		};
	Value.prototype.SetInt = function(x) { return this.go$val.SetInt(x); };
	Value.Ptr.prototype.SetLen = function(n) {
			this.mustBeAssignable();
			this.mustBe(Slice);
			var s = this.val.go$get();
			if (n < 0 || n > s.capacity) {
				throw go$panic("reflect: slice length out of range in SetLen");
			}
			var newSlice = new this.typ.jsType(s.array);
			newSlice.offset = s.offset;
			newSlice.length = n;
			newSlice.capacity = s.capacity;
			this.val.go$set(newSlice);
		};
	Value.prototype.SetLen = function(n) { return this.go$val.SetLen(n); };
	Value.Ptr.prototype.SetCap = function(n) {
			this.mustBeAssignable();
			this.mustBe(Slice);
			var s = this.val.go$get();
			if (n < s.length || n > s.capacity) {
				throw go$panic("reflect: slice capacity out of range in SetCap");
			}
			var newSlice = new this.typ.jsType(s.array);
			newSlice.offset = s.offset;
			newSlice.length = s.length;
			newSlice.capacity = n;
			this.val.go$set(newSlice);
		};
	Value.prototype.SetCap = function(n) { return this.go$val.SetCap(n); };
	Value.Ptr.prototype.SetMapIndex = function(key, val) {
		var _struct, v, tt, _struct$1, _struct$2;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(21);
		(new flag(v.flag)).mustBeExported();
		(new flag(key.flag)).mustBeExported();
		tt = v.typ.mapType;
		key = (_struct$1 = key.assignTo("reflect.Value.SetMapIndex", tt.key, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(val.typ === (go$ptrType(rtype)).nil)) {
			(new flag(val.flag)).mustBeExported();
			val = (_struct$2 = val.assignTo("reflect.Value.SetMapIndex", tt.elem, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		mapassign(v.typ, v.iword(), key.iword(), val.iword(), !(val.typ === (go$ptrType(rtype)).nil));
	};
	Value.prototype.SetMapIndex = function(key, val) { return this.go$val.SetMapIndex(key, val); };
	Value.Ptr.prototype.SetUint = function(x) {
			this.mustBeAssignable();
			var k = this.kind();
			switch (k) {
			case Uint:
			case Uint8:
			case Uint16:
			case Uint32:
			case Uintptr:
				this.val.go$set(x.low);
				return;
			case Uint64:
				this.val.go$set(new this.typ.jsType(x.high, x.low));
				return;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.SetUint", k));
		};
	Value.prototype.SetUint = function(x) { return this.go$val.SetUint(x); };
	Value.Ptr.prototype.SetPointer = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(26);
		v.val.go$set(x);
	};
	Value.prototype.SetPointer = function(x) { return this.go$val.SetPointer(x); };
	Value.Ptr.prototype.SetString = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(24);
		v.val.go$set(x);
	};
	Value.prototype.SetString = function(x) { return this.go$val.SetString(x); };
	Value.Ptr.prototype.Slice = function(i, j) {
			var typ, s, cap;
			var kind = this.kind();
			switch (kind) {
			case Array:
				if ((this.flag & flagAddr) === 0) {
					throw go$panic("reflect.Value.Slice: slice of unaddressable array");
				}
				var tt = this.typ.arrayType;
				cap = tt.len;
				typ = SliceOf(tt.elem);
				s = new typ.jsType(this.iword());
				break;
			case Slice:
				typ = this.typ.sliceType;
				s = this.iword();
				cap = s.capacity;
				break;
			case String:
				s = this.iword();
				if (i < 0 || j < i || j > s.length) {
					throw go$panic("reflect.Value.Slice: string slice index out of bounds");
				}
				return new Value.Ptr(this.typ, s.substring(i, j), this.flag);
			default:
				throw go$panic(new ValueError.Ptr("reflect.Value.Slice", kind));
			}

			if (i < 0 || j < i || j > cap) {
				throw go$panic("reflect.Value.Slice: slice index out of bounds");
			}

			var fl = (this.flag & flagRO) | (Slice << flagKindShift);
			return new Value.Ptr(typ.common(), go$subslice(s, i, j), fl);
		};
	Value.prototype.Slice = function(i, j) { return this.go$val.Slice(i, j); };
	Value.Ptr.prototype.Slice3 = function(i, j, k) {
			var typ, s, cap;
			var kind = this.kind();
			switch (kind) {
			case Array:
				if ((this.flag & flagAddr) === 0) {
					throw go$panic("reflect.Value.Slice3: slice of unaddressable array");
				}
				var tt = this.typ.arrayType;
				cap = tt.len;
				typ = SliceOf(tt.elem);
				s = new typ.jsType(this.iword());
				break;
			case Slice:
				typ = this.typ.sliceType;
				s = this.iword();
				cap = s.capacity;
				break;
			default:
				throw go$panic(new ValueError.Ptr("reflect.Value.Slice3", kind));
			}

			if (i < 0 || j < i || k < j || k > cap) {
				throw go$panic("reflect.Value.Slice3: slice index out of bounds");
			}

			var fl = (this.flag & flagRO) | (Slice << flagKindShift);
			return new Value.Ptr(typ.common(), go$subslice(s, i, j, k), fl);
		};
	Value.prototype.Slice3 = function(i, j, k) { return this.go$val.Slice3(i, j, k); };
	Value.Ptr.prototype.String = function() {
			switch (this.kind()) {
			case Invalid:
				return "<invalid Value>";
			case String:
				return this.iword();
			}
			return "<" + this.typ.String() + " Value>";
		};
	Value.prototype.String = function() { return this.go$val.String(); };
	Value.Ptr.prototype.TryRecv = function() {
		var x, ok, _struct, v, _tuple, _struct$1, _struct$2;
		x = new Value.Ptr();
		ok = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		_tuple = v.recv(true), x = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), ok = _tuple[1];
		return [(_struct$2 = x, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), ok];
	};
	Value.prototype.TryRecv = function() { return this.go$val.TryRecv(); };
	Value.Ptr.prototype.TrySend = function(x) {
		var _struct, v, _struct$1;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		return v.send((_struct$1 = x, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), true);
	};
	Value.prototype.TrySend = function(x) { return this.go$val.TrySend(x); };
	Value.Ptr.prototype.Type = function() {
		var _struct, v, f, i, tt, _slice, _index, m, ut, _slice$1, _index$1, m$1;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		f = v.flag;
		if (f === 0) {
			throw go$panic(new ValueError.Ptr("reflect.Value.Type", 0));
		}
		if (((f & 8) >>> 0) === 0) {
			return v.typ;
		}
		i = (v.flag >> 0) >> 9 >> 0;
		if (v.typ.Kind() === 20) {
			tt = v.typ.interfaceType;
			if (i < 0 || i >= tt.methods.length) {
				throw go$panic(new Go$String("reflect: internal error: invalid method index"));
			}
			m = (_slice = tt.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			return m.typ;
		}
		ut = v.typ.uncommonType.uncommon();
		if (ut === (go$ptrType(uncommonType)).nil || i < 0 || i >= ut.methods.length) {
			throw go$panic(new Go$String("reflect: internal error: invalid method index"));
		}
		m$1 = (_slice$1 = ut.methods, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
		return m$1.mtyp;
	};
	Value.prototype.Type = function() { return this.go$val.Type(); };
	Value.Ptr.prototype.Uint = function() {
		var _struct, v, k, p, v$1, _ref, x;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		p = 0;
		if (!((((v.flag & 2) >>> 0) === 0))) {
			p = v.val;
		} else {
			p = new (go$ptrType(Go$UnsafePointer))(function() { return v.val; }, function(v$1) { v.val = v$1; });
		}
		_ref = k;
		if (_ref === 7) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 8) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 9) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 10) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 11) {
			return p.go$get();
		} else if (_ref === 12) {
			return (x = p.go$get(), new Go$Uint64(0, x.constructor === Number ? x : 1));
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.Uint", k));
	};
	Value.prototype.Uint = function() { return this.go$val.Uint(); };
	Value.Ptr.prototype.UnsafeAddr = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.UnsafeAddr", 0));
		}
		if (((v.flag & 4) >>> 0) === 0) {
			throw go$panic(new Go$String("reflect.Value.UnsafeAddr of unaddressable value"));
		}
		return v.val;
	};
	Value.prototype.UnsafeAddr = function() { return this.go$val.UnsafeAddr(); };
	var typesMustMatch = function(what, t1, t2) {
		if (!(go$interfaceIsEqual(t1, t2))) {
			throw go$panic(new Go$String(what + ": " + t1.String() + " != " + t2.String()));
		}
	};
	var grow = function(s, extra) {
		var i0, i1, m, _struct, _q, _struct$1, t, _struct$2, _struct$3, _struct$4;
		i0 = s.Len();
		i1 = i0 + extra >> 0;
		if (i1 < i0) {
			throw go$panic(new Go$String("reflect.Append: slice overflow"));
		}
		m = s.Cap();
		if (i1 <= m) {
			return [(_struct = s.Slice(0, i1), new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), i0, i1];
		}
		if (m === 0) {
			m = extra;
		} else {
			while (m < i1) {
				if (i0 < 1024) {
					m = m + (m) >> 0;
				} else {
					m = m + ((_q = m / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"))) >> 0;
				}
			}
		}
		t = (_struct$1 = MakeSlice(s.Type(), i1, m), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		Copy((_struct$2 = t, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), (_struct$3 = s, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
		return [(_struct$4 = t, new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), i0, i1];
	};
	var Append = go$pkg.Append = function(s, x) {
		var _tuple, _struct, _struct$1, i0, i1, _tuple$1, i, j, _tuple$2, _slice, _index, _struct$2, _struct$3;
		(new flag(s.flag)).mustBe(23);
		_tuple = grow((_struct = s, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), x.length), s = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), i0 = _tuple[1], i1 = _tuple[2];
		_tuple$1 = [i0, 0], i = _tuple$1[0], j = _tuple$1[1];
		while (i < i1) {
			s.Index(i).Set((_struct$2 = (_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)));
			_tuple$2 = [i + 1 >> 0, j + 1 >> 0], i = _tuple$2[0], j = _tuple$2[1];
		}
		return (_struct$3 = s, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
	var AppendSlice = go$pkg.AppendSlice = function(s, t) {
		var _tuple, _struct, _struct$1, i0, i1, _struct$2, _struct$3, _struct$4;
		(new flag(s.flag)).mustBe(23);
		(new flag(t.flag)).mustBe(23);
		typesMustMatch("reflect.AppendSlice", s.Type().Elem(), t.Type().Elem());
		_tuple = grow((_struct = s, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), t.Len()), s = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), i0 = _tuple[1], i1 = _tuple[2];
		Copy((_struct$2 = s.Slice(i0, i1), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), (_struct$3 = t, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
		return (_struct$4 = s, new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
	};
	var Copy = go$pkg.Copy = function(dst, src) {
			var dk = dst.kind();
			if (dk !== Array && dk !== Slice) {
				throw go$panic(new ValueError.Ptr("reflect.Copy", dk));
			}
			if (dk === Array) {
				dst.mustBeAssignable();
			}
			dst.mustBeExported();

			var sk = src.kind();
			if (sk !== Array && sk != Slice) {
				throw go$panic(new ValueError.Ptr("reflect.Copy", sk));
			}
			src.mustBeExported();

			typesMustMatch("reflect.Copy", dst.typ.Elem(), src.typ.Elem());

			var dstVal = dst.iword();
			if (dk === Array) {
				dstVal = new (go$sliceType(dst.typ.Elem().jsType))(dstVal);
			}
			var srcVal = src.iword();
			if (sk === Array) {
				srcVal = new (go$sliceType(src.typ.Elem().jsType))(srcVal);
			}
			return go$copySlice(dstVal, srcVal);
		};
	var rselect = function() {
		throw go$panic("Native function not implemented: rselect");
	};
	var Select = go$pkg.Select = function(cases) {
		var chosen, recv, recvOK, runcases, haveDefault, _ref, _i, _slice, _index, _struct, _struct$1, _struct$2, c, i, _slice$1, _index$1, rc, _ref$1, _struct$3, ch, tt, _struct$4, v, _struct$5, _struct$6, ch$1, tt$1, _tuple, word, _slice$2, _index$2, _slice$3, _index$3, tt$2, typ, fl, _struct$7, _tuple$1, _struct$8;
		chosen = 0;
		recv = new Value.Ptr();
		recvOK = false;
		runcases = (go$sliceType(runtimeSelect)).make(cases.length, 0, function() { return new runtimeSelect.Ptr(); });
		haveDefault = false;
		_ref = cases;
		_i = 0;
		while (_i < _ref.length) {
			c = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new SelectCase.Ptr(_struct.Dir, (_struct$1 = _struct.Chan, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), (_struct$2 = _struct.Send, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag))));
			i = _i;
			rc = (_slice$1 = runcases, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			rc.dir = (c.Dir >>> 0);
			_ref$1 = c.Dir;
			switch (0) { default: if (_ref$1 === 3) {
				if (haveDefault) {
					throw go$panic(new Go$String("reflect.Select: multiple default cases"));
				}
				haveDefault = true;
				if (c.Chan.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: default case has Chan value"));
				}
				if (c.Send.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: default case has Send value"));
				}
			} else if (_ref$1 === 1) {
				ch = (_struct$3 = c.Chan, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
				if (!ch.IsValid()) {
					break;
				}
				(new flag(ch.flag)).mustBe(18);
				(new flag(ch.flag)).mustBeExported();
				tt = ch.typ.chanType;
				if (((tt.dir >> 0) & 2) === 0) {
					throw go$panic(new Go$String("reflect.Select: SendDir case using recv-only channel"));
				}
				rc.ch = ch.iword();
				rc.typ = tt.rtype;
				v = (_struct$4 = c.Send, new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
				if (!v.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: SendDir case missing Send value"));
				}
				(new flag(v.flag)).mustBeExported();
				v = (_struct$5 = v.assignTo("reflect.Select", tt.elem, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag));
				rc.val = v.iword();
			} else if (_ref$1 === 2) {
				if (c.Send.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: RecvDir case has Send value"));
				}
				ch$1 = (_struct$6 = c.Chan, new Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag));
				if (!ch$1.IsValid()) {
					break;
				}
				(new flag(ch$1.flag)).mustBe(18);
				(new flag(ch$1.flag)).mustBeExported();
				tt$1 = ch$1.typ.chanType;
				rc.typ = tt$1.rtype;
				if (((tt$1.dir >> 0) & 1) === 0) {
					throw go$panic(new Go$String("reflect.Select: RecvDir case using send-only channel"));
				}
				rc.ch = ch$1.iword();
			} else {
				throw go$panic(new Go$String("reflect.Select: invalid Dir"));
			} }
			_i++;
		}
		_tuple = rselect(runcases), chosen = _tuple[0], word = _tuple[1], recvOK = _tuple[2];
		if ((_slice$2 = runcases, _index$2 = chosen, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).dir === 2) {
			tt$2 = (_slice$3 = runcases, _index$3 = chosen, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).typ.chanType;
			typ = tt$2.elem;
			fl = (typ.Kind() >>> 0) << 4 >>> 0;
			if (typ.size > 4) {
				fl = (fl | 2) >>> 0;
			}
			recv = new Value.Ptr(typ, word, fl);
		}
		_tuple$1 = [chosen, (_struct$7 = recv, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), recvOK], chosen = _tuple$1[0], recv = _tuple$1[1], recvOK = _tuple$1[2];
		return [chosen, (_struct$8 = recv, new Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)), recvOK];
	};
	var unsafe_New = function(typ) {
			switch (typ.Kind()) {
			case Struct:
				return new typ.jsType.Ptr();
			case Array:
				return zeroVal(typ);
			default:
				return go$newDataPointer(zeroVal(typ), typ.ptrTo().jsType);
			}
		};
	var unsafe_NewArray = function() {
		throw go$panic("Native function not implemented: unsafe_NewArray");
	};
	var MakeSlice = go$pkg.MakeSlice = function(typ, len, cap) {
			if (typ.Kind() !== Slice) {
				throw go$panic("reflect.MakeSlice of non-slice type");
			}
			if (len < 0) {
				throw go$panic("reflect.MakeSlice: negative len");
			}
			if (cap < 0) {
				throw go$panic("reflect.MakeSlice: negative cap");
			}
			if (len > cap) {
				throw go$panic("reflect.MakeSlice: len > cap");
			}
			return new Value.Ptr(typ.common(), typ.jsType.make(len, cap, function() { return zeroVal(typ.Elem()); }), Slice << flagKindShift);
		};
	var MakeChan = go$pkg.MakeChan = function(typ, buffer) {
		var ch;
		if (!((typ.Kind() === 18))) {
			throw go$panic(new Go$String("reflect.MakeChan of non-chan type"));
		}
		if (buffer < 0) {
			throw go$panic(new Go$String("reflect.MakeChan: negative buffer size"));
		}
		if (!((typ.ChanDir() === 3))) {
			throw go$panic(new Go$String("reflect.MakeChan: unidirectional channel type"));
		}
		ch = makechan((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))), new Go$Uint64(0, buffer));
		return new Value.Ptr(typ.common(), ch, 288);
	};
	var MakeMap = go$pkg.MakeMap = function(typ) {
		var m;
		if (!((typ.Kind() === 21))) {
			throw go$panic(new Go$String("reflect.MakeMap of non-map type"));
		}
		m = makemap((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))));
		return new Value.Ptr(typ.common(), m, 336);
	};
	var Indirect = go$pkg.Indirect = function(v) {
		var _struct, _struct$1;
		if (!((v.Kind() === 22))) {
			return (_struct = v, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		}
		return (_struct$1 = v.Elem(), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
	var ValueOf = go$pkg.ValueOf = function(i) {
			if (i === null) {
				return new Value.Ptr();
			}
			if (i.constructor.kind === undefined) { // js.Object
				return new Value.Ptr(Go$String.reflectType(), String(i), String << flagKindShift);
			}
			var typ = i.constructor.reflectType();
			return new Value.Ptr(typ, i.go$val, typ.Kind() << flagKindShift);
		};
	var Zero = go$pkg.Zero = function(typ) {
			return new Value.Ptr(typ, zeroVal(typ), typ.Kind() << flagKindShift);
		};
	var New = go$pkg.New = function(typ) {
		var ptr, fl;
		if (go$interfaceIsEqual(typ, null)) {
			throw go$panic(new Go$String("reflect: New(nil)"));
		}
		ptr = unsafe_New((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))));
		fl = 352;
		return new Value.Ptr(typ.common().ptrTo(), ptr, fl);
	};
	var NewAt = go$pkg.NewAt = function(typ, p) {
		var fl;
		fl = 352;
		return new Value.Ptr(typ.common().ptrTo(), p, fl);
	};
	Value.Ptr.prototype.assignTo = function(context, dst, target) {
		var _struct, v, _struct$1, _struct$2, fl, _struct$3, x;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (!((((v.flag & 8) >>> 0) === 0))) {
			v = (_struct$2 = makeMethodValue(context, (_struct$1 = v, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		if (directlyAssignable(dst, v.typ)) {
			v.typ = dst;
			fl = (v.flag & 7) >>> 0;
			fl = (fl | (((dst.Kind() >>> 0) << 4 >>> 0))) >>> 0;
			return new Value.Ptr(dst, v.val, fl);
		} else if (implements$1(dst, v.typ)) {
			if (target === (go$ptrType(go$emptyInterface)).nil) {
				target = go$newDataPointer(null, (go$ptrType(go$emptyInterface)));
			}
			x = valueInterface((_struct$3 = v, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), false);
			if (dst.NumMethod() === 0) {
				target.go$set(x);
			} else {
				ifaceE2I(dst, x, target);
			}
			return new Value.Ptr(dst, target, 322);
		}
		throw go$panic(new Go$String(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String()));
	};
	Value.prototype.assignTo = function(context, dst, target) { return this.go$val.assignTo(context, dst, target); };
	Value.Ptr.prototype.Convert = function(t) {
		var _struct, v, _struct$1, _struct$2, op, _struct$3, _struct$4;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (!((((v.flag & 8) >>> 0) === 0))) {
			v = (_struct$2 = makeMethodValue("Convert", (_struct$1 = v, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		op = convertOp(t.common(), v.typ);
		if (op === go$throwNilPointerError) {
			throw go$panic(new Go$String("reflect.Value.Convert: value of type " + v.typ.String() + " cannot be converted to type " + t.String()));
		}
		return (_struct$4 = op((_struct$3 = v, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), t), new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
	};
	Value.prototype.Convert = function(t) { return this.go$val.Convert(t); };
	var convertOp = function(dst, src) {
		var _ref, _ref$1, _ref$2, _ref$3, _ref$4, _ref$5, _ref$6;
		_ref = src.Kind();
		if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			_ref$1 = dst.Kind();
			if (_ref$1 === 2 || _ref$1 === 3 || _ref$1 === 4 || _ref$1 === 5 || _ref$1 === 6 || _ref$1 === 7 || _ref$1 === 8 || _ref$1 === 9 || _ref$1 === 10 || _ref$1 === 11 || _ref$1 === 12) {
				return cvtInt;
			} else if (_ref$1 === 13 || _ref$1 === 14) {
				return cvtIntFloat;
			} else if (_ref$1 === 24) {
				return cvtIntString;
			}
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			_ref$2 = dst.Kind();
			if (_ref$2 === 2 || _ref$2 === 3 || _ref$2 === 4 || _ref$2 === 5 || _ref$2 === 6 || _ref$2 === 7 || _ref$2 === 8 || _ref$2 === 9 || _ref$2 === 10 || _ref$2 === 11 || _ref$2 === 12) {
				return cvtUint;
			} else if (_ref$2 === 13 || _ref$2 === 14) {
				return cvtUintFloat;
			} else if (_ref$2 === 24) {
				return cvtUintString;
			}
		} else if (_ref === 13 || _ref === 14) {
			_ref$3 = dst.Kind();
			if (_ref$3 === 2 || _ref$3 === 3 || _ref$3 === 4 || _ref$3 === 5 || _ref$3 === 6) {
				return cvtFloatInt;
			} else if (_ref$3 === 7 || _ref$3 === 8 || _ref$3 === 9 || _ref$3 === 10 || _ref$3 === 11 || _ref$3 === 12) {
				return cvtFloatUint;
			} else if (_ref$3 === 13 || _ref$3 === 14) {
				return cvtFloat;
			}
		} else if (_ref === 15 || _ref === 16) {
			_ref$4 = dst.Kind();
			if (_ref$4 === 15 || _ref$4 === 16) {
				return cvtComplex;
			}
		} else if (_ref === 24) {
			if ((dst.Kind() === 23) && dst.Elem().PkgPath() === "") {
				_ref$5 = dst.Elem().Kind();
				if (_ref$5 === 8) {
					return cvtStringBytes;
				} else if (_ref$5 === 5) {
					return cvtStringRunes;
				}
			}
		} else if (_ref === 23) {
			if ((dst.Kind() === 24) && src.Elem().PkgPath() === "") {
				_ref$6 = src.Elem().Kind();
				if (_ref$6 === 8) {
					return cvtBytesString;
				} else if (_ref$6 === 5) {
					return cvtRunesString;
				}
			}
		}
		if (haveIdenticalUnderlyingType(dst, src)) {
			return cvtDirect;
		}
		if ((dst.Kind() === 22) && dst.Name() === "" && (src.Kind() === 22) && src.Name() === "" && haveIdenticalUnderlyingType(dst.Elem().common(), src.Elem().common())) {
			return cvtDirect;
		}
		if (implements$1(dst, src)) {
			if (src.Kind() === 20) {
				return cvtI2I;
			}
			return cvtT2I;
		}
		return go$throwNilPointerError;
	};
	var makeInt = function(f, bits, typ) {
			var val;
			switch (typ.Kind()) {
			case Int8:
				val = bits.low << 24 >> 24;
				break;
			case Int16:
				val = bits.low << 16 >> 16;
				break;
			case Int:
			case Int32:
				val = bits.low >> 0;
				break;
			case Int64:
				return new Value.Ptr(typ, go$newDataPointer(new Go$Int64(bits.high, bits.low), typ.ptrTo().jsType), f | flagIndir | (Int64 << flagKindShift));
			case Uint8:
				val = bits.low << 24 >>> 24;
				break;
			case Uint16:
				val = bits.low << 16 >>> 16;
				break;
			case Uint64:
				return new Value.Ptr(typ, go$newDataPointer(bits, typ.ptrTo().jsType), f | flagIndir | (Int64 << flagKindShift));
			case Uint:
			case Uint32:
			case Uintptr:
				val = bits.low >>> 0;
				break;
			}
			return new Value.Ptr(typ, val, f | (typ.Kind() << flagKindShift));
		};
	var makeFloat = function(f, v, t) {
		var typ, ptr, w, _ref, v$1, v$2;
		typ = t.common();
		if (typ.size > 4) {
			ptr = unsafe_New(typ);
			ptr.go$set(v);
			return new Value.Ptr(typ, ptr, (((f | 2) >>> 0) | ((typ.Kind() >>> 0) << 4 >>> 0)) >>> 0);
		}
		w = 0;
		_ref = typ.size;
		if (_ref === 4) {
			new (go$ptrType(iword))(function() { return w; }, function(v$1) { w = v$1; }).go$set(v);
		} else if (_ref === 8) {
			new (go$ptrType(iword))(function() { return w; }, function(v$2) { w = v$2; }).go$set(v);
		}
		return new Value.Ptr(typ, w, (f | ((typ.Kind() >>> 0) << 4 >>> 0)) >>> 0);
	};
	var makeComplex = function(f, v, typ) {
			return new Value.Ptr(typ, new typ.jsType(v.real, v.imag), f | (typ.Kind() << flagKindShift));
		};
	var makeString = function(f, v, t) {
		var _struct, ret, _struct$1;
		ret = (_struct = New(t).Elem(), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		ret.SetString(v);
		ret.flag = ((ret.flag & ~4) | f) >>> 0;
		return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
	var makeBytes = function(f, v, t) {
		var _struct, ret, _struct$1;
		ret = (_struct = New(t).Elem(), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		ret.SetBytes(v);
		ret.flag = ((ret.flag & ~4) | f) >>> 0;
		return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
	var makeRunes = function(f, v, t) {
		var _struct, ret, _struct$1;
		ret = (_struct = New(t).Elem(), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		ret.setRunes(v);
		ret.flag = ((ret.flag & ~4) | f) >>> 0;
		return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
	var cvtInt = function(v, t) {
		var x, _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, (x = v.Int(), new Go$Uint64(x.high, x.low)), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtUint = function(v, t) {
		var _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, v.Uint(), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtFloatInt = function(v, t) {
		var x, _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, (x = new Go$Int64(0, v.Float()), new Go$Uint64(x.high, x.low)), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtFloatUint = function(v, t) {
		var _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, new Go$Uint64(0, v.Float()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtIntFloat = function(v, t) {
		var _struct;
		return (_struct = makeFloat((v.flag & 1) >>> 0, go$flatten64(v.Int()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtUintFloat = function(v, t) {
		var _struct;
		return (_struct = makeFloat((v.flag & 1) >>> 0, go$flatten64(v.Uint()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtFloat = function(v, t) {
		var _struct;
		return (_struct = makeFloat((v.flag & 1) >>> 0, v.Float(), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtComplex = function(v, t) {
		var _struct;
		return (_struct = makeComplex((v.flag & 1) >>> 0, v.Complex(), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtIntString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$encodeRune(v.Int().low), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtUintString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$encodeRune(v.Uint().low), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtBytesString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$bytesToString(v.Bytes()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtStringBytes = function(v, typ) {
			return new Value.Ptr(typ, new typ.jsType(go$stringToBytes(v.iword())), (v.flag & flagRO) | (Slice << flagKindShift));
		};
	var cvtRunesString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$runesToString(v.runes()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
	var cvtStringRunes = function(v, typ) {
			return new Value.Ptr(typ, new typ.jsType(go$stringToRunes(v.iword())), (v.flag & flagRO) | (Slice << flagKindShift));
		};
	var cvtDirect = function(v, typ) {
			var srcVal = v.iword();
			if (srcVal === v.typ.jsType.nil) {
				return new Value.Ptr(typ, typ.jsType.nil, v.flag);
			}

			var val;
			switch (typ.Kind()) {
			case Chan:
				val = new typ.jsType();
				break;
			case Slice:
				val = new typ.jsType(srcVal.array);
				val.length = srcVal.length;
				val.cap = srcVal.cap;
				break;
			case Ptr:
				if (typ.Elem().Kind() === Struct) {
					if (typ.Elem() === v.typ.Elem()) {
						val = srcVal;
					}
					val = new typ.jsType();
					copyStruct(val, srcVal, typ.Elem());
					break;
				}
				val = new typ.jsType(srcVal.go$get, srcVal.go$set);
				break;
			case Struct:
				val = new typ.jsType.Ptr();
				copyStruct(val, srcVal, typ);
				break;
			case Array:
			case Func:
			case Interface:
			case Map:
			case String:
				val = srcVal;
				break;
			default:
				throw go$panic(new ValueError.Ptr("reflect.Convert", typ.Kind()));
			}
			return new Value.Ptr(typ, val, (v.flag & flagRO) | (typ.Kind() << flagKindShift));
		};
	var cvtT2I = function(v, typ) {
		var target, _struct, x;
		target = go$newDataPointer(null, (go$ptrType(go$emptyInterface)));
		x = valueInterface((_struct = v, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
		if (typ.NumMethod() === 0) {
			target.go$set(x);
		} else {
			ifaceE2I((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))), x, target);
		}
		return new Value.Ptr(typ.common(), target, (((((v.flag & 1) >>> 0) | 2) >>> 0) | 320) >>> 0);
	};
	var cvtI2I = function(v, typ) {
		var _struct, ret, _struct$1, _struct$2, _struct$3;
		if (v.IsNil()) {
			ret = (_struct = Zero(typ), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			ret.flag = (ret.flag | (((v.flag & 1) >>> 0))) >>> 0;
			return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		}
		return (_struct$3 = cvtT2I((_struct$2 = v.Elem(), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), typ), new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
	var chancap = function(ch) { go$notSupported("channels"); };
	var chanclose = function(ch) { go$notSupported("channels"); };
	var chanlen = function(ch) { go$notSupported("channels"); };
	var chanrecv = function(t, ch, nb) { go$notSupported("channels"); };
	var chansend = function(t, ch, val, nb) { go$notSupported("channels"); };
	var makechan = function(typ, size) {
			return new typ.jsType();
		};
	var makemap = function(t) {
			return new Go$Map();
		};
	var mapaccess = function(t, m, key) {
			var entry = m[key.go$key ? key.go$key() : key];
			if (entry === undefined) {
				return [undefined, false];
			}
			return [entry.v, true];
		};
	var mapassign = function(t, m, key, val, ok) {
			if (!ok) {
				delete m[key.go$key ? key.go$key() : key];
				return;
			}
			if (t.Elem().kind === Struct) {
				var newVal = {};
				copyStruct(newVal, val, t.Elem());
				val = newVal;
			}
			m[key.go$key ? key.go$key() : key] = { k: key, v: val };
		};
	var mapiterinit = function(t, m) {
			return [m, go$keys(m), 0];
		};
	var mapiterkey = function(it) {
			var key = it[1][it[2]];
			return [it[0][key].k, true];
		};
	var mapiternext = function(it) {
			it[2]++;
		};
	var maplen = function(m) {
			return go$keys(m).length;
		};
	var call = function(fn, arg, n) {
		throw go$panic("Native function not implemented: call");
	};
	var ifaceE2I = function(t, src, dst) {
			dst.go$set(src);
		};
	var escapes = function(x) {
		if (dummy.b) {
			dummy.x = x;
		}
	};

			var Invalid = 0;
			var Bool = 1;
			var Int = 2;
			var Int8 = 3;
			var Int16 = 4;
			var Int32 = 5;
			var Int64 = 6;
			var Uint = 7;
			var Uint8 = 8;
			var Uint16 = 9;
			var Uint32 = 10;
			var Uint64 = 11;
			var Uintptr = 12;
			var Float32 = 13;
			var Float64 = 14;
			var Complex64 = 15;
			var Complex128 = 16;
			var Array = 17;
			var Chan = 18;
			var Func = 19;
			var Interface = 20;
			var Map = 21;
			var Ptr = 22;
			var Slice = 23;
			var String = 24;
			var Struct = 25;
			var UnsafePointer = 26;

			var RecvDir = 1;
			var SendDir = 2;
			var BothDir = 3;

			var flagRO = 1;
			var flagIndir = 2;
			var flagAddr = 4;
			var flagMethod = 8;
			var flagKindShift = 4;
			var flagKindWidth = 5;
			var flagKindMask = 31;
			var flagMethodShift = 9;

			go$reflect = {
				rtype: rtype.Ptr, uncommonType: uncommonType.Ptr, method: method.Ptr, arrayType: arrayType.Ptr, chanType: chanType.Ptr, funcType: funcType.Ptr, interfaceType: interfaceType.Ptr, mapType: mapType.Ptr, ptrType: ptrType.Ptr, sliceType: sliceType.Ptr, structType: structType.Ptr,
				imethod: imethod.Ptr, structField: structField.Ptr,
				kinds: { Bool: Bool, Int: Int, Int8: Int8, Int16: Int16, Int32: Int32, Int64: Int64, Uint: Uint, Uint8: Uint8, Uint16: Uint16, Uint32: Uint32, Uint64: Uint64, Uintptr: Uintptr, Float32: Float32, Float64: Float64, Complex64: Complex64, Complex128: Complex128, Array: Array, Chan: Chan, Func: Func, Interface: Interface, Map: Map, Ptr: Ptr, Slice: Slice, String: String, Struct: Struct, UnsafePointer: UnsafePointer },
				RecvDir: RecvDir, SendDir: SendDir, BothDir: BothDir
			};

			var isWrapped = function(typ) {
				switch (typ.Kind()) {
				case Bool:
				case Int:
				case Int8:
				case Int16:
				case Int32:
				case Uint:
				case Uint8:
				case Uint16:
				case Uint32:
				case Uintptr:
				case Float32:
				case Float64:
				case Array:
				case Map:
				case Func:
				case String:
				case Struct:
					return true;
				case Ptr:
					return typ.Elem().Kind() === Array;
				}
				return false;
			};
			var fieldName = function(field, i) {
				if (field.name.go$get === go$throwNilPointerError) {
					var ntyp = field.typ;
					if (ntyp.Kind() === Ptr) {
						ntyp = ntyp.Elem().common();
					}
					return ntyp.Name();
				}
				var name = field.name.go$get();
				if (name === "_" || go$reservedKeywords.indexOf(name) != -1) {
					return name + "$" + i;
				}
				return name;
			};
			var copyStruct = function(dst, src, typ) {
				var fields = typ.structType.fields.array, i;
				for (i = 0; i < fields.length; i++) {
					var field = fields[i];
					var name = fieldName(field, i);
					dst[name] = src[name];
				}
			};
			var deepValueEqual = function(v1, v2, visited) {
				if (!v1.IsValid() || !v2.IsValid()) {
					return !v1.IsValid() && !v2.IsValid();
				}
				if (v1.Type() !== v2.Type()) {
					return false;
				}

				var i;
				switch(v1.Kind()) {
				case Array:
				case Map:
				case Slice:
				case Struct:
					for (i = 0; i < visited.length; i++) {
						var entry = visited[i];
						if (v1.val === entry[0] && v2.val === entry[1]) {
							return true;
						}
					}
					visited.push([v1.val, v2.val]);
				}

				switch(v1.Kind()) {
				case Array:
				case Slice:
					if (v1.Kind() === Slice) {
						if (v1.IsNil() !== v2.IsNil()) {
							return false;
						}
						if (v1.iword() === v2.iword()) {
							return true;
						}
					}
					var n = v1.Len();
					if (n !== v2.Len()) {
						return false;
					}
					for (i = 0; i < n; i++) {
						if (!deepValueEqual(v1.Index(i), v2.Index(i), visited)) {
							return false;
						}
					}
					return true;
				case Interface:
					if (v1.IsNil() || v2.IsNil()) {
						return v1.IsNil() && v2.IsNil();
					}
					return deepValueEqual(v1.Elem(), v2.Elem(), visited);
				case Ptr:
					return deepValueEqual(v1.Elem(), v2.Elem(), visited);
				case Struct:
					var n = v1.NumField();
					for (i = 0; i < n; i++) {
						if (!deepValueEqual(v1.Field(i), v2.Field(i), visited)) {
							return false;
						}
					}
					return true;
				case Map:
					if (v1.IsNil() !== v2.IsNil()) {
						return false;
					}
					if (v1.iword() === v2.iword()) {
						return true;
					}
					var keys = v1.MapKeys();
					if (keys.length !== v2.Len()) {
						return false;
					}
					for (i = 0; i < keys.length; i++) {
						var k = keys.array[i];
						if (!deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited)) {
							return false;
						}
					}
					return true;
				case Func:
					return v1.IsNil() && v2.IsNil();
				}

				return go$interfaceIsEqual(valueInterface(v1, false), valueInterface(v2, false));
			};
			var zeroVal = function(typ) {
				switch (typ.Kind()) {
				case Bool:
					return false;
				case Int:
				case Int8:
				case Int16:
				case Int32:
				case Uint:
				case Uint8:
				case Uint16:
				case Uint32:
				case Uintptr:
				case Float32:
				case Float64:
					return 0;
				case Int64:
				case Uint64:
				case Complex64:
				case Complex128:
					return new typ.jsType(0, 0);
				case Array:
					var elemType = typ.Elem();
					return go$makeNativeArray(elemType.jsType.kind, typ.Len(), function() { return zeroVal(elemType); });
				case Func:
					return go$throwNilPointerError;
				case Interface:
					return null;
				case Map:
					return false;
				case Chan:
				case Ptr:
				case Slice:
					return typ.jsType.nil;
				case String:
					return "";
				case Struct:
					return new typ.jsType.Ptr();
				default:
					throw go$panic(new ValueError.Ptr("reflect.Zero", this.kind()));
				}
			};
			go$pkg.init = function() {
		ptrMap = new (go$structType([["", "", sync.RWMutex, ""], ["m", "reflect", (go$mapType((go$ptrType(rtype)), (go$ptrType(ptrType)))), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
		lookupCache = new (go$structType([["", "", sync.RWMutex, ""], ["m", "reflect", (go$mapType(cacheKey, (go$ptrType(rtype)))), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
		dummy = new (go$structType([["b", "reflect", Go$Bool, ""], ["x", "reflect", go$emptyInterface, ""]])).Ptr(false, null);
		var x;
		kindNames = new (go$sliceType(Go$String))(["invalid", "bool", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr", "float32", "float64", "complex64", "complex128", "array", "chan", "func", "interface", "map", "ptr", "slice", "string", "struct", "unsafe.Pointer"]);
		ptrDataGCProg = new ptrDataGC.Ptr(4, 2, 0, 0);
		sliceEmptyGCProg = new sliceEmptyGC.Ptr(12, 2, 0, 0);
		uint8Type = (x = TypeOf(new Go$Uint8(0)), (x !== null && x.constructor === (go$ptrType(rtype)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(rtype)))));
	};
	return go$pkg;
})();
go$packages["fmt"] = (function() {
	var go$pkg = {};
	var strconv = go$packages["strconv"];
	var utf8 = go$packages["unicode/utf8"];
	var errors = go$packages["errors"];
	var io = go$packages["io"];
	var os = go$packages["os"];
	var reflect = go$packages["reflect"];
	var sync = go$packages["sync"];
	var math = go$packages["math"];
	var fmt;
	fmt = go$newType(0, "Struct", "fmt.fmt", "fmt", "fmt", function(intbuf_, buf_, wid_, prec_, widPresent_, precPresent_, minus_, plus_, sharp_, space_, unicode_, uniQuote_, zero_) {
		this.go$val = this;
		this.intbuf = intbuf_ !== undefined ? intbuf_ : go$makeNativeArray("Uint8", 65, function() { return 0; });
		this.buf = buf_ !== undefined ? buf_ : (go$ptrType(buffer)).nil;
		this.wid = wid_ !== undefined ? wid_ : 0;
		this.prec = prec_ !== undefined ? prec_ : 0;
		this.widPresent = widPresent_ !== undefined ? widPresent_ : false;
		this.precPresent = precPresent_ !== undefined ? precPresent_ : false;
		this.minus = minus_ !== undefined ? minus_ : false;
		this.plus = plus_ !== undefined ? plus_ : false;
		this.sharp = sharp_ !== undefined ? sharp_ : false;
		this.space = space_ !== undefined ? space_ : false;
		this.unicode = unicode_ !== undefined ? unicode_ : false;
		this.uniQuote = uniQuote_ !== undefined ? uniQuote_ : false;
		this.zero = zero_ !== undefined ? zero_ : false;
	});
	go$pkg.fmt = fmt;
	var State;
	State = go$newType(0, "Interface", "fmt.State", "State", "fmt", null);
	go$pkg.State = State;
	var Formatter;
	Formatter = go$newType(0, "Interface", "fmt.Formatter", "Formatter", "fmt", null);
	go$pkg.Formatter = Formatter;
	var Stringer;
	Stringer = go$newType(0, "Interface", "fmt.Stringer", "Stringer", "fmt", null);
	go$pkg.Stringer = Stringer;
	var GoStringer;
	GoStringer = go$newType(0, "Interface", "fmt.GoStringer", "GoStringer", "fmt", null);
	go$pkg.GoStringer = GoStringer;
	var buffer;
	buffer = go$newType(0, "Slice", "fmt.buffer", "buffer", "fmt", null);
	go$pkg.buffer = buffer;
	var pp;
	pp = go$newType(0, "Struct", "fmt.pp", "pp", "fmt", function(n_, panicking_, erroring_, buf_, arg_, value_, reordered_, goodArgNum_, runeBuf_, fmt_) {
		this.go$val = this;
		this.n = n_ !== undefined ? n_ : 0;
		this.panicking = panicking_ !== undefined ? panicking_ : false;
		this.erroring = erroring_ !== undefined ? erroring_ : false;
		this.buf = buf_ !== undefined ? buf_ : buffer.nil;
		this.arg = arg_ !== undefined ? arg_ : null;
		this.value = value_ !== undefined ? value_ : new reflect.Value.Ptr();
		this.reordered = reordered_ !== undefined ? reordered_ : false;
		this.goodArgNum = goodArgNum_ !== undefined ? goodArgNum_ : false;
		this.runeBuf = runeBuf_ !== undefined ? runeBuf_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
		this.fmt = fmt_ !== undefined ? fmt_ : new fmt.Ptr();
	});
	go$pkg.pp = pp;
	var cache;
	cache = go$newType(0, "Struct", "fmt.cache", "cache", "fmt", function(mu_, saved_, new$2_) {
		this.go$val = this;
		this.mu = mu_ !== undefined ? mu_ : new sync.Mutex.Ptr();
		this.saved = saved_ !== undefined ? saved_ : (go$sliceType(go$emptyInterface)).nil;
		this.new$2 = new$2_ !== undefined ? new$2_ : go$throwNilPointerError;
	});
	go$pkg.cache = cache;
	var runeUnreader;
	runeUnreader = go$newType(0, "Interface", "fmt.runeUnreader", "runeUnreader", "fmt", null);
	go$pkg.runeUnreader = runeUnreader;
	var ScanState;
	ScanState = go$newType(0, "Interface", "fmt.ScanState", "ScanState", "fmt", null);
	go$pkg.ScanState = ScanState;
	var Scanner;
	Scanner = go$newType(0, "Interface", "fmt.Scanner", "Scanner", "fmt", null);
	go$pkg.Scanner = Scanner;
	var stringReader;
	stringReader = go$newType(0, "String", "fmt.stringReader", "stringReader", "fmt", null);
	go$pkg.stringReader = stringReader;
	var scanError;
	scanError = go$newType(0, "Struct", "fmt.scanError", "scanError", "fmt", function(err_) {
		this.go$val = this;
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.scanError = scanError;
	var ss;
	ss = go$newType(0, "Struct", "fmt.ss", "ss", "fmt", function(rr_, buf_, peekRune_, prevRune_, count_, atEOF_, ssave_) {
		this.go$val = this;
		this.rr = rr_ !== undefined ? rr_ : null;
		this.buf = buf_ !== undefined ? buf_ : buffer.nil;
		this.peekRune = peekRune_ !== undefined ? peekRune_ : 0;
		this.prevRune = prevRune_ !== undefined ? prevRune_ : 0;
		this.count = count_ !== undefined ? count_ : 0;
		this.atEOF = atEOF_ !== undefined ? atEOF_ : false;
		this.ssave = ssave_ !== undefined ? ssave_ : new ssave.Ptr();
	});
	go$pkg.ss = ss;
	var ssave;
	ssave = go$newType(0, "Struct", "fmt.ssave", "ssave", "fmt", function(validSave_, nlIsEnd_, nlIsSpace_, argLimit_, limit_, maxWid_) {
		this.go$val = this;
		this.validSave = validSave_ !== undefined ? validSave_ : false;
		this.nlIsEnd = nlIsEnd_ !== undefined ? nlIsEnd_ : false;
		this.nlIsSpace = nlIsSpace_ !== undefined ? nlIsSpace_ : false;
		this.argLimit = argLimit_ !== undefined ? argLimit_ : 0;
		this.limit = limit_ !== undefined ? limit_ : 0;
		this.maxWid = maxWid_ !== undefined ? maxWid_ : 0;
	});
	go$pkg.ssave = ssave;
	var readRune;
	readRune = go$newType(0, "Struct", "fmt.readRune", "readRune", "fmt", function(reader_, buf_, pending_, pendBuf_) {
		this.go$val = this;
		this.reader = reader_ !== undefined ? reader_ : null;
		this.buf = buf_ !== undefined ? buf_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
		this.pending = pending_ !== undefined ? pending_ : 0;
		this.pendBuf = pendBuf_ !== undefined ? pendBuf_ : go$makeNativeArray("Uint8", 4, function() { return 0; });
	});
	go$pkg.readRune = readRune;
	fmt.init([["intbuf", "fmt", (go$arrayType(Go$Uint8, 65)), ""], ["buf", "fmt", (go$ptrType(buffer)), ""], ["wid", "fmt", Go$Int, ""], ["prec", "fmt", Go$Int, ""], ["widPresent", "fmt", Go$Bool, ""], ["precPresent", "fmt", Go$Bool, ""], ["minus", "fmt", Go$Bool, ""], ["plus", "fmt", Go$Bool, ""], ["sharp", "fmt", Go$Bool, ""], ["space", "fmt", Go$Bool, ""], ["unicode", "fmt", Go$Bool, ""], ["uniQuote", "fmt", Go$Bool, ""], ["zero", "fmt", Go$Bool, ""]]);
	(go$ptrType(fmt)).methods = [["clearflags", "fmt", [], [], false], ["computePadding", "fmt", [Go$Int], [(go$sliceType(Go$Uint8)), Go$Int, Go$Int], false], ["fmt_E32", "fmt", [Go$Float32], [], false], ["fmt_E64", "fmt", [Go$Float64], [], false], ["fmt_G32", "fmt", [Go$Float32], [], false], ["fmt_G64", "fmt", [Go$Float64], [], false], ["fmt_boolean", "fmt", [Go$Bool], [], false], ["fmt_bx", "fmt", [(go$sliceType(Go$Uint8)), Go$String], [], false], ["fmt_c128", "fmt", [Go$Complex128, Go$Int32], [], false], ["fmt_c64", "fmt", [Go$Complex64, Go$Int32], [], false], ["fmt_e32", "fmt", [Go$Float32], [], false], ["fmt_e64", "fmt", [Go$Float64], [], false], ["fmt_f32", "fmt", [Go$Float32], [], false], ["fmt_f64", "fmt", [Go$Float64], [], false], ["fmt_fb32", "fmt", [Go$Float32], [], false], ["fmt_fb64", "fmt", [Go$Float64], [], false], ["fmt_g32", "fmt", [Go$Float32], [], false], ["fmt_g64", "fmt", [Go$Float64], [], false], ["fmt_q", "fmt", [Go$String], [], false], ["fmt_qc", "fmt", [Go$Int64], [], false], ["fmt_s", "fmt", [Go$String], [], false], ["fmt_sbx", "fmt", [Go$String, (go$sliceType(Go$Uint8)), Go$String], [], false], ["fmt_sx", "fmt", [Go$String, Go$String], [], false], ["formatFloat", "fmt", [Go$Float64, Go$Uint8, Go$Int, Go$Int], [], false], ["init", "fmt", [(go$ptrType(buffer))], [], false], ["integer", "fmt", [Go$Int64, Go$Uint64, Go$Bool, Go$String], [], false], ["pad", "fmt", [(go$sliceType(Go$Uint8))], [], false], ["padString", "fmt", [Go$String], [], false], ["truncate", "fmt", [Go$String], [Go$String], false], ["writePadding", "fmt", [Go$Int, (go$sliceType(Go$Uint8))], [], false]];
	State.init([["Flag", "", (go$funcType([Go$Int], [Go$Bool], false))], ["Precision", "", (go$funcType([], [Go$Int, Go$Bool], false))], ["Width", "", (go$funcType([], [Go$Int, Go$Bool], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
	Formatter.init([["Format", "", (go$funcType([State, Go$Int32], [], false))]]);
	Stringer.init([["String", "", (go$funcType([], [Go$String], false))]]);
	GoStringer.init([["GoString", "", (go$funcType([], [Go$String], false))]]);
	buffer.init(Go$Uint8);
	(go$ptrType(buffer)).methods = [["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["WriteByte", "", [Go$Uint8], [go$error], false], ["WriteRune", "", [Go$Int32], [go$error], false], ["WriteString", "", [Go$String], [Go$Int, go$error], false]];
	pp.init([["n", "fmt", Go$Int, ""], ["panicking", "fmt", Go$Bool, ""], ["erroring", "fmt", Go$Bool, ""], ["buf", "fmt", buffer, ""], ["arg", "fmt", go$emptyInterface, ""], ["value", "fmt", reflect.Value, ""], ["reordered", "fmt", Go$Bool, ""], ["goodArgNum", "fmt", Go$Bool, ""], ["runeBuf", "fmt", (go$arrayType(Go$Uint8, 4)), ""], ["fmt", "fmt", fmt, ""]]);
	(go$ptrType(pp)).methods = [["Flag", "", [Go$Int], [Go$Bool], false], ["Precision", "", [], [Go$Int, Go$Bool], false], ["Width", "", [], [Go$Int, Go$Bool], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["add", "fmt", [Go$Int32], [], false], ["argNumber", "fmt", [Go$Int, Go$String, Go$Int, Go$Int], [Go$Int, Go$Int, Go$Bool], false], ["badVerb", "fmt", [Go$Int32], [], false], ["catchPanic", "fmt", [go$emptyInterface, Go$Int32], [], false], ["doPrint", "fmt", [(go$sliceType(go$emptyInterface)), Go$Bool, Go$Bool], [], false], ["doPrintf", "fmt", [Go$String, (go$sliceType(go$emptyInterface))], [], false], ["fmt0x64", "fmt", [Go$Uint64, Go$Bool], [], false], ["fmtBool", "fmt", [Go$Bool, Go$Int32], [], false], ["fmtBytes", "fmt", [(go$sliceType(Go$Uint8)), Go$Int32, Go$Bool, reflect.Type, Go$Int], [], false], ["fmtC", "fmt", [Go$Int64], [], false], ["fmtComplex128", "fmt", [Go$Complex128, Go$Int32], [], false], ["fmtComplex64", "fmt", [Go$Complex64, Go$Int32], [], false], ["fmtFloat32", "fmt", [Go$Float32, Go$Int32], [], false], ["fmtFloat64", "fmt", [Go$Float64, Go$Int32], [], false], ["fmtInt64", "fmt", [Go$Int64, Go$Int32], [], false], ["fmtPointer", "fmt", [reflect.Value, Go$Int32, Go$Bool], [], false], ["fmtString", "fmt", [Go$String, Go$Int32, Go$Bool], [], false], ["fmtUint64", "fmt", [Go$Uint64, Go$Int32, Go$Bool], [], false], ["fmtUnicode", "fmt", [Go$Int64], [], false], ["free", "fmt", [], [], false], ["handleMethods", "fmt", [Go$Int32, Go$Bool, Go$Bool, Go$Int], [Go$Bool, Go$Bool], false], ["printArg", "fmt", [go$emptyInterface, Go$Int32, Go$Bool, Go$Bool, Go$Int], [Go$Bool], false], ["printReflectValue", "fmt", [reflect.Value, Go$Int32, Go$Bool, Go$Bool, Go$Int], [Go$Bool], false], ["printValue", "fmt", [reflect.Value, Go$Int32, Go$Bool, Go$Bool, Go$Int], [Go$Bool], false], ["unknownType", "fmt", [go$emptyInterface], [], false]];
	cache.init([["mu", "fmt", sync.Mutex, ""], ["saved", "fmt", (go$sliceType(go$emptyInterface)), ""], ["new", "fmt", (go$funcType([], [go$emptyInterface], false)), ""]]);
	(go$ptrType(cache)).methods = [["get", "fmt", [], [go$emptyInterface], false], ["put", "fmt", [go$emptyInterface], [], false]];
	runeUnreader.init([["UnreadRune", "", (go$funcType([], [go$error], false))]]);
	ScanState.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["ReadRune", "", (go$funcType([], [Go$Int32, Go$Int, go$error], false))], ["SkipSpace", "", (go$funcType([], [], false))], ["Token", "", (go$funcType([Go$Bool, (go$funcType([Go$Int32], [Go$Bool], false))], [(go$sliceType(Go$Uint8)), go$error], false))], ["UnreadRune", "", (go$funcType([], [go$error], false))], ["Width", "", (go$funcType([], [Go$Int, Go$Bool], false))]]);
	Scanner.init([["Scan", "", (go$funcType([ScanState, Go$Int32], [go$error], false))]]);
	(go$ptrType(stringReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	scanError.init([["err", "fmt", go$error, ""]]);
	ss.init([["rr", "fmt", io.RuneReader, ""], ["buf", "fmt", buffer, ""], ["peekRune", "fmt", Go$Int32, ""], ["prevRune", "fmt", Go$Int32, ""], ["count", "fmt", Go$Int, ""], ["atEOF", "fmt", Go$Bool, ""], ["", "fmt", ssave, ""]]);
	(go$ptrType(ss)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["SkipSpace", "", [], [], false], ["Token", "", [Go$Bool, (go$funcType([Go$Int32], [Go$Bool], false))], [(go$sliceType(Go$Uint8)), go$error], false], ["UnreadRune", "", [], [go$error], false], ["Width", "", [], [Go$Int, Go$Bool], false], ["accept", "fmt", [Go$String], [Go$Bool], false], ["advance", "fmt", [Go$String], [Go$Int], false], ["complexTokens", "fmt", [], [Go$String, Go$String], false], ["consume", "fmt", [Go$String, Go$Bool], [Go$Bool], false], ["convertFloat", "fmt", [Go$String, Go$Int], [Go$Float64], false], ["convertString", "fmt", [Go$Int32], [Go$String], false], ["doScan", "fmt", [(go$sliceType(go$emptyInterface))], [Go$Int, go$error], false], ["doScanf", "fmt", [Go$String, (go$sliceType(go$emptyInterface))], [Go$Int, go$error], false], ["error", "fmt", [go$error], [], false], ["errorString", "fmt", [Go$String], [], false], ["floatToken", "fmt", [], [Go$String], false], ["free", "fmt", [ssave], [], false], ["getBase", "fmt", [Go$Int32], [Go$Int, Go$String], false], ["getRune", "fmt", [], [Go$Int32], false], ["hexByte", "fmt", [], [Go$Uint8, Go$Bool], false], ["hexDigit", "fmt", [Go$Int32], [Go$Int], false], ["hexString", "fmt", [], [Go$String], false], ["mustReadRune", "fmt", [], [Go$Int32], false], ["notEOF", "fmt", [], [], false], ["okVerb", "fmt", [Go$Int32, Go$String, Go$String], [Go$Bool], false], ["peek", "fmt", [Go$String], [Go$Bool], false], ["quotedString", "fmt", [], [Go$String], false], ["scanBasePrefix", "fmt", [], [Go$Int, Go$String, Go$Bool], false], ["scanBool", "fmt", [Go$Int32], [Go$Bool], false], ["scanComplex", "fmt", [Go$Int32, Go$Int], [Go$Complex128], false], ["scanInt", "fmt", [Go$Int32, Go$Int], [Go$Int64], false], ["scanNumber", "fmt", [Go$String, Go$Bool], [Go$String], false], ["scanOne", "fmt", [Go$Int32, go$emptyInterface], [], false], ["scanRune", "fmt", [Go$Int], [Go$Int64], false], ["scanUint", "fmt", [Go$Int32, Go$Int], [Go$Uint64], false], ["skipSpace", "fmt", [Go$Bool], [], false], ["token", "fmt", [Go$Bool, (go$funcType([Go$Int32], [Go$Bool], false))], [(go$sliceType(Go$Uint8))], false]];
	ssave.init([["validSave", "fmt", Go$Bool, ""], ["nlIsEnd", "fmt", Go$Bool, ""], ["nlIsSpace", "fmt", Go$Bool, ""], ["argLimit", "fmt", Go$Int, ""], ["limit", "fmt", Go$Int, ""], ["maxWid", "fmt", Go$Int, ""]]);
	readRune.init([["reader", "fmt", io.Reader, ""], ["buf", "fmt", (go$arrayType(Go$Uint8, 4)), ""], ["pending", "fmt", Go$Int, ""], ["pendBuf", "fmt", (go$arrayType(Go$Uint8, 4)), ""]]);
	(go$ptrType(readRune)).methods = [["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["readByte", "fmt", [], [Go$Uint8, go$error], false], ["unread", "fmt", [(go$sliceType(Go$Uint8))], [], false]];
	var padZeroBytes, padSpaceBytes, trueBytes, falseBytes, commaSpaceBytes, nilAngleBytes, nilParenBytes, nilBytes, mapBytes, percentBangBytes, missingBytes, badIndexBytes, panicBytes, extraBytes, irparenBytes, bytesBytes, badWidthBytes, badPrecBytes, noVerbBytes, ppFree, intBits, uintptrBits, space, ssFree, complexError, boolError;
	fmt.Ptr.prototype.clearflags = function() {
		var f;
		f = this;
		f.wid = 0;
		f.widPresent = false;
		f.prec = 0;
		f.precPresent = false;
		f.minus = false;
		f.plus = false;
		f.sharp = false;
		f.space = false;
		f.unicode = false;
		f.uniQuote = false;
		f.zero = false;
	};
	fmt.prototype.clearflags = function() { return this.go$val.clearflags(); };
	fmt.Ptr.prototype.init = function(buf) {
		var f;
		f = this;
		f.buf = buf;
		f.clearflags();
	};
	fmt.prototype.init = function(buf) { return this.go$val.init(buf); };
	fmt.Ptr.prototype.computePadding = function(width) {
		var padding, leftWidth, rightWidth, f, left, w, _tuple, _tuple$1, _tuple$2;
		padding = (go$sliceType(Go$Uint8)).nil;
		leftWidth = 0;
		rightWidth = 0;
		f = this;
		left = !f.minus;
		w = f.wid;
		if (w < 0) {
			left = false;
			w = -w;
		}
		w = w - (width) >> 0;
		if (w > 0) {
			if (left && f.zero) {
				_tuple = [padZeroBytes, w, 0], padding = _tuple[0], leftWidth = _tuple[1], rightWidth = _tuple[2];
				return [padding, leftWidth, rightWidth];
			}
			if (left) {
				_tuple$1 = [padSpaceBytes, w, 0], padding = _tuple$1[0], leftWidth = _tuple$1[1], rightWidth = _tuple$1[2];
				return [padding, leftWidth, rightWidth];
			} else {
				_tuple$2 = [padSpaceBytes, 0, w], padding = _tuple$2[0], leftWidth = _tuple$2[1], rightWidth = _tuple$2[2];
				return [padding, leftWidth, rightWidth];
			}
		}
		return [padding, leftWidth, rightWidth];
	};
	fmt.prototype.computePadding = function(width) { return this.go$val.computePadding(width); };
	fmt.Ptr.prototype.writePadding = function(n, padding) {
		var f, m;
		f = this;
		while (n > 0) {
			m = n;
			if (m > 65) {
				m = 65;
			}
			f.buf.Write(go$subslice(padding, 0, m));
			n = n - (m) >> 0;
		}
	};
	fmt.prototype.writePadding = function(n, padding) { return this.go$val.writePadding(n, padding); };
	fmt.Ptr.prototype.pad = function(b) {
		var f, _tuple, padding, left, right;
		f = this;
		if (!f.widPresent || (f.wid === 0)) {
			f.buf.Write(b);
			return;
		}
		_tuple = f.computePadding(b.length), padding = _tuple[0], left = _tuple[1], right = _tuple[2];
		if (left > 0) {
			f.writePadding(left, padding);
		}
		f.buf.Write(b);
		if (right > 0) {
			f.writePadding(right, padding);
		}
	};
	fmt.prototype.pad = function(b) { return this.go$val.pad(b); };
	fmt.Ptr.prototype.padString = function(s) {
		var f, _tuple, padding, left, right;
		f = this;
		if (!f.widPresent || (f.wid === 0)) {
			f.buf.WriteString(s);
			return;
		}
		_tuple = f.computePadding(utf8.RuneCountInString(s)), padding = _tuple[0], left = _tuple[1], right = _tuple[2];
		if (left > 0) {
			f.writePadding(left, padding);
		}
		f.buf.WriteString(s);
		if (right > 0) {
			f.writePadding(right, padding);
		}
	};
	fmt.prototype.padString = function(s) { return this.go$val.padString(s); };
	fmt.Ptr.prototype.fmt_boolean = function(v) {
		var f;
		f = this;
		if (v) {
			f.pad(trueBytes);
		} else {
			f.pad(falseBytes);
		}
	};
	fmt.prototype.fmt_boolean = function(v) { return this.go$val.fmt_boolean(v); };
	fmt.Ptr.prototype.integer = function(a, base, signedness, digits) {
		var f, buf, negative, prec, i, ua, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _ref, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10, _slice$11, _index$11, runeWidth, width, j, _slice$12, _index$12, _slice$13, _index$13, _slice$14, _index$14;
		f = this;
		if (f.precPresent && (f.prec === 0) && (a.high === 0 && a.low === 0)) {
			return;
		}
		buf = go$subslice(new (go$sliceType(Go$Uint8))(f.intbuf), 0);
		if (f.widPresent && f.wid > 65) {
			buf = (go$sliceType(Go$Uint8)).make(f.wid, 0, function() { return 0; });
		}
		negative = signedness === true && (a.high < 0 || (a.high === 0 && a.low < 0));
		if (negative) {
			a = new Go$Int64(-a.high, -a.low);
		}
		prec = 0;
		if (f.precPresent) {
			prec = f.prec;
			f.zero = false;
		} else if (f.zero && f.widPresent && !f.minus && f.wid > 0) {
			prec = f.wid;
			if (negative || f.plus || f.space) {
				prec = prec - 1 >> 0;
			}
		}
		i = buf.length;
		ua = new Go$Uint64(a.high, a.low);
		while ((ua.high > base.high || (ua.high === base.high && ua.low >= base.low))) {
			i = i - 1 >> 0;
			_slice = buf, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = digits.charCodeAt(go$flatten64(go$div64(ua, base, true)))) : go$throwRuntimeError("index out of range");
			ua = go$div64(ua, (base), false);
		}
		i = i - 1 >> 0;
		_slice$1 = buf, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = digits.charCodeAt(go$flatten64(ua))) : go$throwRuntimeError("index out of range");
		while (i > 0 && prec > (buf.length - i >> 0)) {
			i = i - 1 >> 0;
			_slice$2 = buf, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 48) : go$throwRuntimeError("index out of range");
		}
		if (f.sharp) {
			_ref = base;
			if ((_ref.high === 0 && _ref.low === 8)) {
				if (!(((_slice$3 = buf, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) === 48))) {
					i = i - 1 >> 0;
					_slice$4 = buf, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = 48) : go$throwRuntimeError("index out of range");
				}
			} else if ((_ref.high === 0 && _ref.low === 16)) {
				i = i - 1 >> 0;
				_slice$5 = buf, _index$5 = i, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (120 + digits.charCodeAt(10) << 24 >>> 24) - 97 << 24 >>> 24) : go$throwRuntimeError("index out of range");
				i = i - 1 >> 0;
				_slice$6 = buf, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = 48) : go$throwRuntimeError("index out of range");
			}
		}
		if (f.unicode) {
			i = i - 1 >> 0;
			_slice$7 = buf, _index$7 = i, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = 43) : go$throwRuntimeError("index out of range");
			i = i - 1 >> 0;
			_slice$8 = buf, _index$8 = i, (_index$8 >= 0 && _index$8 < _slice$8.length) ? (_slice$8.array[_slice$8.offset + _index$8] = 85) : go$throwRuntimeError("index out of range");
		}
		if (negative) {
			i = i - 1 >> 0;
			_slice$9 = buf, _index$9 = i, (_index$9 >= 0 && _index$9 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$9] = 45) : go$throwRuntimeError("index out of range");
		} else if (f.plus) {
			i = i - 1 >> 0;
			_slice$10 = buf, _index$10 = i, (_index$10 >= 0 && _index$10 < _slice$10.length) ? (_slice$10.array[_slice$10.offset + _index$10] = 43) : go$throwRuntimeError("index out of range");
		} else if (f.space) {
			i = i - 1 >> 0;
			_slice$11 = buf, _index$11 = i, (_index$11 >= 0 && _index$11 < _slice$11.length) ? (_slice$11.array[_slice$11.offset + _index$11] = 32) : go$throwRuntimeError("index out of range");
		}
		if (f.unicode && f.uniQuote && (a.high > 0 || (a.high === 0 && a.low >= 0)) && (a.high < 0 || (a.high === 0 && a.low <= 1114111)) && strconv.IsPrint(((a.low + ((a.high >> 31) * 4294967296)) >> 0))) {
			runeWidth = utf8.RuneLen(((a.low + ((a.high >> 31) * 4294967296)) >> 0));
			width = (2 + runeWidth >> 0) + 1 >> 0;
			go$copySlice(go$subslice(buf, (i - width >> 0)), go$subslice(buf, i));
			i = i - (width) >> 0;
			j = buf.length - width >> 0;
			_slice$12 = buf, _index$12 = j, (_index$12 >= 0 && _index$12 < _slice$12.length) ? (_slice$12.array[_slice$12.offset + _index$12] = 32) : go$throwRuntimeError("index out of range");
			j = j + 1 >> 0;
			_slice$13 = buf, _index$13 = j, (_index$13 >= 0 && _index$13 < _slice$13.length) ? (_slice$13.array[_slice$13.offset + _index$13] = 39) : go$throwRuntimeError("index out of range");
			j = j + 1 >> 0;
			utf8.EncodeRune(go$subslice(buf, j), ((a.low + ((a.high >> 31) * 4294967296)) >> 0));
			j = j + (runeWidth) >> 0;
			_slice$14 = buf, _index$14 = j, (_index$14 >= 0 && _index$14 < _slice$14.length) ? (_slice$14.array[_slice$14.offset + _index$14] = 39) : go$throwRuntimeError("index out of range");
		}
		f.pad(go$subslice(buf, i));
	};
	fmt.prototype.integer = function(a, base, signedness, digits) { return this.go$val.integer(a, base, signedness, digits); };
	fmt.Ptr.prototype.truncate = function(s) {
		var f, n, _ref, _i, _rune, i;
		f = this;
		if (f.precPresent && f.prec < utf8.RuneCountInString(s)) {
			n = f.prec;
			_ref = s;
			_i = 0;
			while (_i < _ref.length) {
				_rune = go$decodeRune(_ref, _i);
				i = _i;
				if (n === 0) {
					s = s.substring(0, i);
					break;
				}
				n = n - 1 >> 0;
				_i += _rune[1];
			}
		}
		return s;
	};
	fmt.prototype.truncate = function(s) { return this.go$val.truncate(s); };
	fmt.Ptr.prototype.fmt_s = function(s) {
		var f;
		f = this;
		s = f.truncate(s);
		f.padString(s);
	};
	fmt.prototype.fmt_s = function(s) { return this.go$val.fmt_s(s); };
	fmt.Ptr.prototype.fmt_sbx = function(s, b, digits) {
		var f, n, x, buf, i, c, _slice, _index;
		f = this;
		n = b.length;
		if (b === (go$sliceType(Go$Uint8)).nil) {
			n = s.length;
		}
		x = (digits.charCodeAt(10) - 97 << 24 >>> 24) + 120 << 24 >>> 24;
		buf = (go$sliceType(Go$Uint8)).nil;
		i = 0;
		while (i < n) {
			if (i > 0 && f.space) {
				buf = go$append(buf, 32);
			}
			if (f.sharp) {
				buf = go$append(buf, 48, x);
			}
			c = 0;
			if (b === (go$sliceType(Go$Uint8)).nil) {
				c = s.charCodeAt(i);
			} else {
				c = (_slice = b, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			}
			buf = go$append(buf, digits.charCodeAt((c >>> 4 << 24 >>> 24)), digits.charCodeAt(((c & 15) >>> 0)));
			i = i + 1 >> 0;
		}
		f.pad(buf);
	};
	fmt.prototype.fmt_sbx = function(s, b, digits) { return this.go$val.fmt_sbx(s, b, digits); };
	fmt.Ptr.prototype.fmt_sx = function(s, digits) {
		var f;
		f = this;
		f.fmt_sbx(s, (go$sliceType(Go$Uint8)).nil, digits);
	};
	fmt.prototype.fmt_sx = function(s, digits) { return this.go$val.fmt_sx(s, digits); };
	fmt.Ptr.prototype.fmt_bx = function(b, digits) {
		var f;
		f = this;
		f.fmt_sbx("", b, digits);
	};
	fmt.prototype.fmt_bx = function(b, digits) { return this.go$val.fmt_bx(b, digits); };
	fmt.Ptr.prototype.fmt_q = function(s) {
		var f, quoted;
		f = this;
		s = f.truncate(s);
		quoted = "";
		if (f.sharp && strconv.CanBackquote(s)) {
			quoted = "`" + s + "`";
		} else {
			if (f.plus) {
				quoted = strconv.QuoteToASCII(s);
			} else {
				quoted = strconv.Quote(s);
			}
		}
		f.padString(quoted);
	};
	fmt.prototype.fmt_q = function(s) { return this.go$val.fmt_q(s); };
	fmt.Ptr.prototype.fmt_qc = function(c) {
		var f, quoted;
		f = this;
		quoted = (go$sliceType(Go$Uint8)).nil;
		if (f.plus) {
			quoted = strconv.AppendQuoteRuneToASCII(go$subslice(new (go$sliceType(Go$Uint8))(f.intbuf), 0, 0), ((c.low + ((c.high >> 31) * 4294967296)) >> 0));
		} else {
			quoted = strconv.AppendQuoteRune(go$subslice(new (go$sliceType(Go$Uint8))(f.intbuf), 0, 0), ((c.low + ((c.high >> 31) * 4294967296)) >> 0));
		}
		f.pad(quoted);
	};
	fmt.prototype.fmt_qc = function(c) { return this.go$val.fmt_qc(c); };
	var doPrec = function(f, def) {
		if (f.precPresent) {
			return f.prec;
		}
		return def;
	};
	fmt.Ptr.prototype.formatFloat = function(v, verb, prec, n) {
		var f, slice, _ref, _slice, _index, _slice$1, _index$1, _slice$2, _index$2;
		f = this;
		f.intbuf[0] = 32;
		slice = strconv.AppendFloat(go$subslice(new (go$sliceType(Go$Uint8))(f.intbuf), 0, 1), v, verb, prec, n);
		_ref = (_slice = slice, _index = 1, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		if (_ref === 45 || _ref === 43) {
			if (f.zero && f.widPresent && f.wid > slice.length) {
				f.buf.WriteByte((_slice$1 = slice, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")));
				f.wid = f.wid - 1 >> 0;
				f.pad(go$subslice(slice, 2));
				return;
			}
			slice = go$subslice(slice, 1);
		} else {
			if (f.plus) {
				_slice$2 = slice, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 43) : go$throwRuntimeError("index out of range");
			} else if (f.space) {
			} else {
				slice = go$subslice(slice, 1);
			}
		}
		f.pad(slice);
	};
	fmt.prototype.formatFloat = function(v, verb, prec, n) { return this.go$val.formatFloat(v, verb, prec, n); };
	fmt.Ptr.prototype.fmt_e64 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 101, doPrec(f, 6), 64);
	};
	fmt.prototype.fmt_e64 = function(v) { return this.go$val.fmt_e64(v); };
	fmt.Ptr.prototype.fmt_E64 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 69, doPrec(f, 6), 64);
	};
	fmt.prototype.fmt_E64 = function(v) { return this.go$val.fmt_E64(v); };
	fmt.Ptr.prototype.fmt_f64 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 102, doPrec(f, 6), 64);
	};
	fmt.prototype.fmt_f64 = function(v) { return this.go$val.fmt_f64(v); };
	fmt.Ptr.prototype.fmt_g64 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 103, doPrec(f, -1), 64);
	};
	fmt.prototype.fmt_g64 = function(v) { return this.go$val.fmt_g64(v); };
	fmt.Ptr.prototype.fmt_G64 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 71, doPrec(f, -1), 64);
	};
	fmt.prototype.fmt_G64 = function(v) { return this.go$val.fmt_G64(v); };
	fmt.Ptr.prototype.fmt_fb64 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 98, 0, 64);
	};
	fmt.prototype.fmt_fb64 = function(v) { return this.go$val.fmt_fb64(v); };
	fmt.Ptr.prototype.fmt_e32 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 101, doPrec(f, 6), 32);
	};
	fmt.prototype.fmt_e32 = function(v) { return this.go$val.fmt_e32(v); };
	fmt.Ptr.prototype.fmt_E32 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 69, doPrec(f, 6), 32);
	};
	fmt.prototype.fmt_E32 = function(v) { return this.go$val.fmt_E32(v); };
	fmt.Ptr.prototype.fmt_f32 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 102, doPrec(f, 6), 32);
	};
	fmt.prototype.fmt_f32 = function(v) { return this.go$val.fmt_f32(v); };
	fmt.Ptr.prototype.fmt_g32 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 103, doPrec(f, -1), 32);
	};
	fmt.prototype.fmt_g32 = function(v) { return this.go$val.fmt_g32(v); };
	fmt.Ptr.prototype.fmt_G32 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 71, doPrec(f, -1), 32);
	};
	fmt.prototype.fmt_G32 = function(v) { return this.go$val.fmt_G32(v); };
	fmt.Ptr.prototype.fmt_fb32 = function(v) {
		var f;
		f = this;
		f.formatFloat(v, 98, 0, 32);
	};
	fmt.prototype.fmt_fb32 = function(v) { return this.go$val.fmt_fb32(v); };
	fmt.Ptr.prototype.fmt_c64 = function(v, verb) {
		var f, r, oldPlus, i, _ref;
		f = this;
		f.buf.WriteByte(40);
		r = v.real;
		oldPlus = f.plus;
		i = 0;
		while (true) {
			_ref = verb;
			if (_ref === 98) {
				f.fmt_fb32(r);
			} else if (_ref === 101) {
				f.fmt_e32(r);
			} else if (_ref === 69) {
				f.fmt_E32(r);
			} else if (_ref === 102) {
				f.fmt_f32(r);
			} else if (_ref === 103) {
				f.fmt_g32(r);
			} else if (_ref === 71) {
				f.fmt_G32(r);
			}
			if (!((i === 0))) {
				break;
			}
			f.plus = true;
			r = v.imag;
			i = i + 1 >> 0;
		}
		f.plus = oldPlus;
		f.buf.Write(irparenBytes);
	};
	fmt.prototype.fmt_c64 = function(v, verb) { return this.go$val.fmt_c64(v, verb); };
	fmt.Ptr.prototype.fmt_c128 = function(v, verb) {
		var f, r, oldPlus, i, _ref;
		f = this;
		f.buf.WriteByte(40);
		r = v.real;
		oldPlus = f.plus;
		i = 0;
		while (true) {
			_ref = verb;
			if (_ref === 98) {
				f.fmt_fb64(r);
			} else if (_ref === 101) {
				f.fmt_e64(r);
			} else if (_ref === 69) {
				f.fmt_E64(r);
			} else if (_ref === 102) {
				f.fmt_f64(r);
			} else if (_ref === 103) {
				f.fmt_g64(r);
			} else if (_ref === 71) {
				f.fmt_G64(r);
			}
			if (!((i === 0))) {
				break;
			}
			f.plus = true;
			r = v.imag;
			i = i + 1 >> 0;
		}
		f.plus = oldPlus;
		f.buf.Write(irparenBytes);
	};
	fmt.prototype.fmt_c128 = function(v, verb) { return this.go$val.fmt_c128(v, verb); };
	go$ptrType(buffer).prototype.Write = function(p) {
		var n, err, b, _tuple;
		n = 0;
		err = null;
		b = this;
		b.go$set(go$appendSlice(b.go$get(), p));
		_tuple = [p.length, null], n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	buffer.prototype.Write = function(p) { var obj = this; return (new (go$ptrType(buffer))(function() { return obj; }, null)).Write(p); };
	go$ptrType(buffer).prototype.WriteString = function(s) {
		var n, err, b, _tuple;
		n = 0;
		err = null;
		b = this;
		b.go$set(go$appendSlice(b.go$get(), new buffer(go$stringToBytes(s))));
		_tuple = [s.length, null], n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	buffer.prototype.WriteString = function(s) { var obj = this; return (new (go$ptrType(buffer))(function() { return obj; }, null)).WriteString(s); };
	go$ptrType(buffer).prototype.WriteByte = function(c) {
		var b;
		b = this;
		b.go$set(go$append(b.go$get(), c));
		return null;
	};
	buffer.prototype.WriteByte = function(c) { var obj = this; return (new (go$ptrType(buffer))(function() { return obj; }, null)).WriteByte(c); };
	go$ptrType(buffer).prototype.WriteRune = function(r) {
		var bp, b, n, x, w;
		bp = this;
		if (r < 128) {
			bp.go$set(go$append(bp.go$get(), (r << 24 >>> 24)));
			return null;
		}
		b = bp.go$get();
		n = b.length;
		while ((n + 4 >> 0) > b.capacity) {
			b = go$append(b, 0);
		}
		w = utf8.EncodeRune((x = go$subslice(b, n, (n + 4 >> 0)), go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length)), r);
		bp.go$set(go$subslice(b, 0, (n + w >> 0)));
		return null;
	};
	buffer.prototype.WriteRune = function(r) { var obj = this; return (new (go$ptrType(buffer))(function() { return obj; }, null)).WriteRune(r); };
	cache.Ptr.prototype.put = function(x) {
		var c;
		c = this;
		c.mu.Lock();
		if (c.saved.length < c.saved.capacity) {
			c.saved = go$append(c.saved, x);
		}
		c.mu.Unlock();
	};
	cache.prototype.put = function(x) { return this.go$val.put(x); };
	cache.Ptr.prototype.get = function() {
		var c, n, _slice, _index, x;
		c = this;
		c.mu.Lock();
		n = c.saved.length;
		if (n === 0) {
			c.mu.Unlock();
			return c.new$2();
		}
		x = (_slice = c.saved, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		c.saved = go$subslice(c.saved, 0, (n - 1 >> 0));
		c.mu.Unlock();
		return x;
	};
	cache.prototype.get = function() { return this.go$val.get(); };
	var newCache = function(f) {
		return new cache.Ptr(new sync.Mutex.Ptr(), (go$sliceType(go$emptyInterface)).make(0, 100, function() { return null; }), f);
	};
	var newPrinter = function() {
		var x, p, v;
		p = (x = ppFree.get(), (x !== null && x.constructor === (go$ptrType(pp)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(pp)))));
		p.panicking = false;
		p.erroring = false;
		p.fmt.init(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; }));
		return p;
	};
	pp.Ptr.prototype.free = function() {
		var p;
		p = this;
		if (p.buf.capacity > 1024) {
			return;
		}
		p.buf = go$subslice(p.buf, 0, 0);
		p.arg = null;
		p.value = new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0);
		ppFree.put(p);
	};
	pp.prototype.free = function() { return this.go$val.free(); };
	pp.Ptr.prototype.Width = function() {
		var wid, ok, p, _tuple;
		wid = 0;
		ok = false;
		p = this;
		_tuple = [p.fmt.wid, p.fmt.widPresent], wid = _tuple[0], ok = _tuple[1];
		return [wid, ok];
	};
	pp.prototype.Width = function() { return this.go$val.Width(); };
	pp.Ptr.prototype.Precision = function() {
		var prec, ok, p, _tuple;
		prec = 0;
		ok = false;
		p = this;
		_tuple = [p.fmt.prec, p.fmt.precPresent], prec = _tuple[0], ok = _tuple[1];
		return [prec, ok];
	};
	pp.prototype.Precision = function() { return this.go$val.Precision(); };
	pp.Ptr.prototype.Flag = function(b) {
		var p, _ref;
		p = this;
		_ref = b;
		if (_ref === 45) {
			return p.fmt.minus;
		} else if (_ref === 43) {
			return p.fmt.plus;
		} else if (_ref === 35) {
			return p.fmt.sharp;
		} else if (_ref === 32) {
			return p.fmt.space;
		} else if (_ref === 48) {
			return p.fmt.zero;
		}
		return false;
	};
	pp.prototype.Flag = function(b) { return this.go$val.Flag(b); };
	pp.Ptr.prototype.add = function(c) {
		var p, v;
		p = this;
		(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).WriteRune(c);
	};
	pp.prototype.add = function(c) { return this.go$val.add(c); };
	pp.Ptr.prototype.Write = function(b) {
		var ret, err, p, _tuple, v;
		ret = 0;
		err = null;
		p = this;
		_tuple = (new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).Write(b), ret = _tuple[0], err = _tuple[1];
		return [ret, err];
	};
	pp.prototype.Write = function(b) { return this.go$val.Write(b); };
	var Fprintf = go$pkg.Fprintf = function(w, format, a) {
		var n, err, p, _tuple, x;
		n = 0;
		err = null;
		p = newPrinter();
		p.doPrintf(format, a);
		_tuple = w.Write((x = p.buf, go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length))), n = _tuple[0], err = _tuple[1];
		p.free();
		return [n, err];
	};
	var Printf = go$pkg.Printf = function(format, a) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = Fprintf(os.Stdout, format, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Sprintf = go$pkg.Sprintf = function(format, a) {
		var p, s;
		p = newPrinter();
		p.doPrintf(format, a);
		s = go$bytesToString(p.buf);
		p.free();
		return s;
	};
	var Errorf = go$pkg.Errorf = function(format, a) {
		return errors.New(Sprintf(format, a));
	};
	var Fprint = go$pkg.Fprint = function(w, a) {
		var n, err, p, _tuple, x;
		n = 0;
		err = null;
		p = newPrinter();
		p.doPrint(a, false, false);
		_tuple = w.Write((x = p.buf, go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length))), n = _tuple[0], err = _tuple[1];
		p.free();
		return [n, err];
	};
	var Print = go$pkg.Print = function(a) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = Fprint(os.Stdout, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Sprint = go$pkg.Sprint = function(a) {
		var p, s;
		p = newPrinter();
		p.doPrint(a, false, false);
		s = go$bytesToString(p.buf);
		p.free();
		return s;
	};
	var Fprintln = go$pkg.Fprintln = function(w, a) {
		var n, err, p, _tuple, x;
		n = 0;
		err = null;
		p = newPrinter();
		p.doPrint(a, true, true);
		_tuple = w.Write((x = p.buf, go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length))), n = _tuple[0], err = _tuple[1];
		p.free();
		return [n, err];
	};
	var Println = go$pkg.Println = function(a) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = Fprintln(os.Stdout, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Sprintln = go$pkg.Sprintln = function(a) {
		var p, s;
		p = newPrinter();
		p.doPrint(a, true, true);
		s = go$bytesToString(p.buf);
		p.free();
		return s;
	};
	var getField = function(v, i) {
		var _struct, val, _struct$1, _struct$2;
		val = (_struct = v.Field(i), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if ((val.Kind() === 20) && !val.IsNil()) {
			val = (_struct$1 = val.Elem(), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		}
		return (_struct$2 = val, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
	};
	var parsenum = function(s, start, end) {
		var num, isnum, newi, _tuple, x;
		num = 0;
		isnum = false;
		newi = 0;
		if (start >= end) {
			_tuple = [0, false, end], num = _tuple[0], isnum = _tuple[1], newi = _tuple[2];
			return [num, isnum, newi];
		}
		newi = start;
		while (newi < end && 48 <= s.charCodeAt(newi) && s.charCodeAt(newi) <= 57) {
			num = (x = 10, (((num >>> 16 << 16) * x >> 0) + (num << 16 >>> 16) * x) >> 0) + ((s.charCodeAt(newi) - 48 << 24 >>> 24) >> 0) >> 0;
			isnum = true;
			newi = newi + 1 >> 0;
		}
		return [num, isnum, newi];
	};
	pp.Ptr.prototype.unknownType = function(v) {
		var p, v$1, v$2, v$3, v$4;
		p = this;
		if (go$interfaceIsEqual(v, null)) {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).Write(nilAngleBytes);
			return;
		}
		(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).WriteByte(63);
		(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$3) { p.buf = v$3; })).WriteString(reflect.TypeOf(v).String());
		(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$4) { p.buf = v$4; })).WriteByte(63);
	};
	pp.prototype.unknownType = function(v) { return this.go$val.unknownType(v); };
	pp.Ptr.prototype.badVerb = function(verb) {
		var p, v, v$1, _struct, v$2;
		p = this;
		p.erroring = true;
		p.add(37);
		p.add(33);
		p.add(verb);
		p.add(40);
		if (!(go$interfaceIsEqual(p.arg, null))) {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).WriteString(reflect.TypeOf(p.arg).String());
			p.add(61);
			p.printArg(p.arg, 118, false, false, 0);
		} else if (p.value.IsValid()) {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).WriteString(p.value.Type().String());
			p.add(61);
			p.printValue((_struct = p.value, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), 118, false, false, 0);
		} else {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).Write(nilAngleBytes);
		}
		p.add(41);
		p.erroring = false;
	};
	pp.prototype.badVerb = function(verb) { return this.go$val.badVerb(verb); };
	pp.Ptr.prototype.fmtBool = function(v, verb) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 116 || _ref === 118) {
			p.fmt.fmt_boolean(v);
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtBool = function(v, verb) { return this.go$val.fmtBool(v, verb); };
	pp.Ptr.prototype.fmtC = function(c) {
		var p, r, x, w;
		p = this;
		r = ((c.low + ((c.high >> 31) * 4294967296)) >> 0);
		if (!((x = new Go$Int64(0, r), (x.high === c.high && x.low === c.low)))) {
			r = 65533;
		}
		w = utf8.EncodeRune(go$subslice(new (go$sliceType(Go$Uint8))(p.runeBuf), 0, 4), r);
		p.fmt.pad(go$subslice(new (go$sliceType(Go$Uint8))(p.runeBuf), 0, w));
	};
	pp.prototype.fmtC = function(c) { return this.go$val.fmtC(c); };
	pp.Ptr.prototype.fmtInt64 = function(v, verb) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 98) {
			p.fmt.integer(v, new Go$Uint64(0, 2), true, "0123456789abcdef");
		} else if (_ref === 99) {
			p.fmtC(v);
		} else if (_ref === 100 || _ref === 118) {
			p.fmt.integer(v, new Go$Uint64(0, 10), true, "0123456789abcdef");
		} else if (_ref === 111) {
			p.fmt.integer(v, new Go$Uint64(0, 8), true, "0123456789abcdef");
		} else if (_ref === 113) {
			if ((0 < v.high || (0 === v.high && 0 <= v.low)) && (v.high < 0 || (v.high === 0 && v.low <= 1114111))) {
				p.fmt.fmt_qc(v);
			} else {
				p.badVerb(verb);
			}
		} else if (_ref === 120) {
			p.fmt.integer(v, new Go$Uint64(0, 16), true, "0123456789abcdef");
		} else if (_ref === 85) {
			p.fmtUnicode(v);
		} else if (_ref === 88) {
			p.fmt.integer(v, new Go$Uint64(0, 16), true, "0123456789ABCDEF");
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtInt64 = function(v, verb) { return this.go$val.fmtInt64(v, verb); };
	pp.Ptr.prototype.fmt0x64 = function(v, leading0x) {
		var p, sharp;
		p = this;
		sharp = p.fmt.sharp;
		p.fmt.sharp = leading0x;
		p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 16), false, "0123456789abcdef");
		p.fmt.sharp = sharp;
	};
	pp.prototype.fmt0x64 = function(v, leading0x) { return this.go$val.fmt0x64(v, leading0x); };
	pp.Ptr.prototype.fmtUnicode = function(v) {
		var p, precPresent, sharp, prec;
		p = this;
		precPresent = p.fmt.precPresent;
		sharp = p.fmt.sharp;
		p.fmt.sharp = false;
		prec = p.fmt.prec;
		if (!precPresent) {
			p.fmt.prec = 4;
			p.fmt.precPresent = true;
		}
		p.fmt.unicode = true;
		p.fmt.uniQuote = sharp;
		p.fmt.integer(v, new Go$Uint64(0, 16), false, "0123456789ABCDEF");
		p.fmt.unicode = false;
		p.fmt.uniQuote = false;
		p.fmt.prec = prec;
		p.fmt.precPresent = precPresent;
		p.fmt.sharp = sharp;
	};
	pp.prototype.fmtUnicode = function(v) { return this.go$val.fmtUnicode(v); };
	pp.Ptr.prototype.fmtUint64 = function(v, verb, goSyntax) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 98) {
			p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 2), false, "0123456789abcdef");
		} else if (_ref === 99) {
			p.fmtC(new Go$Int64(v.high, v.low));
		} else if (_ref === 100) {
			p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 10), false, "0123456789abcdef");
		} else if (_ref === 118) {
			if (goSyntax) {
				p.fmt0x64(v, true);
			} else {
				p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 10), false, "0123456789abcdef");
			}
		} else if (_ref === 111) {
			p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 8), false, "0123456789abcdef");
		} else if (_ref === 113) {
			if ((0 < v.high || (0 === v.high && 0 <= v.low)) && (v.high < 0 || (v.high === 0 && v.low <= 1114111))) {
				p.fmt.fmt_qc(new Go$Int64(v.high, v.low));
			} else {
				p.badVerb(verb);
			}
		} else if (_ref === 120) {
			p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 16), false, "0123456789abcdef");
		} else if (_ref === 88) {
			p.fmt.integer(new Go$Int64(v.high, v.low), new Go$Uint64(0, 16), false, "0123456789ABCDEF");
		} else if (_ref === 85) {
			p.fmtUnicode(new Go$Int64(v.high, v.low));
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtUint64 = function(v, verb, goSyntax) { return this.go$val.fmtUint64(v, verb, goSyntax); };
	pp.Ptr.prototype.fmtFloat32 = function(v, verb) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 98) {
			p.fmt.fmt_fb32(v);
		} else if (_ref === 101) {
			p.fmt.fmt_e32(v);
		} else if (_ref === 69) {
			p.fmt.fmt_E32(v);
		} else if (_ref === 102) {
			p.fmt.fmt_f32(v);
		} else if (_ref === 103 || _ref === 118) {
			p.fmt.fmt_g32(v);
		} else if (_ref === 71) {
			p.fmt.fmt_G32(v);
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtFloat32 = function(v, verb) { return this.go$val.fmtFloat32(v, verb); };
	pp.Ptr.prototype.fmtFloat64 = function(v, verb) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 98) {
			p.fmt.fmt_fb64(v);
		} else if (_ref === 101) {
			p.fmt.fmt_e64(v);
		} else if (_ref === 69) {
			p.fmt.fmt_E64(v);
		} else if (_ref === 102) {
			p.fmt.fmt_f64(v);
		} else if (_ref === 103 || _ref === 118) {
			p.fmt.fmt_g64(v);
		} else if (_ref === 71) {
			p.fmt.fmt_G64(v);
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtFloat64 = function(v, verb) { return this.go$val.fmtFloat64(v, verb); };
	pp.Ptr.prototype.fmtComplex64 = function(v, verb) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 98 || _ref === 101 || _ref === 69 || _ref === 102 || _ref === 70 || _ref === 103 || _ref === 71) {
			p.fmt.fmt_c64(v, verb);
		} else if (_ref === 118) {
			p.fmt.fmt_c64(v, 103);
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtComplex64 = function(v, verb) { return this.go$val.fmtComplex64(v, verb); };
	pp.Ptr.prototype.fmtComplex128 = function(v, verb) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 98 || _ref === 101 || _ref === 69 || _ref === 102 || _ref === 70 || _ref === 103 || _ref === 71) {
			p.fmt.fmt_c128(v, verb);
		} else if (_ref === 118) {
			p.fmt.fmt_c128(v, 103);
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtComplex128 = function(v, verb) { return this.go$val.fmtComplex128(v, verb); };
	pp.Ptr.prototype.fmtString = function(v, verb, goSyntax) {
		var p, _ref;
		p = this;
		_ref = verb;
		if (_ref === 118) {
			if (goSyntax) {
				p.fmt.fmt_q(v);
			} else {
				p.fmt.fmt_s(v);
			}
		} else if (_ref === 115) {
			p.fmt.fmt_s(v);
		} else if (_ref === 120) {
			p.fmt.fmt_sx(v, "0123456789abcdef");
		} else if (_ref === 88) {
			p.fmt.fmt_sx(v, "0123456789ABCDEF");
		} else if (_ref === 113) {
			p.fmt.fmt_q(v);
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtString = function(v, verb, goSyntax) { return this.go$val.fmtString(v, verb, goSyntax); };
	pp.Ptr.prototype.fmtBytes = function(v, verb, goSyntax, typ, depth) {
		var p, v$1, v$2, v$3, v$4, _ref, _i, _slice, _index, c, i, v$5, v$6, v$7, v$8, _ref$1;
		p = this;
		if ((verb === 118) || (verb === 100)) {
			if (goSyntax) {
				if (go$interfaceIsEqual(typ, null)) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).Write(bytesBytes);
				} else {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).WriteString(typ.String());
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$3) { p.buf = v$3; })).WriteByte(123);
				}
			} else {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$4) { p.buf = v$4; })).WriteByte(91);
			}
			_ref = v;
			_i = 0;
			while (_i < _ref.length) {
				c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				if (i > 0) {
					if (goSyntax) {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$5) { p.buf = v$5; })).Write(commaSpaceBytes);
					} else {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$6) { p.buf = v$6; })).WriteByte(32);
					}
				}
				p.printArg(new Go$Uint8(c), 118, p.fmt.plus, goSyntax, depth + 1 >> 0);
				_i++;
			}
			if (goSyntax) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$7) { p.buf = v$7; })).WriteByte(125);
			} else {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$8) { p.buf = v$8; })).WriteByte(93);
			}
			return;
		}
		_ref$1 = verb;
		if (_ref$1 === 115) {
			p.fmt.fmt_s(go$bytesToString(v));
		} else if (_ref$1 === 120) {
			p.fmt.fmt_bx(v, "0123456789abcdef");
		} else if (_ref$1 === 88) {
			p.fmt.fmt_bx(v, "0123456789ABCDEF");
		} else if (_ref$1 === 113) {
			p.fmt.fmt_q(go$bytesToString(v));
		} else {
			p.badVerb(verb);
		}
	};
	pp.prototype.fmtBytes = function(v, verb, goSyntax, typ, depth) { return this.go$val.fmtBytes(v, verb, goSyntax, typ, depth); };
	pp.Ptr.prototype.fmtPointer = function(value, verb, goSyntax) {
		var p, use0x64, _ref, u, _ref$1, v, v$1, v$2;
		p = this;
		use0x64 = true;
		_ref = verb;
		if (_ref === 112 || _ref === 118) {
		} else if (_ref === 98 || _ref === 100 || _ref === 111 || _ref === 120 || _ref === 88) {
			use0x64 = false;
		} else {
			p.badVerb(verb);
			return;
		}
		u = 0;
		_ref$1 = value.Kind();
		if (_ref$1 === 18 || _ref$1 === 19 || _ref$1 === 21 || _ref$1 === 22 || _ref$1 === 23 || _ref$1 === 26) {
			u = value.Pointer();
		} else {
			p.badVerb(verb);
			return;
		}
		if (goSyntax) {
			p.add(40);
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).WriteString(value.Type().String());
			p.add(41);
			p.add(40);
			if (u === 0) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).Write(nilBytes);
			} else {
				p.fmt0x64(new Go$Uint64(0, u.constructor === Number ? u : 1), true);
			}
			p.add(41);
		} else if ((verb === 118) && (u === 0)) {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).Write(nilAngleBytes);
		} else {
			if (use0x64) {
				p.fmt0x64(new Go$Uint64(0, u.constructor === Number ? u : 1), !p.fmt.sharp);
			} else {
				p.fmtUint64(new Go$Uint64(0, u.constructor === Number ? u : 1), verb, false);
			}
		}
	};
	pp.prototype.fmtPointer = function(value, verb, goSyntax) { return this.go$val.fmtPointer(value, verb, goSyntax); };
	pp.Ptr.prototype.catchPanic = function(arg, verb) {
		var p, err, v, _struct, v$1, v$2, v$3, v$4;
		p = this;
		if (err = go$recover(), !(go$interfaceIsEqual(err, null))) {
			if (v = (_struct = reflect.ValueOf(arg), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), (v.Kind() === 22) && v.IsNil()) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).Write(nilAngleBytes);
				return;
			}
			if (p.panicking) {
				throw go$panic(err);
			}
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).Write(percentBangBytes);
			p.add(verb);
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$3) { p.buf = v$3; })).Write(panicBytes);
			p.panicking = true;
			p.printArg(err, 118, false, false, 0);
			p.panicking = false;
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$4) { p.buf = v$4; })).WriteByte(41);
		}
	};
	pp.prototype.catchPanic = function(arg, verb) { return this.go$val.catchPanic(arg, verb); };
	pp.Ptr.prototype.handleMethods = function(verb, plus, goSyntax, depth) {
		var wasString, handled, p, ok, _tuple, x, formatter, ok$1, _tuple$1, x$1, stringer, _ref, v, _ref$1, _type;
		wasString = false;
		handled = false;
		var go$deferred = [];
		try {
			p = this;
			if (p.erroring) {
				return [wasString, handled];
			}
			if (_tuple = (x = p.arg, (x !== null && Formatter.implementedBy.indexOf(x.constructor) !== -1 ? [x, true] : [null, false])), formatter = _tuple[0], ok = _tuple[1], ok) {
				handled = true;
				wasString = false;
				go$deferred.push({ recv: p, method: "catchPanic", args: [p.arg, verb] });
				formatter.Format(p, verb);
				return [wasString, handled];
			}
			if (plus) {
				p.fmt.plus = false;
			}
			if (goSyntax) {
				p.fmt.sharp = false;
				if (_tuple$1 = (x$1 = p.arg, (x$1 !== null && GoStringer.implementedBy.indexOf(x$1.constructor) !== -1 ? [x$1, true] : [null, false])), stringer = _tuple$1[0], ok$1 = _tuple$1[1], ok$1) {
					wasString = false;
					handled = true;
					go$deferred.push({ recv: p, method: "catchPanic", args: [p.arg, verb] });
					p.fmtString(stringer.GoString(), 115, false);
					return [wasString, handled];
				}
			} else {
				_ref = verb;
				if (_ref === 118 || _ref === 115 || _ref === 120 || _ref === 88 || _ref === 113) {
					_ref$1 = p.arg;
					_type = _ref$1 !== null ? _ref$1.constructor : null;
					if (go$error.implementedBy.indexOf(_type) !== -1) {
						v = _ref$1;
						wasString = false;
						handled = true;
						go$deferred.push({ recv: p, method: "catchPanic", args: [p.arg, verb] });
						p.printArg(new Go$String(v.Error()), verb, plus, false, depth);
						return [wasString, handled];
					} else if (Stringer.implementedBy.indexOf(_type) !== -1) {
						v = _ref$1;
						wasString = false;
						handled = true;
						go$deferred.push({ recv: p, method: "catchPanic", args: [p.arg, verb] });
						p.printArg(new Go$String(v.String()), verb, plus, false, depth);
						return [wasString, handled];
					}
				}
			}
			handled = false;
			return [wasString, handled];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [wasString, handled];
		}
	};
	pp.prototype.handleMethods = function(verb, plus, goSyntax, depth) { return this.go$val.handleMethods(verb, plus, goSyntax, depth); };
	pp.Ptr.prototype.printArg = function(arg, verb, plus, goSyntax, depth) {
		var wasString, p, _ref, _struct, oldPlus, oldSharp, f, _ref$1, _type, handled, _tuple, isString, _struct$1;
		wasString = false;
		p = this;
		p.arg = arg;
		p.value = new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0);
		if (go$interfaceIsEqual(arg, null)) {
			if ((verb === 84) || (verb === 118)) {
				p.fmt.pad(nilAngleBytes);
			} else {
				p.badVerb(verb);
			}
			wasString = false;
			return wasString;
		}
		_ref = verb;
		if (_ref === 84) {
			p.printArg(new Go$String(reflect.TypeOf(arg).String()), 115, false, false, 0);
			wasString = false;
			return wasString;
		} else if (_ref === 112) {
			p.fmtPointer((_struct = reflect.ValueOf(arg), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), verb, goSyntax);
			wasString = false;
			return wasString;
		}
		oldPlus = p.fmt.plus;
		oldSharp = p.fmt.sharp;
		if (plus) {
			p.fmt.plus = false;
		}
		if (goSyntax) {
			p.fmt.sharp = false;
		}
		_ref$1 = arg;
		_type = _ref$1 !== null ? _ref$1.constructor : null;
		if (_type === Go$Bool) {
			f = _ref$1.go$val;
			p.fmtBool(f, verb);
		} else if (_type === Go$Float32) {
			f = _ref$1.go$val;
			p.fmtFloat32(f, verb);
		} else if (_type === Go$Float64) {
			f = _ref$1.go$val;
			p.fmtFloat64(f, verb);
		} else if (_type === Go$Complex64) {
			f = _ref$1.go$val;
			p.fmtComplex64(f, verb);
		} else if (_type === Go$Complex128) {
			f = _ref$1.go$val;
			p.fmtComplex128(f, verb);
		} else if (_type === Go$Int) {
			f = _ref$1.go$val;
			p.fmtInt64(new Go$Int64(0, f), verb);
		} else if (_type === Go$Int8) {
			f = _ref$1.go$val;
			p.fmtInt64(new Go$Int64(0, f), verb);
		} else if (_type === Go$Int16) {
			f = _ref$1.go$val;
			p.fmtInt64(new Go$Int64(0, f), verb);
		} else if (_type === Go$Int32) {
			f = _ref$1.go$val;
			p.fmtInt64(new Go$Int64(0, f), verb);
		} else if (_type === Go$Int64) {
			f = _ref$1.go$val;
			p.fmtInt64(f, verb);
		} else if (_type === Go$Uint) {
			f = _ref$1.go$val;
			p.fmtUint64(new Go$Uint64(0, f), verb, goSyntax);
		} else if (_type === Go$Uint8) {
			f = _ref$1.go$val;
			p.fmtUint64(new Go$Uint64(0, f), verb, goSyntax);
		} else if (_type === Go$Uint16) {
			f = _ref$1.go$val;
			p.fmtUint64(new Go$Uint64(0, f), verb, goSyntax);
		} else if (_type === Go$Uint32) {
			f = _ref$1.go$val;
			p.fmtUint64(new Go$Uint64(0, f), verb, goSyntax);
		} else if (_type === Go$Uint64) {
			f = _ref$1.go$val;
			p.fmtUint64(f, verb, goSyntax);
		} else if (_type === Go$Uintptr) {
			f = _ref$1.go$val;
			p.fmtUint64(new Go$Uint64(0, f.constructor === Number ? f : 1), verb, goSyntax);
		} else if (_type === Go$String) {
			f = _ref$1.go$val;
			p.fmtString(f, verb, goSyntax);
			wasString = (verb === 115) || (verb === 118);
		} else if (_type === (go$sliceType(Go$Uint8))) {
			f = _ref$1.go$val;
			p.fmtBytes(f, verb, goSyntax, null, depth);
			wasString = verb === 115;
		} else {
			f = _ref$1;
			p.fmt.plus = oldPlus;
			p.fmt.sharp = oldSharp;
			if (_tuple = p.handleMethods(verb, plus, goSyntax, depth), isString = _tuple[0], handled = _tuple[1], handled) {
				wasString = isString;
				return wasString;
			}
			wasString = p.printReflectValue((_struct$1 = reflect.ValueOf(arg), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), verb, plus, goSyntax, depth);
			return wasString;
		}
		p.arg = null;
		return wasString;
	};
	pp.prototype.printArg = function(arg, verb, plus, goSyntax, depth) { return this.go$val.printArg(arg, verb, plus, goSyntax, depth); };
	pp.Ptr.prototype.printValue = function(value, verb, plus, goSyntax, depth) {
		var wasString, p, v, _ref, _struct, handled, _tuple, isString, _struct$1;
		wasString = false;
		p = this;
		if (!value.IsValid()) {
			if ((verb === 84) || (verb === 118)) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).Write(nilAngleBytes);
			} else {
				p.badVerb(verb);
			}
			wasString = false;
			return wasString;
		}
		_ref = verb;
		if (_ref === 84) {
			p.printArg(new Go$String(value.Type().String()), 115, false, false, 0);
			wasString = false;
			return wasString;
		} else if (_ref === 112) {
			p.fmtPointer((_struct = value, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), verb, goSyntax);
			wasString = false;
			return wasString;
		}
		p.arg = null;
		if (value.CanInterface()) {
			p.arg = value.Interface();
		}
		if (_tuple = p.handleMethods(verb, plus, goSyntax, depth), isString = _tuple[0], handled = _tuple[1], handled) {
			wasString = isString;
			return wasString;
		}
		wasString = p.printReflectValue((_struct$1 = value, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), verb, plus, goSyntax, depth);
		return wasString;
	};
	pp.prototype.printValue = function(value, verb, plus, goSyntax, depth) { return this.go$val.printValue(value, verb, plus, goSyntax, depth); };
	pp.Ptr.prototype.printReflectValue = function(value, verb, plus, goSyntax, depth) {
		var wasString, p, _struct, oldValue, _struct$1, _struct$2, f, _ref, x, v, v$1, v$2, v$3, keys, _ref$1, _i, _slice, _index, _struct$3, key, i, v$4, v$5, _struct$4, v$6, _struct$5, _struct$6, v$7, v$8, v$9, _struct$7, v$10, t, i$1, v$11, v$12, f$1, _struct$8, v$13, v$14, _struct$9, _struct$10, v$15, _struct$11, value$1, v$16, v$17, v$18, _struct$12, typ, bytes, _ref$2, _i$1, i$2, _slice$1, _index$1, v$19, v$20, v$21, v$22, i$3, v$23, v$24, _struct$13, v$25, v$26, v$27, _struct$14, a, _ref$3, v$28, _struct$15, v$29, _struct$16, _struct$17, _struct$18, _struct$19;
		wasString = false;
		p = this;
		oldValue = (_struct = p.value, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		p.value = (_struct$1 = value, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		f = (_struct$2 = value, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		_ref = f.Kind();
		BigSwitch: switch (0) { default: if (_ref === 1) {
			p.fmtBool(f.Bool(), verb);
		} else if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			p.fmtInt64(f.Int(), verb);
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			p.fmtUint64(f.Uint(), verb, goSyntax);
		} else if (_ref === 13 || _ref === 14) {
			if (f.Type().Size() === 4) {
				p.fmtFloat32(f.Float(), verb);
			} else {
				p.fmtFloat64(f.Float(), verb);
			}
		} else if (_ref === 15 || _ref === 16) {
			if (f.Type().Size() === 8) {
				p.fmtComplex64((x = f.Complex(), new Go$Complex64(x.real, x.imag)), verb);
			} else {
				p.fmtComplex128(f.Complex(), verb);
			}
		} else if (_ref === 24) {
			p.fmtString(f.String(), verb, goSyntax);
		} else if (_ref === 21) {
			if (goSyntax) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).WriteString(f.Type().String());
				if (f.IsNil()) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).WriteString("(nil)");
					break;
				}
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).WriteByte(123);
			} else {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$3) { p.buf = v$3; })).Write(mapBytes);
			}
			keys = f.MapKeys();
			_ref$1 = keys;
			_i = 0;
			while (_i < _ref$1.length) {
				key = (_struct$3 = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
				i = _i;
				if (i > 0) {
					if (goSyntax) {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$4) { p.buf = v$4; })).Write(commaSpaceBytes);
					} else {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$5) { p.buf = v$5; })).WriteByte(32);
					}
				}
				p.printValue((_struct$4 = key, new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), verb, plus, goSyntax, depth + 1 >> 0);
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$6) { p.buf = v$6; })).WriteByte(58);
				p.printValue((_struct$6 = f.MapIndex((_struct$5 = key, new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag))), new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)), verb, plus, goSyntax, depth + 1 >> 0);
				_i++;
			}
			if (goSyntax) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$7) { p.buf = v$7; })).WriteByte(125);
			} else {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$8) { p.buf = v$8; })).WriteByte(93);
			}
		} else if (_ref === 25) {
			if (goSyntax) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$9) { p.buf = v$9; })).WriteString(value.Type().String());
			}
			p.add(123);
			v$10 = (_struct$7 = f, new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag));
			t = v$10.Type();
			i$1 = 0;
			while (i$1 < v$10.NumField()) {
				if (i$1 > 0) {
					if (goSyntax) {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$11) { p.buf = v$11; })).Write(commaSpaceBytes);
					} else {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$12) { p.buf = v$12; })).WriteByte(32);
					}
				}
				if (plus || goSyntax) {
					if (f$1 = (_struct$8 = t.Field(i$1), new reflect.StructField.Ptr(_struct$8.Name, _struct$8.PkgPath, _struct$8.Type, _struct$8.Tag, _struct$8.Offset, _struct$8.Index, _struct$8.Anonymous)), !(f$1.Name === "")) {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$13) { p.buf = v$13; })).WriteString(f$1.Name);
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$14) { p.buf = v$14; })).WriteByte(58);
					}
				}
				p.printValue((_struct$10 = getField((_struct$9 = v$10, new reflect.Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag)), i$1), new reflect.Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag)), verb, plus, goSyntax, depth + 1 >> 0);
				i$1 = i$1 + 1 >> 0;
			}
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$15) { p.buf = v$15; })).WriteByte(125);
		} else if (_ref === 20) {
			value$1 = (_struct$11 = f.Elem(), new reflect.Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag));
			if (!value$1.IsValid()) {
				if (goSyntax) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$16) { p.buf = v$16; })).WriteString(f.Type().String());
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$17) { p.buf = v$17; })).Write(nilParenBytes);
				} else {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$18) { p.buf = v$18; })).Write(nilAngleBytes);
				}
			} else {
				wasString = p.printValue((_struct$12 = value$1, new reflect.Value.Ptr(_struct$12.typ, _struct$12.val, _struct$12.flag)), verb, plus, goSyntax, depth + 1 >> 0);
			}
		} else if (_ref === 17 || _ref === 23) {
			if (typ = f.Type(), typ.Elem().Kind() === 8) {
				bytes = (go$sliceType(Go$Uint8)).nil;
				if (f.Kind() === 23) {
					bytes = f.Bytes();
				} else if (f.CanAddr()) {
					bytes = f.Slice(0, f.Len()).Bytes();
				} else {
					bytes = (go$sliceType(Go$Uint8)).make(f.Len(), 0, function() { return 0; });
					_ref$2 = bytes;
					_i$1 = 0;
					while (_i$1 < _ref$2.length) {
						i$2 = _i$1;
						_slice$1 = bytes, _index$1 = i$2, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (f.Index(i$2).Uint().low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
						_i$1++;
					}
				}
				p.fmtBytes(bytes, verb, goSyntax, typ, depth);
				wasString = verb === 115;
				break;
			}
			if (goSyntax) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$19) { p.buf = v$19; })).WriteString(value.Type().String());
				if ((f.Kind() === 23) && f.IsNil()) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$20) { p.buf = v$20; })).WriteString("(nil)");
					break;
				}
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$21) { p.buf = v$21; })).WriteByte(123);
			} else {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$22) { p.buf = v$22; })).WriteByte(91);
			}
			i$3 = 0;
			while (i$3 < f.Len()) {
				if (i$3 > 0) {
					if (goSyntax) {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$23) { p.buf = v$23; })).Write(commaSpaceBytes);
					} else {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$24) { p.buf = v$24; })).WriteByte(32);
					}
				}
				p.printValue((_struct$13 = f.Index(i$3), new reflect.Value.Ptr(_struct$13.typ, _struct$13.val, _struct$13.flag)), verb, plus, goSyntax, depth + 1 >> 0);
				i$3 = i$3 + 1 >> 0;
			}
			if (goSyntax) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$25) { p.buf = v$25; })).WriteByte(125);
			} else {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$26) { p.buf = v$26; })).WriteByte(93);
			}
		} else if (_ref === 22) {
			v$27 = f.Pointer();
			if (!((v$27 === 0)) && (depth === 0)) {
				a = (_struct$14 = f.Elem(), new reflect.Value.Ptr(_struct$14.typ, _struct$14.val, _struct$14.flag));
				_ref$3 = a.Kind();
				if (_ref$3 === 17 || _ref$3 === 23) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$28) { p.buf = v$28; })).WriteByte(38);
					p.printValue((_struct$15 = a, new reflect.Value.Ptr(_struct$15.typ, _struct$15.val, _struct$15.flag)), verb, plus, goSyntax, depth + 1 >> 0);
					break BigSwitch;
				} else if (_ref$3 === 25) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$29) { p.buf = v$29; })).WriteByte(38);
					p.printValue((_struct$16 = a, new reflect.Value.Ptr(_struct$16.typ, _struct$16.val, _struct$16.flag)), verb, plus, goSyntax, depth + 1 >> 0);
					break BigSwitch;
				}
			}
			p.fmtPointer((_struct$17 = value, new reflect.Value.Ptr(_struct$17.typ, _struct$17.val, _struct$17.flag)), verb, goSyntax);
		} else if (_ref === 18 || _ref === 19 || _ref === 26) {
			p.fmtPointer((_struct$18 = value, new reflect.Value.Ptr(_struct$18.typ, _struct$18.val, _struct$18.flag)), verb, goSyntax);
		} else {
			p.unknownType(new f.constructor.Struct(f));
		} }
		p.value = (_struct$19 = oldValue, new reflect.Value.Ptr(_struct$19.typ, _struct$19.val, _struct$19.flag));
		wasString = wasString;
		return wasString;
	};
	pp.prototype.printReflectValue = function(value, verb, plus, goSyntax, depth) { return this.go$val.printReflectValue(value, verb, plus, goSyntax, depth); };
	var intFromArg = function(a, argNum) {
		var num, isInt, newArgNum, _tuple, x, _slice, _index;
		num = 0;
		isInt = false;
		newArgNum = 0;
		newArgNum = argNum;
		if (argNum < a.length) {
			_tuple = (x = (_slice = a, _index = argNum, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (x !== null && x.constructor === Go$Int ? [x.go$val, true] : [0, false])), num = _tuple[0], isInt = _tuple[1];
			newArgNum = argNum + 1 >> 0;
		}
		return [num, isInt, newArgNum];
	};
	var parseArgNumber = function(format) {
		var index, wid, ok, i, _tuple, width, ok$1, newi, _tuple$1, _tuple$2, _tuple$3;
		index = 0;
		wid = 0;
		ok = false;
		i = 1;
		while (i < format.length) {
			if (format.charCodeAt(i) === 93) {
				_tuple = parsenum(format, 1, i), width = _tuple[0], ok$1 = _tuple[1], newi = _tuple[2];
				if (!ok$1 || !((newi === i))) {
					_tuple$1 = [0, i + 1 >> 0, false], index = _tuple$1[0], wid = _tuple$1[1], ok = _tuple$1[2];
					return [index, wid, ok];
				}
				_tuple$2 = [width - 1 >> 0, i + 1 >> 0, true], index = _tuple$2[0], wid = _tuple$2[1], ok = _tuple$2[2];
				return [index, wid, ok];
			}
			i = i + 1 >> 0;
		}
		_tuple$3 = [0, 1, false], index = _tuple$3[0], wid = _tuple$3[1], ok = _tuple$3[2];
		return [index, wid, ok];
	};
	pp.Ptr.prototype.argNumber = function(argNum, format, i, numArgs) {
		var newArgNum, newi, found, p, _tuple, _tuple$1, index, wid, ok, _tuple$2, _tuple$3;
		newArgNum = 0;
		newi = 0;
		found = false;
		p = this;
		if (format.length <= i || !((format.charCodeAt(i) === 91))) {
			_tuple = [argNum, i, false], newArgNum = _tuple[0], newi = _tuple[1], found = _tuple[2];
			return [newArgNum, newi, found];
		}
		p.reordered = true;
		_tuple$1 = parseArgNumber(format.substring(i)), index = _tuple$1[0], wid = _tuple$1[1], ok = _tuple$1[2];
		if (ok && 0 <= index && index < numArgs) {
			_tuple$2 = [index, i + wid >> 0, true], newArgNum = _tuple$2[0], newi = _tuple$2[1], found = _tuple$2[2];
			return [newArgNum, newi, found];
		}
		p.goodArgNum = false;
		_tuple$3 = [argNum, i + wid >> 0, true], newArgNum = _tuple$3[0], newi = _tuple$3[1], found = _tuple$3[2];
		return [newArgNum, newi, found];
	};
	pp.prototype.argNumber = function(argNum, format, i, numArgs) { return this.go$val.argNumber(argNum, format, i, numArgs); };
	pp.Ptr.prototype.doPrintf = function(format, a) {
		var p, end, argNum, afterIndex, i, lasti, v, _ref, _tuple, _tuple$1, v$1, _tuple$2, _tuple$3, _tuple$4, v$2, _tuple$5, _tuple$6, v$3, _tuple$7, c, w, v$4, v$5, v$6, v$7, v$8, _slice, _index, arg, goSyntax, plus, v$9, _slice$1, _index$1, arg$1, v$10, v$11, v$12, v$13;
		p = this;
		end = format.length;
		argNum = 0;
		afterIndex = false;
		p.reordered = false;
		i = 0;
		while (i < end) {
			p.goodArgNum = true;
			lasti = i;
			while (i < end && !((format.charCodeAt(i) === 37))) {
				i = i + 1 >> 0;
			}
			if (i > lasti) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).WriteString(format.substring(lasti, i));
			}
			if (i >= end) {
				break;
			}
			i = i + 1 >> 0;
			p.fmt.clearflags();
			F: while (i < end) {
				_ref = format.charCodeAt(i);
				if (_ref === 35) {
					p.fmt.sharp = true;
				} else if (_ref === 48) {
					p.fmt.zero = true;
				} else if (_ref === 43) {
					p.fmt.plus = true;
				} else if (_ref === 45) {
					p.fmt.minus = true;
				} else if (_ref === 32) {
					p.fmt.space = true;
				} else {
					break F;
				}
				i = i + 1 >> 0;
			}
			_tuple = p.argNumber(argNum, format, i, a.length), argNum = _tuple[0], i = _tuple[1], afterIndex = _tuple[2];
			if (i < end && (format.charCodeAt(i) === 42)) {
				i = i + 1 >> 0;
				_tuple$1 = intFromArg(a, argNum), p.fmt.wid = _tuple$1[0], p.fmt.widPresent = _tuple$1[1], argNum = _tuple$1[2];
				if (!p.fmt.widPresent) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).Write(badWidthBytes);
				}
				afterIndex = false;
			} else {
				_tuple$2 = parsenum(format, i, end), p.fmt.wid = _tuple$2[0], p.fmt.widPresent = _tuple$2[1], i = _tuple$2[2];
				if (afterIndex && p.fmt.widPresent) {
					p.goodArgNum = false;
				}
			}
			if ((i + 1 >> 0) < end && (format.charCodeAt(i) === 46)) {
				i = i + 1 >> 0;
				if (afterIndex) {
					p.goodArgNum = false;
				}
				_tuple$3 = p.argNumber(argNum, format, i, a.length), argNum = _tuple$3[0], i = _tuple$3[1], afterIndex = _tuple$3[2];
				if (format.charCodeAt(i) === 42) {
					i = i + 1 >> 0;
					_tuple$4 = intFromArg(a, argNum), p.fmt.prec = _tuple$4[0], p.fmt.precPresent = _tuple$4[1], argNum = _tuple$4[2];
					if (!p.fmt.precPresent) {
						(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$2) { p.buf = v$2; })).Write(badPrecBytes);
					}
					afterIndex = false;
				} else {
					_tuple$5 = parsenum(format, i, end), p.fmt.prec = _tuple$5[0], p.fmt.precPresent = _tuple$5[1], i = _tuple$5[2];
					if (!p.fmt.precPresent) {
						p.fmt.prec = 0;
						p.fmt.precPresent = true;
					}
				}
			}
			if (!afterIndex) {
				_tuple$6 = p.argNumber(argNum, format, i, a.length), argNum = _tuple$6[0], i = _tuple$6[1], afterIndex = _tuple$6[2];
			}
			if (i >= end) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$3) { p.buf = v$3; })).Write(noVerbBytes);
				continue;
			}
			_tuple$7 = utf8.DecodeRuneInString(format.substring(i)), c = _tuple$7[0], w = _tuple$7[1];
			i = i + (w) >> 0;
			if (c === 37) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$4) { p.buf = v$4; })).WriteByte(37);
				continue;
			}
			if (!p.goodArgNum) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$5) { p.buf = v$5; })).Write(percentBangBytes);
				p.add(c);
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$6) { p.buf = v$6; })).Write(badIndexBytes);
				continue;
			} else if (argNum >= a.length) {
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$7) { p.buf = v$7; })).Write(percentBangBytes);
				p.add(c);
				(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$8) { p.buf = v$8; })).Write(missingBytes);
				continue;
			}
			arg = (_slice = a, _index = argNum, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			argNum = argNum + 1 >> 0;
			goSyntax = (c === 118) && p.fmt.sharp;
			plus = (c === 118) && p.fmt.plus;
			p.printArg(arg, c, plus, goSyntax, 0);
		}
		if (!p.reordered && argNum < a.length) {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$9) { p.buf = v$9; })).Write(extraBytes);
			while (argNum < a.length) {
				arg$1 = (_slice$1 = a, _index$1 = argNum, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				if (!(go$interfaceIsEqual(arg$1, null))) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$10) { p.buf = v$10; })).WriteString(reflect.TypeOf(arg$1).String());
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$11) { p.buf = v$11; })).WriteByte(61);
				}
				p.printArg(arg$1, 118, false, false, 0);
				if ((argNum + 1 >> 0) < a.length) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$12) { p.buf = v$12; })).Write(commaSpaceBytes);
				}
				argNum = argNum + 1 >> 0;
			}
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$13) { p.buf = v$13; })).WriteByte(41);
		}
	};
	pp.prototype.doPrintf = function(format, a) { return this.go$val.doPrintf(format, a); };
	pp.Ptr.prototype.doPrint = function(a, addspace, addnewline) {
		var p, prevString, argNum, _slice, _index, arg, isString, v, v$1;
		p = this;
		prevString = false;
		argNum = 0;
		while (argNum < a.length) {
			p.fmt.clearflags();
			arg = (_slice = a, _index = argNum, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (argNum > 0) {
				isString = !(go$interfaceIsEqual(arg, null)) && (reflect.TypeOf(arg).Kind() === 24);
				if (addspace || !isString && !prevString) {
					(new (go$ptrType(buffer))(function() { return p.buf; }, function(v) { p.buf = v; })).WriteByte(32);
				}
			}
			prevString = p.printArg(arg, 118, false, false, 0);
			argNum = argNum + 1 >> 0;
		}
		if (addnewline) {
			(new (go$ptrType(buffer))(function() { return p.buf; }, function(v$1) { p.buf = v$1; })).WriteByte(10);
		}
	};
	pp.prototype.doPrint = function(a, addspace, addnewline) { return this.go$val.doPrint(a, addspace, addnewline); };
	var Scan = go$pkg.Scan = function(a) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = Fscan(os.Stdin, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Scanln = go$pkg.Scanln = function(a) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = Fscanln(os.Stdin, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Scanf = go$pkg.Scanf = function(format, a) {
		var n, err, _tuple;
		n = 0;
		err = null;
		_tuple = Fscanf(os.Stdin, format, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	go$ptrType(stringReader).prototype.Read = function(b) {
		var n, err, r;
		n = 0;
		err = null;
		r = this;
		n = go$copyString(b, r.go$get());
		r.go$set((r.go$get()).substring(n));
		if (n === 0) {
			err = io.EOF;
		}
		return [n, err];
	};
	stringReader.prototype.Read = function(b) { var obj = this.go$val; return (new (go$ptrType(stringReader))(function() { return obj; }, null)).Read(b); };
	var Sscan = go$pkg.Sscan = function(str, a) {
		var n, err, _tuple, x, v;
		n = 0;
		err = null;
		_tuple = Fscan((x = new (go$ptrType(Go$String))(function() { return str; }, function(v) { str = v; }), new (go$ptrType(stringReader))(x.go$get, x.go$set)), a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Sscanln = go$pkg.Sscanln = function(str, a) {
		var n, err, _tuple, x, v;
		n = 0;
		err = null;
		_tuple = Fscanln((x = new (go$ptrType(Go$String))(function() { return str; }, function(v) { str = v; }), new (go$ptrType(stringReader))(x.go$get, x.go$set)), a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Sscanf = go$pkg.Sscanf = function(str, format, a) {
		var n, err, _tuple, x, v;
		n = 0;
		err = null;
		_tuple = Fscanf((x = new (go$ptrType(Go$String))(function() { return str; }, function(v) { str = v; }), new (go$ptrType(stringReader))(x.go$get, x.go$set)), format, a), n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	var Fscan = go$pkg.Fscan = function(r, a) {
		var n, err, _tuple, s, _struct, old, _tuple$1, _struct$1;
		n = 0;
		err = null;
		_tuple = newScanState(r, true, false), s = _tuple[0], old = (_struct = _tuple[1], new ssave.Ptr(_struct.validSave, _struct.nlIsEnd, _struct.nlIsSpace, _struct.argLimit, _struct.limit, _struct.maxWid));
		_tuple$1 = s.doScan(a), n = _tuple$1[0], err = _tuple$1[1];
		s.free((_struct$1 = old, new ssave.Ptr(_struct$1.validSave, _struct$1.nlIsEnd, _struct$1.nlIsSpace, _struct$1.argLimit, _struct$1.limit, _struct$1.maxWid)));
		return [n, err];
	};
	var Fscanln = go$pkg.Fscanln = function(r, a) {
		var n, err, _tuple, s, _struct, old, _tuple$1, _struct$1;
		n = 0;
		err = null;
		_tuple = newScanState(r, false, true), s = _tuple[0], old = (_struct = _tuple[1], new ssave.Ptr(_struct.validSave, _struct.nlIsEnd, _struct.nlIsSpace, _struct.argLimit, _struct.limit, _struct.maxWid));
		_tuple$1 = s.doScan(a), n = _tuple$1[0], err = _tuple$1[1];
		s.free((_struct$1 = old, new ssave.Ptr(_struct$1.validSave, _struct$1.nlIsEnd, _struct$1.nlIsSpace, _struct$1.argLimit, _struct$1.limit, _struct$1.maxWid)));
		return [n, err];
	};
	var Fscanf = go$pkg.Fscanf = function(r, format, a) {
		var n, err, _tuple, s, _struct, old, _tuple$1, _struct$1;
		n = 0;
		err = null;
		_tuple = newScanState(r, false, false), s = _tuple[0], old = (_struct = _tuple[1], new ssave.Ptr(_struct.validSave, _struct.nlIsEnd, _struct.nlIsSpace, _struct.argLimit, _struct.limit, _struct.maxWid));
		_tuple$1 = s.doScanf(format, a), n = _tuple$1[0], err = _tuple$1[1];
		s.free((_struct$1 = old, new ssave.Ptr(_struct$1.validSave, _struct$1.nlIsEnd, _struct$1.nlIsSpace, _struct$1.argLimit, _struct$1.limit, _struct$1.maxWid)));
		return [n, err];
	};
	ss.Ptr.prototype.Read = function(buf) {
		var n, err, s, _tuple;
		n = 0;
		err = null;
		s = this;
		_tuple = [0, errors.New("ScanState's Read should not be called. Use ReadRune")], n = _tuple[0], err = _tuple[1];
		return [n, err];
	};
	ss.prototype.Read = function(buf) { return this.go$val.Read(buf); };
	ss.Ptr.prototype.ReadRune = function() {
		var r, size, err, s, _tuple;
		r = 0;
		size = 0;
		err = null;
		s = this;
		if (s.peekRune >= 0) {
			s.count = s.count + 1 >> 0;
			r = s.peekRune;
			size = utf8.RuneLen(r);
			s.prevRune = r;
			s.peekRune = -1;
			return [r, size, err];
		}
		if (s.atEOF || s.ssave.nlIsEnd && (s.prevRune === 10) || s.count >= s.ssave.argLimit) {
			err = io.EOF;
			return [r, size, err];
		}
		_tuple = s.rr.ReadRune(), r = _tuple[0], size = _tuple[1], err = _tuple[2];
		if (go$interfaceIsEqual(err, null)) {
			s.count = s.count + 1 >> 0;
			s.prevRune = r;
		} else if (go$interfaceIsEqual(err, io.EOF)) {
			s.atEOF = true;
		}
		return [r, size, err];
	};
	ss.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	ss.Ptr.prototype.Width = function() {
		var wid, ok, s, _tuple, _tuple$1;
		wid = 0;
		ok = false;
		s = this;
		if (s.ssave.maxWid === 1073741824) {
			_tuple = [0, false], wid = _tuple[0], ok = _tuple[1];
			return [wid, ok];
		}
		_tuple$1 = [s.ssave.maxWid, true], wid = _tuple$1[0], ok = _tuple$1[1];
		return [wid, ok];
	};
	ss.prototype.Width = function() { return this.go$val.Width(); };
	ss.Ptr.prototype.getRune = function() {
		var r, s, _tuple, err;
		r = 0;
		s = this;
		_tuple = s.ReadRune(), r = _tuple[0], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			if (go$interfaceIsEqual(err, io.EOF)) {
				r = -1;
				return r;
			}
			s.error(err);
		}
		return r;
	};
	ss.prototype.getRune = function() { return this.go$val.getRune(); };
	ss.Ptr.prototype.mustReadRune = function() {
		var r, s;
		r = 0;
		s = this;
		r = s.getRune();
		if (r === -1) {
			s.error(io.ErrUnexpectedEOF);
		}
		return r;
	};
	ss.prototype.mustReadRune = function() { return this.go$val.mustReadRune(); };
	ss.Ptr.prototype.UnreadRune = function() {
		var s, ok, _tuple, x, u;
		s = this;
		if (_tuple = (x = s.rr, (x !== null && runeUnreader.implementedBy.indexOf(x.constructor) !== -1 ? [x, true] : [null, false])), u = _tuple[0], ok = _tuple[1], ok) {
			u.UnreadRune();
		} else {
			s.peekRune = s.prevRune;
		}
		s.prevRune = -1;
		s.count = s.count - 1 >> 0;
		return null;
	};
	ss.prototype.UnreadRune = function() { return this.go$val.UnreadRune(); };
	ss.Ptr.prototype.error = function(err) {
		var s, x;
		s = this;
		throw go$panic((x = new scanError.Ptr(err), new x.constructor.Struct(x)));
	};
	ss.prototype.error = function(err) { return this.go$val.error(err); };
	ss.Ptr.prototype.errorString = function(err) {
		var s, x;
		s = this;
		throw go$panic((x = new scanError.Ptr(errors.New(err)), new x.constructor.Struct(x)));
	};
	ss.prototype.errorString = function(err) { return this.go$val.errorString(err); };
	ss.Ptr.prototype.Token = function(skipSpace, f) {
		var tok, err, s;
		tok = (go$sliceType(Go$Uint8)).nil;
		err = null;
		var go$deferred = [];
		try {
			s = this;
			go$deferred.push({ fun: (function() {
				var e, ok, _tuple, _struct, se;
				if (e = go$recover(), !(go$interfaceIsEqual(e, null))) {
					if (_tuple = (e !== null && e.constructor === scanError ? [e.go$val, true] : [new scanError.Ptr(), false]), se = (_struct = _tuple[0], new scanError.Ptr(_struct.err)), ok = _tuple[1], ok) {
						err = se.err;
					} else {
						throw go$panic(e);
					}
				}
			}), args: [] });
			if (f === go$throwNilPointerError) {
				f = notSpace;
			}
			s.buf = go$subslice(s.buf, 0, 0);
			tok = s.token(skipSpace, f);
			return [tok, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [tok, err];
		}
	};
	ss.prototype.Token = function(skipSpace, f) { return this.go$val.Token(skipSpace, f); };
	var isSpace = function(r) {
		var rx, _ref, _i, _slice, _index, rng;
		if (r >= 65536) {
			return false;
		}
		rx = (r << 16 >>> 16);
		_ref = space;
		_i = 0;
		while (_i < _ref.length) {
			rng = go$mapArray((_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), function(entry) { return entry; });
			if (rx < rng[0]) {
				return false;
			}
			if (rx <= rng[1]) {
				return true;
			}
			_i++;
		}
		return false;
	};
	var notSpace = function(r) {
		return !isSpace(r);
	};
	ss.Ptr.prototype.SkipSpace = function() {
		var s;
		s = this;
		s.skipSpace(false);
	};
	ss.prototype.SkipSpace = function() { return this.go$val.SkipSpace(); };
	readRune.Ptr.prototype.readByte = function() {
		var b, err, r, _tuple, n, _tuple$1, _tuple$2;
		b = 0;
		err = null;
		r = this;
		if (r.pending > 0) {
			b = r.pendBuf[0];
			go$copySlice(go$subslice(new (go$sliceType(Go$Uint8))(r.pendBuf), 0), go$subslice(new (go$sliceType(Go$Uint8))(r.pendBuf), 1));
			r.pending = r.pending - 1 >> 0;
			return [b, err];
		}
		_tuple = io.ReadFull(r.reader, go$subslice(new (go$sliceType(Go$Uint8))(r.pendBuf), 0, 1)), n = _tuple[0], err = _tuple[1];
		if (!((n === 1))) {
			_tuple$1 = [0, err], b = _tuple$1[0], err = _tuple$1[1];
			return [b, err];
		}
		_tuple$2 = [r.pendBuf[0], err], b = _tuple$2[0], err = _tuple$2[1];
		return [b, err];
	};
	readRune.prototype.readByte = function() { return this.go$val.readByte(); };
	readRune.Ptr.prototype.unread = function(buf) {
		var r;
		r = this;
		go$copySlice(go$subslice(new (go$sliceType(Go$Uint8))(r.pendBuf), r.pending), buf);
		r.pending = r.pending + (buf.length) >> 0;
	};
	readRune.prototype.unread = function(buf) { return this.go$val.unread(buf); };
	readRune.Ptr.prototype.ReadRune = function() {
		var rr, size, err, r, _tuple, _tuple$1, n, _tuple$2, _tuple$3;
		rr = 0;
		size = 0;
		err = null;
		r = this;
		_tuple = r.readByte(), r.buf[0] = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			_tuple$1 = [0, 0, err], rr = _tuple$1[0], size = _tuple$1[1], err = _tuple$1[2];
			return [rr, size, err];
		}
		if (r.buf[0] < 128) {
			rr = (r.buf[0] >> 0);
			return [rr, size, err];
		}
		n = 0;
		n = 1;
		while (!utf8.FullRune(go$subslice(new (go$sliceType(Go$Uint8))(r.buf), 0, n))) {
			_tuple$2 = r.readByte(), r.buf[n] = _tuple$2[0], err = _tuple$2[1];
			if (!(go$interfaceIsEqual(err, null))) {
				if (go$interfaceIsEqual(err, io.EOF)) {
					err = null;
					break;
				}
				return [rr, size, err];
			}
			n = n + 1 >> 0;
		}
		_tuple$3 = utf8.DecodeRune(go$subslice(new (go$sliceType(Go$Uint8))(r.buf), 0, n)), rr = _tuple$3[0], size = _tuple$3[1];
		if (size < n) {
			r.unread(go$subslice(new (go$sliceType(Go$Uint8))(r.buf), size, n));
		}
		return [rr, size, err];
	};
	readRune.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	var newScanState = function(r, nlIsSpace, nlIsEnd) {
		var s, old, _tuple, ok, _struct, _struct$1, x, ok$1, _tuple$1, rr, _struct$2;
		s = (go$ptrType(ss)).nil;
		old = new ssave.Ptr();
		_tuple = (r !== null && r.constructor === (go$ptrType(ss)) ? [r.go$val, true] : [(go$ptrType(ss)).nil, false]), s = _tuple[0], ok = _tuple[1];
		if (ok) {
			old = (_struct = s.ssave, new ssave.Ptr(_struct.validSave, _struct.nlIsEnd, _struct.nlIsSpace, _struct.argLimit, _struct.limit, _struct.maxWid));
			s.ssave.limit = s.ssave.argLimit;
			s.ssave.nlIsEnd = nlIsEnd || s.ssave.nlIsEnd;
			s.ssave.nlIsSpace = nlIsSpace;
			return [s, (_struct$1 = old, new ssave.Ptr(_struct$1.validSave, _struct$1.nlIsEnd, _struct$1.nlIsSpace, _struct$1.argLimit, _struct$1.limit, _struct$1.maxWid))];
		}
		s = (x = ssFree.get(), (x !== null && x.constructor === (go$ptrType(ss)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(ss)))));
		if (_tuple$1 = (r !== null && io.RuneReader.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), rr = _tuple$1[0], ok$1 = _tuple$1[1], ok$1) {
			s.rr = rr;
		} else {
			s.rr = new readRune.Ptr(r, go$makeNativeArray("Uint8", 4, function() { return 0; }), 0, go$makeNativeArray("Uint8", 4, function() { return 0; }));
		}
		s.ssave.nlIsSpace = nlIsSpace;
		s.ssave.nlIsEnd = nlIsEnd;
		s.prevRune = -1;
		s.peekRune = -1;
		s.atEOF = false;
		s.ssave.limit = 1073741824;
		s.ssave.argLimit = 1073741824;
		s.ssave.maxWid = 1073741824;
		s.ssave.validSave = true;
		s.count = 0;
		return [s, (_struct$2 = old, new ssave.Ptr(_struct$2.validSave, _struct$2.nlIsEnd, _struct$2.nlIsSpace, _struct$2.argLimit, _struct$2.limit, _struct$2.maxWid))];
	};
	ss.Ptr.prototype.free = function(old) {
		var s, _struct;
		s = this;
		if (old.validSave) {
			s.ssave = (_struct = old, new ssave.Ptr(_struct.validSave, _struct.nlIsEnd, _struct.nlIsSpace, _struct.argLimit, _struct.limit, _struct.maxWid));
			return;
		}
		if (s.buf.capacity > 1024) {
			return;
		}
		s.buf = go$subslice(s.buf, 0, 0);
		s.rr = null;
		ssFree.put(s);
	};
	ss.prototype.free = function(old) { return this.go$val.free(old); };
	ss.Ptr.prototype.skipSpace = function(stopAtNewline) {
		var s, r;
		s = this;
		while (true) {
			r = s.getRune();
			if (r === -1) {
				return;
			}
			if ((r === 13) && s.peek("\n")) {
				continue;
			}
			if (r === 10) {
				if (stopAtNewline) {
					break;
				}
				if (s.ssave.nlIsSpace) {
					continue;
				}
				s.errorString("unexpected newline");
				return;
			}
			if (!isSpace(r)) {
				s.UnreadRune();
				break;
			}
		}
	};
	ss.prototype.skipSpace = function(stopAtNewline) { return this.go$val.skipSpace(stopAtNewline); };
	ss.Ptr.prototype.token = function(skipSpace, f) {
		var s, r, v, x;
		s = this;
		if (skipSpace) {
			s.skipSpace(false);
		}
		while (true) {
			r = s.getRune();
			if (r === -1) {
				break;
			}
			if (!f(r)) {
				s.UnreadRune();
				break;
			}
			(new (go$ptrType(buffer))(function() { return s.buf; }, function(v) { s.buf = v; })).WriteRune(r);
		}
		return (x = s.buf, go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length));
	};
	ss.prototype.token = function(skipSpace, f) { return this.go$val.token(skipSpace, f); };
	var indexRune = function(s, r) {
		var _ref, _i, _rune, c, i;
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			c = _rune[0];
			i = _i;
			if (c === r) {
				return i;
			}
			_i += _rune[1];
		}
		return -1;
	};
	ss.Ptr.prototype.consume = function(ok, accept) {
		var s, r, v;
		s = this;
		r = s.getRune();
		if (r === -1) {
			return false;
		}
		if (indexRune(ok, r) >= 0) {
			if (accept) {
				(new (go$ptrType(buffer))(function() { return s.buf; }, function(v) { s.buf = v; })).WriteRune(r);
			}
			return true;
		}
		if (!((r === -1)) && accept) {
			s.UnreadRune();
		}
		return false;
	};
	ss.prototype.consume = function(ok, accept) { return this.go$val.consume(ok, accept); };
	ss.Ptr.prototype.peek = function(ok) {
		var s, r;
		s = this;
		r = s.getRune();
		if (!((r === -1))) {
			s.UnreadRune();
		}
		return indexRune(ok, r) >= 0;
	};
	ss.prototype.peek = function(ok) { return this.go$val.peek(ok); };
	ss.Ptr.prototype.notEOF = function() {
		var s, r;
		s = this;
		if (r = s.getRune(), r === -1) {
			throw go$panic(io.EOF);
		}
		s.UnreadRune();
	};
	ss.prototype.notEOF = function() { return this.go$val.notEOF(); };
	ss.Ptr.prototype.accept = function(ok) {
		var s;
		s = this;
		return s.consume(ok, true);
	};
	ss.prototype.accept = function(ok) { return this.go$val.accept(ok); };
	ss.Ptr.prototype.okVerb = function(verb, okVerbs, typ) {
		var s, _ref, _i, _rune, v;
		s = this;
		_ref = okVerbs;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			v = _rune[0];
			if (v === verb) {
				return true;
			}
			_i += _rune[1];
		}
		s.errorString("bad verb %" + go$encodeRune(verb) + " for " + typ);
		return false;
	};
	ss.prototype.okVerb = function(verb, okVerbs, typ) { return this.go$val.okVerb(verb, okVerbs, typ); };
	ss.Ptr.prototype.scanBool = function(verb) {
		var s, _ref;
		s = this;
		s.skipSpace(false);
		s.notEOF();
		if (!s.okVerb(verb, "tv", "boolean")) {
			return false;
		}
		_ref = s.getRune();
		if (_ref === 48) {
			return false;
		} else if (_ref === 49) {
			return true;
		} else if (_ref === 116 || _ref === 84) {
			if (s.accept("rR") && (!s.accept("uU") || !s.accept("eE"))) {
				s.error(boolError);
			}
			return true;
		} else if (_ref === 102 || _ref === 70) {
			if (s.accept("aA") && (!s.accept("lL") || !s.accept("sS") || !s.accept("eE"))) {
				s.error(boolError);
			}
			return false;
		}
		return false;
	};
	ss.prototype.scanBool = function(verb) { return this.go$val.scanBool(verb); };
	ss.Ptr.prototype.getBase = function(verb) {
		var base, digits, s, _ref;
		base = 0;
		digits = "";
		s = this;
		s.okVerb(verb, "bdoUxXv", "integer");
		base = 10;
		digits = "0123456789";
		_ref = verb;
		if (_ref === 98) {
			base = 2;
			digits = "01";
		} else if (_ref === 111) {
			base = 8;
			digits = "01234567";
		} else if (_ref === 120 || _ref === 88 || _ref === 85) {
			base = 16;
			digits = "0123456789aAbBcCdDeEfF";
		}
		return [base, digits];
	};
	ss.prototype.getBase = function(verb) { return this.go$val.getBase(verb); };
	ss.Ptr.prototype.scanNumber = function(digits, haveDigits) {
		var s;
		s = this;
		if (!haveDigits) {
			s.notEOF();
			if (!s.accept(digits)) {
				s.errorString("expected integer");
			}
		}
		while (s.accept(digits)) {
		}
		return go$bytesToString(s.buf);
	};
	ss.prototype.scanNumber = function(digits, haveDigits) { return this.go$val.scanNumber(digits, haveDigits); };
	ss.Ptr.prototype.scanRune = function(bitSize) {
		var s, r, n, x;
		s = this;
		s.notEOF();
		r = new Go$Int64(0, s.getRune());
		n = (bitSize >>> 0);
		x = go$shiftRightInt64((go$shiftLeft64(r, ((64 - n >>> 0)))), ((64 - n >>> 0)));
		if (!((x.high === r.high && x.low === r.low))) {
			s.errorString("overflow on character value " + go$encodeRune(r.low));
		}
		return r;
	};
	ss.prototype.scanRune = function(bitSize) { return this.go$val.scanRune(bitSize); };
	ss.Ptr.prototype.scanBasePrefix = function() {
		var base, digits, found, s, _tuple, _tuple$1, _tuple$2;
		base = 0;
		digits = "";
		found = false;
		s = this;
		if (!s.peek("0")) {
			_tuple = [10, "0123456789", false], base = _tuple[0], digits = _tuple[1], found = _tuple[2];
			return [base, digits, found];
		}
		s.accept("0");
		found = true;
		_tuple$1 = [8, "01234567"], base = _tuple$1[0], digits = _tuple$1[1];
		if (s.peek("xX")) {
			s.consume("xX", false);
			_tuple$2 = [16, "0123456789aAbBcCdDeEfF"], base = _tuple$2[0], digits = _tuple$2[1];
		}
		return [base, digits, found];
	};
	ss.prototype.scanBasePrefix = function() { return this.go$val.scanBasePrefix(); };
	ss.Ptr.prototype.scanInt = function(verb, bitSize) {
		var s, _tuple, base, digits, haveDigits, _tuple$1, tok, _tuple$2, i, err, n, x;
		s = this;
		if (verb === 99) {
			return s.scanRune(bitSize);
		}
		s.skipSpace(false);
		s.notEOF();
		_tuple = s.getBase(verb), base = _tuple[0], digits = _tuple[1];
		haveDigits = false;
		if (verb === 85) {
			if (!s.consume("U", false) || !s.consume("+", false)) {
				s.errorString("bad unicode format ");
			}
		} else {
			s.accept("+-");
			if (verb === 118) {
				_tuple$1 = s.scanBasePrefix(), base = _tuple$1[0], digits = _tuple$1[1], haveDigits = _tuple$1[2];
			}
		}
		tok = s.scanNumber(digits, haveDigits);
		_tuple$2 = strconv.ParseInt(tok, base, 64), i = _tuple$2[0], err = _tuple$2[1];
		if (!(go$interfaceIsEqual(err, null))) {
			s.error(err);
		}
		n = (bitSize >>> 0);
		x = go$shiftRightInt64((go$shiftLeft64(i, ((64 - n >>> 0)))), ((64 - n >>> 0)));
		if (!((x.high === i.high && x.low === i.low))) {
			s.errorString("integer overflow on token " + tok);
		}
		return i;
	};
	ss.prototype.scanInt = function(verb, bitSize) { return this.go$val.scanInt(verb, bitSize); };
	ss.Ptr.prototype.scanUint = function(verb, bitSize) {
		var s, x, _tuple, base, digits, haveDigits, _tuple$1, tok, _tuple$2, i, err, n, x$1;
		s = this;
		if (verb === 99) {
			return (x = s.scanRune(bitSize), new Go$Uint64(x.high, x.low));
		}
		s.skipSpace(false);
		s.notEOF();
		_tuple = s.getBase(verb), base = _tuple[0], digits = _tuple[1];
		haveDigits = false;
		if (verb === 85) {
			if (!s.consume("U", false) || !s.consume("+", false)) {
				s.errorString("bad unicode format ");
			}
		} else if (verb === 118) {
			_tuple$1 = s.scanBasePrefix(), base = _tuple$1[0], digits = _tuple$1[1], haveDigits = _tuple$1[2];
		}
		tok = s.scanNumber(digits, haveDigits);
		_tuple$2 = strconv.ParseUint(tok, base, 64), i = _tuple$2[0], err = _tuple$2[1];
		if (!(go$interfaceIsEqual(err, null))) {
			s.error(err);
		}
		n = (bitSize >>> 0);
		x$1 = go$shiftRightUint64((go$shiftLeft64(i, ((64 - n >>> 0)))), ((64 - n >>> 0)));
		if (!((x$1.high === i.high && x$1.low === i.low))) {
			s.errorString("unsigned integer overflow on token " + tok);
		}
		return i;
	};
	ss.prototype.scanUint = function(verb, bitSize) { return this.go$val.scanUint(verb, bitSize); };
	ss.Ptr.prototype.floatToken = function() {
		var s;
		s = this;
		s.buf = go$subslice(s.buf, 0, 0);
		if (s.accept("nN") && s.accept("aA") && s.accept("nN")) {
			return go$bytesToString(s.buf);
		}
		s.accept("+-");
		if (s.accept("iI") && s.accept("nN") && s.accept("fF")) {
			return go$bytesToString(s.buf);
		}
		while (s.accept("0123456789")) {
		}
		if (s.accept(".")) {
			while (s.accept("0123456789")) {
			}
		}
		if (s.accept("eEp")) {
			s.accept("+-");
			while (s.accept("0123456789")) {
			}
		}
		return go$bytesToString(s.buf);
	};
	ss.prototype.floatToken = function() { return this.go$val.floatToken(); };
	ss.Ptr.prototype.complexTokens = function() {
		var real, imag, s, parens, imagSign, _tuple;
		real = "";
		imag = "";
		s = this;
		parens = s.accept("(");
		real = s.floatToken();
		s.buf = go$subslice(s.buf, 0, 0);
		if (!s.accept("+-")) {
			s.error(complexError);
		}
		imagSign = go$bytesToString(s.buf);
		imag = s.floatToken();
		if (!s.accept("i")) {
			s.error(complexError);
		}
		if (parens && !s.accept(")")) {
			s.error(complexError);
		}
		_tuple = [real, imagSign + imag], real = _tuple[0], imag = _tuple[1];
		return [real, imag];
	};
	ss.prototype.complexTokens = function() { return this.go$val.complexTokens(); };
	ss.Ptr.prototype.convertFloat = function(str, n) {
		var s, p, _tuple, f, err, ok, _tuple$1, e, _tuple$2, m, ok$1, _tuple$3, e$1, _tuple$4, f$1, err$1;
		s = this;
		if (p = indexRune(str, 112), p >= 0) {
			_tuple = strconv.ParseFloat(str.substring(0, p), n), f = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				if (_tuple$1 = (err !== null && err.constructor === (go$ptrType(strconv.NumError)) ? [err.go$val, true] : [(go$ptrType(strconv.NumError)).nil, false]), e = _tuple$1[0], ok = _tuple$1[1], ok) {
					e.Num = str;
				}
				s.error(err);
			}
			_tuple$2 = strconv.Atoi(str.substring((p + 1 >> 0))), m = _tuple$2[0], err = _tuple$2[1];
			if (!(go$interfaceIsEqual(err, null))) {
				if (_tuple$3 = (err !== null && err.constructor === (go$ptrType(strconv.NumError)) ? [err.go$val, true] : [(go$ptrType(strconv.NumError)).nil, false]), e$1 = _tuple$3[0], ok$1 = _tuple$3[1], ok$1) {
					e$1.Num = str;
				}
				s.error(err);
			}
			return math.Ldexp(f, m);
		}
		_tuple$4 = strconv.ParseFloat(str, n), f$1 = _tuple$4[0], err$1 = _tuple$4[1];
		if (!(go$interfaceIsEqual(err$1, null))) {
			s.error(err$1);
		}
		return f$1;
	};
	ss.prototype.convertFloat = function(str, n) { return this.go$val.convertFloat(str, n); };
	ss.Ptr.prototype.scanComplex = function(verb, n) {
		var s, _tuple, sreal, simag, _q, real, _q$1, imag;
		s = this;
		if (!s.okVerb(verb, "beEfFgGv", "complex")) {
			return new Go$Complex128(0, 0);
		}
		s.skipSpace(false);
		s.notEOF();
		_tuple = s.complexTokens(), sreal = _tuple[0], simag = _tuple[1];
		real = s.convertFloat(sreal, (_q = n / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")));
		imag = s.convertFloat(simag, (_q$1 = n / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")));
		return new Go$Complex128(real, imag);
	};
	ss.prototype.scanComplex = function(verb, n) { return this.go$val.scanComplex(verb, n); };
	ss.Ptr.prototype.convertString = function(verb) {
		var str, s, _ref;
		str = "";
		s = this;
		if (!s.okVerb(verb, "svqx", "string")) {
			str = "";
			return str;
		}
		s.skipSpace(false);
		s.notEOF();
		_ref = verb;
		if (_ref === 113) {
			str = s.quotedString();
		} else if (_ref === 120) {
			str = s.hexString();
		} else {
			str = go$bytesToString(s.token(true, notSpace));
		}
		return str;
	};
	ss.prototype.convertString = function(verb) { return this.go$val.convertString(verb); };
	ss.Ptr.prototype.quotedString = function() {
		var s, quote, _ref, r, v, v$1, r$1, v$2, v$3, _tuple, result, err;
		s = this;
		s.notEOF();
		quote = s.getRune();
		_ref = quote;
		if (_ref === 96) {
			while (true) {
				r = s.mustReadRune();
				if (r === quote) {
					break;
				}
				(new (go$ptrType(buffer))(function() { return s.buf; }, function(v) { s.buf = v; })).WriteRune(r);
			}
			return go$bytesToString(s.buf);
		} else if (_ref === 34) {
			(new (go$ptrType(buffer))(function() { return s.buf; }, function(v$1) { s.buf = v$1; })).WriteRune(quote);
			while (true) {
				r$1 = s.mustReadRune();
				(new (go$ptrType(buffer))(function() { return s.buf; }, function(v$2) { s.buf = v$2; })).WriteRune(r$1);
				if (r$1 === 92) {
					(new (go$ptrType(buffer))(function() { return s.buf; }, function(v$3) { s.buf = v$3; })).WriteRune(s.mustReadRune());
				} else if (r$1 === 34) {
					break;
				}
			}
			_tuple = strconv.Unquote(go$bytesToString(s.buf)), result = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				s.error(err);
			}
			return result;
		} else {
			s.errorString("expected quoted string");
		}
		return "";
	};
	ss.prototype.quotedString = function() { return this.go$val.quotedString(); };
	ss.Ptr.prototype.hexDigit = function(d) {
		var s, digit, _ref;
		s = this;
		digit = (d >> 0);
		_ref = digit;
		if (_ref === 48 || _ref === 49 || _ref === 50 || _ref === 51 || _ref === 52 || _ref === 53 || _ref === 54 || _ref === 55 || _ref === 56 || _ref === 57) {
			return digit - 48 >> 0;
		} else if (_ref === 97 || _ref === 98 || _ref === 99 || _ref === 100 || _ref === 101 || _ref === 102) {
			return (10 + digit >> 0) - 97 >> 0;
		} else if (_ref === 65 || _ref === 66 || _ref === 67 || _ref === 68 || _ref === 69 || _ref === 70) {
			return (10 + digit >> 0) - 65 >> 0;
		}
		s.errorString("illegal hex digit");
		return 0;
	};
	ss.prototype.hexDigit = function(d) { return this.go$val.hexDigit(d); };
	ss.Ptr.prototype.hexByte = function() {
		var b, ok, s, rune1, rune2, _tuple;
		b = 0;
		ok = false;
		s = this;
		rune1 = s.getRune();
		if (rune1 === -1) {
			return [b, ok];
		}
		if (isSpace(rune1)) {
			s.UnreadRune();
			return [b, ok];
		}
		rune2 = s.mustReadRune();
		_tuple = [(((s.hexDigit(rune1) << 4 >> 0) | s.hexDigit(rune2)) << 24 >>> 24), true], b = _tuple[0], ok = _tuple[1];
		return [b, ok];
	};
	ss.prototype.hexByte = function() { return this.go$val.hexByte(); };
	ss.Ptr.prototype.hexString = function() {
		var s, _tuple, b, ok, v;
		s = this;
		s.notEOF();
		while (true) {
			_tuple = s.hexByte(), b = _tuple[0], ok = _tuple[1];
			if (!ok) {
				break;
			}
			(new (go$ptrType(buffer))(function() { return s.buf; }, function(v) { s.buf = v; })).WriteByte(b);
		}
		if (s.buf.length === 0) {
			s.errorString("no hex data for %x string");
			return "";
		}
		return go$bytesToString(s.buf);
	};
	ss.prototype.hexString = function() { return this.go$val.hexString(); };
	ss.Ptr.prototype.scanOne = function(verb, arg) {
		var s, err, ok, _tuple, v, v$1, _ref, _type, x, x$1, x$2, x$3, x$4, _struct, val, _struct$1, ptr, _struct$2, v$2, _ref$1, typ, str, _struct$3, i;
		s = this;
		s.buf = go$subslice(s.buf, 0, 0);
		err = null;
		if (_tuple = (arg !== null && Scanner.implementedBy.indexOf(arg.constructor) !== -1 ? [arg, true] : [null, false]), v = _tuple[0], ok = _tuple[1], ok) {
			err = v.Scan(s, verb);
			if (!(go$interfaceIsEqual(err, null))) {
				if (go$interfaceIsEqual(err, io.EOF)) {
					err = io.ErrUnexpectedEOF;
				}
				s.error(err);
			}
			return;
		}
		_ref = arg;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(Go$Bool))) {
			v$1 = _ref.go$val;
			v$1.go$set(s.scanBool(verb));
		} else if (_type === (go$ptrType(Go$Complex64))) {
			v$1 = _ref.go$val;
			v$1.go$set((x = s.scanComplex(verb, 64), new Go$Complex64(x.real, x.imag)));
		} else if (_type === (go$ptrType(Go$Complex128))) {
			v$1 = _ref.go$val;
			v$1.go$set(s.scanComplex(verb, 128));
		} else if (_type === (go$ptrType(Go$Int))) {
			v$1 = _ref.go$val;
			v$1.go$set(((x$1 = s.scanInt(verb, intBits), x$1.low + ((x$1.high >> 31) * 4294967296)) >> 0));
		} else if (_type === (go$ptrType(Go$Int8))) {
			v$1 = _ref.go$val;
			v$1.go$set(((x$2 = s.scanInt(verb, 8), x$2.low + ((x$2.high >> 31) * 4294967296)) << 24 >> 24));
		} else if (_type === (go$ptrType(Go$Int16))) {
			v$1 = _ref.go$val;
			v$1.go$set(((x$3 = s.scanInt(verb, 16), x$3.low + ((x$3.high >> 31) * 4294967296)) << 16 >> 16));
		} else if (_type === (go$ptrType(Go$Int32))) {
			v$1 = _ref.go$val;
			v$1.go$set(((x$4 = s.scanInt(verb, 32), x$4.low + ((x$4.high >> 31) * 4294967296)) >> 0));
		} else if (_type === (go$ptrType(Go$Int64))) {
			v$1 = _ref.go$val;
			v$1.go$set(s.scanInt(verb, 64));
		} else if (_type === (go$ptrType(Go$Uint))) {
			v$1 = _ref.go$val;
			v$1.go$set((s.scanUint(verb, intBits).low >>> 0));
		} else if (_type === (go$ptrType(Go$Uint8))) {
			v$1 = _ref.go$val;
			v$1.go$set((s.scanUint(verb, 8).low << 24 >>> 24));
		} else if (_type === (go$ptrType(Go$Uint16))) {
			v$1 = _ref.go$val;
			v$1.go$set((s.scanUint(verb, 16).low << 16 >>> 16));
		} else if (_type === (go$ptrType(Go$Uint32))) {
			v$1 = _ref.go$val;
			v$1.go$set((s.scanUint(verb, 32).low >>> 0));
		} else if (_type === (go$ptrType(Go$Uint64))) {
			v$1 = _ref.go$val;
			v$1.go$set(s.scanUint(verb, 64));
		} else if (_type === (go$ptrType(Go$Uintptr))) {
			v$1 = _ref.go$val;
			v$1.go$set((s.scanUint(verb, uintptrBits).low >>> 0));
		} else if (_type === (go$ptrType(Go$Float32))) {
			v$1 = _ref.go$val;
			if (s.okVerb(verb, "beEfFgGv", "float32")) {
				s.skipSpace(false);
				s.notEOF();
				v$1.go$set(s.convertFloat(s.floatToken(), 32));
			}
		} else if (_type === (go$ptrType(Go$Float64))) {
			v$1 = _ref.go$val;
			if (s.okVerb(verb, "beEfFgGv", "float64")) {
				s.skipSpace(false);
				s.notEOF();
				v$1.go$set(s.convertFloat(s.floatToken(), 64));
			}
		} else if (_type === (go$ptrType(Go$String))) {
			v$1 = _ref.go$val;
			v$1.go$set(s.convertString(verb));
		} else if (_type === (go$ptrType((go$sliceType(Go$Uint8))))) {
			v$1 = _ref.go$val;
			v$1.go$set(new (go$sliceType(Go$Uint8))(go$stringToBytes(s.convertString(verb))));
		} else {
			v$1 = _ref;
			val = (_struct = reflect.ValueOf(v$1), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			ptr = (_struct$1 = val, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
			if (!((ptr.Kind() === 22))) {
				s.errorString("type not a pointer: " + val.Type().String());
				return;
			}
			v$2 = (_struct$2 = ptr.Elem(), new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
			_ref$1 = v$2.Kind();
			if (_ref$1 === 1) {
				v$2.SetBool(s.scanBool(verb));
			} else if (_ref$1 === 2 || _ref$1 === 3 || _ref$1 === 4 || _ref$1 === 5 || _ref$1 === 6) {
				v$2.SetInt(s.scanInt(verb, v$2.Type().Bits()));
			} else if (_ref$1 === 7 || _ref$1 === 8 || _ref$1 === 9 || _ref$1 === 10 || _ref$1 === 11 || _ref$1 === 12) {
				v$2.SetUint(s.scanUint(verb, v$2.Type().Bits()));
			} else if (_ref$1 === 24) {
				v$2.SetString(s.convertString(verb));
			} else if (_ref$1 === 23) {
				typ = v$2.Type();
				if (!((typ.Elem().Kind() === 8))) {
					s.errorString("can't scan type: " + val.Type().String());
				}
				str = s.convertString(verb);
				v$2.Set((_struct$3 = reflect.MakeSlice(typ, str.length, str.length), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
				i = 0;
				while (i < str.length) {
					v$2.Index(i).SetUint(new Go$Uint64(0, str.charCodeAt(i)));
					i = i + 1 >> 0;
				}
			} else if (_ref$1 === 13 || _ref$1 === 14) {
				s.skipSpace(false);
				s.notEOF();
				v$2.SetFloat(s.convertFloat(s.floatToken(), v$2.Type().Bits()));
			} else if (_ref$1 === 15 || _ref$1 === 16) {
				v$2.SetComplex(s.scanComplex(verb, v$2.Type().Bits()));
			} else {
				s.errorString("can't scan type: " + val.Type().String());
			}
		}
	};
	ss.prototype.scanOne = function(verb, arg) { return this.go$val.scanOne(verb, arg); };
	var errorHandler = function(errp) {
		var e, ok, ok$1, eof, _tuple, _struct, se, _tuple$1;
		if (e = go$recover(), !(go$interfaceIsEqual(e, null))) {
			if (_tuple = (e !== null && e.constructor === scanError ? [e.go$val, true] : [new scanError.Ptr(), false]), se = (_struct = _tuple[0], new scanError.Ptr(_struct.err)), ok = _tuple[1], ok) {
				errp.go$set(se.err);
			} else if (_tuple$1 = (e !== null && go$error.implementedBy.indexOf(e.constructor) !== -1 ? [e, true] : [null, false]), eof = _tuple$1[0], ok$1 = _tuple$1[1], ok$1 && go$interfaceIsEqual(eof, io.EOF)) {
				errp.go$set(eof);
			} else {
				throw go$panic(e);
			}
		}
	};
	ss.Ptr.prototype.doScan = function(a) {
		var numProcessed, err, s, v, _ref, _i, _slice, _index, arg, r;
		numProcessed = 0;
		err = null;
		var go$deferred = [];
		try {
			s = this;
			go$deferred.push({ fun: errorHandler, args: [new (go$ptrType(go$error))(function() { return err; }, function(v) { err = v; })] });
			_ref = a;
			_i = 0;
			while (_i < _ref.length) {
				arg = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				s.scanOne(118, arg);
				numProcessed = numProcessed + 1 >> 0;
				_i++;
			}
			if (!s.ssave.nlIsSpace) {
				while (true) {
					r = s.getRune();
					if ((r === 10) || (r === -1)) {
						break;
					}
					if (!isSpace(r)) {
						s.errorString("expected newline");
						break;
					}
				}
			}
			return [numProcessed, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [numProcessed, err];
		}
	};
	ss.prototype.doScan = function(a) { return this.go$val.doScan(a); };
	ss.Ptr.prototype.advance = function(format) {
		var i, s, _tuple, fmtc, w, _tuple$1, nextc, sawSpace, _tuple$2, inputc, inputc$1;
		i = 0;
		s = this;
		while (i < format.length) {
			_tuple = utf8.DecodeRuneInString(format.substring(i)), fmtc = _tuple[0], w = _tuple[1];
			if (fmtc === 37) {
				_tuple$1 = utf8.DecodeRuneInString(format.substring((i + w >> 0))), nextc = _tuple$1[0];
				if (!((nextc === 37))) {
					return i;
				}
				i = i + (w) >> 0;
			}
			sawSpace = false;
			while (isSpace(fmtc) && i < format.length) {
				sawSpace = true;
				i = i + (w) >> 0;
				_tuple$2 = utf8.DecodeRuneInString(format.substring(i)), fmtc = _tuple$2[0], w = _tuple$2[1];
			}
			if (sawSpace) {
				inputc = s.getRune();
				if ((inputc === -1) || (inputc === 10)) {
					return i;
				}
				if (!isSpace(inputc)) {
					s.errorString("expected space in input to match format");
				}
				s.skipSpace(true);
				continue;
			}
			inputc$1 = s.mustReadRune();
			if (!((fmtc === inputc$1))) {
				s.UnreadRune();
				i = -1;
				return i;
			}
			i = i + (w) >> 0;
		}
		return i;
	};
	ss.prototype.advance = function(format) { return this.go$val.advance(format); };
	ss.Ptr.prototype.doScanf = function(format, a) {
		var numProcessed, err, s, v, end, i, w, widPresent, _tuple, f, _tuple$1, c, _slice, _index, arg;
		numProcessed = 0;
		err = null;
		var go$deferred = [];
		try {
			s = this;
			go$deferred.push({ fun: errorHandler, args: [new (go$ptrType(go$error))(function() { return err; }, function(v) { err = v; })] });
			end = format.length - 1 >> 0;
			i = 0;
			while (i <= end) {
				w = s.advance(format.substring(i));
				if (w > 0) {
					i = i + (w) >> 0;
					continue;
				}
				if (!((format.charCodeAt(i) === 37))) {
					if (w < 0) {
						s.errorString("input does not match format");
					}
					break;
				}
				i = i + 1 >> 0;
				widPresent = false;
				_tuple = parsenum(format, i, end), s.ssave.maxWid = _tuple[0], widPresent = _tuple[1], i = _tuple[2];
				if (!widPresent) {
					s.ssave.maxWid = 1073741824;
				}
				s.ssave.argLimit = s.ssave.limit;
				if (f = s.count + s.ssave.maxWid >> 0, f < s.ssave.argLimit) {
					s.ssave.argLimit = f;
				}
				_tuple$1 = utf8.DecodeRuneInString(format.substring(i)), c = _tuple$1[0], w = _tuple$1[1];
				i = i + (w) >> 0;
				if (numProcessed >= a.length) {
					s.errorString("too few operands for format %" + format.substring((i - w >> 0)));
					break;
				}
				arg = (_slice = a, _index = numProcessed, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				s.scanOne(c, arg);
				numProcessed = numProcessed + 1 >> 0;
				s.ssave.argLimit = s.ssave.limit;
			}
			if (numProcessed < a.length) {
				s.errorString("too many operands");
			}
			return [numProcessed, err];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [numProcessed, err];
		}
	};
	ss.prototype.doScanf = function(format, a) { return this.go$val.doScanf(format, a); };
	go$pkg.init = function() {
		var i, _slice, _index, _slice$1, _index$1;
		padZeroBytes = (go$sliceType(Go$Uint8)).make(65, 0, function() { return 0; });
		padSpaceBytes = (go$sliceType(Go$Uint8)).make(65, 0, function() { return 0; });
		trueBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("true"));
		falseBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("false"));
		commaSpaceBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes(", "));
		nilAngleBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("<nil>"));
		nilParenBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("(nil)"));
		nilBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("nil"));
		mapBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("map["));
		percentBangBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("%!"));
		missingBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("(MISSING)"));
		badIndexBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("(BADINDEX)"));
		panicBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("(PANIC="));
		extraBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("%!(EXTRA "));
		irparenBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("i)"));
		bytesBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("[]byte{"));
		badWidthBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("%!(BADWIDTH)"));
		badPrecBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("%!(BADPREC)"));
		noVerbBytes = new (go$sliceType(Go$Uint8))(go$stringToBytes("%!(NOVERB)"));
		ppFree = newCache((function() {
			return new pp.Ptr();
		}));
		intBits = reflect.TypeOf(new Go$Int(0)).Bits();
		uintptrBits = reflect.TypeOf(new Go$Uintptr(0)).Bits();
		space = new (go$sliceType((go$arrayType(Go$Uint16, 2))))([go$toNativeArray("Uint16", [9, 13]), go$toNativeArray("Uint16", [32, 32]), go$toNativeArray("Uint16", [133, 133]), go$toNativeArray("Uint16", [160, 160]), go$toNativeArray("Uint16", [5760, 5760]), go$toNativeArray("Uint16", [6158, 6158]), go$toNativeArray("Uint16", [8192, 8202]), go$toNativeArray("Uint16", [8232, 8233]), go$toNativeArray("Uint16", [8239, 8239]), go$toNativeArray("Uint16", [8287, 8287]), go$toNativeArray("Uint16", [12288, 12288])]);
		ssFree = newCache((function() {
			return new ss.Ptr();
		}));
		complexError = errors.New("syntax error scanning complex number");
		boolError = errors.New("syntax error scanning boolean");
		i = 0;
		while (i < 65) {
			_slice = padZeroBytes, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 48) : go$throwRuntimeError("index out of range");
			_slice$1 = padSpaceBytes, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 32) : go$throwRuntimeError("index out of range");
			i = i + 1 >> 0;
		}
	};
	return go$pkg;
})();
go$packages["sort"] = (function() {
	var go$pkg = {};
	var Interface;
	Interface = go$newType(0, "Interface", "sort.Interface", "Interface", "sort", null);
	go$pkg.Interface = Interface;
	var reverse;
	reverse = go$newType(0, "Struct", "sort.reverse", "reverse", "sort", function(Interface_) {
		this.go$val = this;
		this.Interface = Interface_ !== undefined ? Interface_ : null;
	});
	reverse.prototype.Len = function() { return this.go$val.Len(); };
	reverse.Ptr.prototype.Len = function() { return this.Interface.Len(); };
	reverse.prototype.Less = function(i, j) { return this.go$val.Less(i, j); };
	reverse.Ptr.prototype.Less = function(i, j) { return this.Interface.Less(i, j); };
	reverse.prototype.Swap = function(i, j) { return this.go$val.Swap(i, j); };
	reverse.Ptr.prototype.Swap = function(i, j) { return this.Interface.Swap(i, j); };
	go$pkg.reverse = reverse;
	var IntSlice;
	IntSlice = go$newType(0, "Slice", "sort.IntSlice", "IntSlice", "sort", null);
	go$pkg.IntSlice = IntSlice;
	var Float64Slice;
	Float64Slice = go$newType(0, "Slice", "sort.Float64Slice", "Float64Slice", "sort", null);
	go$pkg.Float64Slice = Float64Slice;
	var StringSlice;
	StringSlice = go$newType(0, "Slice", "sort.StringSlice", "StringSlice", "sort", null);
	go$pkg.StringSlice = StringSlice;
	Interface.init([["Len", "", (go$funcType([], [Go$Int], false))], ["Less", "", (go$funcType([Go$Int, Go$Int], [Go$Bool], false))], ["Swap", "", (go$funcType([Go$Int, Go$Int], [], false))]]);
	reverse.init([["", "", Interface, ""]]);
	reverse.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(reverse)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	IntSlice.init(Go$Int);
	IntSlice.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Search", "", [Go$Int], [Go$Int], false], ["Sort", "", [], [], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(IntSlice)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Search", "", [Go$Int], [Go$Int], false], ["Sort", "", [], [], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	Float64Slice.init(Go$Float64);
	Float64Slice.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Search", "", [Go$Float64], [Go$Int], false], ["Sort", "", [], [], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(Float64Slice)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Search", "", [Go$Float64], [Go$Int], false], ["Sort", "", [], [], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	StringSlice.init(Go$String);
	StringSlice.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Search", "", [Go$String], [Go$Int], false], ["Sort", "", [], [], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(StringSlice)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Search", "", [Go$String], [Go$Int], false], ["Sort", "", [], [], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	var Search = go$pkg.Search = function(n, f) {
		var _tuple, i, j, _q, h;
		_tuple = [0, n], i = _tuple[0], j = _tuple[1];
		while (i < j) {
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			if (!f(h)) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	var SearchInts = go$pkg.SearchInts = function(a, x) {
		return Search(a.length, (function(i) {
			var _slice, _index;
			return (_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >= x;
		}));
	};
	var SearchFloat64s = go$pkg.SearchFloat64s = function(a, x) {
		return Search(a.length, (function(i) {
			var _slice, _index;
			return (_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >= x;
		}));
	};
	var SearchStrings = go$pkg.SearchStrings = function(a, x) {
		return Search(a.length, (function(i) {
			var _slice, _index;
			return (_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >= x;
		}));
	};
	IntSlice.prototype.Search = function(x) {
		var p;
		p = this;
		return SearchInts(go$subslice(new (go$sliceType(Go$Int))(p.array), p.offset, p.offset + p.length), x);
	};
	go$ptrType(IntSlice).prototype.Search = function(x) { return this.go$get().Search(x); };
	Float64Slice.prototype.Search = function(x) {
		var p;
		p = this;
		return SearchFloat64s(go$subslice(new (go$sliceType(Go$Float64))(p.array), p.offset, p.offset + p.length), x);
	};
	go$ptrType(Float64Slice).prototype.Search = function(x) { return this.go$get().Search(x); };
	StringSlice.prototype.Search = function(x) {
		var p;
		p = this;
		return SearchStrings(go$subslice(new (go$sliceType(Go$String))(p.array), p.offset, p.offset + p.length), x);
	};
	go$ptrType(StringSlice).prototype.Search = function(x) { return this.go$get().Search(x); };
	var min = function(a, b) {
		if (a < b) {
			return a;
		}
		return b;
	};
	var insertionSort = function(data, a, b) {
		var i, j;
		i = a + 1 >> 0;
		while (i < b) {
			j = i;
			while (j > a && data.Less(j, j - 1 >> 0)) {
				data.Swap(j, j - 1 >> 0);
				j = j - 1 >> 0;
			}
			i = i + 1 >> 0;
		}
	};
	var siftDown = function(data, lo, hi, first) {
		var root, x, child;
		root = lo;
		while (true) {
			child = (x = 2, (((x >>> 16 << 16) * root >> 0) + (x << 16 >>> 16) * root) >> 0) + 1 >> 0;
			if (child >= hi) {
				break;
			}
			if ((child + 1 >> 0) < hi && data.Less(first + child >> 0, (first + child >> 0) + 1 >> 0)) {
				child = child + 1 >> 0;
			}
			if (!data.Less(first + root >> 0, first + child >> 0)) {
				return;
			}
			data.Swap(first + root >> 0, first + child >> 0);
			root = child;
		}
	};
	var heapSort = function(data, a, b) {
		var first, lo, hi, _q, i, i$1;
		first = a;
		lo = 0;
		hi = b - a >> 0;
		i = (_q = ((hi - 1 >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		while (i >= 0) {
			siftDown(data, i, hi, first);
			i = i - 1 >> 0;
		}
		i$1 = hi - 1 >> 0;
		while (i$1 >= 0) {
			data.Swap(first, first + i$1 >> 0);
			siftDown(data, lo, i$1, first);
			i$1 = i$1 - 1 >> 0;
		}
	};
	var medianOfThree = function(data, a, b, c) {
		var m0, m1, m2;
		m0 = b;
		m1 = a;
		m2 = c;
		if (data.Less(m1, m0)) {
			data.Swap(m1, m0);
		}
		if (data.Less(m2, m1)) {
			data.Swap(m2, m1);
		}
		if (data.Less(m1, m0)) {
			data.Swap(m1, m0);
		}
	};
	var swapRange = function(data, a, b, n) {
		var i;
		i = 0;
		while (i < n) {
			data.Swap(a + i >> 0, b + i >> 0);
			i = i + 1 >> 0;
		}
	};
	var doPivot = function(data, lo, hi) {
		var midlo, midhi, _q, m, _q$1, s, x, x$1, pivot, _tuple, a, b, c, d, n, _tuple$1;
		midlo = 0;
		midhi = 0;
		m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
		if ((hi - lo >> 0) > 40) {
			s = (_q$1 = ((hi - lo >> 0)) / 8, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
			medianOfThree(data, lo, lo + s >> 0, lo + (x = 2, (((x >>> 16 << 16) * s >> 0) + (x << 16 >>> 16) * s) >> 0) >> 0);
			medianOfThree(data, m, m - s >> 0, m + s >> 0);
			medianOfThree(data, hi - 1 >> 0, (hi - 1 >> 0) - s >> 0, (hi - 1 >> 0) - (x$1 = 2, (((x$1 >>> 16 << 16) * s >> 0) + (x$1 << 16 >>> 16) * s) >> 0) >> 0);
		}
		medianOfThree(data, lo, m, hi - 1 >> 0);
		pivot = lo;
		_tuple = [lo + 1 >> 0, lo + 1 >> 0, hi, hi], a = _tuple[0], b = _tuple[1], c = _tuple[2], d = _tuple[3];
		while (true) {
			while (b < c) {
				if (data.Less(b, pivot)) {
					b = b + 1 >> 0;
				} else if (!data.Less(pivot, b)) {
					data.Swap(a, b);
					a = a + 1 >> 0;
					b = b + 1 >> 0;
				} else {
					break;
				}
			}
			while (b < c) {
				if (data.Less(pivot, c - 1 >> 0)) {
					c = c - 1 >> 0;
				} else if (!data.Less(c - 1 >> 0, pivot)) {
					data.Swap(c - 1 >> 0, d - 1 >> 0);
					c = c - 1 >> 0;
					d = d - 1 >> 0;
				} else {
					break;
				}
			}
			if (b >= c) {
				break;
			}
			data.Swap(b, c - 1 >> 0);
			b = b + 1 >> 0;
			c = c - 1 >> 0;
		}
		n = min(b - a >> 0, a - lo >> 0);
		swapRange(data, lo, b - n >> 0, n);
		n = min(hi - d >> 0, d - c >> 0);
		swapRange(data, c, hi - n >> 0, n);
		_tuple$1 = [(lo + b >> 0) - a >> 0, hi - ((d - c >> 0)) >> 0], midlo = _tuple$1[0], midhi = _tuple$1[1];
		return [midlo, midhi];
	};
	var quickSort = function(data, a, b, maxDepth) {
		var _tuple, mlo, mhi;
		while ((b - a >> 0) > 7) {
			if (maxDepth === 0) {
				heapSort(data, a, b);
				return;
			}
			maxDepth = maxDepth - 1 >> 0;
			_tuple = doPivot(data, a, b), mlo = _tuple[0], mhi = _tuple[1];
			if ((mlo - a >> 0) < (b - mhi >> 0)) {
				quickSort(data, a, mlo, maxDepth);
				a = mhi;
			} else {
				quickSort(data, mhi, b, maxDepth);
				b = mlo;
			}
		}
		if ((b - a >> 0) > 1) {
			insertionSort(data, a, b);
		}
	};
	var Sort = go$pkg.Sort = function(data) {
		var n, maxDepth, i, x;
		n = data.Len();
		maxDepth = 0;
		i = n;
		while (i > 0) {
			maxDepth = maxDepth + 1 >> 0;
			i = i >> 1 >> 0;
		}
		maxDepth = (x = 2, (((maxDepth >>> 16 << 16) * x >> 0) + (maxDepth << 16 >>> 16) * x) >> 0);
		quickSort(data, 0, n, maxDepth);
	};
	reverse.Ptr.prototype.Less = function(i, j) {
		var _struct, r;
		r = (_struct = this, new reverse.Ptr(_struct.Interface));
		return r.Interface.Less(j, i);
	};
	reverse.prototype.Less = function(i, j) { return this.go$val.Less(i, j); };
	var Reverse = go$pkg.Reverse = function(data) {
		return new reverse.Ptr(data);
	};
	var IsSorted = go$pkg.IsSorted = function(data) {
		var n, i;
		n = data.Len();
		i = n - 1 >> 0;
		while (i > 0) {
			if (data.Less(i, i - 1 >> 0)) {
				return false;
			}
			i = i - 1 >> 0;
		}
		return true;
	};
	IntSlice.prototype.Len = function() {
		var p;
		p = this;
		return p.length;
	};
	go$ptrType(IntSlice).prototype.Len = function() { return this.go$get().Len(); };
	IntSlice.prototype.Less = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1;
		p = this;
		return (_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < (_slice$1 = p, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
	};
	go$ptrType(IntSlice).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
	IntSlice.prototype.Swap = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		_tuple = [(_slice = p, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = p, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = p, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(IntSlice).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
	IntSlice.prototype.Sort = function() {
		var p;
		p = this;
		Sort(p);
	};
	go$ptrType(IntSlice).prototype.Sort = function() { return this.go$get().Sort(); };
	Float64Slice.prototype.Len = function() {
		var p;
		p = this;
		return p.length;
	};
	go$ptrType(Float64Slice).prototype.Len = function() { return this.go$get().Len(); };
	Float64Slice.prototype.Less = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		return (_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < (_slice$1 = p, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) || isNaN((_slice$2 = p, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))) && !isNaN((_slice$3 = p, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")));
	};
	go$ptrType(Float64Slice).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
	Float64Slice.prototype.Swap = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		_tuple = [(_slice = p, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = p, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = p, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(Float64Slice).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
	var isNaN = function(f) {
		return !((f === f));
	};
	Float64Slice.prototype.Sort = function() {
		var p;
		p = this;
		Sort(p);
	};
	go$ptrType(Float64Slice).prototype.Sort = function() { return this.go$get().Sort(); };
	StringSlice.prototype.Len = function() {
		var p;
		p = this;
		return p.length;
	};
	go$ptrType(StringSlice).prototype.Len = function() { return this.go$get().Len(); };
	StringSlice.prototype.Less = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1;
		p = this;
		return (_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < (_slice$1 = p, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
	};
	go$ptrType(StringSlice).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
	StringSlice.prototype.Swap = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		_tuple = [(_slice = p, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = p, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = p, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(StringSlice).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
	StringSlice.prototype.Sort = function() {
		var p;
		p = this;
		Sort(p);
	};
	go$ptrType(StringSlice).prototype.Sort = function() { return this.go$get().Sort(); };
	var Ints = go$pkg.Ints = function(a) {
		Sort(go$subslice(new IntSlice(a.array), a.offset, a.offset + a.length));
	};
	var Float64s = go$pkg.Float64s = function(a) {
		Sort(go$subslice(new Float64Slice(a.array), a.offset, a.offset + a.length));
	};
	var Strings = go$pkg.Strings = function(a) {
		Sort(go$subslice(new StringSlice(a.array), a.offset, a.offset + a.length));
	};
	var IntsAreSorted = go$pkg.IntsAreSorted = function(a) {
		return IsSorted(go$subslice(new IntSlice(a.array), a.offset, a.offset + a.length));
	};
	var Float64sAreSorted = go$pkg.Float64sAreSorted = function(a) {
		return IsSorted(go$subslice(new Float64Slice(a.array), a.offset, a.offset + a.length));
	};
	var StringsAreSorted = go$pkg.StringsAreSorted = function(a) {
		return IsSorted(go$subslice(new StringSlice(a.array), a.offset, a.offset + a.length));
	};
	var Stable = go$pkg.Stable = function(data) {
		var n, blockSize, _tuple, a, b, x, _tuple$1, x$1, x$2;
		n = data.Len();
		blockSize = 20;
		_tuple = [0, blockSize], a = _tuple[0], b = _tuple[1];
		while (b <= n) {
			insertionSort(data, a, b);
			a = b;
			b = b + (blockSize) >> 0;
		}
		insertionSort(data, a, n);
		while (blockSize < n) {
			_tuple$1 = [0, (x = 2, (((x >>> 16 << 16) * blockSize >> 0) + (x << 16 >>> 16) * blockSize) >> 0)], a = _tuple$1[0], b = _tuple$1[1];
			while (b <= n) {
				symMerge(data, a, a + blockSize >> 0, b);
				a = b;
				b = b + ((x$1 = 2, (((x$1 >>> 16 << 16) * blockSize >> 0) + (x$1 << 16 >>> 16) * blockSize) >> 0)) >> 0;
			}
			symMerge(data, a, a + blockSize >> 0, n);
			blockSize = (x$2 = 2, (((blockSize >>> 16 << 16) * x$2 >> 0) + (blockSize << 16 >>> 16) * x$2) >> 0);
		}
	};
	var symMerge = function(data, a, m, b) {
		var _q, mid, n, start, _tuple, r, p, _q$1, c, _tuple$1, r$1, p$1, _q$2, c$1, end;
		if (a >= m || m >= b) {
			return;
		}
		mid = a + (_q = ((b - a >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
		n = mid + m >> 0;
		start = 0;
		if (m > mid) {
			start = n - b >> 0;
			_tuple = [mid, n - 1 >> 0], r = _tuple[0], p = _tuple[1];
			while (start < r) {
				c = start + (_q$1 = ((r - start >> 0)) / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
				if (!data.Less(p - c >> 0, c)) {
					start = c + 1 >> 0;
				} else {
					r = c;
				}
			}
		} else {
			start = a;
			_tuple$1 = [m, n - 1 >> 0], r$1 = _tuple$1[0], p$1 = _tuple$1[1];
			while (start < r$1) {
				c$1 = start + (_q$2 = ((r$1 - start >> 0)) / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
				if (!data.Less(p$1 - c$1 >> 0, c$1)) {
					start = c$1 + 1 >> 0;
				} else {
					r$1 = c$1;
				}
			}
		}
		end = n - start >> 0;
		rotate(data, start, m, end);
		symMerge(data, a, start, mid);
		symMerge(data, mid, end, b);
	};
	var rotate = function(data, a, m, b) {
		var i, j, p;
		i = m - a >> 0;
		if (i === 0) {
			return;
		}
		j = b - m >> 0;
		if (j === 0) {
			return;
		}
		if (i === j) {
			swapRange(data, a, m, i);
			return;
		}
		p = a + i >> 0;
		while (!((i === j))) {
			if (i > j) {
				swapRange(data, p - i >> 0, p, j);
				i = i - (j) >> 0;
			} else {
				swapRange(data, p - i >> 0, (p + j >> 0) - i >> 0, i);
				j = j - (i) >> 0;
			}
		}
		swapRange(data, p - i >> 0, p, i);
	};
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["encoding/json"] = (function() {
	var go$pkg = {};
	var encoding = go$packages["encoding"];
	var base64 = go$packages["encoding/base64"];
	var errors = go$packages["errors"];
	var fmt = go$packages["fmt"];
	var reflect = go$packages["reflect"];
	var runtime = go$packages["runtime"];
	var strconv = go$packages["strconv"];
	var strings = go$packages["strings"];
	var unicode = go$packages["unicode"];
	var utf16 = go$packages["unicode/utf16"];
	var utf8 = go$packages["unicode/utf8"];
	var bytes = go$packages["bytes"];
	var math = go$packages["math"];
	var sort = go$packages["sort"];
	var sync = go$packages["sync"];
	var io = go$packages["io"];
	var Unmarshaler;
	Unmarshaler = go$newType(0, "Interface", "json.Unmarshaler", "Unmarshaler", "encoding/json", null);
	go$pkg.Unmarshaler = Unmarshaler;
	var UnmarshalTypeError;
	UnmarshalTypeError = go$newType(0, "Struct", "json.UnmarshalTypeError", "UnmarshalTypeError", "encoding/json", function(Value_, Type_) {
		this.go$val = this;
		this.Value = Value_ !== undefined ? Value_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
	});
	go$pkg.UnmarshalTypeError = UnmarshalTypeError;
	var UnmarshalFieldError;
	UnmarshalFieldError = go$newType(0, "Struct", "json.UnmarshalFieldError", "UnmarshalFieldError", "encoding/json", function(Key_, Type_, Field_) {
		this.go$val = this;
		this.Key = Key_ !== undefined ? Key_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Field = Field_ !== undefined ? Field_ : new reflect.StructField.Ptr();
	});
	go$pkg.UnmarshalFieldError = UnmarshalFieldError;
	var InvalidUnmarshalError;
	InvalidUnmarshalError = go$newType(0, "Struct", "json.InvalidUnmarshalError", "InvalidUnmarshalError", "encoding/json", function(Type_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
	});
	go$pkg.InvalidUnmarshalError = InvalidUnmarshalError;
	var Number;
	Number = go$newType(0, "String", "json.Number", "Number", "encoding/json", null);
	go$pkg.Number = Number;
	var decodeState;
	decodeState = go$newType(0, "Struct", "json.decodeState", "decodeState", "encoding/json", function(data_, off_, scan_, nextscan_, savedError_, tempstr_, useNumber_) {
		this.go$val = this;
		this.data = data_ !== undefined ? data_ : (go$sliceType(Go$Uint8)).nil;
		this.off = off_ !== undefined ? off_ : 0;
		this.scan = scan_ !== undefined ? scan_ : new scanner.Ptr();
		this.nextscan = nextscan_ !== undefined ? nextscan_ : new scanner.Ptr();
		this.savedError = savedError_ !== undefined ? savedError_ : null;
		this.tempstr = tempstr_ !== undefined ? tempstr_ : "";
		this.useNumber = useNumber_ !== undefined ? useNumber_ : false;
	});
	go$pkg.decodeState = decodeState;
	var Marshaler;
	Marshaler = go$newType(0, "Interface", "json.Marshaler", "Marshaler", "encoding/json", null);
	go$pkg.Marshaler = Marshaler;
	var UnsupportedTypeError;
	UnsupportedTypeError = go$newType(0, "Struct", "json.UnsupportedTypeError", "UnsupportedTypeError", "encoding/json", function(Type_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
	});
	go$pkg.UnsupportedTypeError = UnsupportedTypeError;
	var UnsupportedValueError;
	UnsupportedValueError = go$newType(0, "Struct", "json.UnsupportedValueError", "UnsupportedValueError", "encoding/json", function(Value_, Str_) {
		this.go$val = this;
		this.Value = Value_ !== undefined ? Value_ : new reflect.Value.Ptr();
		this.Str = Str_ !== undefined ? Str_ : "";
	});
	go$pkg.UnsupportedValueError = UnsupportedValueError;
	var InvalidUTF8Error;
	InvalidUTF8Error = go$newType(0, "Struct", "json.InvalidUTF8Error", "InvalidUTF8Error", "encoding/json", function(S_) {
		this.go$val = this;
		this.S = S_ !== undefined ? S_ : "";
	});
	go$pkg.InvalidUTF8Error = InvalidUTF8Error;
	var MarshalerError;
	MarshalerError = go$newType(0, "Struct", "json.MarshalerError", "MarshalerError", "encoding/json", function(Type_, Err_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.MarshalerError = MarshalerError;
	var encodeState;
	encodeState = go$newType(0, "Struct", "json.encodeState", "encodeState", "encoding/json", function(Buffer_, scratch_) {
		this.go$val = this;
		this.Buffer = Buffer_ !== undefined ? Buffer_ : new bytes.Buffer.Ptr();
		this.scratch = scratch_ !== undefined ? scratch_ : go$makeNativeArray("Uint8", 64, function() { return 0; });
	});
	encodeState.prototype.Bytes = function() { return this.go$val.Bytes(); };
	encodeState.Ptr.prototype.Bytes = function() { return this.Buffer.Bytes(); };
	encodeState.prototype.Grow = function(n) { return this.go$val.Grow(n); };
	encodeState.Ptr.prototype.Grow = function(n) { return this.Buffer.Grow(n); };
	encodeState.prototype.Len = function() { return this.go$val.Len(); };
	encodeState.Ptr.prototype.Len = function() { return this.Buffer.Len(); };
	encodeState.prototype.Next = function(n) { return this.go$val.Next(n); };
	encodeState.Ptr.prototype.Next = function(n) { return this.Buffer.Next(n); };
	encodeState.prototype.Read = function(p) { return this.go$val.Read(p); };
	encodeState.Ptr.prototype.Read = function(p) { return this.Buffer.Read(p); };
	encodeState.prototype.ReadByte = function() { return this.go$val.ReadByte(); };
	encodeState.Ptr.prototype.ReadByte = function() { return this.Buffer.ReadByte(); };
	encodeState.prototype.ReadBytes = function(delim) { return this.go$val.ReadBytes(delim); };
	encodeState.Ptr.prototype.ReadBytes = function(delim) { return this.Buffer.ReadBytes(delim); };
	encodeState.prototype.ReadFrom = function(r) { return this.go$val.ReadFrom(r); };
	encodeState.Ptr.prototype.ReadFrom = function(r) { return this.Buffer.ReadFrom(r); };
	encodeState.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	encodeState.Ptr.prototype.ReadRune = function() { return this.Buffer.ReadRune(); };
	encodeState.prototype.ReadString = function(delim) { return this.go$val.ReadString(delim); };
	encodeState.Ptr.prototype.ReadString = function(delim) { return this.Buffer.ReadString(delim); };
	encodeState.prototype.Reset = function() { return this.go$val.Reset(); };
	encodeState.Ptr.prototype.Reset = function() { return this.Buffer.Reset(); };
	encodeState.prototype.String = function() { return this.go$val.String(); };
	encodeState.Ptr.prototype.String = function() { return this.Buffer.String(); };
	encodeState.prototype.Truncate = function(n) { return this.go$val.Truncate(n); };
	encodeState.Ptr.prototype.Truncate = function(n) { return this.Buffer.Truncate(n); };
	encodeState.prototype.UnreadByte = function() { return this.go$val.UnreadByte(); };
	encodeState.Ptr.prototype.UnreadByte = function() { return this.Buffer.UnreadByte(); };
	encodeState.prototype.UnreadRune = function() { return this.go$val.UnreadRune(); };
	encodeState.Ptr.prototype.UnreadRune = function() { return this.Buffer.UnreadRune(); };
	encodeState.prototype.Write = function(p) { return this.go$val.Write(p); };
	encodeState.Ptr.prototype.Write = function(p) { return this.Buffer.Write(p); };
	encodeState.prototype.WriteByte = function(c) { return this.go$val.WriteByte(c); };
	encodeState.Ptr.prototype.WriteByte = function(c) { return this.Buffer.WriteByte(c); };
	encodeState.prototype.WriteRune = function(r) { return this.go$val.WriteRune(r); };
	encodeState.Ptr.prototype.WriteRune = function(r) { return this.Buffer.WriteRune(r); };
	encodeState.prototype.WriteString = function(s) { return this.go$val.WriteString(s); };
	encodeState.Ptr.prototype.WriteString = function(s) { return this.Buffer.WriteString(s); };
	encodeState.prototype.WriteTo = function(w) { return this.go$val.WriteTo(w); };
	encodeState.Ptr.prototype.WriteTo = function(w) { return this.Buffer.WriteTo(w); };
	encodeState.prototype.grow = function(n) { return this.go$val.grow(n); };
	encodeState.Ptr.prototype.grow = function(n) { return this.Buffer.grow(n); };
	encodeState.prototype.readSlice = function(delim) { return this.go$val.readSlice(delim); };
	encodeState.Ptr.prototype.readSlice = function(delim) { return this.Buffer.readSlice(delim); };
	go$pkg.encodeState = encodeState;
	var encoderFunc;
	encoderFunc = go$newType(0, "Func", "json.encoderFunc", "encoderFunc", "encoding/json", null);
	go$pkg.encoderFunc = encoderFunc;
	var floatEncoder;
	floatEncoder = go$newType(4, "Int", "json.floatEncoder", "floatEncoder", "encoding/json", null);
	go$pkg.floatEncoder = floatEncoder;
	var structEncoder;
	structEncoder = go$newType(0, "Struct", "json.structEncoder", "structEncoder", "encoding/json", function(fields_, fieldEncs_) {
		this.go$val = this;
		this.fields = fields_ !== undefined ? fields_ : (go$sliceType(field)).nil;
		this.fieldEncs = fieldEncs_ !== undefined ? fieldEncs_ : (go$sliceType(encoderFunc)).nil;
	});
	go$pkg.structEncoder = structEncoder;
	var mapEncoder;
	mapEncoder = go$newType(0, "Struct", "json.mapEncoder", "mapEncoder", "encoding/json", function(elemEnc_) {
		this.go$val = this;
		this.elemEnc = elemEnc_ !== undefined ? elemEnc_ : go$throwNilPointerError;
	});
	go$pkg.mapEncoder = mapEncoder;
	var sliceEncoder;
	sliceEncoder = go$newType(0, "Struct", "json.sliceEncoder", "sliceEncoder", "encoding/json", function(arrayEnc_) {
		this.go$val = this;
		this.arrayEnc = arrayEnc_ !== undefined ? arrayEnc_ : go$throwNilPointerError;
	});
	go$pkg.sliceEncoder = sliceEncoder;
	var arrayEncoder;
	arrayEncoder = go$newType(0, "Struct", "json.arrayEncoder", "arrayEncoder", "encoding/json", function(elemEnc_) {
		this.go$val = this;
		this.elemEnc = elemEnc_ !== undefined ? elemEnc_ : go$throwNilPointerError;
	});
	go$pkg.arrayEncoder = arrayEncoder;
	var ptrEncoder;
	ptrEncoder = go$newType(0, "Struct", "json.ptrEncoder", "ptrEncoder", "encoding/json", function(elemEnc_) {
		this.go$val = this;
		this.elemEnc = elemEnc_ !== undefined ? elemEnc_ : go$throwNilPointerError;
	});
	go$pkg.ptrEncoder = ptrEncoder;
	var condAddrEncoder;
	condAddrEncoder = go$newType(0, "Struct", "json.condAddrEncoder", "condAddrEncoder", "encoding/json", function(canAddrEnc_, elseEnc_) {
		this.go$val = this;
		this.canAddrEnc = canAddrEnc_ !== undefined ? canAddrEnc_ : go$throwNilPointerError;
		this.elseEnc = elseEnc_ !== undefined ? elseEnc_ : go$throwNilPointerError;
	});
	go$pkg.condAddrEncoder = condAddrEncoder;
	var stringValues;
	stringValues = go$newType(0, "Slice", "json.stringValues", "stringValues", "encoding/json", null);
	go$pkg.stringValues = stringValues;
	var field;
	field = go$newType(0, "Struct", "json.field", "field", "encoding/json", function(name_, tag_, index_, typ_, omitEmpty_, quoted_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.tag = tag_ !== undefined ? tag_ : false;
		this.index = index_ !== undefined ? index_ : (go$sliceType(Go$Int)).nil;
		this.typ = typ_ !== undefined ? typ_ : null;
		this.omitEmpty = omitEmpty_ !== undefined ? omitEmpty_ : false;
		this.quoted = quoted_ !== undefined ? quoted_ : false;
	});
	go$pkg.field = field;
	var byName;
	byName = go$newType(0, "Slice", "json.byName", "byName", "encoding/json", null);
	go$pkg.byName = byName;
	var byIndex;
	byIndex = go$newType(0, "Slice", "json.byIndex", "byIndex", "encoding/json", null);
	go$pkg.byIndex = byIndex;
	var SyntaxError;
	SyntaxError = go$newType(0, "Struct", "json.SyntaxError", "SyntaxError", "encoding/json", function(msg_, Offset_) {
		this.go$val = this;
		this.msg = msg_ !== undefined ? msg_ : "";
		this.Offset = Offset_ !== undefined ? Offset_ : new Go$Int64(0, 0);
	});
	go$pkg.SyntaxError = SyntaxError;
	var scanner;
	scanner = go$newType(0, "Struct", "json.scanner", "scanner", "encoding/json", function(step_, endTop_, parseState_, err_, redo_, redoCode_, redoState_, bytes_) {
		this.go$val = this;
		this.step = step_ !== undefined ? step_ : go$throwNilPointerError;
		this.endTop = endTop_ !== undefined ? endTop_ : false;
		this.parseState = parseState_ !== undefined ? parseState_ : (go$sliceType(Go$Int)).nil;
		this.err = err_ !== undefined ? err_ : null;
		this.redo = redo_ !== undefined ? redo_ : false;
		this.redoCode = redoCode_ !== undefined ? redoCode_ : 0;
		this.redoState = redoState_ !== undefined ? redoState_ : go$throwNilPointerError;
		this.bytes = bytes_ !== undefined ? bytes_ : new Go$Int64(0, 0);
	});
	go$pkg.scanner = scanner;
	var Decoder;
	Decoder = go$newType(0, "Struct", "json.Decoder", "Decoder", "encoding/json", function(r_, buf_, d_, scan_, err_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.buf = buf_ !== undefined ? buf_ : (go$sliceType(Go$Uint8)).nil;
		this.d = d_ !== undefined ? d_ : new decodeState.Ptr();
		this.scan = scan_ !== undefined ? scan_ : new scanner.Ptr();
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.Decoder = Decoder;
	var Encoder;
	Encoder = go$newType(0, "Struct", "json.Encoder", "Encoder", "encoding/json", function(w_, e_, err_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : null;
		this.e = e_ !== undefined ? e_ : new encodeState.Ptr();
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.Encoder = Encoder;
	var RawMessage;
	RawMessage = go$newType(0, "Slice", "json.RawMessage", "RawMessage", "encoding/json", null);
	go$pkg.RawMessage = RawMessage;
	var tagOptions;
	tagOptions = go$newType(0, "String", "json.tagOptions", "tagOptions", "encoding/json", null);
	go$pkg.tagOptions = tagOptions;
	Unmarshaler.init([["UnmarshalJSON", "", (go$funcType([(go$sliceType(Go$Uint8))], [go$error], false))]]);
	UnmarshalTypeError.init([["Value", "", Go$String, ""], ["Type", "", reflect.Type, ""]]);
	(go$ptrType(UnmarshalTypeError)).methods = [["Error", "", [], [Go$String], false]];
	UnmarshalFieldError.init([["Key", "", Go$String, ""], ["Type", "", reflect.Type, ""], ["Field", "", reflect.StructField, ""]]);
	(go$ptrType(UnmarshalFieldError)).methods = [["Error", "", [], [Go$String], false]];
	InvalidUnmarshalError.init([["Type", "", reflect.Type, ""]]);
	(go$ptrType(InvalidUnmarshalError)).methods = [["Error", "", [], [Go$String], false]];
	Number.methods = [["Float64", "", [], [Go$Float64, go$error], false], ["Int64", "", [], [Go$Int64, go$error], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Number)).methods = [["Float64", "", [], [Go$Float64, go$error], false], ["Int64", "", [], [Go$Int64, go$error], false], ["String", "", [], [Go$String], false]];
	decodeState.init([["data", "encoding/json", (go$sliceType(Go$Uint8)), ""], ["off", "encoding/json", Go$Int, ""], ["scan", "encoding/json", scanner, ""], ["nextscan", "encoding/json", scanner, ""], ["savedError", "encoding/json", go$error, ""], ["tempstr", "encoding/json", Go$String, ""], ["useNumber", "encoding/json", Go$Bool, ""]]);
	(go$ptrType(decodeState)).methods = [["array", "encoding/json", [reflect.Value], [], false], ["arrayInterface", "encoding/json", [], [(go$sliceType(go$emptyInterface))], false], ["convertNumber", "encoding/json", [Go$String], [go$emptyInterface, go$error], false], ["error", "encoding/json", [go$error], [], false], ["indirect", "encoding/json", [reflect.Value, Go$Bool], [Unmarshaler, encoding.TextUnmarshaler, reflect.Value], false], ["init", "encoding/json", [(go$sliceType(Go$Uint8))], [(go$ptrType(decodeState))], false], ["literal", "encoding/json", [reflect.Value], [], false], ["literalInterface", "encoding/json", [], [go$emptyInterface], false], ["literalStore", "encoding/json", [(go$sliceType(Go$Uint8)), reflect.Value, Go$Bool], [], false], ["next", "encoding/json", [], [(go$sliceType(Go$Uint8))], false], ["object", "encoding/json", [reflect.Value], [], false], ["objectInterface", "encoding/json", [], [(go$mapType(Go$String, go$emptyInterface))], false], ["saveError", "encoding/json", [go$error], [], false], ["scanWhile", "encoding/json", [Go$Int], [Go$Int], false], ["unmarshal", "encoding/json", [go$emptyInterface], [go$error], false], ["value", "encoding/json", [reflect.Value], [], false], ["valueInterface", "encoding/json", [], [go$emptyInterface], false]];
	Marshaler.init([["MarshalJSON", "", (go$funcType([], [(go$sliceType(Go$Uint8)), go$error], false))]]);
	UnsupportedTypeError.init([["Type", "", reflect.Type, ""]]);
	(go$ptrType(UnsupportedTypeError)).methods = [["Error", "", [], [Go$String], false]];
	UnsupportedValueError.init([["Value", "", reflect.Value, ""], ["Str", "", Go$String, ""]]);
	(go$ptrType(UnsupportedValueError)).methods = [["Error", "", [], [Go$String], false]];
	InvalidUTF8Error.init([["S", "", Go$String, ""]]);
	(go$ptrType(InvalidUTF8Error)).methods = [["Error", "", [], [Go$String], false]];
	MarshalerError.init([["Type", "", reflect.Type, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(MarshalerError)).methods = [["Error", "", [], [Go$String], false]];
	encodeState.init([["", "", bytes.Buffer, ""], ["scratch", "encoding/json", (go$arrayType(Go$Uint8, 64)), ""]]);
	(go$ptrType(encodeState)).methods = [["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Grow", "", [Go$Int], [], false], ["Len", "", [], [Go$Int], false], ["Next", "", [Go$Int], [(go$sliceType(Go$Uint8))], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadByte", "", [], [Go$Uint8, go$error], false], ["ReadBytes", "", [Go$Uint8], [(go$sliceType(Go$Uint8)), go$error], false], ["ReadFrom", "", [io.Reader], [Go$Int64, go$error], false], ["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["ReadString", "", [Go$Uint8], [Go$String, go$error], false], ["Reset", "", [], [], false], ["String", "", [], [Go$String], false], ["Truncate", "", [Go$Int], [], false], ["UnreadByte", "", [], [go$error], false], ["UnreadRune", "", [], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["WriteByte", "", [Go$Uint8], [go$error], false], ["WriteRune", "", [Go$Int32], [Go$Int, go$error], false], ["WriteString", "", [Go$String], [Go$Int, go$error], false], ["WriteTo", "", [io.Writer], [Go$Int64, go$error], false], ["grow", "bytes", [Go$Int], [Go$Int], false], ["readSlice", "bytes", [Go$Uint8], [(go$sliceType(Go$Uint8)), go$error], false], ["error", "encoding/json", [go$error], [], false], ["marshal", "encoding/json", [go$emptyInterface], [go$error], false], ["reflectValue", "encoding/json", [reflect.Value], [], false], ["string", "encoding/json", [Go$String], [Go$Int, go$error], false], ["stringBytes", "encoding/json", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	encoderFunc.init([(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false);
	floatEncoder.methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	(go$ptrType(floatEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	structEncoder.init([["fields", "encoding/json", (go$sliceType(field)), ""], ["fieldEncs", "encoding/json", (go$sliceType(encoderFunc)), ""]]);
	(go$ptrType(structEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	mapEncoder.init([["elemEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(mapEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	sliceEncoder.init([["arrayEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(sliceEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	arrayEncoder.init([["elemEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(arrayEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	ptrEncoder.init([["elemEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(ptrEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	condAddrEncoder.init([["canAddrEnc", "encoding/json", encoderFunc, ""], ["elseEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(condAddrEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	stringValues.init(reflect.Value);
	stringValues.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false], ["get", "encoding/json", [Go$Int], [Go$String], false]];
	(go$ptrType(stringValues)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false], ["get", "encoding/json", [Go$Int], [Go$String], false]];
	field.init([["name", "encoding/json", Go$String, ""], ["tag", "encoding/json", Go$Bool, ""], ["index", "encoding/json", (go$sliceType(Go$Int)), ""], ["typ", "encoding/json", reflect.Type, ""], ["omitEmpty", "encoding/json", Go$Bool, ""], ["quoted", "encoding/json", Go$Bool, ""]]);
	byName.init(field);
	byName.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(byName)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	byIndex.init(field);
	byIndex.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(byIndex)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	SyntaxError.init([["msg", "encoding/json", Go$String, ""], ["Offset", "", Go$Int64, ""]]);
	(go$ptrType(SyntaxError)).methods = [["Error", "", [], [Go$String], false]];
	scanner.init([["step", "encoding/json", (go$funcType([(go$ptrType(scanner)), Go$Int], [Go$Int], false)), ""], ["endTop", "encoding/json", Go$Bool, ""], ["parseState", "encoding/json", (go$sliceType(Go$Int)), ""], ["err", "encoding/json", go$error, ""], ["redo", "encoding/json", Go$Bool, ""], ["redoCode", "encoding/json", Go$Int, ""], ["redoState", "encoding/json", (go$funcType([(go$ptrType(scanner)), Go$Int], [Go$Int], false)), ""], ["bytes", "encoding/json", Go$Int64, ""]]);
	(go$ptrType(scanner)).methods = [["eof", "encoding/json", [], [Go$Int], false], ["error", "encoding/json", [Go$Int, Go$String], [Go$Int], false], ["popParseState", "encoding/json", [], [], false], ["pushParseState", "encoding/json", [Go$Int], [], false], ["reset", "encoding/json", [], [], false], ["undo", "encoding/json", [Go$Int], [], false]];
	Decoder.init([["r", "encoding/json", io.Reader, ""], ["buf", "encoding/json", (go$sliceType(Go$Uint8)), ""], ["d", "encoding/json", decodeState, ""], ["scan", "encoding/json", scanner, ""], ["err", "encoding/json", go$error, ""]]);
	(go$ptrType(Decoder)).methods = [["Buffered", "", [], [io.Reader], false], ["Decode", "", [go$emptyInterface], [go$error], false], ["UseNumber", "", [], [], false], ["readValue", "encoding/json", [], [Go$Int, go$error], false]];
	Encoder.init([["w", "encoding/json", io.Writer, ""], ["e", "encoding/json", encodeState, ""], ["err", "encoding/json", go$error, ""]]);
	(go$ptrType(Encoder)).methods = [["Encode", "", [go$emptyInterface], [go$error], false]];
	RawMessage.init(Go$Uint8);
	(go$ptrType(RawMessage)).methods = [["MarshalJSON", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["UnmarshalJSON", "", [(go$sliceType(Go$Uint8))], [go$error], false]];
	tagOptions.methods = [["Contains", "", [Go$String], [Go$Bool], false]];
	(go$ptrType(tagOptions)).methods = [["Contains", "", [Go$String], [Go$Bool], false]];
	var errPhase, numberType, hex, encodeStatePool, byteSliceType, encoderCache, marshalerType, textMarshalerType, float32Encoder, float64Encoder, fieldCache;
	var Unmarshal = go$pkg.Unmarshal = function(data, v) {
		var d, err;
		d = new decodeState.Ptr();
		err = checkValid(data, d.scan);
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		d.init(data);
		return d.unmarshal(v);
	};
	UnmarshalTypeError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String();
	};
	UnmarshalTypeError.prototype.Error = function() { return this.go$val.Error(); };
	UnmarshalFieldError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String();
	};
	UnmarshalFieldError.prototype.Error = function() { return this.go$val.Error(); };
	InvalidUnmarshalError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		if (go$interfaceIsEqual(e.Type, null)) {
			return "json: Unmarshal(nil)";
		}
		if (!((e.Type.Kind() === 22))) {
			return "json: Unmarshal(non-pointer " + e.Type.String() + ")";
		}
		return "json: Unmarshal(nil " + e.Type.String() + ")";
	};
	InvalidUnmarshalError.prototype.Error = function() { return this.go$val.Error(); };
	decodeState.Ptr.prototype.unmarshal = function(v) {
		var err, d, _struct, rv, _struct$1;
		err = null;
		var go$deferred = [];
		try {
			d = this;
			go$deferred.push({ fun: (function() {
				var r, ok, _tuple;
				if (r = go$recover(), !(go$interfaceIsEqual(r, null))) {
					if (_tuple = (r !== null && runtime.Error.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), ok = _tuple[1], ok) {
						throw go$panic(r);
					}
					err = (r !== null && go$error.implementedBy.indexOf(r.constructor) !== -1 ? r : go$typeAssertionFailed(r, go$error));
				}
			}), args: [] });
			rv = (_struct = reflect.ValueOf(v), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			if (!((rv.Kind() === 22)) || rv.IsNil()) {
				err = new InvalidUnmarshalError.Ptr(reflect.TypeOf(v));
				return err;
			}
			d.scan.reset();
			d.value((_struct$1 = rv, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)));
			err = d.savedError;
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	decodeState.prototype.unmarshal = function(v) { return this.go$val.unmarshal(v); };
	Number.prototype.String = function() {
		var n;
		n = this.go$val;
		return n;
	};
	go$ptrType(Number).prototype.String = function() { return new Number(this.go$get()).String(); };
	Number.prototype.Float64 = function() {
		var n;
		n = this.go$val;
		return strconv.ParseFloat(n, 64);
	};
	go$ptrType(Number).prototype.Float64 = function() { return new Number(this.go$get()).Float64(); };
	Number.prototype.Int64 = function() {
		var n;
		n = this.go$val;
		return strconv.ParseInt(n, 10, 64);
	};
	go$ptrType(Number).prototype.Int64 = function() { return new Number(this.go$get()).Int64(); };
	decodeState.Ptr.prototype.init = function(data) {
		var d;
		d = this;
		d.data = data;
		d.off = 0;
		d.savedError = null;
		return d;
	};
	decodeState.prototype.init = function(data) { return this.go$val.init(data); };
	decodeState.Ptr.prototype.error = function(err) {
		var d;
		d = this;
		throw go$panic(err);
	};
	decodeState.prototype.error = function(err) { return this.go$val.error(err); };
	decodeState.Ptr.prototype.saveError = function(err) {
		var d;
		d = this;
		if (go$interfaceIsEqual(d.savedError, null)) {
			d.savedError = err;
		}
	};
	decodeState.prototype.saveError = function(err) { return this.go$val.saveError(err); };
	decodeState.Ptr.prototype.next = function() {
		var d, _slice, _index, c, _tuple, item, rest, err;
		d = this;
		c = (_slice = d.data, _index = d.off, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		_tuple = nextValue(go$subslice(d.data, d.off), d.nextscan), item = _tuple[0], rest = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			d.error(err);
		}
		d.off = d.data.length - rest.length >> 0;
		if (c === 123) {
			d.scan.step(d.scan, 125);
		} else {
			d.scan.step(d.scan, 93);
		}
		return item;
	};
	decodeState.prototype.next = function() { return this.go$val.next(); };
	decodeState.Ptr.prototype.scanWhile = function(op) {
		var d, newOp, _slice, _index, c;
		d = this;
		newOp = 0;
		while (true) {
			if (d.off >= d.data.length) {
				newOp = d.scan.eof();
				d.off = d.data.length + 1 >> 0;
			} else {
				c = ((_slice = d.data, _index = d.off, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0);
				d.off = d.off + 1 >> 0;
				newOp = d.scan.step(d.scan, c);
			}
			if (!((newOp === op))) {
				break;
			}
		}
		return newOp;
	};
	decodeState.prototype.scanWhile = function(op) { return this.go$val.scanWhile(op); };
	decodeState.Ptr.prototype.value = function(v) {
		var d, _tuple, rest, err, n, _slice, _index, op, _ref, _struct, _struct$1, _struct$2;
		d = this;
		if (!v.IsValid()) {
			_tuple = nextValue(go$subslice(d.data, d.off), d.nextscan), rest = _tuple[1], err = _tuple[2];
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			d.off = d.data.length - rest.length >> 0;
			if (d.scan.redo) {
				d.scan.redo = false;
				d.scan.step = stateBeginValue;
			}
			d.scan.step(d.scan, 34);
			d.scan.step(d.scan, 34);
			n = d.scan.parseState.length;
			if (n > 0 && ((_slice = d.scan.parseState, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 0)) {
				d.scan.step(d.scan, 58);
				d.scan.step(d.scan, 34);
				d.scan.step(d.scan, 34);
				d.scan.step(d.scan, 125);
			}
			return;
		}
		op = d.scanWhile(9);
		_ref = op;
		if (_ref === 6) {
			d.array((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
		} else if (_ref === 2) {
			d.object((_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)));
		} else if (_ref === 1) {
			d.literal((_struct$2 = v, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)));
		} else {
			d.error(errPhase);
		}
	};
	decodeState.prototype.value = function(v) { return this.go$val.value(v); };
	decodeState.Ptr.prototype.indirect = function(v, decodingNull) {
		var d, _struct, _struct$1, e, _struct$2, _struct$3, ok, _tuple, x, u, ok$1, _tuple$1, x$1, u$1, _struct$4, _struct$5;
		d = this;
		if (!((v.Kind() === 22)) && !(v.Type().Name() === "") && v.CanAddr()) {
			v = (_struct = v.Addr(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		}
		while (true) {
			if ((v.Kind() === 20) && !v.IsNil()) {
				e = (_struct$1 = v.Elem(), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
				if ((e.Kind() === 22) && !e.IsNil() && (!decodingNull || (e.Elem().Kind() === 22))) {
					v = (_struct$2 = e, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
					continue;
				}
			}
			if (!((v.Kind() === 22))) {
				break;
			}
			if (!((v.Elem().Kind() === 22)) && decodingNull && v.CanSet()) {
				break;
			}
			if (v.IsNil()) {
				v.Set((_struct$3 = reflect.New(v.Type().Elem()), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
			}
			if (v.Type().NumMethod() > 0) {
				if (_tuple = (x = v.Interface(), (x !== null && Unmarshaler.implementedBy.indexOf(x.constructor) !== -1 ? [x, true] : [null, false])), u = _tuple[0], ok = _tuple[1], ok) {
					return [u, null, new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0)];
				}
				if (_tuple$1 = (x$1 = v.Interface(), (x$1 !== null && encoding.TextUnmarshaler.implementedBy.indexOf(x$1.constructor) !== -1 ? [x$1, true] : [null, false])), u$1 = _tuple$1[0], ok$1 = _tuple$1[1], ok$1) {
					return [null, u$1, new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0)];
				}
			}
			v = (_struct$4 = v.Elem(), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
		}
		return [null, null, (_struct$5 = v, new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag))];
	};
	decodeState.prototype.indirect = function(v, decodingNull) { return this.go$val.indirect(v, decodingNull); };
	decodeState.Ptr.prototype.array = function(v) {
		var d, _tuple, _struct, u, ut, _struct$1, pv, err, _struct$2, _ref, _struct$3, i, op, _q, newcap, _struct$4, newv, _struct$5, _struct$6, _struct$7, _struct$8, _struct$9, z, _struct$10, _struct$11;
		d = this;
		_tuple = d.indirect((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false), u = _tuple[0], ut = _tuple[1], pv = (_struct$1 = _tuple[2], new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(go$interfaceIsEqual(u, null))) {
			d.off = d.off - 1 >> 0;
			err = u.UnmarshalJSON(d.next());
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			return;
		}
		if (!(go$interfaceIsEqual(ut, null))) {
			d.saveError(new UnmarshalTypeError.Ptr("array", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		}
		v = (_struct$2 = pv, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		_ref = v.Kind();
		switch (0) { default: if (_ref === 20) {
			if (v.NumMethod() === 0) {
				v.Set((_struct$3 = reflect.ValueOf(d.arrayInterface()), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
				return;
			}
			d.saveError(new UnmarshalTypeError.Ptr("array", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		} else if (_ref === 17) {
		} else if (_ref === 23) {
			break;
		} else {
			d.saveError(new UnmarshalTypeError.Ptr("array", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		} }
		i = 0;
		while (true) {
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			d.off = d.off - 1 >> 0;
			d.scan.undo(op);
			if (v.Kind() === 23) {
				if (i >= v.Cap()) {
					newcap = v.Cap() + (_q = v.Cap() / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
					if (newcap < 4) {
						newcap = 4;
					}
					newv = (_struct$4 = reflect.MakeSlice(v.Type(), v.Len(), newcap), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
					reflect.Copy((_struct$5 = newv, new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), (_struct$6 = v, new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
					v.Set((_struct$7 = newv, new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)));
				}
				if (i >= v.Len()) {
					v.SetLen(i + 1 >> 0);
				}
			}
			if (i < v.Len()) {
				d.value((_struct$8 = v.Index(i), new reflect.Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)));
			} else {
				d.value(new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0));
			}
			i = i + 1 >> 0;
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			if (!((op === 7))) {
				d.error(errPhase);
			}
		}
		if (i < v.Len()) {
			if (v.Kind() === 17) {
				z = (_struct$9 = reflect.Zero(v.Type().Elem()), new reflect.Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag));
				while (i < v.Len()) {
					v.Index(i).Set((_struct$10 = z, new reflect.Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag)));
					i = i + 1 >> 0;
				}
			} else {
				v.SetLen(i);
			}
		}
		if ((i === 0) && (v.Kind() === 23)) {
			v.Set((_struct$11 = reflect.MakeSlice(v.Type(), 0, 0), new reflect.Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag)));
		}
	};
	decodeState.prototype.array = function(v) { return this.go$val.array(v); };
	decodeState.Ptr.prototype.object = function(v) {
		var d, _tuple, _struct, u, ut, _struct$1, pv, err, _struct$2, _struct$3, _ref, t, _struct$4, mapElem, op, start, item, _tuple$1, key, ok, subv, destring, elemType, _struct$5, _struct$6, _struct$7, f, fields, _ref$1, _i, i, _slice, _index, ff, _struct$8, _ref$2, _i$1, _slice$1, _index$1, i$1, _struct$9, _struct$10, _struct$11, v$1, _struct$12, _struct$13, _struct$14, _struct$15, kv, _struct$16, _struct$17;
		d = this;
		_tuple = d.indirect((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false), u = _tuple[0], ut = _tuple[1], pv = (_struct$1 = _tuple[2], new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(go$interfaceIsEqual(u, null))) {
			d.off = d.off - 1 >> 0;
			err = u.UnmarshalJSON(d.next());
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			return;
		}
		if (!(go$interfaceIsEqual(ut, null))) {
			d.saveError(new UnmarshalTypeError.Ptr("object", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		}
		v = (_struct$2 = pv, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		if ((v.Kind() === 20) && (v.NumMethod() === 0)) {
			v.Set((_struct$3 = reflect.ValueOf(new (go$mapType(Go$String, go$emptyInterface))(d.objectInterface())), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
			return;
		}
		_ref = v.Kind();
		switch (0) { default: if (_ref === 21) {
			t = v.Type();
			if (!((t.Key().Kind() === 24))) {
				d.saveError(new UnmarshalTypeError.Ptr("object", v.Type()));
				break;
			}
			if (v.IsNil()) {
				v.Set((_struct$4 = reflect.MakeMap(t), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)));
			}
		} else if (_ref === 25) {
		} else {
			d.saveError(new UnmarshalTypeError.Ptr("object", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		} }
		mapElem = new reflect.Value.Ptr();
		while (true) {
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 1))) {
				d.error(errPhase);
			}
			start = d.off - 1 >> 0;
			op = d.scanWhile(0);
			item = go$subslice(d.data, start, (d.off - 1 >> 0));
			_tuple$1 = unquote(item), key = _tuple$1[0], ok = _tuple$1[1];
			if (!ok) {
				d.error(errPhase);
			}
			subv = new reflect.Value.Ptr();
			destring = false;
			if (v.Kind() === 21) {
				elemType = v.Type().Elem();
				if (!mapElem.IsValid()) {
					mapElem = (_struct$5 = reflect.New(elemType).Elem(), new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag));
				} else {
					mapElem.Set((_struct$6 = reflect.Zero(elemType), new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
				}
				subv = (_struct$7 = mapElem, new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag));
			} else {
				f = (go$ptrType(field)).nil;
				fields = cachedTypeFields(v.Type());
				_ref$1 = fields;
				_i = 0;
				while (_i < _ref$1.length) {
					i = _i;
					ff = (_slice = fields, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
					if (ff.name === key) {
						f = ff;
						break;
					}
					if (f === (go$ptrType(field)).nil && strings.EqualFold(ff.name, key)) {
						f = ff;
					}
					_i++;
				}
				if (!(f === (go$ptrType(field)).nil)) {
					subv = (_struct$8 = v, new reflect.Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag));
					destring = f.quoted;
					_ref$2 = f.index;
					_i$1 = 0;
					while (_i$1 < _ref$2.length) {
						i$1 = (_slice$1 = _ref$2, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
						if (subv.Kind() === 22) {
							if (subv.IsNil()) {
								subv.Set((_struct$9 = reflect.New(subv.Type().Elem()), new reflect.Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag)));
							}
							subv = (_struct$10 = subv.Elem(), new reflect.Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag));
						}
						subv = (_struct$11 = subv.Field(i$1), new reflect.Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag));
						_i$1++;
					}
				}
			}
			if (op === 9) {
				op = d.scanWhile(9);
			}
			if (!((op === 3))) {
				d.error(errPhase);
			}
			if (destring) {
				d.value((_struct$12 = reflect.ValueOf(new (go$ptrType(Go$String))(function() { return d.tempstr; }, function(v$1) { d.tempstr = v$1; })), new reflect.Value.Ptr(_struct$12.typ, _struct$12.val, _struct$12.flag)));
				d.literalStore(new (go$sliceType(Go$Uint8))(go$stringToBytes(d.tempstr)), (_struct$13 = subv, new reflect.Value.Ptr(_struct$13.typ, _struct$13.val, _struct$13.flag)), true);
			} else {
				d.value((_struct$14 = subv, new reflect.Value.Ptr(_struct$14.typ, _struct$14.val, _struct$14.flag)));
			}
			if (v.Kind() === 21) {
				kv = (_struct$15 = reflect.ValueOf(new Go$String(key)).Convert(v.Type().Key()), new reflect.Value.Ptr(_struct$15.typ, _struct$15.val, _struct$15.flag));
				v.SetMapIndex((_struct$16 = kv, new reflect.Value.Ptr(_struct$16.typ, _struct$16.val, _struct$16.flag)), (_struct$17 = subv, new reflect.Value.Ptr(_struct$17.typ, _struct$17.val, _struct$17.flag)));
			}
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 4))) {
				d.error(errPhase);
			}
		}
	};
	decodeState.prototype.object = function(v) { return this.go$val.object(v); };
	decodeState.Ptr.prototype.literal = function(v) {
		var d, start, op, _struct;
		d = this;
		start = d.off - 1 >> 0;
		op = d.scanWhile(0);
		d.off = d.off - 1 >> 0;
		d.scan.undo(op);
		d.literalStore(go$subslice(d.data, start, d.off), (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
	};
	decodeState.prototype.literal = function(v) { return this.go$val.literal(v); };
	decodeState.Ptr.prototype.convertNumber = function(s) {
		var d, _tuple, f, err;
		d = this;
		if (d.useNumber) {
			return [new Number(s), null];
		}
		_tuple = strconv.ParseFloat(s, 64), f = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [null, new UnmarshalTypeError.Ptr("number " + s, reflect.TypeOf(new Go$Float64(0)))];
		}
		return [new Go$Float64(f), null];
	};
	decodeState.prototype.convertNumber = function(s) { return this.go$val.convertNumber(s); };
	decodeState.Ptr.prototype.literalStore = function(item, v, fromQuoted) {
		var d, _slice, _index, wantptr, _tuple, _struct, u, ut, _struct$1, pv, err, _slice$1, _index$1, _tuple$1, s, ok, err$1, _struct$2, _slice$2, _index$2, c, _ref, _ref$1, _struct$3, value, _ref$2, _struct$4, _tuple$2, s$1, ok$1, _ref$3, b, _tuple$3, n, err$2, _struct$5, _struct$6, s$2, _ref$4, _tuple$4, n$1, err$3, _struct$7, _tuple$5, n$2, err$4, _tuple$6, n$3, err$5, _tuple$7, n$4, err$6;
		d = this;
		if (item.length === 0) {
			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
			return;
		}
		wantptr = (_slice = item, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 110;
		_tuple = d.indirect((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), wantptr), u = _tuple[0], ut = _tuple[1], pv = (_struct$1 = _tuple[2], new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(go$interfaceIsEqual(u, null))) {
			err = u.UnmarshalJSON(item);
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			return;
		}
		if (!(go$interfaceIsEqual(ut, null))) {
			if (!(((_slice$1 = item, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 34))) {
				if (fromQuoted) {
					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
				}
			}
			_tuple$1 = unquoteBytes(item), s = _tuple$1[0], ok = _tuple$1[1];
			if (!ok) {
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(errPhase);
				}
			}
			err$1 = ut.UnmarshalText(s);
			if (!(go$interfaceIsEqual(err$1, null))) {
				d.error(err$1);
			}
			return;
		}
		v = (_struct$2 = pv, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		c = (_slice$2 = item, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
		_ref = c;
		if (_ref === 110) {
			_ref$1 = v.Kind();
			if (_ref$1 === 20 || _ref$1 === 22 || _ref$1 === 21 || _ref$1 === 23) {
				v.Set((_struct$3 = reflect.Zero(v.Type()), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
			}
		} else if (_ref === 116 || _ref === 102) {
			value = c === 116;
			_ref$2 = v.Kind();
			if (_ref$2 === 1) {
				v.SetBool(value);
			} else if (_ref$2 === 20) {
				if (v.NumMethod() === 0) {
					v.Set((_struct$4 = reflect.ValueOf(new Go$Bool(value)), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("bool", v.Type()));
				}
			} else {
				if (fromQuoted) {
					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("bool", v.Type()));
				}
			}
		} else if (_ref === 34) {
			_tuple$2 = unquoteBytes(item), s$1 = _tuple$2[0], ok$1 = _tuple$2[1];
			if (!ok$1) {
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(errPhase);
				}
			}
			_ref$3 = v.Kind();
			switch (0) { default: if (_ref$3 === 23) {
				if (!(go$interfaceIsEqual(v.Type(), byteSliceType))) {
					d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
					break;
				}
				b = (go$sliceType(Go$Uint8)).make(base64.StdEncoding.DecodedLen(s$1.length), 0, function() { return 0; });
				_tuple$3 = base64.StdEncoding.Decode(b, s$1), n = _tuple$3[0], err$2 = _tuple$3[1];
				if (!(go$interfaceIsEqual(err$2, null))) {
					d.saveError(err$2);
					break;
				}
				v.Set((_struct$5 = reflect.ValueOf(go$subslice(b, 0, n)), new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)));
			} else if (_ref$3 === 24) {
				v.SetString(go$bytesToString(s$1));
			} else if (_ref$3 === 20) {
				if (v.NumMethod() === 0) {
					v.Set((_struct$6 = reflect.ValueOf(new Go$String(go$bytesToString(s$1))), new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
				}
			} else {
				d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
			} }
		} else {
			if (!((c === 45)) && (c < 48 || c > 57)) {
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(errPhase);
				}
			}
			s$2 = go$bytesToString(item);
			_ref$4 = v.Kind();
			switch (0) { default: if (_ref$4 === 20) {
				_tuple$4 = d.convertNumber(s$2), n$1 = _tuple$4[0], err$3 = _tuple$4[1];
				if (!(go$interfaceIsEqual(err$3, null))) {
					d.saveError(err$3);
					break;
				}
				if (!((v.NumMethod() === 0))) {
					d.saveError(new UnmarshalTypeError.Ptr("number", v.Type()));
					break;
				}
				v.Set((_struct$7 = reflect.ValueOf(n$1), new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)));
			} else if (_ref$4 === 2 || _ref$4 === 3 || _ref$4 === 4 || _ref$4 === 5 || _ref$4 === 6) {
				_tuple$5 = strconv.ParseInt(s$2, 10, 64), n$2 = _tuple$5[0], err$4 = _tuple$5[1];
				if (!(go$interfaceIsEqual(err$4, null)) || v.OverflowInt(n$2)) {
					d.saveError(new UnmarshalTypeError.Ptr("number " + s$2, v.Type()));
					break;
				}
				v.SetInt(n$2);
			} else if (_ref$4 === 7 || _ref$4 === 8 || _ref$4 === 9 || _ref$4 === 10 || _ref$4 === 11 || _ref$4 === 12) {
				_tuple$6 = strconv.ParseUint(s$2, 10, 64), n$3 = _tuple$6[0], err$5 = _tuple$6[1];
				if (!(go$interfaceIsEqual(err$5, null)) || v.OverflowUint(n$3)) {
					d.saveError(new UnmarshalTypeError.Ptr("number " + s$2, v.Type()));
					break;
				}
				v.SetUint(n$3);
			} else if (_ref$4 === 13 || _ref$4 === 14) {
				_tuple$7 = strconv.ParseFloat(s$2, v.Type().Bits()), n$4 = _tuple$7[0], err$6 = _tuple$7[1];
				if (!(go$interfaceIsEqual(err$6, null)) || v.OverflowFloat(n$4)) {
					d.saveError(new UnmarshalTypeError.Ptr("number " + s$2, v.Type()));
					break;
				}
				v.SetFloat(n$4);
			} else {
				if ((v.Kind() === 24) && go$interfaceIsEqual(v.Type(), numberType)) {
					v.SetString(s$2);
					break;
				}
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(new UnmarshalTypeError.Ptr("number", v.Type()));
				}
			} }
		}
	};
	decodeState.prototype.literalStore = function(item, v, fromQuoted) { return this.go$val.literalStore(item, v, fromQuoted); };
	decodeState.Ptr.prototype.valueInterface = function() {
		var d, _ref;
		d = this;
		_ref = d.scanWhile(9);
		if (_ref === 6) {
			return d.arrayInterface();
		} else if (_ref === 2) {
			return new (go$mapType(Go$String, go$emptyInterface))(d.objectInterface());
		} else if (_ref === 1) {
			return d.literalInterface();
		} else {
			d.error(errPhase);
			throw go$panic(new Go$String("unreachable"));
		}
	};
	decodeState.prototype.valueInterface = function() { return this.go$val.valueInterface(); };
	decodeState.Ptr.prototype.arrayInterface = function() {
		var d, v, op;
		d = this;
		v = (go$sliceType(go$emptyInterface)).make(0, 0, function() { return null; });
		while (true) {
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			d.off = d.off - 1 >> 0;
			d.scan.undo(op);
			v = go$append(v, d.valueInterface());
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			if (!((op === 7))) {
				d.error(errPhase);
			}
		}
		return v;
	};
	decodeState.prototype.arrayInterface = function() { return this.go$val.arrayInterface(); };
	decodeState.Ptr.prototype.objectInterface = function() {
		var d, m, op, start, item, _tuple, key, ok, _key;
		d = this;
		m = new Go$Map();
		while (true) {
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 1))) {
				d.error(errPhase);
			}
			start = d.off - 1 >> 0;
			op = d.scanWhile(0);
			item = go$subslice(d.data, start, (d.off - 1 >> 0));
			_tuple = unquote(item), key = _tuple[0], ok = _tuple[1];
			if (!ok) {
				d.error(errPhase);
			}
			if (op === 9) {
				op = d.scanWhile(9);
			}
			if (!((op === 3))) {
				d.error(errPhase);
			}
			_key = key, (m || go$throwRuntimeError("assignment to entry in nil map"))[_key] = { k: _key, v: d.valueInterface() };
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 4))) {
				d.error(errPhase);
			}
		}
		return m;
	};
	decodeState.prototype.objectInterface = function() { return this.go$val.objectInterface(); };
	decodeState.Ptr.prototype.literalInterface = function() {
		var d, start, op, item, _slice, _index, c, _ref, _tuple, s, ok, _tuple$1, n, err;
		d = this;
		start = d.off - 1 >> 0;
		op = d.scanWhile(0);
		d.off = d.off - 1 >> 0;
		d.scan.undo(op);
		item = go$subslice(d.data, start, d.off);
		c = (_slice = item, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		_ref = c;
		if (_ref === 110) {
			return null;
		} else if (_ref === 116 || _ref === 102) {
			return new Go$Bool((c === 116));
		} else if (_ref === 34) {
			_tuple = unquote(item), s = _tuple[0], ok = _tuple[1];
			if (!ok) {
				d.error(errPhase);
			}
			return new Go$String(s);
		} else {
			if (!((c === 45)) && (c < 48 || c > 57)) {
				d.error(errPhase);
			}
			_tuple$1 = d.convertNumber(go$bytesToString(item)), n = _tuple$1[0], err = _tuple$1[1];
			if (!(go$interfaceIsEqual(err, null))) {
				d.saveError(err);
			}
			return n;
		}
	};
	decodeState.prototype.literalInterface = function() { return this.go$val.literalInterface(); };
	var getu4 = function(s) {
		var _slice, _index, _slice$1, _index$1, _tuple, r, err;
		if (s.length < 6 || !(((_slice = s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 92)) || !(((_slice$1 = s, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 117))) {
			return -1;
		}
		_tuple = strconv.ParseUint(go$bytesToString(go$subslice(s, 2, 6)), 16, 64), r = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return -1;
		}
		return (r.low >> 0);
	};
	var unquote = function(s) {
		var t, ok, _tuple;
		t = "";
		ok = false;
		_tuple = unquoteBytes(s), s = _tuple[0], ok = _tuple[1];
		t = go$bytesToString(s);
		return [t, ok];
	};
	var unquoteBytes = function(s) {
		var t, ok, _slice, _index, _slice$1, _index$1, r, _slice$2, _index$2, c, _tuple, rr, size, _tuple$1, b, w, x, x$1, nb, _slice$3, _index$3, c$1, _ref, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10, _slice$11, _index$11, rr$1, rr1, dec, _slice$12, _index$12, _tuple$2, rr$2, size$1, _tuple$3;
		t = (go$sliceType(Go$Uint8)).nil;
		ok = false;
		if (s.length < 2 || !(((_slice = s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 34)) || !(((_slice$1 = s, _index$1 = (s.length - 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 34))) {
			return [t, ok];
		}
		s = go$subslice(s, 1, (s.length - 1 >> 0));
		r = 0;
		while (r < s.length) {
			c = (_slice$2 = s, _index$2 = r, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			if ((c === 92) || (c === 34) || c < 32) {
				break;
			}
			if (c < 128) {
				r = r + 1 >> 0;
				continue;
			}
			_tuple = utf8.DecodeRune(go$subslice(s, r)), rr = _tuple[0], size = _tuple[1];
			if ((rr === 65533) && (size === 1)) {
				break;
			}
			r = r + (size) >> 0;
		}
		if (r === s.length) {
			_tuple$1 = [s, true], t = _tuple$1[0], ok = _tuple$1[1];
			return [t, ok];
		}
		b = (go$sliceType(Go$Uint8)).make(s.length + 8 >> 0, 0, function() { return 0; });
		w = go$copySlice(b, go$subslice(s, 0, r));
		while (r < s.length) {
			if (w >= (b.length - 8 >> 0)) {
				nb = (go$sliceType(Go$Uint8)).make((x = (b.length + 4 >> 0), x$1 = 2, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0), 0, function() { return 0; });
				go$copySlice(nb, go$subslice(b, 0, w));
				b = nb;
			}
			c$1 = (_slice$3 = s, _index$3 = r, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			if (c$1 === 92) {
				r = r + 1 >> 0;
				if (r >= s.length) {
					return [t, ok];
				}
				_ref = (_slice$4 = s, _index$4 = r, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
				switch (0) { default: if (_ref === 34 || _ref === 92 || _ref === 47 || _ref === 39) {
					_slice$6 = b, _index$6 = w, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = (_slice$5 = s, _index$5 = r, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"))) : go$throwRuntimeError("index out of range");
					r = r + 1 >> 0;
					w = w + 1 >> 0;
				} else if (_ref === 98) {
					_slice$7 = b, _index$7 = w, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = 8) : go$throwRuntimeError("index out of range");
					r = r + 1 >> 0;
					w = w + 1 >> 0;
				} else if (_ref === 102) {
					_slice$8 = b, _index$8 = w, (_index$8 >= 0 && _index$8 < _slice$8.length) ? (_slice$8.array[_slice$8.offset + _index$8] = 12) : go$throwRuntimeError("index out of range");
					r = r + 1 >> 0;
					w = w + 1 >> 0;
				} else if (_ref === 110) {
					_slice$9 = b, _index$9 = w, (_index$9 >= 0 && _index$9 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$9] = 10) : go$throwRuntimeError("index out of range");
					r = r + 1 >> 0;
					w = w + 1 >> 0;
				} else if (_ref === 114) {
					_slice$10 = b, _index$10 = w, (_index$10 >= 0 && _index$10 < _slice$10.length) ? (_slice$10.array[_slice$10.offset + _index$10] = 13) : go$throwRuntimeError("index out of range");
					r = r + 1 >> 0;
					w = w + 1 >> 0;
				} else if (_ref === 116) {
					_slice$11 = b, _index$11 = w, (_index$11 >= 0 && _index$11 < _slice$11.length) ? (_slice$11.array[_slice$11.offset + _index$11] = 9) : go$throwRuntimeError("index out of range");
					r = r + 1 >> 0;
					w = w + 1 >> 0;
				} else if (_ref === 117) {
					r = r - 1 >> 0;
					rr$1 = getu4(go$subslice(s, r));
					if (rr$1 < 0) {
						return [t, ok];
					}
					r = r + 6 >> 0;
					if (utf16.IsSurrogate(rr$1)) {
						rr1 = getu4(go$subslice(s, r));
						if (dec = utf16.DecodeRune(rr$1, rr1), !((dec === 65533))) {
							r = r + 6 >> 0;
							w = w + (utf8.EncodeRune(go$subslice(b, w), dec)) >> 0;
							break;
						}
						rr$1 = 65533;
					}
					w = w + (utf8.EncodeRune(go$subslice(b, w), rr$1)) >> 0;
				} else {
					return [t, ok];
				} }
			} else if (c$1 === 34 || c$1 < 32) {
				return [t, ok];
			} else if (c$1 < 128) {
				_slice$12 = b, _index$12 = w, (_index$12 >= 0 && _index$12 < _slice$12.length) ? (_slice$12.array[_slice$12.offset + _index$12] = c$1) : go$throwRuntimeError("index out of range");
				r = r + 1 >> 0;
				w = w + 1 >> 0;
			} else {
				_tuple$2 = utf8.DecodeRune(go$subslice(s, r)), rr$2 = _tuple$2[0], size$1 = _tuple$2[1];
				r = r + (size$1) >> 0;
				w = w + (utf8.EncodeRune(go$subslice(b, w), rr$2)) >> 0;
			}
		}
		_tuple$3 = [go$subslice(b, 0, w), true], t = _tuple$3[0], ok = _tuple$3[1];
		return [t, ok];
	};
	var Marshal = go$pkg.Marshal = function(v) {
		var e, err;
		e = new encodeState.Ptr(new bytes.Buffer.Ptr(), go$makeNativeArray("Uint8", 64, function() { return 0; }));
		err = e.marshal(v);
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(Go$Uint8)).nil, err];
		}
		return [e.Buffer.Bytes(), null];
	};
	var MarshalIndent = go$pkg.MarshalIndent = function(v, prefix, indent) {
		var _tuple, b, err, buf;
		_tuple = Marshal(v), b = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(Go$Uint8)).nil, err];
		}
		buf = new bytes.Buffer.Ptr();
		err = Indent(buf, b, prefix, indent);
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(Go$Uint8)).nil, err];
		}
		return [buf.Bytes(), null];
	};
	var HTMLEscape = go$pkg.HTMLEscape = function(dst, src) {
		var start, _ref, _i, _slice, _index, c, i, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		start = 0;
		_ref = src;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if ((c === 60) || (c === 62) || (c === 38)) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u00");
				dst.WriteByte(hex.charCodeAt((c >>> 4 << 24 >>> 24)));
				dst.WriteByte(hex.charCodeAt(((c & 15) >>> 0)));
				start = i + 1 >> 0;
			}
			if ((c === 226) && (i + 2 >> 0) < src.length && ((_slice$1 = src, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 128) && (((_slice$2 = src, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) & ~1) === 168)) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u202");
				dst.WriteByte(hex.charCodeAt((((_slice$3 = src, _index$3 = (i + 2 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) & 15) >>> 0)));
				start = i + 3 >> 0;
			}
			_i++;
		}
		if (start < src.length) {
			dst.Write(go$subslice(src, start));
		}
	};
	UnsupportedTypeError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: unsupported type: " + e.Type.String();
	};
	UnsupportedTypeError.prototype.Error = function() { return this.go$val.Error(); };
	UnsupportedValueError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: unsupported value: " + e.Str;
	};
	UnsupportedValueError.prototype.Error = function() { return this.go$val.Error(); };
	InvalidUTF8Error.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: invalid UTF-8 in string: " + strconv.Quote(e.S);
	};
	InvalidUTF8Error.prototype.Error = function() { return this.go$val.Error(); };
	MarshalerError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: error calling MarshalJSON for type " + e.Type.String() + ": " + e.Err.Error();
	};
	MarshalerError.prototype.Error = function() { return this.go$val.Error(); };
	var newEncodeState = function() {
			var e = encodeStates.pop();
			if (e !== undefined) {
				e.Reset();
				return e;
			}
			return new encodeState.Ptr();
		};
	var putEncodeState = function(e) {
			encodeStates.push(e);
		};
	encodeState.Ptr.prototype.marshal = function(v) {
		var err, e, _struct;
		err = null;
		var go$deferred = [];
		try {
			e = this;
			go$deferred.push({ fun: (function() {
				var r, ok, _tuple, ok$1, _tuple$1, s;
				if (r = go$recover(), !(go$interfaceIsEqual(r, null))) {
					if (_tuple = (r !== null && runtime.Error.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), ok = _tuple[1], ok) {
						throw go$panic(r);
					}
					if (_tuple$1 = (r !== null && r.constructor === Go$String ? [r.go$val, true] : ["", false]), s = _tuple$1[0], ok$1 = _tuple$1[1], ok$1) {
						throw go$panic(new Go$String(s));
					}
					err = (r !== null && go$error.implementedBy.indexOf(r.constructor) !== -1 ? r : go$typeAssertionFailed(r, go$error));
				}
			}), args: [] });
			e.reflectValue((_struct = reflect.ValueOf(v), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
			err = null;
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	encodeState.prototype.marshal = function(v) { return this.go$val.marshal(v); };
	encodeState.Ptr.prototype.error = function(err) {
		var e;
		e = this;
		throw go$panic(err);
	};
	encodeState.prototype.error = function(err) { return this.go$val.error(err); };
	var isEmptyValue = function(v) {
		var _ref, x, x$1;
		_ref = v.Kind();
		if (_ref === 17 || _ref === 21 || _ref === 23 || _ref === 24) {
			return v.Len() === 0;
		} else if (_ref === 1) {
			return !v.Bool();
		} else if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			return (x = v.Int(), (x.high === 0 && x.low === 0));
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			return (x$1 = v.Uint(), (x$1.high === 0 && x$1.low === 0));
		} else if (_ref === 13 || _ref === 14) {
			return v.Float() === 0;
		} else if (_ref === 20 || _ref === 22) {
			return v.IsNil();
		}
		return false;
	};
	encodeState.Ptr.prototype.reflectValue = function(v) {
		var e, _struct, _struct$1;
		e = this;
		valueEncoder((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)))(e, (_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), false);
	};
	encodeState.prototype.reflectValue = function(v) { return this.go$val.reflectValue(v); };
	var valueEncoder = function(v) {
		if (!v.IsValid()) {
			return invalidValueEncoder;
		}
		return typeEncoder(v.Type());
	};
	var typeEncoder = function(t) {
		var _entry, f, wg, _key, _key$1;
		encoderCache.RWMutex.RLock();
		f = (_entry = encoderCache.m[(t || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : go$throwNilPointerError);
		encoderCache.RWMutex.RUnlock();
		if (!(f === go$throwNilPointerError)) {
			return f;
		}
		encoderCache.RWMutex.Lock();
		if (encoderCache.m === false) {
			encoderCache.m = new Go$Map();
		}
		wg = new sync.WaitGroup.Ptr();
		wg.Add(1);
		_key = t, (encoderCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(_key || go$interfaceNil).go$key()] = { k: _key, v: (function(e, v, quoted) {
			var _struct;
			wg.Wait();
			f(e, (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), quoted);
		}) };
		encoderCache.RWMutex.Unlock();
		f = newTypeEncoder(t, true);
		wg.Done();
		encoderCache.RWMutex.Lock();
		_key$1 = t, (encoderCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(_key$1 || go$interfaceNil).go$key()] = { k: _key$1, v: f };
		encoderCache.RWMutex.Unlock();
		return f;
	};
	var newTypeEncoder = function(t, allowAddr) {
		var _ref;
		if (t.Implements(marshalerType)) {
			return marshalerEncoder;
		}
		if (!((t.Kind() === 22)) && allowAddr) {
			if (reflect.PtrTo(t).Implements(marshalerType)) {
				return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false));
			}
		}
		if (t.Implements(textMarshalerType)) {
			return textMarshalerEncoder;
		}
		if (!((t.Kind() === 22)) && allowAddr) {
			if (reflect.PtrTo(t).Implements(textMarshalerType)) {
				return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false));
			}
		}
		_ref = t.Kind();
		if (_ref === 1) {
			return boolEncoder;
		} else if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			return intEncoder;
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			return uintEncoder;
		} else if (_ref === 13) {
			return float32Encoder;
		} else if (_ref === 14) {
			return float64Encoder;
		} else if (_ref === 24) {
			return stringEncoder;
		} else if (_ref === 20) {
			return interfaceEncoder;
		} else if (_ref === 25) {
			return newStructEncoder(t);
		} else if (_ref === 21) {
			return newMapEncoder(t);
		} else if (_ref === 23) {
			return newSliceEncoder(t);
		} else if (_ref === 17) {
			return newArrayEncoder(t);
		} else if (_ref === 22) {
			return newPtrEncoder(t);
		} else {
			return unsupportedTypeEncoder;
		}
	};
	var invalidValueEncoder = function(e, v, quoted) {
		e.Buffer.WriteString("null");
	};
	var marshalerEncoder = function(e, v, quoted) {
		var x, m, _tuple, b, err;
		if ((v.Kind() === 22) && v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = v.Interface(), (x !== null && Marshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, Marshaler)));
		_tuple = m.MarshalJSON(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			err = compact(e.Buffer, b, true);
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
	var addrMarshalerEncoder = function(e, v, quoted) {
		var _struct, va, x, m, _tuple, b, err;
		va = (_struct = v.Addr(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (va.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = va.Interface(), (x !== null && Marshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, Marshaler)));
		_tuple = m.MarshalJSON(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			err = compact(e.Buffer, b, true);
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
	var textMarshalerEncoder = function(e, v, quoted) {
		var x, m, _tuple, b, err, _tuple$1;
		if ((v.Kind() === 22) && v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = v.Interface(), (x !== null && encoding.TextMarshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, encoding.TextMarshaler)));
		_tuple = m.MarshalText(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			_tuple$1 = e.stringBytes(b), err = _tuple$1[1];
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
	var addrTextMarshalerEncoder = function(e, v, quoted) {
		var _struct, va, x, m, _tuple, b, err, _tuple$1;
		va = (_struct = v.Addr(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (va.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = va.Interface(), (x !== null && encoding.TextMarshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, encoding.TextMarshaler)));
		_tuple = m.MarshalText(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			_tuple$1 = e.stringBytes(b), err = _tuple$1[1];
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
	var boolEncoder = function(e, v, quoted) {
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		if (v.Bool()) {
			e.Buffer.WriteString("true");
		} else {
			e.Buffer.WriteString("false");
		}
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	var intEncoder = function(e, v, quoted) {
		var b;
		b = strconv.AppendInt(go$subslice(new (go$sliceType(Go$Uint8))(e.scratch), 0, 0), v.Int(), 10);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	var uintEncoder = function(e, v, quoted) {
		var b;
		b = strconv.AppendUint(go$subslice(new (go$sliceType(Go$Uint8))(e.scratch), 0, 0), v.Uint(), 10);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	floatEncoder.prototype.encode = function(e, v, quoted) {
		var bits, f, _struct, b;
		bits = this.go$val;
		f = v.Float();
		if (math.IsInf(f, 0) || math.IsNaN(f)) {
			e.error(new UnsupportedValueError.Ptr((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), strconv.FormatFloat(f, 103, -1, (bits >> 0))));
		}
		b = strconv.AppendFloat(go$subslice(new (go$sliceType(Go$Uint8))(e.scratch), 0, 0), f, 103, -1, (bits >> 0));
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	go$ptrType(floatEncoder).prototype.encode = function(e, v, quoted) { return new floatEncoder(this.go$get()).encode(e, v, quoted); };
	var stringEncoder = function(e, v, quoted) {
		var numStr, _tuple, sb, err;
		if (go$interfaceIsEqual(v.Type(), numberType)) {
			numStr = v.String();
			if (numStr === "") {
				numStr = "0";
			}
			e.Buffer.WriteString(numStr);
			return;
		}
		if (quoted) {
			_tuple = Marshal(new Go$String(v.String())), sb = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				e.error(err);
			}
			e.string(go$bytesToString(sb));
		} else {
			e.string(v.String());
		}
	};
	var interfaceEncoder = function(e, v, quoted) {
		var _struct;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		e.reflectValue((_struct = v.Elem(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
	};
	var unsupportedTypeEncoder = function(e, v, quoted) {
		e.error(new UnsupportedTypeError.Ptr(v.Type()));
	};
	structEncoder.Ptr.prototype.encode = function(e, v, quoted) {
		var se, first, _ref, _i, _slice, _index, _struct, f, i, _struct$1, _struct$2, fv, _struct$3, _slice$1, _index$1, _struct$4;
		se = this;
		e.Buffer.WriteByte(123);
		first = true;
		_ref = se.fields;
		_i = 0;
		while (_i < _ref.length) {
			f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
			i = _i;
			fv = (_struct$2 = fieldByIndex((_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), f.index), new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
			if (!fv.IsValid() || f.omitEmpty && isEmptyValue((_struct$3 = fv, new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)))) {
				_i++;
				continue;
			}
			if (first) {
				first = false;
			} else {
				e.Buffer.WriteByte(44);
			}
			e.string(f.name);
			e.Buffer.WriteByte(58);
			(_slice$1 = se.fieldEncs, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))(e, (_struct$4 = fv, new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), f.quoted);
			_i++;
		}
		e.Buffer.WriteByte(125);
	};
	structEncoder.prototype.encode = function(e, v, quoted) { return this.go$val.encode(e, v, quoted); };
	var newStructEncoder = function(t) {
		var fields, se, _ref, _i, _slice, _index, _struct, f, i, _slice$1, _index$1, e, v, quoted, _recv;
		fields = cachedTypeFields(t);
		se = new structEncoder.Ptr(fields, (go$sliceType(encoderFunc)).make(fields.length, 0, function() { return go$throwNilPointerError; }));
		_ref = fields;
		_i = 0;
		while (_i < _ref.length) {
			f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
			i = _i;
			_slice$1 = se.fieldEncs, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = typeEncoder(typeByIndex(t, f.index))) : go$throwRuntimeError("index out of range");
			_i++;
		}
		return (_recv = se, function(e, v, quoted) { return _recv.encode(e, v, quoted); });
	};
	mapEncoder.Ptr.prototype.encode = function(e, v, param) {
		var me, x, sv, _ref, _i, _slice, _index, _struct, k, i, _struct$1, _struct$2;
		me = this;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		e.Buffer.WriteByte(123);
		sv = (x = v.MapKeys(), go$subslice(new stringValues(x.array), x.offset, x.offset + x.length));
		sort.Sort(sv);
		_ref = sv;
		_i = 0;
		while (_i < _ref.length) {
			k = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			i = _i;
			if (i > 0) {
				e.Buffer.WriteByte(44);
			}
			e.string(k.String());
			e.Buffer.WriteByte(58);
			me.elemEnc(e, (_struct$2 = v.MapIndex((_struct$1 = k, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))), new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), false);
			_i++;
		}
		e.Buffer.WriteByte(125);
	};
	mapEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
	var newMapEncoder = function(t) {
		var me, e, v, _, _recv;
		if (!((t.Key().Kind() === 24))) {
			return unsupportedTypeEncoder;
		}
		me = new mapEncoder.Ptr(typeEncoder(t.Elem()));
		return (_recv = me, function(e, v, _) { return _recv.encode(e, v, _); });
	};
	var encodeByteSlice = function(e, v, param) {
		var s, dst, enc;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		s = v.Bytes();
		e.Buffer.WriteByte(34);
		if (s.length < 1024) {
			dst = (go$sliceType(Go$Uint8)).make(base64.StdEncoding.EncodedLen(s.length), 0, function() { return 0; });
			base64.StdEncoding.Encode(dst, s);
			e.Buffer.Write(dst);
		} else {
			enc = base64.NewEncoder(base64.StdEncoding, e);
			enc.Write(s);
			enc.Close();
		}
		e.Buffer.WriteByte(34);
	};
	sliceEncoder.Ptr.prototype.encode = function(e, v, param) {
		var se, _struct;
		se = this;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		se.arrayEnc(e, (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
	};
	sliceEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
	var newSliceEncoder = function(t) {
		var enc, e, v, _, _recv;
		if (t.Elem().Kind() === 8) {
			return encodeByteSlice;
		}
		enc = new sliceEncoder.Ptr(newArrayEncoder(t));
		return (_recv = enc, function(e, v, _) { return _recv.encode(e, v, _); });
	};
	arrayEncoder.Ptr.prototype.encode = function(e, v, param) {
		var ae, n, i, _struct;
		ae = this;
		e.Buffer.WriteByte(91);
		n = v.Len();
		i = 0;
		while (i < n) {
			if (i > 0) {
				e.Buffer.WriteByte(44);
			}
			ae.elemEnc(e, (_struct = v.Index(i), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
			i = i + 1 >> 0;
		}
		e.Buffer.WriteByte(93);
	};
	arrayEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
	var newArrayEncoder = function(t) {
		var enc, e, v, _, _recv;
		enc = new arrayEncoder.Ptr(typeEncoder(t.Elem()));
		return (_recv = enc, function(e, v, _) { return _recv.encode(e, v, _); });
	};
	ptrEncoder.Ptr.prototype.encode = function(e, v, param) {
		var pe, _struct;
		pe = this;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		pe.elemEnc(e, (_struct = v.Elem(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
	};
	ptrEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
	var newPtrEncoder = function(t) {
		var enc, e, v, _, _recv;
		enc = new ptrEncoder.Ptr(typeEncoder(t.Elem()));
		return (_recv = enc, function(e, v, _) { return _recv.encode(e, v, _); });
	};
	condAddrEncoder.Ptr.prototype.encode = function(e, v, quoted) {
		var ce, _struct, _struct$1;
		ce = this;
		if (v.CanAddr()) {
			ce.canAddrEnc(e, (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), quoted);
		} else {
			ce.elseEnc(e, (_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), quoted);
		}
	};
	condAddrEncoder.prototype.encode = function(e, v, quoted) { return this.go$val.encode(e, v, quoted); };
	var newCondAddrEncoder = function(canAddrEnc, elseEnc) {
		var enc, e, v, quoted, _recv;
		enc = new condAddrEncoder.Ptr(canAddrEnc, elseEnc);
		return (_recv = enc, function(e, v, quoted) { return _recv.encode(e, v, quoted); });
	};
	var isValidTag = function(s) {
		var _ref, _i, _rune, c;
		if (s === "") {
			return false;
		}
		_ref = s;
		_i = 0;
		while (_i < _ref.length) {
			_rune = go$decodeRune(_ref, _i);
			c = _rune[0];
			if (strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c)) {
			} else {
				if (!unicode.IsLetter(c) && !unicode.IsDigit(c)) {
					return false;
				}
			}
			_i += _rune[1];
		}
		return true;
	};
	var fieldByIndex = function(v, index) {
		var _ref, _i, _slice, _index, i, _struct, _struct$1, _struct$2;
		_ref = index;
		_i = 0;
		while (_i < _ref.length) {
			i = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (v.Kind() === 22) {
				if (v.IsNil()) {
					return new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0);
				}
				v = (_struct = v.Elem(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			}
			v = (_struct$1 = v.Field(i), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
			_i++;
		}
		return (_struct$2 = v, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
	};
	var typeByIndex = function(t, index) {
		var _ref, _i, _slice, _index, i;
		_ref = index;
		_i = 0;
		while (_i < _ref.length) {
			i = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (t.Kind() === 22) {
				t = t.Elem();
			}
			t = t.Field(i).Type;
			_i++;
		}
		return t;
	};
	stringValues.prototype.Len = function() {
		var sv;
		sv = this;
		return sv.length;
	};
	go$ptrType(stringValues).prototype.Len = function() { return this.go$get().Len(); };
	stringValues.prototype.Swap = function(i, j) {
		var sv, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		sv = this;
		_tuple = [(_struct = (_slice = sv, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), (_struct$1 = (_slice$1 = sv, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))], _slice$2 = sv, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = sv, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(stringValues).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
	stringValues.prototype.Less = function(i, j) {
		var sv;
		sv = this;
		return sv.get(i) < sv.get(j);
	};
	go$ptrType(stringValues).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
	stringValues.prototype.get = function(i) {
		var sv, _slice, _index;
		sv = this;
		return (_slice = sv, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).String();
	};
	go$ptrType(stringValues).prototype.get = function(i) { return this.go$get().get(i); };
	encodeState.Ptr.prototype.string = function(s) {
		var e, len0, start, i, b, _ref, _tuple, c, size;
		e = this;
		len0 = e.Buffer.Len();
		e.Buffer.WriteByte(34);
		start = 0;
		i = 0;
		while (i < s.length) {
			if (b = s.charCodeAt(i), b < 128) {
				if (32 <= b && !((b === 92)) && !((b === 34)) && !((b === 60)) && !((b === 62)) && !((b === 38))) {
					i = i + 1 >> 0;
					continue;
				}
				if (start < i) {
					e.Buffer.WriteString(s.substring(start, i));
				}
				_ref = b;
				if (_ref === 92 || _ref === 34) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(b);
				} else if (_ref === 10) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(110);
				} else if (_ref === 13) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(114);
				} else {
					e.Buffer.WriteString("\\u00");
					e.Buffer.WriteByte(hex.charCodeAt((b >>> 4 << 24 >>> 24)));
					e.Buffer.WriteByte(hex.charCodeAt(((b & 15) >>> 0)));
				}
				i = i + 1 >> 0;
				start = i;
				continue;
			}
			_tuple = utf8.DecodeRuneInString(s.substring(i)), c = _tuple[0], size = _tuple[1];
			if ((c === 65533) && (size === 1)) {
				if (start < i) {
					e.Buffer.WriteString(s.substring(start, i));
				}
				e.Buffer.WriteString("\\ufffd");
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			if ((c === 8232) || (c === 8233)) {
				if (start < i) {
					e.Buffer.WriteString(s.substring(start, i));
				}
				e.Buffer.WriteString("\\u202");
				e.Buffer.WriteByte(hex.charCodeAt((c & 15)));
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			i = i + (size) >> 0;
		}
		if (start < s.length) {
			e.Buffer.WriteString(s.substring(start));
		}
		e.Buffer.WriteByte(34);
		return [e.Buffer.Len() - len0 >> 0, null];
	};
	encodeState.prototype.string = function(s) { return this.go$val.string(s); };
	encodeState.Ptr.prototype.stringBytes = function(s) {
		var e, len0, start, i, b, _slice, _index, _ref, _tuple, c, size;
		e = this;
		len0 = e.Buffer.Len();
		e.Buffer.WriteByte(34);
		start = 0;
		i = 0;
		while (i < s.length) {
			if (b = (_slice = s, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), b < 128) {
				if (32 <= b && !((b === 92)) && !((b === 34)) && !((b === 60)) && !((b === 62)) && !((b === 38))) {
					i = i + 1 >> 0;
					continue;
				}
				if (start < i) {
					e.Buffer.Write(go$subslice(s, start, i));
				}
				_ref = b;
				if (_ref === 92 || _ref === 34) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(b);
				} else if (_ref === 10) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(110);
				} else if (_ref === 13) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(114);
				} else {
					e.Buffer.WriteString("\\u00");
					e.Buffer.WriteByte(hex.charCodeAt((b >>> 4 << 24 >>> 24)));
					e.Buffer.WriteByte(hex.charCodeAt(((b & 15) >>> 0)));
				}
				i = i + 1 >> 0;
				start = i;
				continue;
			}
			_tuple = utf8.DecodeRune(go$subslice(s, i)), c = _tuple[0], size = _tuple[1];
			if ((c === 65533) && (size === 1)) {
				if (start < i) {
					e.Buffer.Write(go$subslice(s, start, i));
				}
				e.Buffer.WriteString("\\ufffd");
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			if ((c === 8232) || (c === 8233)) {
				if (start < i) {
					e.Buffer.Write(go$subslice(s, start, i));
				}
				e.Buffer.WriteString("\\u202");
				e.Buffer.WriteByte(hex.charCodeAt((c & 15)));
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			i = i + (size) >> 0;
		}
		if (start < s.length) {
			e.Buffer.Write(go$subslice(s, start));
		}
		e.Buffer.WriteByte(34);
		return [e.Buffer.Len() - len0 >> 0, null];
	};
	encodeState.prototype.stringBytes = function(s) { return this.go$val.stringBytes(s); };
	byName.prototype.Len = function() {
		var x;
		x = this;
		return x.length;
	};
	go$ptrType(byName).prototype.Len = function() { return this.go$get().Len(); };
	byName.prototype.Swap = function(i, j) {
		var x, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_struct = (_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted)), (_struct$1 = (_slice$1 = x, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$1.name, _struct$1.tag, _struct$1.index, _struct$1.typ, _struct$1.omitEmpty, _struct$1.quoted))], _slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byName).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
	byName.prototype.Less = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10;
		x = this;
		if (!((_slice = x, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).name === (_slice$1 = x, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).name)) {
			return (_slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).name < (_slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).name;
		}
		if (!(((_slice$4 = x, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).index.length === (_slice$5 = x, _index$5 = j, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).index.length))) {
			return (_slice$6 = x, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).index.length < (_slice$7 = x, _index$7 = j, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).index.length;
		}
		if (!((_slice$8 = x, _index$8 = i, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")).tag === (_slice$9 = x, _index$9 = j, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")).tag)) {
			return (_slice$10 = x, _index$10 = i, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")).tag;
		}
		return go$subslice(new byIndex(x.array), x.offset, x.offset + x.length).Less(i, j);
	};
	go$ptrType(byName).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
	byIndex.prototype.Len = function() {
		var x;
		x = this;
		return x.length;
	};
	go$ptrType(byIndex).prototype.Len = function() { return this.go$get().Len(); };
	byIndex.prototype.Swap = function(i, j) {
		var x, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_struct = (_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted)), (_struct$1 = (_slice$1 = x, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$1.name, _struct$1.tag, _struct$1.index, _struct$1.typ, _struct$1.omitEmpty, _struct$1.quoted))], _slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byIndex).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
	byIndex.prototype.Less = function(i, j) {
		var x, _ref, _slice, _index, _i, _slice$1, _index$1, xik, k, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8;
		x = this;
		_ref = (_slice = x, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).index;
		_i = 0;
		while (_i < _ref.length) {
			xik = (_slice$1 = _ref, _index$1 = _i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			k = _i;
			if (k >= (_slice$2 = x, _index$2 = j, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).index.length) {
				return false;
			}
			if (!((xik === (_slice$3 = (_slice$4 = x, _index$4 = j, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).index, _index$3 = k, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"))))) {
				return xik < (_slice$5 = (_slice$6 = x, _index$6 = j, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).index, _index$5 = k, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
			}
			_i++;
		}
		return (_slice$7 = x, _index$7 = i, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).index.length < (_slice$8 = x, _index$8 = j, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")).index.length;
	};
	go$ptrType(byIndex).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
	var typeFields = function(t) {
		var current, next, _map, _key, count, _map$1, _key$1, nextCount, _map$2, _key$2, visited, fields, _tuple, _map$3, _key$3, _tuple$1, _ref, _i, _slice, _index, _struct, f, _entry, _key$4, i, _struct$1, sf, tag, _tuple$2, name, opts, index, _slice$1, _index$1, ft, tagged, _entry$1, _slice$2, _index$2, _struct$2, _lhs, _index$3, _entry$2, _key$5, _entry$3, out, _tuple$3, advance, i$1, _slice$3, _index$4, _struct$3, fi, name$1, _slice$4, _index$5, _struct$4, fj, _struct$5, _tuple$4, _struct$6, dominant, ok, _struct$7;
		current = new (go$sliceType(field))([]);
		next = new (go$sliceType(field))([new field.Ptr("", false, (go$sliceType(Go$Int)).nil, t, false, false)]);
		count = (_map = new Go$Map(), _map);
		nextCount = (_map$1 = new Go$Map(), _map$1);
		visited = (_map$2 = new Go$Map(), _map$2);
		fields = (go$sliceType(field)).nil;
		while (next.length > 0) {
			_tuple = [next, go$subslice(current, 0, 0)], current = _tuple[0], next = _tuple[1];
			_tuple$1 = [nextCount, (_map$3 = new Go$Map(), _map$3)], count = _tuple$1[0], nextCount = _tuple$1[1];
			_ref = current;
			_i = 0;
			while (_i < _ref.length) {
				f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
				if ((_entry = visited[(f.typ || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : false)) {
					_i++;
					continue;
				}
				_key$4 = f.typ, (visited || go$throwRuntimeError("assignment to entry in nil map"))[(_key$4 || go$interfaceNil).go$key()] = { k: _key$4, v: true };
				i = 0;
				while (i < f.typ.NumField()) {
					sf = (_struct$1 = f.typ.Field(i), new reflect.StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous));
					if (!(sf.PkgPath === "")) {
						i = i + 1 >> 0;
						continue;
					}
					tag = (new reflect.StructTag(sf.Tag)).Get("json");
					if (tag === "-") {
						i = i + 1 >> 0;
						continue;
					}
					_tuple$2 = parseTag(tag), name = _tuple$2[0], opts = _tuple$2[1];
					if (!isValidTag(name)) {
						name = "";
					}
					index = (go$sliceType(Go$Int)).make(f.index.length + 1 >> 0, 0, function() { return 0; });
					go$copySlice(index, f.index);
					_slice$1 = index, _index$1 = f.index.length, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = i) : go$throwRuntimeError("index out of range");
					ft = sf.Type;
					if (ft.Name() === "" && (ft.Kind() === 22)) {
						ft = ft.Elem();
					}
					if (!(name === "") || !sf.Anonymous || !((ft.Kind() === 25))) {
						tagged = !(name === "");
						if (name === "") {
							name = sf.Name;
						}
						fields = go$append(fields, new field.Ptr(name, tagged, index, ft, (new tagOptions(opts)).Contains("omitempty"), (new tagOptions(opts)).Contains("string")));
						if ((_entry$1 = count[(f.typ || go$interfaceNil).go$key()], _entry$1 !== undefined ? _entry$1.v : 0) > 1) {
							fields = go$append(fields, (_struct$2 = (_slice$2 = fields, _index$2 = (fields.length - 1 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$2.name, _struct$2.tag, _struct$2.index, _struct$2.typ, _struct$2.omitEmpty, _struct$2.quoted)));
						}
						i = i + 1 >> 0;
						continue;
					}
					_lhs = nextCount, _index$3 = ft, _key$5 = _index$3, (_lhs || go$throwRuntimeError("assignment to entry in nil map"))[(_key$5 || go$interfaceNil).go$key()] = { k: _key$5, v: (_entry$2 = _lhs[(_index$3 || go$interfaceNil).go$key()], _entry$2 !== undefined ? _entry$2.v : 0) + 1 >> 0 };
					if ((_entry$3 = nextCount[(ft || go$interfaceNil).go$key()], _entry$3 !== undefined ? _entry$3.v : 0) === 1) {
						next = go$append(next, new field.Ptr(ft.Name(), false, index, ft, false, false));
					}
					i = i + 1 >> 0;
				}
				_i++;
			}
		}
		sort.Sort(go$subslice(new byName(fields.array), fields.offset, fields.offset + fields.length));
		out = go$subslice(fields, 0, 0);
		_tuple$3 = [0, 0], advance = _tuple$3[0], i$1 = _tuple$3[1];
		while (i$1 < fields.length) {
			fi = (_struct$3 = (_slice$3 = fields, _index$4 = i$1, (_index$4 >= 0 && _index$4 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$4] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$3.name, _struct$3.tag, _struct$3.index, _struct$3.typ, _struct$3.omitEmpty, _struct$3.quoted));
			name$1 = fi.name;
			advance = 1;
			while ((i$1 + advance >> 0) < fields.length) {
				fj = (_struct$4 = (_slice$4 = fields, _index$5 = (i$1 + advance >> 0), (_index$5 >= 0 && _index$5 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$5] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$4.name, _struct$4.tag, _struct$4.index, _struct$4.typ, _struct$4.omitEmpty, _struct$4.quoted));
				if (!(fj.name === name$1)) {
					break;
				}
				advance = advance + 1 >> 0;
			}
			if (advance === 1) {
				out = go$append(out, (_struct$5 = fi, new field.Ptr(_struct$5.name, _struct$5.tag, _struct$5.index, _struct$5.typ, _struct$5.omitEmpty, _struct$5.quoted)));
				i$1 = i$1 + (advance) >> 0;
				continue;
			}
			_tuple$4 = dominantField(go$subslice(fields, i$1, (i$1 + advance >> 0))), dominant = (_struct$6 = _tuple$4[0], new field.Ptr(_struct$6.name, _struct$6.tag, _struct$6.index, _struct$6.typ, _struct$6.omitEmpty, _struct$6.quoted)), ok = _tuple$4[1];
			if (ok) {
				out = go$append(out, (_struct$7 = dominant, new field.Ptr(_struct$7.name, _struct$7.tag, _struct$7.index, _struct$7.typ, _struct$7.omitEmpty, _struct$7.quoted)));
			}
			i$1 = i$1 + (advance) >> 0;
		}
		fields = out;
		sort.Sort(go$subslice(new byIndex(fields.array), fields.offset, fields.offset + fields.length));
		return fields;
	};
	var dominantField = function(fields) {
		var _slice, _index, length, tagged, _ref, _i, _slice$1, _index$1, _struct, f, i, _slice$2, _index$2, _struct$1, _slice$3, _index$3, _struct$2;
		length = (_slice = fields, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).index.length;
		tagged = -1;
		_ref = fields;
		_i = 0;
		while (_i < _ref.length) {
			f = (_struct = (_slice$1 = _ref, _index$1 = _i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
			i = _i;
			if (f.index.length > length) {
				fields = go$subslice(fields, 0, i);
				break;
			}
			if (f.tag) {
				if (tagged >= 0) {
					return [new field.Ptr("", false, (go$sliceType(Go$Int)).nil, null, false, false), false];
				}
				tagged = i;
			}
			_i++;
		}
		if (tagged >= 0) {
			return [(_struct$1 = (_slice$2 = fields, _index$2 = tagged, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$1.name, _struct$1.tag, _struct$1.index, _struct$1.typ, _struct$1.omitEmpty, _struct$1.quoted)), true];
		}
		if (fields.length > 1) {
			return [new field.Ptr("", false, (go$sliceType(Go$Int)).nil, null, false, false), false];
		}
		return [(_struct$2 = (_slice$3 = fields, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$2.name, _struct$2.tag, _struct$2.index, _struct$2.typ, _struct$2.omitEmpty, _struct$2.quoted)), true];
	};
	var cachedTypeFields = function(t) {
		var _entry, f, _map, _key, _key$1;
		fieldCache.RWMutex.RLock();
		f = (_entry = fieldCache.m[(t || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : (go$sliceType(field)).nil);
		fieldCache.RWMutex.RUnlock();
		if (!(f === (go$sliceType(field)).nil)) {
			return f;
		}
		f = typeFields(t);
		if (f === (go$sliceType(field)).nil) {
			f = new (go$sliceType(field))([]);
		}
		fieldCache.RWMutex.Lock();
		if (fieldCache.m === false) {
			fieldCache.m = (_map = new Go$Map(), _map);
		}
		_key$1 = t, (fieldCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(_key$1 || go$interfaceNil).go$key()] = { k: _key$1, v: f };
		fieldCache.RWMutex.Unlock();
		return f;
	};
	var Compact = go$pkg.Compact = function(dst, src) {
		return compact(dst, src, false);
	};
	var compact = function(dst, src, escape) {
		var origLen, scan, start, _ref, _i, _slice, _index, c, i, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, v;
		origLen = dst.Len();
		scan = new scanner.Ptr();
		scan.reset();
		start = 0;
		_ref = src;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (escape && ((c === 60) || (c === 62) || (c === 38))) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u00");
				dst.WriteByte(hex.charCodeAt((c >>> 4 << 24 >>> 24)));
				dst.WriteByte(hex.charCodeAt(((c & 15) >>> 0)));
				start = i + 1 >> 0;
			}
			if ((c === 226) && (i + 2 >> 0) < src.length && ((_slice$1 = src, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 128) && (((_slice$2 = src, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) & ~1) === 168)) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u202");
				dst.WriteByte(hex.charCodeAt((((_slice$3 = src, _index$3 = (i + 2 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) & 15) >>> 0)));
				start = i + 3 >> 0;
			}
			v = scan.step(scan, (c >> 0));
			if (v >= 9) {
				if (v === 11) {
					break;
				}
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				start = i + 1 >> 0;
			}
			_i++;
		}
		if (scan.eof() === 11) {
			dst.Truncate(origLen);
			return scan.err;
		}
		if (start < src.length) {
			dst.Write(go$subslice(src, start));
		}
		return null;
	};
	var newline = function(dst, prefix, indent, depth) {
		var i;
		dst.WriteByte(10);
		dst.WriteString(prefix);
		i = 0;
		while (i < depth) {
			dst.WriteString(indent);
			i = i + 1 >> 0;
		}
	};
	var Indent = go$pkg.Indent = function(dst, src, prefix, indent) {
		var origLen, scan, needIndent, depth, _ref, _i, _slice, _index, c, x, v, _ref$1;
		origLen = dst.Len();
		scan = new scanner.Ptr();
		scan.reset();
		needIndent = false;
		depth = 0;
		_ref = src;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			scan.bytes = (x = scan.bytes, new Go$Int64(x.high + 0, x.low + 1));
			v = scan.step(scan, (c >> 0));
			if (v === 9) {
				_i++;
				continue;
			}
			if (v === 11) {
				break;
			}
			if (needIndent && !((v === 5)) && !((v === 8))) {
				needIndent = false;
				depth = depth + 1 >> 0;
				newline(dst, prefix, indent, depth);
			}
			if (v === 0) {
				dst.WriteByte(c);
				_i++;
				continue;
			}
			_ref$1 = c;
			if (_ref$1 === 123 || _ref$1 === 91) {
				needIndent = true;
				dst.WriteByte(c);
			} else if (_ref$1 === 44) {
				dst.WriteByte(c);
				newline(dst, prefix, indent, depth);
			} else if (_ref$1 === 58) {
				dst.WriteByte(c);
				dst.WriteByte(32);
			} else if (_ref$1 === 125 || _ref$1 === 93) {
				if (needIndent) {
					needIndent = false;
				} else {
					depth = depth - 1 >> 0;
					newline(dst, prefix, indent, depth);
				}
				dst.WriteByte(c);
			} else {
				dst.WriteByte(c);
			}
			_i++;
		}
		if (scan.eof() === 11) {
			dst.Truncate(origLen);
			return scan.err;
		}
		return null;
	};
	var checkValid = function(data, scan) {
		var _ref, _i, _slice, _index, c, x;
		scan.reset();
		_ref = data;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			scan.bytes = (x = scan.bytes, new Go$Int64(x.high + 0, x.low + 1));
			if (scan.step(scan, (c >> 0)) === 11) {
				return scan.err;
			}
			_i++;
		}
		if (scan.eof() === 11) {
			return scan.err;
		}
		return null;
	};
	var nextValue = function(data, scan) {
		var value, rest, err, _ref, _i, _slice, _index, c, i, v, _ref$1, _tuple, _tuple$1, _tuple$2, _tuple$3;
		value = (go$sliceType(Go$Uint8)).nil;
		rest = (go$sliceType(Go$Uint8)).nil;
		err = null;
		scan.reset();
		_ref = data;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			v = scan.step(scan, (c >> 0));
			if (v >= 10) {
				_ref$1 = v;
				if (_ref$1 === 11) {
					_tuple = [(go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, scan.err], value = _tuple[0], rest = _tuple[1], err = _tuple[2];
					return [value, rest, err];
				} else if (_ref$1 === 10) {
					_tuple$1 = [go$subslice(data, 0, i), go$subslice(data, i), null], value = _tuple$1[0], rest = _tuple$1[1], err = _tuple$1[2];
					return [value, rest, err];
				}
			}
			_i++;
		}
		if (scan.eof() === 11) {
			_tuple$2 = [(go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, scan.err], value = _tuple$2[0], rest = _tuple$2[1], err = _tuple$2[2];
			return [value, rest, err];
		}
		_tuple$3 = [data, (go$sliceType(Go$Uint8)).nil, null], value = _tuple$3[0], rest = _tuple$3[1], err = _tuple$3[2];
		return [value, rest, err];
	};
	SyntaxError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.msg;
	};
	SyntaxError.prototype.Error = function() { return this.go$val.Error(); };
	scanner.Ptr.prototype.reset = function() {
		var s;
		s = this;
		s.step = stateBeginValue;
		s.parseState = go$subslice(s.parseState, 0, 0);
		s.err = null;
		s.redo = false;
		s.endTop = false;
	};
	scanner.prototype.reset = function() { return this.go$val.reset(); };
	scanner.Ptr.prototype.eof = function() {
		var s;
		s = this;
		if (!(go$interfaceIsEqual(s.err, null))) {
			return 11;
		}
		if (s.endTop) {
			return 10;
		}
		s.step(s, 32);
		if (s.endTop) {
			return 10;
		}
		if (go$interfaceIsEqual(s.err, null)) {
			s.err = new SyntaxError.Ptr("unexpected end of JSON input", s.bytes);
		}
		return 11;
	};
	scanner.prototype.eof = function() { return this.go$val.eof(); };
	scanner.Ptr.prototype.pushParseState = function(p) {
		var s;
		s = this;
		s.parseState = go$append(s.parseState, p);
	};
	scanner.prototype.pushParseState = function(p) { return this.go$val.pushParseState(p); };
	scanner.Ptr.prototype.popParseState = function() {
		var s, n;
		s = this;
		n = s.parseState.length - 1 >> 0;
		s.parseState = go$subslice(s.parseState, 0, n);
		s.redo = false;
		if (n === 0) {
			s.step = stateEndTop;
			s.endTop = true;
		} else {
			s.step = stateEndValue;
		}
	};
	scanner.prototype.popParseState = function() { return this.go$val.popParseState(); };
	var isSpace = function(c) {
		return (c === 32) || (c === 9) || (c === 13) || (c === 10);
	};
	var stateBeginValueOrEmpty = function(s, c) {
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		if (c === 93) {
			return stateEndValue(s, c);
		}
		return stateBeginValue(s, c);
	};
	var stateBeginValue = function(s, c) {
		var _ref;
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		_ref = c;
		if (_ref === 123) {
			s.step = stateBeginStringOrEmpty;
			s.pushParseState(0);
			return 2;
		} else if (_ref === 91) {
			s.step = stateBeginValueOrEmpty;
			s.pushParseState(2);
			return 6;
		} else if (_ref === 34) {
			s.step = stateInString;
			return 1;
		} else if (_ref === 45) {
			s.step = stateNeg;
			return 1;
		} else if (_ref === 48) {
			s.step = state0;
			return 1;
		} else if (_ref === 116) {
			s.step = stateT;
			return 1;
		} else if (_ref === 102) {
			s.step = stateF;
			return 1;
		} else if (_ref === 110) {
			s.step = stateN;
			return 1;
		}
		if (49 <= c && c <= 57) {
			s.step = state1;
			return 1;
		}
		return s.error(c, "looking for beginning of value");
	};
	var stateBeginStringOrEmpty = function(s, c) {
		var n, _slice, _index;
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		if (c === 125) {
			n = s.parseState.length;
			_slice = s.parseState, _index = n - 1 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 1) : go$throwRuntimeError("index out of range");
			return stateEndValue(s, c);
		}
		return stateBeginString(s, c);
	};
	var stateBeginString = function(s, c) {
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		if (c === 34) {
			s.step = stateInString;
			return 1;
		}
		return s.error(c, "looking for beginning of object key string");
	};
	var stateEndValue = function(s, c) {
		var n, _slice, _index, ps, _ref, _slice$1, _index$1, _slice$2, _index$2;
		n = s.parseState.length;
		if (n === 0) {
			s.step = stateEndTop;
			s.endTop = true;
			return stateEndTop(s, c);
		}
		if (c <= 32 && isSpace((c >> 0))) {
			s.step = stateEndValue;
			return 9;
		}
		ps = (_slice = s.parseState, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		_ref = ps;
		if (_ref === 0) {
			if (c === 58) {
				_slice$1 = s.parseState, _index$1 = n - 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 1) : go$throwRuntimeError("index out of range");
				s.step = stateBeginValue;
				return 3;
			}
			return s.error(c, "after object key");
		} else if (_ref === 1) {
			if (c === 44) {
				_slice$2 = s.parseState, _index$2 = n - 1 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 0) : go$throwRuntimeError("index out of range");
				s.step = stateBeginString;
				return 4;
			}
			if (c === 125) {
				s.popParseState();
				return 5;
			}
			return s.error(c, "after object key:value pair");
		} else if (_ref === 2) {
			if (c === 44) {
				s.step = stateBeginValue;
				return 7;
			}
			if (c === 93) {
				s.popParseState();
				return 8;
			}
			return s.error(c, "after array element");
		}
		return s.error(c, "");
	};
	var stateEndTop = function(s, c) {
		if (!((c === 32)) && !((c === 9)) && !((c === 13)) && !((c === 10))) {
			s.error(c, "after top-level value");
		}
		return 10;
	};
	var stateInString = function(s, c) {
		if (c === 34) {
			s.step = stateEndValue;
			return 0;
		}
		if (c === 92) {
			s.step = stateInStringEsc;
			return 0;
		}
		if (c < 32) {
			return s.error(c, "in string literal");
		}
		return 0;
	};
	var stateInStringEsc = function(s, c) {
		var _ref;
		_ref = c;
		if (_ref === 98 || _ref === 102 || _ref === 110 || _ref === 114 || _ref === 116 || _ref === 92 || _ref === 47 || _ref === 34) {
			s.step = stateInString;
			return 0;
		}
		if (c === 117) {
			s.step = stateInStringEscU;
			return 0;
		}
		return s.error(c, "in string escape code");
	};
	var stateInStringEscU = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU1;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	var stateInStringEscU1 = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU12;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	var stateInStringEscU12 = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU123;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	var stateInStringEscU123 = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInString;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
	var stateNeg = function(s, c) {
		if (c === 48) {
			s.step = state0;
			return 0;
		}
		if (49 <= c && c <= 57) {
			s.step = state1;
			return 0;
		}
		return s.error(c, "in numeric literal");
	};
	var state1 = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = state1;
			return 0;
		}
		return state0(s, c);
	};
	var state0 = function(s, c) {
		if (c === 46) {
			s.step = stateDot;
			return 0;
		}
		if ((c === 101) || (c === 69)) {
			s.step = stateE;
			return 0;
		}
		return stateEndValue(s, c);
	};
	var stateDot = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateDot0;
			return 0;
		}
		return s.error(c, "after decimal point in numeric literal");
	};
	var stateDot0 = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateDot0;
			return 0;
		}
		if ((c === 101) || (c === 69)) {
			s.step = stateE;
			return 0;
		}
		return stateEndValue(s, c);
	};
	var stateE = function(s, c) {
		if (c === 43) {
			s.step = stateESign;
			return 0;
		}
		if (c === 45) {
			s.step = stateESign;
			return 0;
		}
		return stateESign(s, c);
	};
	var stateESign = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateE0;
			return 0;
		}
		return s.error(c, "in exponent of numeric literal");
	};
	var stateE0 = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateE0;
			return 0;
		}
		return stateEndValue(s, c);
	};
	var stateT = function(s, c) {
		if (c === 114) {
			s.step = stateTr;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'r')");
	};
	var stateTr = function(s, c) {
		if (c === 117) {
			s.step = stateTru;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'u')");
	};
	var stateTru = function(s, c) {
		if (c === 101) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'e')");
	};
	var stateF = function(s, c) {
		if (c === 97) {
			s.step = stateFa;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'a')");
	};
	var stateFa = function(s, c) {
		if (c === 108) {
			s.step = stateFal;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'l')");
	};
	var stateFal = function(s, c) {
		if (c === 115) {
			s.step = stateFals;
			return 0;
		}
		return s.error(c, "in literal false (expecting 's')");
	};
	var stateFals = function(s, c) {
		if (c === 101) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'e')");
	};
	var stateN = function(s, c) {
		if (c === 117) {
			s.step = stateNu;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'u')");
	};
	var stateNu = function(s, c) {
		if (c === 108) {
			s.step = stateNul;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'l')");
	};
	var stateNul = function(s, c) {
		if (c === 108) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'l')");
	};
	var stateError = function(s, c) {
		return 11;
	};
	scanner.Ptr.prototype.error = function(c, context) {
		var s;
		s = this;
		s.step = stateError;
		s.err = new SyntaxError.Ptr("invalid character " + quoteChar(c) + " " + context, s.bytes);
		return 11;
	};
	scanner.prototype.error = function(c, context) { return this.go$val.error(c, context); };
	var quoteChar = function(c) {
		var s;
		if (c === 39) {
			return "'\\''";
		}
		if (c === 34) {
			return "'\"'";
		}
		s = strconv.Quote(go$encodeRune(c));
		return "'" + s.substring(1, (s.length - 1 >> 0)) + "'";
	};
	scanner.Ptr.prototype.undo = function(scanCode) {
		var s;
		s = this;
		if (s.redo) {
			throw go$panic(new Go$String("json: invalid use of scanner"));
		}
		s.redoCode = scanCode;
		s.redoState = s.step;
		s.step = stateRedo;
		s.redo = true;
	};
	scanner.prototype.undo = function(scanCode) { return this.go$val.undo(scanCode); };
	var stateRedo = function(s, c) {
		s.redo = false;
		s.step = s.redoState;
		return s.redoCode;
	};
	var NewDecoder = go$pkg.NewDecoder = function(r) {
		return new Decoder.Ptr(r, (go$sliceType(Go$Uint8)).nil, new decodeState.Ptr(), new scanner.Ptr(), null);
	};
	Decoder.Ptr.prototype.UseNumber = function() {
		var dec;
		dec = this;
		dec.d.useNumber = true;
	};
	Decoder.prototype.UseNumber = function() { return this.go$val.UseNumber(); };
	Decoder.Ptr.prototype.Decode = function(v) {
		var dec, _tuple, n, err, rest;
		dec = this;
		if (!(go$interfaceIsEqual(dec.err, null))) {
			return dec.err;
		}
		_tuple = dec.readValue(), n = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		dec.d.init(go$subslice(dec.buf, 0, n));
		err = dec.d.unmarshal(v);
		rest = go$copySlice(dec.buf, go$subslice(dec.buf, n));
		dec.buf = go$subslice(dec.buf, 0, rest);
		return err;
	};
	Decoder.prototype.Decode = function(v) { return this.go$val.Decode(v); };
	Decoder.Ptr.prototype.Buffered = function() {
		var dec;
		dec = this;
		return bytes.NewReader(dec.buf);
	};
	Decoder.prototype.Buffered = function() { return this.go$val.Buffered(); };
	Decoder.Ptr.prototype.readValue = function() {
		var dec, scanp, err, _ref, _i, _slice, _index, c, i, x, v, x$1, x$2, newBuf, n, _tuple;
		dec = this;
		dec.scan.reset();
		scanp = 0;
		err = null;
		Input: while (true) {
			_ref = go$subslice(dec.buf, scanp);
			_i = 0;
			while (_i < _ref.length) {
				c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				dec.scan.bytes = (x = dec.scan.bytes, new Go$Int64(x.high + 0, x.low + 1));
				v = dec.scan.step(dec.scan, (c >> 0));
				if (v === 10) {
					scanp = scanp + (i) >> 0;
					break Input;
				}
				if (((v === 5) || (v === 8)) && (dec.scan.step(dec.scan, 32) === 10)) {
					scanp = scanp + ((i + 1 >> 0)) >> 0;
					break Input;
				}
				if (v === 11) {
					dec.err = dec.scan.err;
					return [0, dec.scan.err];
				}
				_i++;
			}
			scanp = dec.buf.length;
			if (!(go$interfaceIsEqual(err, null))) {
				if (go$interfaceIsEqual(err, io.EOF)) {
					if (dec.scan.step(dec.scan, 32) === 10) {
						break Input;
					}
					if (nonSpace(dec.buf)) {
						err = io.ErrUnexpectedEOF;
					}
				}
				dec.err = err;
				return [0, err];
			}
			if ((dec.buf.capacity - dec.buf.length >> 0) < 512) {
				newBuf = (go$sliceType(Go$Uint8)).make(dec.buf.length, (x$1 = 2, x$2 = dec.buf.capacity, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + 512 >> 0, function() { return 0; });
				go$copySlice(newBuf, dec.buf);
				dec.buf = newBuf;
			}
			n = 0;
			_tuple = dec.r.Read(go$subslice(dec.buf, dec.buf.length, dec.buf.capacity)), n = _tuple[0], err = _tuple[1];
			dec.buf = go$subslice(dec.buf, 0, (dec.buf.length + n >> 0));
		}
		return [scanp, null];
	};
	Decoder.prototype.readValue = function() { return this.go$val.readValue(); };
	var nonSpace = function(b) {
		var _ref, _i, _slice, _index, c;
		_ref = b;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!isSpace((c >> 0))) {
				return true;
			}
			_i++;
		}
		return false;
	};
	var NewEncoder = go$pkg.NewEncoder = function(w) {
		return new Encoder.Ptr(w, new encodeState.Ptr(), null);
	};
	Encoder.Ptr.prototype.Encode = function(v) {
		var enc, e, err, _tuple;
		enc = this;
		if (!(go$interfaceIsEqual(enc.err, null))) {
			return enc.err;
		}
		e = newEncodeState();
		err = e.marshal(v);
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		e.Buffer.WriteByte(10);
		if (_tuple = enc.w.Write(e.Buffer.Bytes()), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			enc.err = err;
		}
		putEncodeState(e);
		return err;
	};
	Encoder.prototype.Encode = function(v) { return this.go$val.Encode(v); };
	go$ptrType(RawMessage).prototype.MarshalJSON = function() {
		var m, x;
		m = this;
		return [(x = m.go$get(), go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length)), null];
	};
	RawMessage.prototype.MarshalJSON = function() { var obj = this; return (new (go$ptrType(RawMessage))(function() { return obj; }, null)).MarshalJSON(); };
	go$ptrType(RawMessage).prototype.UnmarshalJSON = function(data) {
		var m;
		m = this;
		if (go$pointerIsEqual(m, (go$ptrType(RawMessage)).nil)) {
			return errors.New("json.RawMessage: UnmarshalJSON on nil pointer");
		}
		m.go$set(go$appendSlice(go$subslice((m.go$get()), 0, 0), data));
		return null;
	};
	RawMessage.prototype.UnmarshalJSON = function(data) { var obj = this; return (new (go$ptrType(RawMessage))(function() { return obj; }, null)).UnmarshalJSON(data); };
	var parseTag = function(tag) {
		var idx;
		if (idx = strings.Index(tag, ","), !((idx === -1))) {
			return [tag.substring(0, idx), tag.substring((idx + 1 >> 0))];
		}
		return [tag, ""];
	};
	tagOptions.prototype.Contains = function(optionName) {
		var o, s, next, i, _tuple;
		o = this.go$val;
		if (o.length === 0) {
			return false;
		}
		s = o;
		while (!(s === "")) {
			next = "";
			i = strings.Index(s, ",");
			if (i >= 0) {
				_tuple = [s.substring(0, i), s.substring((i + 1 >> 0))], s = _tuple[0], next = _tuple[1];
			}
			if (s === optionName) {
				return true;
			}
			s = next;
		}
		return false;
	};
	go$ptrType(tagOptions).prototype.Contains = function(optionName) { return new tagOptions(this.go$get()).Contains(optionName); };

		  var encodeStates = [];
			go$pkg.init = function() {
		encoderCache = new (go$structType([["", "", sync.RWMutex, ""], ["m", "encoding/json", (go$mapType(reflect.Type, encoderFunc)), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
		fieldCache = new (go$structType([["", "", sync.RWMutex, ""], ["m", "encoding/json", (go$mapType(reflect.Type, (go$sliceType(field)))), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
		var e, v, quoted, _recv, e$1, v$1, quoted$1, _recv$1;
		errPhase = errors.New("JSON decoder out of sync - data changing underfoot?");
		numberType = reflect.TypeOf(new Number(""));
		hex = "0123456789abcdef";
		encodeStatePool = new (go$chanType((go$ptrType(encodeState)), false, false))();
		byteSliceType = reflect.TypeOf((go$sliceType(Go$Uint8)).nil);
		marshalerType = reflect.TypeOf(go$newDataPointer(null, (go$ptrType(Marshaler)))).Elem();
		textMarshalerType = reflect.TypeOf(go$newDataPointer(null, (go$ptrType(encoding.TextMarshaler)))).Elem();
		float32Encoder = (_recv = (new floatEncoder(32)), function(e, v, quoted) { return _recv.encode(e, v, quoted); });
		float64Encoder = (_recv$1 = (new floatEncoder(64)), function(e$1, v$1, quoted$1) { return _recv$1.encode(e$1, v$1, quoted$1); });
	};
	return go$pkg;
})();
go$packages["math/rand"] = (function() {
	var go$pkg = {};
	var math = go$packages["math"];
	var sync = go$packages["sync"];
	var Source;
	Source = go$newType(0, "Interface", "rand.Source", "Source", "math/rand", null);
	go$pkg.Source = Source;
	var Rand;
	Rand = go$newType(0, "Struct", "rand.Rand", "Rand", "math/rand", function(src_) {
		this.go$val = this;
		this.src = src_ !== undefined ? src_ : null;
	});
	go$pkg.Rand = Rand;
	var lockedSource;
	lockedSource = go$newType(0, "Struct", "rand.lockedSource", "lockedSource", "math/rand", function(lk_, src_) {
		this.go$val = this;
		this.lk = lk_ !== undefined ? lk_ : new sync.Mutex.Ptr();
		this.src = src_ !== undefined ? src_ : null;
	});
	go$pkg.lockedSource = lockedSource;
	var rngSource;
	rngSource = go$newType(0, "Struct", "rand.rngSource", "rngSource", "math/rand", function(tap_, feed_, vec_) {
		this.go$val = this;
		this.tap = tap_ !== undefined ? tap_ : 0;
		this.feed = feed_ !== undefined ? feed_ : 0;
		this.vec = vec_ !== undefined ? vec_ : go$makeNativeArray("Int64", 607, function() { return new Go$Int64(0, 0); });
	});
	go$pkg.rngSource = rngSource;
	var Zipf;
	Zipf = go$newType(0, "Struct", "rand.Zipf", "Zipf", "math/rand", function(r_, imax_, v_, q_, s_, oneminusQ_, oneminusQinv_, hxm_, hx0minusHxm_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : (go$ptrType(Rand)).nil;
		this.imax = imax_ !== undefined ? imax_ : 0;
		this.v = v_ !== undefined ? v_ : 0;
		this.q = q_ !== undefined ? q_ : 0;
		this.s = s_ !== undefined ? s_ : 0;
		this.oneminusQ = oneminusQ_ !== undefined ? oneminusQ_ : 0;
		this.oneminusQinv = oneminusQinv_ !== undefined ? oneminusQinv_ : 0;
		this.hxm = hxm_ !== undefined ? hxm_ : 0;
		this.hx0minusHxm = hx0minusHxm_ !== undefined ? hx0minusHxm_ : 0;
	});
	go$pkg.Zipf = Zipf;
	Source.init([["Int63", "", (go$funcType([], [Go$Int64], false))], ["Seed", "", (go$funcType([Go$Int64], [], false))]]);
	Rand.init([["src", "math/rand", Source, ""]]);
	(go$ptrType(Rand)).methods = [["ExpFloat64", "", [], [Go$Float64], false], ["Float32", "", [], [Go$Float32], false], ["Float64", "", [], [Go$Float64], false], ["Int", "", [], [Go$Int], false], ["Int31", "", [], [Go$Int32], false], ["Int31n", "", [Go$Int32], [Go$Int32], false], ["Int63", "", [], [Go$Int64], false], ["Int63n", "", [Go$Int64], [Go$Int64], false], ["Intn", "", [Go$Int], [Go$Int], false], ["NormFloat64", "", [], [Go$Float64], false], ["Perm", "", [Go$Int], [(go$sliceType(Go$Int))], false], ["Seed", "", [Go$Int64], [], false], ["Uint32", "", [], [Go$Uint32], false]];
	lockedSource.init([["lk", "math/rand", sync.Mutex, ""], ["src", "math/rand", Source, ""]]);
	(go$ptrType(lockedSource)).methods = [["Int63", "", [], [Go$Int64], false], ["Seed", "", [Go$Int64], [], false]];
	rngSource.init([["tap", "math/rand", Go$Int, ""], ["feed", "math/rand", Go$Int, ""], ["vec", "math/rand", (go$arrayType(Go$Int64, 607)), ""]]);
	(go$ptrType(rngSource)).methods = [["Int63", "", [], [Go$Int64], false], ["Seed", "", [Go$Int64], [], false]];
	Zipf.init([["r", "math/rand", (go$ptrType(Rand)), ""], ["imax", "math/rand", Go$Float64, ""], ["v", "math/rand", Go$Float64, ""], ["q", "math/rand", Go$Float64, ""], ["s", "math/rand", Go$Float64, ""], ["oneminusQ", "math/rand", Go$Float64, ""], ["oneminusQinv", "math/rand", Go$Float64, ""], ["hxm", "math/rand", Go$Float64, ""], ["hx0minusHxm", "math/rand", Go$Float64, ""]]);
	(go$ptrType(Zipf)).methods = [["Uint64", "", [], [Go$Uint64], false], ["h", "math/rand", [Go$Float64], [Go$Float64], false], ["hinv", "math/rand", [Go$Float64], [Go$Float64], false]];
	var ke, we, fe, kn, wn, fn, globalRand, rng_cooked;
	Rand.Ptr.prototype.ExpFloat64 = function() {
		var r, j, i, x;
		r = this;
		while (true) {
			j = r.Uint32();
			i = (j & 255) >>> 0;
			x = j * we[i];
			if (j < ke[i]) {
				return x;
			}
			if (i === 0) {
				return 7.69711747013105 - math.Log(r.Float64());
			}
			if (fe[i] + r.Float64() * (fe[(i - 1 >>> 0)] - fe[i]) < math.Exp(-x)) {
				return x;
			}
		}
	};
	Rand.prototype.ExpFloat64 = function() { return this.go$val.ExpFloat64(); };
	var absInt32 = function(i) {
		if (i < 0) {
			return (-i >>> 0);
		}
		return (i >>> 0);
	};
	Rand.Ptr.prototype.NormFloat64 = function() {
		var r, j, i, x, y;
		r = this;
		while (true) {
			j = (r.Uint32() >> 0);
			i = j & 127;
			x = j * wn[i];
			if (absInt32(j) < kn[i]) {
				return x;
			}
			if (i === 0) {
				while (true) {
					x = -math.Log(r.Float64()) * 0.29047645161474317;
					y = -math.Log(r.Float64());
					if (y + y >= x * x) {
						break;
					}
				}
				if (j > 0) {
					return 3.442619855899 + x;
				}
				return -3.442619855899 - x;
			}
			if (fn[i] + r.Float64() * (fn[(i - 1 >> 0)] - fn[i]) < math.Exp(-0.5 * x * x)) {
				return x;
			}
		}
	};
	Rand.prototype.NormFloat64 = function() { return this.go$val.NormFloat64(); };
	var NewSource = go$pkg.NewSource = function(seed) {
		var rng;
		rng = new rngSource.Ptr();
		rng.Seed(seed);
		return rng;
	};
	var New = go$pkg.New = function(src) {
		return new Rand.Ptr(src);
	};
	Rand.Ptr.prototype.Seed = function(seed) {
		var r;
		r = this;
		r.src.Seed(seed);
	};
	Rand.prototype.Seed = function(seed) { return this.go$val.Seed(seed); };
	Rand.Ptr.prototype.Int63 = function() {
		var r;
		r = this;
		return r.src.Int63();
	};
	Rand.prototype.Int63 = function() { return this.go$val.Int63(); };
	Rand.Ptr.prototype.Uint32 = function() {
		var r;
		r = this;
		return (go$shiftRightInt64(r.Int63(), 31).low >>> 0);
	};
	Rand.prototype.Uint32 = function() { return this.go$val.Uint32(); };
	Rand.Ptr.prototype.Int31 = function() {
		var r, x;
		r = this;
		return ((x = go$shiftRightInt64(r.Int63(), 32), x.low + ((x.high >> 31) * 4294967296)) >> 0);
	};
	Rand.prototype.Int31 = function() { return this.go$val.Int31(); };
	Rand.Ptr.prototype.Int = function() {
		var r, u;
		r = this;
		u = (r.Int63().low >>> 0);
		return (((u << 1 >>> 0) >>> 1 >>> 0) >> 0);
	};
	Rand.prototype.Int = function() { return this.go$val.Int(); };
	Rand.Ptr.prototype.Int63n = function(n) {
		var r, x, x$1, max, v;
		r = this;
		if ((n.high < 0 || (n.high === 0 && n.low <= 0))) {
			throw go$panic(new Go$String("invalid argument to Int63n"));
		}
		max = (x = (x$1 = go$div64(new Go$Uint64(2147483648, 0), new Go$Uint64(n.high, n.low), true), new Go$Uint64(2147483647 - x$1.high, 4294967295 - x$1.low)), new Go$Int64(x.high, x.low));
		v = r.Int63();
		while ((v.high > max.high || (v.high === max.high && v.low > max.low))) {
			v = r.Int63();
		}
		return go$div64(v, n, true);
	};
	Rand.prototype.Int63n = function(n) { return this.go$val.Int63n(n); };
	Rand.Ptr.prototype.Int31n = function(n) {
		var r, _r, max, v, _r$1;
		r = this;
		if (n <= 0) {
			throw go$panic(new Go$String("invalid argument to Int31n"));
		}
		max = ((2147483647 - (_r = 2147483648 % (n >>> 0), _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) >>> 0) >> 0);
		v = r.Int31();
		while (v > max) {
			v = r.Int31();
		}
		return (_r$1 = v % n, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero"));
	};
	Rand.prototype.Int31n = function(n) { return this.go$val.Int31n(n); };
	Rand.Ptr.prototype.Intn = function(n) {
		var r, x;
		r = this;
		if (n <= 0) {
			throw go$panic(new Go$String("invalid argument to Intn"));
		}
		if (n <= 2147483647) {
			return (r.Int31n((n >> 0)) >> 0);
		}
		return ((x = r.Int63n(new Go$Int64(0, n)), x.low + ((x.high >> 31) * 4294967296)) >> 0);
	};
	Rand.prototype.Intn = function(n) { return this.go$val.Intn(n); };
	Rand.Ptr.prototype.Float64 = function() {
		var r;
		r = this;
		return go$flatten64(r.Int63()) / 9.223372036854776e+18;
	};
	Rand.prototype.Float64 = function() { return this.go$val.Float64(); };
	Rand.Ptr.prototype.Float32 = function() {
		var r;
		r = this;
		return r.Float64();
	};
	Rand.prototype.Float32 = function() { return this.go$val.Float32(); };
	Rand.Ptr.prototype.Perm = function(n) {
		var r, m, i, _slice, _index, i$1, j, _slice$1, _index$1, _slice$2, _index$2, _tuple, _slice$3, _index$3, _slice$4, _index$4;
		r = this;
		m = (go$sliceType(Go$Int)).make(n, 0, function() { return 0; });
		i = 0;
		while (i < n) {
			_slice = m, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = i) : go$throwRuntimeError("index out of range");
			i = i + 1 >> 0;
		}
		i$1 = 0;
		while (i$1 < n) {
			j = r.Intn(i$1 + 1 >> 0);
			_tuple = [(_slice$1 = m, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = m, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))], _slice$3 = m, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$4 = m, _index$4 = j, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = _tuple[1]) : go$throwRuntimeError("index out of range");
			i$1 = i$1 + 1 >> 0;
		}
		return m;
	};
	Rand.prototype.Perm = function(n) { return this.go$val.Perm(n); };
	var Seed = go$pkg.Seed = function(seed) {
		globalRand.Seed(seed);
	};
	var Int63 = go$pkg.Int63 = function() {
		return globalRand.Int63();
	};
	var Uint32 = go$pkg.Uint32 = function() {
		return globalRand.Uint32();
	};
	var Int31 = go$pkg.Int31 = function() {
		return globalRand.Int31();
	};
	var Int = go$pkg.Int = function() {
		return globalRand.Int();
	};
	var Int63n = go$pkg.Int63n = function(n) {
		return globalRand.Int63n(n);
	};
	var Int31n = go$pkg.Int31n = function(n) {
		return globalRand.Int31n(n);
	};
	var Intn = go$pkg.Intn = function(n) {
		return globalRand.Intn(n);
	};
	var Float64 = go$pkg.Float64 = function() {
		return globalRand.Float64();
	};
	var Float32 = go$pkg.Float32 = function() {
		return globalRand.Float32();
	};
	var Perm = go$pkg.Perm = function(n) {
		return globalRand.Perm(n);
	};
	var NormFloat64 = go$pkg.NormFloat64 = function() {
		return globalRand.NormFloat64();
	};
	var ExpFloat64 = go$pkg.ExpFloat64 = function() {
		return globalRand.ExpFloat64();
	};
	lockedSource.Ptr.prototype.Int63 = function() {
		var n, r;
		n = new Go$Int64(0, 0);
		r = this;
		r.lk.Lock();
		n = r.src.Int63();
		r.lk.Unlock();
		return n;
	};
	lockedSource.prototype.Int63 = function() { return this.go$val.Int63(); };
	lockedSource.Ptr.prototype.Seed = function(seed) {
		var r;
		r = this;
		r.lk.Lock();
		r.src.Seed(seed);
		r.lk.Unlock();
	};
	lockedSource.prototype.Seed = function(seed) { return this.go$val.Seed(seed); };
	var seedrand = function(x) {
		var _q, hi, _r, lo;
		hi = (_q = x / 44488, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		lo = (_r = x % 44488, _r === _r ? _r : go$throwRuntimeError("integer divide by zero"));
		x = ((((48271 >>> 16 << 16) * lo >> 0) + (48271 << 16 >>> 16) * lo) >> 0) - ((((3399 >>> 16 << 16) * hi >> 0) + (3399 << 16 >>> 16) * hi) >> 0) >> 0;
		if (x < 0) {
			x = x + 2147483647 >> 0;
		}
		return x;
	};
	rngSource.Ptr.prototype.Seed = function(seed) {
		var rng, x, i, u, x$1, x$2, x$3;
		rng = this;
		rng.tap = 0;
		rng.feed = 334;
		seed = go$div64(seed, new Go$Int64(0, 2147483647), true);
		if ((seed.high < 0 || (seed.high === 0 && seed.low < 0))) {
			seed = new Go$Int64(seed.high + 0, seed.low + 2147483647);
		}
		if ((seed.high === 0 && seed.low === 0)) {
			seed = new Go$Int64(0, 89482311);
		}
		x = ((seed.low + ((seed.high >> 31) * 4294967296)) >> 0);
		i = -20;
		while (i < 607) {
			x = seedrand(x);
			if (i >= 0) {
				u = new Go$Int64(0, 0);
				u = go$shiftLeft64(new Go$Int64(0, x), 40);
				x = seedrand(x);
				u = (x$1 = go$shiftLeft64(new Go$Int64(0, x), 20), new Go$Int64(u.high ^ x$1.high, (u.low ^ x$1.low) >>> 0));
				x = seedrand(x);
				u = (x$2 = new Go$Int64(0, x), new Go$Int64(u.high ^ x$2.high, (u.low ^ x$2.low) >>> 0));
				u = (x$3 = rng_cooked[i], new Go$Int64(u.high ^ x$3.high, (u.low ^ x$3.low) >>> 0));
				rng.vec[i] = new Go$Int64(u.high & 2147483647, (u.low & 4294967295) >>> 0);
			}
			i = i + 1 >> 0;
		}
	};
	rngSource.prototype.Seed = function(seed) { return this.go$val.Seed(seed); };
	rngSource.Ptr.prototype.Int63 = function() {
		var rng, x, x$1, x$2, x$3;
		rng = this;
		rng.tap = rng.tap - 1 >> 0;
		if (rng.tap < 0) {
			rng.tap = rng.tap + 607 >> 0;
		}
		rng.feed = rng.feed - 1 >> 0;
		if (rng.feed < 0) {
			rng.feed = rng.feed + 607 >> 0;
		}
		x$3 = (x = (x$1 = rng.vec[rng.feed], x$2 = rng.vec[rng.tap], new Go$Int64(x$1.high + x$2.high, x$1.low + x$2.low)), new Go$Int64(x.high & 2147483647, (x.low & 4294967295) >>> 0));
		rng.vec[rng.feed] = x$3;
		return x$3;
	};
	rngSource.prototype.Int63 = function() { return this.go$val.Int63(); };
	Zipf.Ptr.prototype.h = function(x) {
		var z;
		z = this;
		return math.Exp(z.oneminusQ * math.Log(z.v + x)) * z.oneminusQinv;
	};
	Zipf.prototype.h = function(x) { return this.go$val.h(x); };
	Zipf.Ptr.prototype.hinv = function(x) {
		var z;
		z = this;
		return math.Exp(z.oneminusQinv * math.Log(z.oneminusQ * x)) - z.v;
	};
	Zipf.prototype.hinv = function(x) { return this.go$val.hinv(x); };
	var NewZipf = go$pkg.NewZipf = function(r, s, v, imax) {
		var z;
		z = new Zipf.Ptr();
		if (s <= 1 || v < 1) {
			return (go$ptrType(Zipf)).nil;
		}
		z.r = r;
		z.imax = go$flatten64(imax);
		z.v = v;
		z.q = s;
		z.oneminusQ = 1 - z.q;
		z.oneminusQinv = 1 / z.oneminusQ;
		z.hxm = z.h(z.imax + 0.5);
		z.hx0minusHxm = z.h(0.5) - math.Exp(math.Log(z.v) * (-z.q)) - z.hxm;
		z.s = 1 - z.hinv(z.h(1.5) - math.Exp(-z.q * math.Log(z.v + 1)));
		return z;
	};
	Zipf.Ptr.prototype.Uint64 = function() {
		var z, k, r, ur, x;
		z = this;
		if (z === (go$ptrType(Zipf)).nil) {
			throw go$panic(new Go$String("rand: nil Zipf"));
		}
		k = 0;
		while (true) {
			r = z.r.Float64();
			ur = z.hxm + r * z.hx0minusHxm;
			x = z.hinv(ur);
			k = math.Floor(x + 0.5);
			if (k - x <= z.s) {
				break;
			}
			if (ur >= z.h(k + 0.5) - math.Exp(-math.Log(k + z.v) * z.q)) {
				break;
			}
		}
		return new Go$Uint64(0, k);
	};
	Zipf.prototype.Uint64 = function() { return this.go$val.Uint64(); };
	go$pkg.init = function() {
		ke = go$toNativeArray("Uint32", [3801129273, 0, 2615860924, 3279400049, 3571300752, 3733536696, 3836274812, 3906990442, 3958562475, 3997804264, 4028649213, 4053523342, 4074002619, 4091154507, 4105727352, 4118261130, 4129155133, 4138710916, 4147160435, 4154685009, 4161428406, 4167506077, 4173011791, 4178022498, 4182601930, 4186803325, 4190671498, 4194244443, 4197554582, 4200629752, 4203493986, 4206168142, 4208670408, 4211016720, 4213221098, 4215295924, 4217252177, 4219099625, 4220846988, 4222502074, 4224071896, 4225562770, 4226980400, 4228329951, 4229616109, 4230843138, 4232014925, 4233135020, 4234206673, 4235232866, 4236216336, 4237159604, 4238064994, 4238934652, 4239770563, 4240574564, 4241348362, 4242093539, 4242811568, 4243503822, 4244171579, 4244816032, 4245438297, 4246039419, 4246620374, 4247182079, 4247725394, 4248251127, 4248760037, 4249252839, 4249730206, 4250192773, 4250641138, 4251075867, 4251497493, 4251906522, 4252303431, 4252688672, 4253062674, 4253425844, 4253778565, 4254121205, 4254454110, 4254777611, 4255092022, 4255397640, 4255694750, 4255983622, 4256264513, 4256537670, 4256803325, 4257061702, 4257313014, 4257557464, 4257795244, 4258026541, 4258251531, 4258470383, 4258683258, 4258890309, 4259091685, 4259287526, 4259477966, 4259663135, 4259843154, 4260018142, 4260188212, 4260353470, 4260514019, 4260669958, 4260821380, 4260968374, 4261111028, 4261249421, 4261383632, 4261513736, 4261639802, 4261761900, 4261880092, 4261994441, 4262105003, 4262211835, 4262314988, 4262414513, 4262510454, 4262602857, 4262691764, 4262777212, 4262859239, 4262937878, 4263013162, 4263085118, 4263153776, 4263219158, 4263281289, 4263340187, 4263395872, 4263448358, 4263497660, 4263543789, 4263586755, 4263626565, 4263663224, 4263696735, 4263727099, 4263754314, 4263778377, 4263799282, 4263817020, 4263831582, 4263842955, 4263851124, 4263856071, 4263857776, 4263856218, 4263851370, 4263843206, 4263831695, 4263816804, 4263798497, 4263776735, 4263751476, 4263722676, 4263690284, 4263654251, 4263614520, 4263571032, 4263523724, 4263472530, 4263417377, 4263358192, 4263294892, 4263227394, 4263155608, 4263079437, 4262998781, 4262913534, 4262823581, 4262728804, 4262629075, 4262524261, 4262414220, 4262298801, 4262177846, 4262051187, 4261918645, 4261780032, 4261635148, 4261483780, 4261325704, 4261160681, 4260988457, 4260808763, 4260621313, 4260425802, 4260221905, 4260009277, 4259787550, 4259556329, 4259315195, 4259063697, 4258801357, 4258527656, 4258242044, 4257943926, 4257632664, 4257307571, 4256967906, 4256612870, 4256241598, 4255853155, 4255446525, 4255020608, 4254574202, 4254106002, 4253614578, 4253098370, 4252555662, 4251984571, 4251383021, 4250748722, 4250079132, 4249371435, 4248622490, 4247828790, 4246986404, 4246090910, 4245137315, 4244119963, 4243032411, 4241867296, 4240616155, 4239269214, 4237815118, 4236240596, 4234530035, 4232664930, 4230623176, 4228378137, 4225897409, 4223141146, 4220059768, 4216590757, 4212654085, 4208145538, 4202926710, 4196809522, 4189531420, 4180713890, 4169789475, 4155865042, 4137444620, 4111806704, 4073393724, 4008685917, 3873074895]);
		we = go$toNativeArray("Float32", [2.0249555e-09, 1.486674e-11, 2.4409617e-11, 3.1968806e-11, 3.844677e-11, 4.4228204e-11, 4.9516443e-11, 5.443359e-11, 5.905944e-11, 6.344942e-11, 6.7643814e-11, 7.1672945e-11, 7.556032e-11, 7.932458e-11, 8.298079e-11, 8.654132e-11, 9.0016515e-11, 9.3415074e-11, 9.674443e-11, 1.0001099e-10, 1.03220314e-10, 1.06377254e-10, 1.09486115e-10, 1.1255068e-10, 1.1557435e-10, 1.1856015e-10, 1.2151083e-10, 1.2442886e-10, 1.2731648e-10, 1.3017575e-10, 1.3300853e-10, 1.3581657e-10, 1.3860142e-10, 1.4136457e-10, 1.4410738e-10, 1.4683108e-10, 1.4953687e-10, 1.5222583e-10, 1.54899e-10, 1.5755733e-10, 1.6020171e-10, 1.6283301e-10, 1.6545203e-10, 1.6805951e-10, 1.7065617e-10, 1.732427e-10, 1.7581973e-10, 1.7838787e-10, 1.8094774e-10, 1.8349985e-10, 1.8604476e-10, 1.8858298e-10, 1.9111498e-10, 1.9364126e-10, 1.9616223e-10, 1.9867835e-10, 2.0119004e-10, 2.0369768e-10, 2.0620168e-10, 2.087024e-10, 2.1120022e-10, 2.136955e-10, 2.1618855e-10, 2.1867974e-10, 2.2116936e-10, 2.2365775e-10, 2.261452e-10, 2.2863202e-10, 2.311185e-10, 2.3360494e-10, 2.360916e-10, 2.3857874e-10, 2.4106667e-10, 2.4355562e-10, 2.4604588e-10, 2.485377e-10, 2.5103128e-10, 2.5352695e-10, 2.560249e-10, 2.585254e-10, 2.6102867e-10, 2.6353494e-10, 2.6604446e-10, 2.6855745e-10, 2.7107416e-10, 2.7359479e-10, 2.761196e-10, 2.7864877e-10, 2.8118255e-10, 2.8372119e-10, 2.8626485e-10, 2.888138e-10, 2.9136826e-10, 2.939284e-10, 2.9649452e-10, 2.9906677e-10, 3.016454e-10, 3.0423064e-10, 3.0682268e-10, 3.0942177e-10, 3.1202813e-10, 3.1464195e-10, 3.1726352e-10, 3.19893e-10, 3.2253064e-10, 3.251767e-10, 3.2783135e-10, 3.3049485e-10, 3.3316744e-10, 3.3584938e-10, 3.3854083e-10, 3.4124212e-10, 3.4395342e-10, 3.46675e-10, 3.4940711e-10, 3.5215003e-10, 3.5490397e-10, 3.5766917e-10, 3.6044595e-10, 3.6323455e-10, 3.660352e-10, 3.6884823e-10, 3.7167386e-10, 3.745124e-10, 3.773641e-10, 3.802293e-10, 3.8310827e-10, 3.860013e-10, 3.8890866e-10, 3.918307e-10, 3.9476775e-10, 3.9772008e-10, 4.0068804e-10, 4.0367196e-10, 4.0667217e-10, 4.09689e-10, 4.1272286e-10, 4.1577405e-10, 4.1884296e-10, 4.2192994e-10, 4.250354e-10, 4.281597e-10, 4.313033e-10, 4.3446652e-10, 4.3764986e-10, 4.408537e-10, 4.4407847e-10, 4.4732465e-10, 4.5059267e-10, 4.5388301e-10, 4.571962e-10, 4.6053267e-10, 4.6389292e-10, 4.6727755e-10, 4.70687e-10, 4.741219e-10, 4.7758275e-10, 4.810702e-10, 4.845848e-10, 4.8812715e-10, 4.9169796e-10, 4.9529775e-10, 4.989273e-10, 5.0258725e-10, 5.0627835e-10, 5.100013e-10, 5.1375687e-10, 5.1754584e-10, 5.21369e-10, 5.2522725e-10, 5.2912136e-10, 5.330522e-10, 5.370208e-10, 5.4102806e-10, 5.45075e-10, 5.491625e-10, 5.532918e-10, 5.5746385e-10, 5.616799e-10, 5.6594107e-10, 5.7024857e-10, 5.746037e-10, 5.7900773e-10, 5.834621e-10, 5.8796823e-10, 5.925276e-10, 5.971417e-10, 6.018122e-10, 6.065408e-10, 6.113292e-10, 6.1617933e-10, 6.2109295e-10, 6.260722e-10, 6.3111916e-10, 6.3623595e-10, 6.4142497e-10, 6.4668854e-10, 6.5202926e-10, 6.5744976e-10, 6.6295286e-10, 6.6854156e-10, 6.742188e-10, 6.79988e-10, 6.858526e-10, 6.9181616e-10, 6.978826e-10, 7.04056e-10, 7.103407e-10, 7.167412e-10, 7.2326256e-10, 7.2990985e-10, 7.366886e-10, 7.4360473e-10, 7.5066453e-10, 7.5787476e-10, 7.6524265e-10, 7.7277595e-10, 7.80483e-10, 7.883728e-10, 7.9645507e-10, 8.047402e-10, 8.1323964e-10, 8.219657e-10, 8.309319e-10, 8.401528e-10, 8.496445e-10, 8.594247e-10, 8.6951274e-10, 8.799301e-10, 8.9070046e-10, 9.018503e-10, 9.134092e-10, 9.254101e-10, 9.378904e-10, 9.508923e-10, 9.644638e-10, 9.786603e-10, 9.935448e-10, 1.0091913e-09, 1.025686e-09, 1.0431306e-09, 1.0616465e-09, 1.08138e-09, 1.1025096e-09, 1.1252564e-09, 1.1498986e-09, 1.1767932e-09, 1.206409e-09, 1.2393786e-09, 1.276585e-09, 1.3193139e-09, 1.3695435e-09, 1.4305498e-09, 1.508365e-09, 1.6160854e-09, 1.7921248e-09]);
		fe = go$toNativeArray("Float32", [1, 0.9381437, 0.90046996, 0.87170434, 0.8477855, 0.8269933, 0.8084217, 0.7915276, 0.77595687, 0.7614634, 0.7478686, 0.7350381, 0.72286767, 0.71127474, 0.70019263, 0.6895665, 0.67935055, 0.6695063, 0.66000086, 0.65080583, 0.6418967, 0.63325197, 0.6248527, 0.6166822, 0.60872537, 0.60096896, 0.5934009, 0.58601034, 0.5787874, 0.57172304, 0.5648092, 0.5580383, 0.5514034, 0.5448982, 0.5385169, 0.53225386, 0.5261042, 0.52006316, 0.5141264, 0.50828975, 0.5025495, 0.496902, 0.49134386, 0.485872, 0.48048335, 0.4751752, 0.46994483, 0.46478975, 0.45970762, 0.45469615, 0.44975325, 0.44487688, 0.44006512, 0.43531612, 0.43062815, 0.42599955, 0.42142874, 0.4169142, 0.41245446, 0.40804818, 0.403694, 0.3993907, 0.39513698, 0.39093173, 0.38677382, 0.38266218, 0.37859577, 0.37457356, 0.37059465, 0.3666581, 0.362763, 0.35890847, 0.35509375, 0.351318, 0.3475805, 0.34388044, 0.34021714, 0.3365899, 0.33299807, 0.32944095, 0.32591796, 0.3224285, 0.3189719, 0.31554767, 0.31215525, 0.30879408, 0.3054636, 0.3021634, 0.29889292, 0.2956517, 0.29243928, 0.28925523, 0.28609908, 0.28297043, 0.27986884, 0.27679393, 0.2737453, 0.2707226, 0.2677254, 0.26475343, 0.26180625, 0.25888354, 0.25598502, 0.2531103, 0.25025907, 0.24743107, 0.24462597, 0.24184346, 0.23908329, 0.23634516, 0.23362878, 0.23093392, 0.2282603, 0.22560766, 0.22297576, 0.22036438, 0.21777324, 0.21520215, 0.21265087, 0.21011916, 0.20760682, 0.20511365, 0.20263945, 0.20018397, 0.19774707, 0.19532852, 0.19292815, 0.19054577, 0.1881812, 0.18583426, 0.18350479, 0.1811926, 0.17889754, 0.17661946, 0.17435817, 0.17211354, 0.1698854, 0.16767362, 0.16547804, 0.16329853, 0.16113494, 0.15898713, 0.15685499, 0.15473837, 0.15263714, 0.15055119, 0.14848037, 0.14642459, 0.14438373, 0.14235765, 0.14034624, 0.13834943, 0.13636707, 0.13439907, 0.13244532, 0.13050574, 0.1285802, 0.12666863, 0.12477092, 0.12288698, 0.12101672, 0.119160056, 0.1173169, 0.115487166, 0.11367077, 0.11186763, 0.11007768, 0.10830083, 0.10653701, 0.10478614, 0.10304816, 0.101323, 0.09961058, 0.09791085, 0.09622374, 0.09454919, 0.09288713, 0.091237515, 0.08960028, 0.087975375, 0.08636274, 0.08476233, 0.083174095, 0.081597984, 0.08003395, 0.07848195, 0.076941945, 0.07541389, 0.07389775, 0.072393484, 0.07090106, 0.069420435, 0.06795159, 0.066494495, 0.06504912, 0.063615434, 0.062193416, 0.060783047, 0.059384305, 0.057997175, 0.05662164, 0.05525769, 0.053905312, 0.052564494, 0.051235236, 0.049917534, 0.048611384, 0.047316793, 0.046033762, 0.0447623, 0.043502413, 0.042254124, 0.041017443, 0.039792392, 0.038578995, 0.037377283, 0.036187284, 0.035009038, 0.033842582, 0.032687962, 0.031545233, 0.030414443, 0.02929566, 0.02818895, 0.027094385, 0.026012046, 0.024942026, 0.023884421, 0.022839336, 0.021806888, 0.020787204, 0.019780423, 0.0187867, 0.0178062, 0.016839107, 0.015885621, 0.014945968, 0.014020392, 0.013109165, 0.012212592, 0.011331013, 0.01046481, 0.009614414, 0.008780315, 0.007963077, 0.0071633533, 0.006381906, 0.0056196423, 0.0048776558, 0.004157295, 0.0034602648, 0.0027887989, 0.0021459677, 0.0015362998, 0.0009672693, 0.00045413437]);
		kn = go$toNativeArray("Uint32", [1991057938, 0, 1611602771, 1826899878, 1918584482, 1969227037, 2001281515, 2023368125, 2039498179, 2051788381, 2061460127, 2069267110, 2075699398, 2081089314, 2085670119, 2089610331, 2093034710, 2096037586, 2098691595, 2101053571, 2103168620, 2105072996, 2106796166, 2108362327, 2109791536, 2111100552, 2112303493, 2113412330, 2114437283, 2115387130, 2116269447, 2117090813, 2117856962, 2118572919, 2119243101, 2119871411, 2120461303, 2121015852, 2121537798, 2122029592, 2122493434, 2122931299, 2123344971, 2123736059, 2124106020, 2124456175, 2124787725, 2125101763, 2125399283, 2125681194, 2125948325, 2126201433, 2126441213, 2126668298, 2126883268, 2127086657, 2127278949, 2127460589, 2127631985, 2127793506, 2127945490, 2128088244, 2128222044, 2128347141, 2128463758, 2128572095, 2128672327, 2128764606, 2128849065, 2128925811, 2128994934, 2129056501, 2129110560, 2129157136, 2129196237, 2129227847, 2129251929, 2129268426, 2129277255, 2129278312, 2129271467, 2129256561, 2129233410, 2129201800, 2129161480, 2129112170, 2129053545, 2128985244, 2128906855, 2128817916, 2128717911, 2128606255, 2128482298, 2128345305, 2128194452, 2128028813, 2127847342, 2127648860, 2127432031, 2127195339, 2126937058, 2126655214, 2126347546, 2126011445, 2125643893, 2125241376, 2124799783, 2124314271, 2123779094, 2123187386, 2122530867, 2121799464, 2120980787, 2120059418, 2119015917, 2117825402, 2116455471, 2114863093, 2112989789, 2110753906, 2108037662, 2104664315, 2100355223, 2094642347, 2086670106, 2074676188, 2054300022, 2010539237]);
		wn = go$toNativeArray("Float32", [1.7290405e-09, 1.2680929e-10, 1.6897518e-10, 1.9862688e-10, 2.2232431e-10, 2.4244937e-10, 2.601613e-10, 2.7611988e-10, 2.9073963e-10, 3.042997e-10, 3.1699796e-10, 3.289802e-10, 3.4035738e-10, 3.5121603e-10, 3.616251e-10, 3.7164058e-10, 3.8130857e-10, 3.9066758e-10, 3.9975012e-10, 4.08584e-10, 4.1719309e-10, 4.2559822e-10, 4.338176e-10, 4.418672e-10, 4.497613e-10, 4.5751258e-10, 4.651324e-10, 4.7263105e-10, 4.8001775e-10, 4.87301e-10, 4.944885e-10, 5.015873e-10, 5.0860405e-10, 5.155446e-10, 5.2241467e-10, 5.2921934e-10, 5.359635e-10, 5.426517e-10, 5.4928817e-10, 5.5587696e-10, 5.624219e-10, 5.6892646e-10, 5.753941e-10, 5.818282e-10, 5.882317e-10, 5.946077e-10, 6.00959e-10, 6.072884e-10, 6.135985e-10, 6.19892e-10, 6.2617134e-10, 6.3243905e-10, 6.386974e-10, 6.449488e-10, 6.511956e-10, 6.5744005e-10, 6.6368433e-10, 6.699307e-10, 6.7618144e-10, 6.824387e-10, 6.8870465e-10, 6.949815e-10, 7.012715e-10, 7.075768e-10, 7.1389966e-10, 7.202424e-10, 7.266073e-10, 7.329966e-10, 7.394128e-10, 7.4585826e-10, 7.5233547e-10, 7.58847e-10, 7.653954e-10, 7.719835e-10, 7.7861395e-10, 7.852897e-10, 7.920138e-10, 7.987892e-10, 8.0561924e-10, 8.125073e-10, 8.194569e-10, 8.2647167e-10, 8.3355556e-10, 8.407127e-10, 8.479473e-10, 8.55264e-10, 8.6266755e-10, 8.7016316e-10, 8.777562e-10, 8.8545243e-10, 8.932582e-10, 9.0117996e-10, 9.09225e-10, 9.174008e-10, 9.2571584e-10, 9.341788e-10, 9.427997e-10, 9.515889e-10, 9.605579e-10, 9.697193e-10, 9.790869e-10, 9.88676e-10, 9.985036e-10, 1.0085882e-09, 1.0189509e-09, 1.0296151e-09, 1.0406069e-09, 1.0519566e-09, 1.063698e-09, 1.0758702e-09, 1.0885183e-09, 1.1016947e-09, 1.1154611e-09, 1.1298902e-09, 1.1450696e-09, 1.1611052e-09, 1.1781276e-09, 1.1962995e-09, 1.2158287e-09, 1.2369856e-09, 1.2601323e-09, 1.2857697e-09, 1.3146202e-09, 1.347784e-09, 1.3870636e-09, 1.4357403e-09, 1.5008659e-09, 1.6030948e-09]);
		fn = go$toNativeArray("Float32", [1, 0.9635997, 0.9362827, 0.9130436, 0.89228165, 0.87324303, 0.8555006, 0.8387836, 0.8229072, 0.8077383, 0.793177, 0.7791461, 0.7655842, 0.7524416, 0.73967725, 0.7272569, 0.7151515, 0.7033361, 0.69178915, 0.68049186, 0.6694277, 0.658582, 0.6479418, 0.63749546, 0.6272325, 0.6171434, 0.6072195, 0.5974532, 0.58783704, 0.5783647, 0.56903, 0.5598274, 0.5507518, 0.54179835, 0.5329627, 0.52424055, 0.5156282, 0.50712204, 0.49871865, 0.49041483, 0.48220766, 0.4740943, 0.46607214, 0.4581387, 0.45029163, 0.44252872, 0.43484783, 0.427247, 0.41972435, 0.41227803, 0.40490642, 0.39760786, 0.3903808, 0.3832238, 0.37613547, 0.36911446, 0.3621595, 0.35526937, 0.34844297, 0.34167916, 0.33497685, 0.3283351, 0.3217529, 0.3152294, 0.30876362, 0.30235484, 0.29600215, 0.28970486, 0.2834622, 0.2772735, 0.27113807, 0.2650553, 0.25902456, 0.2530453, 0.24711695, 0.241239, 0.23541094, 0.22963232, 0.2239027, 0.21822165, 0.21258877, 0.20700371, 0.20146611, 0.19597565, 0.19053204, 0.18513499, 0.17978427, 0.17447963, 0.1692209, 0.16400786, 0.15884037, 0.15371831, 0.14864157, 0.14361008, 0.13862377, 0.13368265, 0.12878671, 0.12393598, 0.119130544, 0.11437051, 0.10965602, 0.104987256, 0.10036444, 0.095787846, 0.0912578, 0.08677467, 0.0823389, 0.077950984, 0.073611505, 0.06932112, 0.06508058, 0.06089077, 0.056752663, 0.0526674, 0.048636295, 0.044660863, 0.040742867, 0.03688439, 0.033087887, 0.029356318, 0.025693292, 0.022103304, 0.018592102, 0.015167298, 0.011839478, 0.008624485, 0.005548995, 0.0026696292]);
		rng_cooked = go$toNativeArray("Int64", [new Go$Int64(1173834291, 3952672746), new Go$Int64(1081821761, 3130416987), new Go$Int64(324977939, 3414273807), new Go$Int64(1241840476, 2806224363), new Go$Int64(669549340, 1997590414), new Go$Int64(2103305448, 2402795971), new Go$Int64(1663160183, 1140819369), new Go$Int64(1120601685, 1788868961), new Go$Int64(1848035537, 1089001426), new Go$Int64(1235702047, 873593504), new Go$Int64(1911387977, 581324885), new Go$Int64(492609478, 1609182556), new Go$Int64(1069394745, 1241596776), new Go$Int64(1895445337, 1771189259), new Go$Int64(772864846, 3467012610), new Go$Int64(2006957225, 2344407434), new Go$Int64(402115761, 782467244), new Go$Int64(26335124, 3404933915), new Go$Int64(1063924276, 618867887), new Go$Int64(1178782866, 520164395), new Go$Int64(555910815, 1341358184), new Go$Int64(632398609, 665794848), new Go$Int64(1527227641, 3183648150), new Go$Int64(1781176124, 696329606), new Go$Int64(1789146075, 4151988961), new Go$Int64(60039534, 998951326), new Go$Int64(1535158725, 1364957564), new Go$Int64(63173359, 4090230633), new Go$Int64(649454641, 4009697548), new Go$Int64(248009524, 2569622517), new Go$Int64(778703922, 3742421481), new Go$Int64(1038377625, 1506914633), new Go$Int64(1738099768, 1983412561), new Go$Int64(236311649, 1436266083), new Go$Int64(1035966148, 3922894967), new Go$Int64(810508934, 1792680179), new Go$Int64(563141142, 1188796351), new Go$Int64(1349617468, 405968250), new Go$Int64(1044074554, 433754187), new Go$Int64(870549669, 4073162024), new Go$Int64(1053232044, 433121399), new Go$Int64(2451824, 4162580594), new Go$Int64(2010221076, 4132415622), new Go$Int64(611252600, 3033822028), new Go$Int64(2016407895, 824682382), new Go$Int64(2366218, 3583765414), new Go$Int64(1522878809, 535386927), new Go$Int64(1637219058, 2286693689), new Go$Int64(1453075389, 2968466525), new Go$Int64(193683513, 1351410206), new Go$Int64(1863677552, 1412813499), new Go$Int64(492736522, 4126267639), new Go$Int64(512765208, 2105529399), new Go$Int64(2132966268, 2413882233), new Go$Int64(947457634, 32226200), new Go$Int64(1149341356, 2032329073), new Go$Int64(106485445, 1356518208), new Go$Int64(79673492, 3430061722), new Go$Int64(663048513, 3820169661), new Go$Int64(481498454, 2981816134), new Go$Int64(1017155588, 4184371017), new Go$Int64(206574701, 2119206761), new Go$Int64(1295374591, 2472200560), new Go$Int64(1587026100, 2853524696), new Go$Int64(1307803389, 1681119904), new Go$Int64(1972496813, 95608918), new Go$Int64(392686347, 3690479145), new Go$Int64(941912722, 1397922290), new Go$Int64(988169623, 1516129515), new Go$Int64(1827305493, 1547420459), new Go$Int64(1311333971, 1470949486), new Go$Int64(194013850, 1336785672), new Go$Int64(2102397034, 4131677129), new Go$Int64(755205548, 4246329084), new Go$Int64(1004983461, 3788585631), new Go$Int64(2081005363, 3080389532), new Go$Int64(1501045284, 2215402037), new Go$Int64(391002300, 1171593935), new Go$Int64(1408774047, 1423855166), new Go$Int64(1628305930, 2276716302), new Go$Int64(1779030508, 2068027241), new Go$Int64(1369359303, 3427553297), new Go$Int64(189241615, 3289637845), new Go$Int64(1057480830, 3486407650), new Go$Int64(634572984, 3071877822), new Go$Int64(1159653919, 3363620705), new Go$Int64(1213226718, 4159821533), new Go$Int64(2070861710, 1894661), new Go$Int64(1472989750, 1156868282), new Go$Int64(348271067, 776219088), new Go$Int64(1646054810, 2425634259), new Go$Int64(1716021749, 680510161), new Go$Int64(1573220192, 1310101429), new Go$Int64(1095885995, 2964454134), new Go$Int64(1821788136, 3467098407), new Go$Int64(1990672920, 2109628894), new Go$Int64(7834944, 1232604732), new Go$Int64(309412934, 3261916179), new Go$Int64(1699175360, 434597899), new Go$Int64(235436061, 1624796439), new Go$Int64(521080809, 3589632480), new Go$Int64(1198416575, 864579159), new Go$Int64(208735487, 1380889830), new Go$Int64(619206309, 2654509477), new Go$Int64(1419738251, 1468209306), new Go$Int64(403198876, 100794388), new Go$Int64(956062190, 2991674471), new Go$Int64(1938816907, 2224662036), new Go$Int64(1973824487, 977097250), new Go$Int64(1351320195, 726419512), new Go$Int64(1964023751, 1747974366), new Go$Int64(1394388465, 1556430604), new Go$Int64(1097991433, 1080776742), new Go$Int64(1761636690, 280794874), new Go$Int64(117767733, 919835643), new Go$Int64(1180474222, 3434019658), new Go$Int64(196069168, 2461941785), new Go$Int64(133215641, 3615001066), new Go$Int64(417204809, 3103414427), new Go$Int64(790056561, 3380809712), new Go$Int64(879802240, 2724693469), new Go$Int64(547796833, 598827710), new Go$Int64(300924196, 3452273442), new Go$Int64(2071705424, 649274915), new Go$Int64(1346182319, 2585724112), new Go$Int64(636549385, 3165579553), new Go$Int64(1185578221, 2635894283), new Go$Int64(2094573470, 2053289721), new Go$Int64(985976581, 3169337108), new Go$Int64(1170569632, 144717764), new Go$Int64(1079216270, 1383666384), new Go$Int64(2022678706, 681540375), new Go$Int64(1375448925, 537050586), new Go$Int64(182715304, 315246468), new Go$Int64(226402871, 849323088), new Go$Int64(1262421183, 45543944), new Go$Int64(1201038398, 2319052083), new Go$Int64(2106775454, 3613090841), new Go$Int64(560472520, 2992171180), new Go$Int64(1765620479, 2068244785), new Go$Int64(917538188, 4239862634), new Go$Int64(777927839, 3892253031), new Go$Int64(720683925, 958186149), new Go$Int64(1724185863, 1877702262), new Go$Int64(1357886971, 837674867), new Go$Int64(1837048883, 1507589294), new Go$Int64(1905518400, 873336795), new Go$Int64(267722611, 2764496274), new Go$Int64(341003118, 4196182374), new Go$Int64(1080717893, 550964545), new Go$Int64(818747069, 420611474), new Go$Int64(222653272, 204265180), new Go$Int64(1549974541, 1787046383), new Go$Int64(1215581865, 3102292318), new Go$Int64(418321538, 1552199393), new Go$Int64(1243493047, 980542004), new Go$Int64(267284263, 3293718720), new Go$Int64(1179528763, 3771917473), new Go$Int64(599484404, 2195808264), new Go$Int64(252818753, 3894702887), new Go$Int64(780007692, 2099949527), new Go$Int64(1424094358, 338442522), new Go$Int64(490737398, 637158004), new Go$Int64(419862118, 281976339), new Go$Int64(574970164, 3619802330), new Go$Int64(1715552825, 3084554784), new Go$Int64(882872465, 4129772886), new Go$Int64(43084605, 1680378557), new Go$Int64(525521057, 3339087776), new Go$Int64(1680500332, 4220317857), new Go$Int64(211654685, 2959322499), new Go$Int64(1675600481, 1488354890), new Go$Int64(1312620086, 3958162143), new Go$Int64(920972075, 2773705983), new Go$Int64(1876039582, 225908689), new Go$Int64(963748535, 908216283), new Go$Int64(1541787429, 3574646075), new Go$Int64(319760557, 1936937569), new Go$Int64(1519770881, 75492235), new Go$Int64(816689472, 1935193178), new Go$Int64(2142521206, 2018250883), new Go$Int64(455141620, 3943126022), new Go$Int64(1546084160, 3066544345), new Go$Int64(1932392669, 2793082663), new Go$Int64(908474287, 3297036421), new Go$Int64(1640597065, 2206987825), new Go$Int64(1594236910, 807894872), new Go$Int64(366158341, 766252117), new Go$Int64(2060649606, 3833114345), new Go$Int64(845619743, 1255067973), new Go$Int64(1201145605, 741697208), new Go$Int64(671241040, 2810093753), new Go$Int64(1109032642, 4229340371), new Go$Int64(1462188720, 1361684224), new Go$Int64(988084219, 1906263026), new Go$Int64(475781207, 3904421704), new Go$Int64(1523946520, 1769075545), new Go$Int64(1062308525, 2621599764), new Go$Int64(1279509432, 3431891480), new Go$Int64(404732502, 1871896503), new Go$Int64(128756421, 1412808876), new Go$Int64(1605404688, 952876175), new Go$Int64(1917039957, 1824438899), new Go$Int64(1662295856, 1005035476), new Go$Int64(1990909507, 527508597), new Go$Int64(1288873303, 3066806859), new Go$Int64(565995893, 3244940914), new Go$Int64(1257737460, 209092916), new Go$Int64(1899814242, 1242699167), new Go$Int64(1433653252, 456723774), new Go$Int64(1776978905, 1001252870), new Go$Int64(1468772157, 2026725874), new Go$Int64(857254202, 2137562569), new Go$Int64(765939740, 3183366709), new Go$Int64(1533887628, 2612072960), new Go$Int64(56977098, 1727148468), new Go$Int64(949899753, 3803658212), new Go$Int64(1883670356, 479946959), new Go$Int64(685713571, 1562982345), new Go$Int64(201241205, 1766109365), new Go$Int64(700596547, 3257093788), new Go$Int64(1962768719, 2365720207), new Go$Int64(93384808, 3742754173), new Go$Int64(1689098413, 2878193673), new Go$Int64(1096135042, 2174002182), new Go$Int64(1313222695, 3573511231), new Go$Int64(1392911121, 1760299077), new Go$Int64(771856457, 2260779833), new Go$Int64(1281464374, 1452805722), new Go$Int64(917811730, 2940011802), new Go$Int64(1890251082, 1886183802), new Go$Int64(893897673, 2514369088), new Go$Int64(1644345561, 3924317791), new Go$Int64(172616216, 500935732), new Go$Int64(1403501753, 676580929), new Go$Int64(581571365, 1184984890), new Go$Int64(1455515235, 1271474274), new Go$Int64(318728910, 3163791473), new Go$Int64(2051027584, 2842487377), new Go$Int64(1511537551, 2170968612), new Go$Int64(573262976, 3535856740), new Go$Int64(94256461, 1488599718), new Go$Int64(966951817, 3408913763), new Go$Int64(60951736, 2501050084), new Go$Int64(1272353200, 1639124157), new Go$Int64(138001144, 4088176393), new Go$Int64(1574896563, 3989947576), new Go$Int64(1982239940, 3414355209), new Go$Int64(1355154361, 2275136352), new Go$Int64(89709303, 2151835223), new Go$Int64(1216338715, 1654534827), new Go$Int64(1467562197, 377892833), new Go$Int64(1664767638, 660204544), new Go$Int64(85706799, 390828249), new Go$Int64(725310955, 3402783878), new Go$Int64(678849488, 3717936603), new Go$Int64(1113532086, 2211058823), new Go$Int64(1564224320, 2692150867), new Go$Int64(1952770442, 1928910388), new Go$Int64(788716862, 3931011137), new Go$Int64(1083670504, 1112701047), new Go$Int64(2079333076, 2452299106), new Go$Int64(1251318826, 2337204777), new Go$Int64(1774877857, 273889282), new Go$Int64(1798719843, 1462008793), new Go$Int64(2138834788, 1554494002), new Go$Int64(952516517, 182675323), new Go$Int64(548928884, 1882802136), new Go$Int64(589279648, 3700220025), new Go$Int64(381039426, 3083431543), new Go$Int64(1295624457, 3622207527), new Go$Int64(338126939, 432729309), new Go$Int64(480013522, 2391914317), new Go$Int64(297925497, 235747924), new Go$Int64(2120733629, 3088823825), new Go$Int64(1402403853, 2314658321), new Go$Int64(1165929723, 2957634338), new Go$Int64(501323675, 4117056981), new Go$Int64(1564699815, 1482500298), new Go$Int64(1406657158, 840489337), new Go$Int64(799522364, 3483178565), new Go$Int64(532129761, 2074004656), new Go$Int64(724246478, 3643392642), new Go$Int64(1482330167, 1583624461), new Go$Int64(1261660694, 287473085), new Go$Int64(1667835381, 3136843981), new Go$Int64(1138806821, 1266970974), new Go$Int64(135185781, 1998688839), new Go$Int64(392094735, 1492900209), new Go$Int64(1031326774, 1538112737), new Go$Int64(76914806, 2207265429), new Go$Int64(260686035, 963263315), new Go$Int64(1671145500, 2295892134), new Go$Int64(1068469660, 2002560897), new Go$Int64(1791233343, 1369254035), new Go$Int64(33436120, 3353312708), new Go$Int64(57507843, 947771099), new Go$Int64(201728503, 1747061399), new Go$Int64(1507240140, 2047354631), new Go$Int64(720000810, 4165367136), new Go$Int64(479265078, 3388864963), new Go$Int64(1195302398, 286492130), new Go$Int64(2045622690, 2795735007), new Go$Int64(1431753082, 3703961339), new Go$Int64(1999047161, 1797825479), new Go$Int64(1429039600, 1116589674), new Go$Int64(482063550, 2593309206), new Go$Int64(1329049334, 3404995677), new Go$Int64(1396904208, 3453462936), new Go$Int64(1014767077, 3016498634), new Go$Int64(75698599, 1650371545), new Go$Int64(1592007860, 212344364), new Go$Int64(1127766888, 3843932156), new Go$Int64(1399463792, 3573129983), new Go$Int64(1256901817, 665897820), new Go$Int64(1071492673, 1675628772), new Go$Int64(243225682, 2831752928), new Go$Int64(2120298836, 1486294219), new Go$Int64(193076235, 268782709), new Go$Int64(1145360145, 4186179080), new Go$Int64(624342951, 1613720397), new Go$Int64(857179861, 2703686015), new Go$Int64(1235864944, 2205342611), new Go$Int64(1474779655, 1411666394), new Go$Int64(619028749, 677744900), new Go$Int64(270855115, 4172867247), new Go$Int64(135494707, 2163418403), new Go$Int64(849547544, 2841526879), new Go$Int64(1029966689, 1082141470), new Go$Int64(377371856, 4046134367), new Go$Int64(51415528, 2142943655), new Go$Int64(1897659315, 3124627521), new Go$Int64(998228909, 219992939), new Go$Int64(1068692697, 1756846531), new Go$Int64(1283749206, 1225118210), new Go$Int64(1621625642, 1647770243), new Go$Int64(111523943, 444807907), new Go$Int64(2036369448, 3952076173), new Go$Int64(53201823, 1461839639), new Go$Int64(315761893, 3699250910), new Go$Int64(702974850, 1373688981), new Go$Int64(734022261, 147523747), new Go$Int64(100152742, 1211276581), new Go$Int64(1294440951, 2548832680), new Go$Int64(1144696256, 1995631888), new Go$Int64(154500578, 2011457303), new Go$Int64(796460974, 3057425772), new Go$Int64(667839456, 81484597), new Go$Int64(465502760, 3646681560), new Go$Int64(775020923, 635548515), new Go$Int64(602489502, 2508044581), new Go$Int64(353263531, 1014917157), new Go$Int64(719992433, 3214891315), new Go$Int64(852684611, 959582252), new Go$Int64(226415134, 3347040449), new Go$Int64(1784615552, 4102971975), new Go$Int64(397887437, 4078022210), new Go$Int64(1610679822, 2851767182), new Go$Int64(749162636, 1540160644), new Go$Int64(598384772, 1057290595), new Go$Int64(2034890660, 3907769253), new Go$Int64(579300318, 4248952684), new Go$Int64(1092907599, 132554364), new Go$Int64(1061621234, 1029351092), new Go$Int64(697840928, 2583007416), new Go$Int64(298619124, 1486185789), new Go$Int64(55905697, 2871589073), new Go$Int64(2017643612, 723203291), new Go$Int64(146250550, 2494333952), new Go$Int64(1064490251, 2230939180), new Go$Int64(342915576, 3943232912), new Go$Int64(1768732449, 2181367922), new Go$Int64(1418222537, 2889274791), new Go$Int64(1824032949, 2046728161), new Go$Int64(1653899792, 1376052477), new Go$Int64(1022327048, 381236993), new Go$Int64(1034385958, 3188942166), new Go$Int64(2073003539, 350070824), new Go$Int64(144881592, 61758415), new Go$Int64(1405659422, 3492950336), new Go$Int64(117440928, 3093818430), new Go$Int64(1693893113, 2962480613), new Go$Int64(235432940, 3154871160), new Go$Int64(511005079, 3228564679), new Go$Int64(610731502, 888276216), new Go$Int64(1200780674, 3574998604), new Go$Int64(870415268, 1967526716), new Go$Int64(591335707, 1554691298), new Go$Int64(574459414, 339944798), new Go$Int64(1223764147, 1154515356), new Go$Int64(1825645307, 967516237), new Go$Int64(1546195135, 596588202), new Go$Int64(279882768, 3764362170), new Go$Int64(492091056, 266611402), new Go$Int64(1754227768, 2047856075), new Go$Int64(1146757215, 21444105), new Go$Int64(1198058894, 3065563181), new Go$Int64(1915064845, 1140663212), new Go$Int64(633187674, 2323741028), new Go$Int64(2126290159, 3103873707), new Go$Int64(1008658319, 2766828349), new Go$Int64(1661896145, 1970872996), new Go$Int64(1628585413, 3766615585), new Go$Int64(1552335120, 2036813414), new Go$Int64(152606527, 3105536507), new Go$Int64(13954645, 3396176938), new Go$Int64(1426081645, 1377154485), new Go$Int64(2085644467, 3807014186), new Go$Int64(543009040, 3710110597), new Go$Int64(396058129, 916420443), new Go$Int64(734556788, 2103831255), new Go$Int64(381322154, 717331943), new Go$Int64(572884752, 3550505941), new Go$Int64(45939673, 378749927), new Go$Int64(149867929, 611017331), new Go$Int64(592130075, 758907650), new Go$Int64(1012992349, 154266815), new Go$Int64(1107028706, 1407468696), new Go$Int64(469292398, 970098704), new Go$Int64(1862426162, 1971660656), new Go$Int64(998365243, 3332747885), new Go$Int64(1947089649, 1935189867), new Go$Int64(1510248801, 203520055), new Go$Int64(842317902, 3916463034), new Go$Int64(1758884993, 3474113316), new Go$Int64(1036101639, 316544223), new Go$Int64(373738757, 1650844677), new Go$Int64(1240292229, 4267565603), new Go$Int64(1077208624, 2501167616), new Go$Int64(626831785, 3929401789), new Go$Int64(56122796, 337170252), new Go$Int64(1186981558, 2061966842), new Go$Int64(1843292800, 2508461464), new Go$Int64(206012532, 2791377107), new Go$Int64(1240791848, 1227227588), new Go$Int64(1813978778, 1709681848), new Go$Int64(1153692192, 3768820575), new Go$Int64(1145186199, 2887126398), new Go$Int64(700372314, 296561685), new Go$Int64(700300844, 3729960077), new Go$Int64(575172304, 372833036), new Go$Int64(2078875613, 2409779288), new Go$Int64(1829161290, 555274064), new Go$Int64(1041887929, 4239804901), new Go$Int64(1839403216, 3723486978), new Go$Int64(498390553, 2145871984), new Go$Int64(564717933, 3565480803), new Go$Int64(578829821, 2197313814), new Go$Int64(974785092, 3613674566), new Go$Int64(438638731, 3042093666), new Go$Int64(2050927384, 3324034321), new Go$Int64(869420878, 3708873369), new Go$Int64(946682149, 1698090092), new Go$Int64(1618900382, 4213940712), new Go$Int64(304003901, 2087477361), new Go$Int64(381315848, 2407950639), new Go$Int64(851258090, 3942568569), new Go$Int64(923583198, 4088074412), new Go$Int64(723260036, 2964773675), new Go$Int64(1473561819, 1539178386), new Go$Int64(1062961552, 2694849566), new Go$Int64(460977733, 2120273838), new Go$Int64(542912908, 2484608657), new Go$Int64(880846449, 2956190677), new Go$Int64(1970902366, 4223313749), new Go$Int64(662161910, 3502682327), new Go$Int64(705634754, 4133891139), new Go$Int64(1116124348, 1166449596), new Go$Int64(1038247601, 3362705993), new Go$Int64(93734798, 3892921029), new Go$Int64(1876124043, 786869787), new Go$Int64(1057490746, 1046342263), new Go$Int64(242763728, 493777327), new Go$Int64(1293910447, 3304827646), new Go$Int64(616460742, 125356352), new Go$Int64(499300063, 74094113), new Go$Int64(1351896723, 2500816079), new Go$Int64(1657235204, 514015239), new Go$Int64(1377565129, 543520454), new Go$Int64(107706923, 3614531153), new Go$Int64(2056746300, 2356753985), new Go$Int64(1390062617, 2018141668), new Go$Int64(131272971, 2087974891), new Go$Int64(644556607, 3166972343), new Go$Int64(372256200, 1517638666), new Go$Int64(1212207984, 173466846), new Go$Int64(1451709187, 4241513471), new Go$Int64(733932806, 2783126920), new Go$Int64(1972004134, 4167264826), new Go$Int64(29260506, 3907395640), new Go$Int64(1236582087, 1539634186), new Go$Int64(1551526350, 178241987), new Go$Int64(2034206012, 182168164), new Go$Int64(1044953189, 2386154934), new Go$Int64(1379126408, 4077374341), new Go$Int64(32803926, 1732699140), new Go$Int64(1726425903, 1041306002), new Go$Int64(1860414813, 2068001749), new Go$Int64(1005320202, 3208962910), new Go$Int64(844054010, 697710380), new Go$Int64(638124245, 2228431183), new Go$Int64(1337169671, 3554678728), new Go$Int64(1396494601, 173470263), new Go$Int64(2061597383, 3848297795), new Go$Int64(1220546671, 246236185), new Go$Int64(163293187, 2066374846), new Go$Int64(1771673660, 312890749), new Go$Int64(703378057, 3573310289), new Go$Int64(1548631747, 143166754), new Go$Int64(613554316, 2081511079), new Go$Int64(1197802104, 486038032), new Go$Int64(240999859, 2982218564), new Go$Int64(364901986, 1000939191), new Go$Int64(1902782651, 2750454885), new Go$Int64(1475638791, 3375313137), new Go$Int64(503615608, 881302957), new Go$Int64(638698903, 2514186393), new Go$Int64(443860803, 360024739), new Go$Int64(1399671872, 292500025), new Go$Int64(1381210821, 2276300752), new Go$Int64(521803381, 4069087683), new Go$Int64(208500981, 1637778212), new Go$Int64(720490469, 1676670893), new Go$Int64(1067262482, 3855174429), new Go$Int64(2114075974, 2067248671), new Go$Int64(2058057389, 2884561259), new Go$Int64(1341742553, 2456511185), new Go$Int64(983726246, 561175414), new Go$Int64(427994085, 432588903), new Go$Int64(885133709, 4059399550), new Go$Int64(2054387382, 1075014784), new Go$Int64(413651020, 2728058415), new Go$Int64(1839142064, 1299703678), new Go$Int64(1262333188, 2347583393), new Go$Int64(1285481956, 2468164145), new Go$Int64(989129637, 1140014346), new Go$Int64(2033889184, 1936972070), new Go$Int64(409904655, 3870530098), new Go$Int64(1662989391, 1717789158), new Go$Int64(1914486492, 1153452491), new Go$Int64(1157059232, 3948827651), new Go$Int64(790338018, 2101413152), new Go$Int64(1495744672, 3854091229), new Go$Int64(83644069, 4215565463), new Go$Int64(762206335, 1202710438), new Go$Int64(1582574611, 2072216740), new Go$Int64(705690639, 2066751068), new Go$Int64(33900336, 173902580), new Go$Int64(1405499842, 142459001), new Go$Int64(172391592, 1889151926), new Go$Int64(1648540523, 3034199774), new Go$Int64(1618587731, 516490102), new Go$Int64(93114264, 3692577783), new Go$Int64(68662295, 2953948865), new Go$Int64(1826544975, 4041040923), new Go$Int64(204965672, 592046130), new Go$Int64(1441840008, 384297211), new Go$Int64(95834184, 265863924), new Go$Int64(2101717619, 1333136237), new Go$Int64(1499611781, 1406273556), new Go$Int64(1074670496, 426305476), new Go$Int64(125704633, 2750898176), new Go$Int64(488068495, 1633944332), new Go$Int64(2037723464, 3236349343), new Go$Int64(444060402, 4013676611), new Go$Int64(1718532237, 2265047407), new Go$Int64(1433593806, 875071080), new Go$Int64(1804436145, 1418843655), new Go$Int64(2009228711, 451657300), new Go$Int64(1229446621, 1866374663), new Go$Int64(1653472867, 1551455622), new Go$Int64(577191481, 3560962459), new Go$Int64(1669204077, 3347903778), new Go$Int64(1849156454, 2675874918), new Go$Int64(316128071, 2762991672), new Go$Int64(530492383, 3689068477), new Go$Int64(844089962, 4071997905), new Go$Int64(1508155730, 1381702441), new Go$Int64(2089931018, 2373284878), new Go$Int64(1283216186, 2143983064), new Go$Int64(308739063, 1938207195), new Go$Int64(1754949306, 1188152253), new Go$Int64(1272345009, 615870490), new Go$Int64(742653194, 2662252621), new Go$Int64(1477718295, 3839976789), new Go$Int64(56149435, 306752547), new Go$Int64(720795581, 2162363077), new Go$Int64(2090431015, 2767224719), new Go$Int64(675859549, 2628837712), new Go$Int64(1678405918, 2967771969), new Go$Int64(1694285728, 499792248), new Go$Int64(403352367, 4285253508), new Go$Int64(962357072, 2856511070), new Go$Int64(679471692, 2526409716), new Go$Int64(353777175, 1240875658), new Go$Int64(1232590226, 2577342868), new Go$Int64(1146185433, 4136853496), new Go$Int64(670368674, 2403540137), new Go$Int64(1372824515, 1371410668), new Go$Int64(1970921600, 371758825), new Go$Int64(1706420536, 1528834084), new Go$Int64(2075795018, 1504757260), new Go$Int64(685663576, 699052551), new Go$Int64(1641940109, 3347789870), new Go$Int64(1951619734, 3430604759), new Go$Int64(2119672219, 1935601723), new Go$Int64(966789690, 834676166)]);
		globalRand = New(new lockedSource.Ptr(new sync.Mutex.Ptr(), NewSource(new Go$Int64(0, 1))));
	};
	return go$pkg;
})();
go$packages["github.com/rusco/todomvc/utils"] = (function() {
	var go$pkg = {};
	var json = go$packages["encoding/json"];
	var fmt = go$packages["fmt"];
	var js = go$packages["github.com/neelance/gopherjs/js"];
	var rand = go$packages["math/rand"];
	var time = go$packages["time"];
	var Handlebar;
	Handlebar = go$newType(0, "Struct", "utils.Handlebar", "Handlebar", "github.com/rusco/todomvc/utils", function(Object_) {
		this.go$val = this;
		this.Object = Object_ !== undefined ? Object_ : null;
	});
	Handlebar.prototype.Bool = function() { return this.go$val.Bool(); };
	Handlebar.Ptr.prototype.Bool = function() { return this.Object.Bool(); };
	Handlebar.prototype.Call = function(name, args) { return this.go$val.Call(name, args); };
	Handlebar.Ptr.prototype.Call = function(name, args) { return this.Object.Call(name, args); };
	Handlebar.prototype.Float = function() { return this.go$val.Float(); };
	Handlebar.Ptr.prototype.Float = function() { return this.Object.Float(); };
	Handlebar.prototype.Get = function(name) { return this.go$val.Get(name); };
	Handlebar.Ptr.prototype.Get = function(name) { return this.Object.Get(name); };
	Handlebar.prototype.Index = function(i) { return this.go$val.Index(i); };
	Handlebar.Ptr.prototype.Index = function(i) { return this.Object.Index(i); };
	Handlebar.prototype.Int = function() { return this.go$val.Int(); };
	Handlebar.Ptr.prototype.Int = function() { return this.Object.Int(); };
	Handlebar.prototype.Interface = function() { return this.go$val.Interface(); };
	Handlebar.Ptr.prototype.Interface = function() { return this.Object.Interface(); };
	Handlebar.prototype.Invoke = function(args) { return this.go$val.Invoke(args); };
	Handlebar.Ptr.prototype.Invoke = function(args) { return this.Object.Invoke(args); };
	Handlebar.prototype.IsNull = function() { return this.go$val.IsNull(); };
	Handlebar.Ptr.prototype.IsNull = function() { return this.Object.IsNull(); };
	Handlebar.prototype.IsUndefined = function() { return this.go$val.IsUndefined(); };
	Handlebar.Ptr.prototype.IsUndefined = function() { return this.Object.IsUndefined(); };
	Handlebar.prototype.Length = function() { return this.go$val.Length(); };
	Handlebar.Ptr.prototype.Length = function() { return this.Object.Length(); };
	Handlebar.prototype.New = function(args) { return this.go$val.New(args); };
	Handlebar.Ptr.prototype.New = function(args) { return this.Object.New(args); };
	Handlebar.prototype.Set = function(name, value) { return this.go$val.Set(name, value); };
	Handlebar.Ptr.prototype.Set = function(name, value) { return this.Object.Set(name, value); };
	Handlebar.prototype.SetIndex = function(i, value) { return this.go$val.SetIndex(i, value); };
	Handlebar.Ptr.prototype.SetIndex = function(i, value) { return this.Object.SetIndex(i, value); };
	Handlebar.prototype.String = function() { return this.go$val.String(); };
	Handlebar.Ptr.prototype.String = function() { return this.Object.String(); };
	go$pkg.Handlebar = Handlebar;
	Handlebar.init([["", "", js.Object, ""]]);
	Handlebar.methods = [["Bool", "", [], [Go$Bool], false], ["Call", "", [Go$String, (go$sliceType(go$emptyInterface))], [js.Object], true], ["Float", "", [], [Go$Float64], false], ["Get", "", [Go$String], [js.Object], false], ["Index", "", [Go$Int], [js.Object], false], ["Int", "", [], [Go$Int], false], ["Interface", "", [], [go$emptyInterface], false], ["Invoke", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["IsNull", "", [], [Go$Bool], false], ["IsUndefined", "", [], [Go$Bool], false], ["Length", "", [], [Go$Int], false], ["New", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["Set", "", [Go$String, go$emptyInterface], [], false], ["SetIndex", "", [Go$Int, go$emptyInterface], [], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Handlebar)).methods = [["Bool", "", [], [Go$Bool], false], ["Call", "", [Go$String, (go$sliceType(go$emptyInterface))], [js.Object], true], ["Float", "", [], [Go$Float64], false], ["Get", "", [Go$String], [js.Object], false], ["Index", "", [Go$Int], [js.Object], false], ["Int", "", [], [Go$Int], false], ["Interface", "", [], [go$emptyInterface], false], ["Invoke", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["IsNull", "", [], [Go$Bool], false], ["IsUndefined", "", [], [Go$Bool], false], ["Length", "", [], [Go$Int], false], ["New", "", [(go$sliceType(go$emptyInterface))], [js.Object], true], ["Set", "", [Go$String, go$emptyInterface], [], false], ["SetIndex", "", [Go$Int, go$emptyInterface], [], false], ["String", "", [], [Go$String], false]];
	var Store = go$pkg.Store = function(key, val) {
		var _tuple, byteArr, str;
		_tuple = json.Marshal(val), byteArr = _tuple[0];
		str = go$bytesToString(byteArr);
		go$global.localStorage.setItem(go$externalize(key, Go$String), go$externalize(str, Go$String));
	};
	var Retrieve = go$pkg.Retrieve = function(key, val) {
		var item, str, v;
		item = go$global.localStorage.getItem(go$externalize(key, Go$String));
		if (item === null) {
			val = null;
			return;
		}
		str = go$internalize(item, Go$String);
		json.Unmarshal(new (go$sliceType(Go$Uint8))(go$stringToBytes(str)), new (go$ptrType(go$emptyInterface))(function() { return val; }, function(v) { val = v; }));
	};
	var Pluralize = go$pkg.Pluralize = function(count, word) {
		if (count === 1) {
			return word;
		}
		return word + "s";
	};
	var Uuid = go$pkg.Uuid = function() {
		var uuid, i, rand$1, _ref, _ref$1;
		uuid = "";
		i = 0;
		while (i < 32) {
			rand$1 = (go$parseFloat(go$global.Math.random()) * 16 >> 0) | 0;
			_ref = i;
			if (_ref === 8 || _ref === 12 || _ref === 16 || _ref === 20) {
				uuid = uuid + "-";
			}
			_ref$1 = i;
			if (_ref$1 === 12) {
				uuid = uuid + "4";
			} else if (_ref$1 === 16) {
				uuid = uuid + (go$internalize(new go$global.Number((rand$1 & 3) | 8).toString(16), Go$String));
			} else {
				uuid = uuid + (go$internalize(new go$global.Number(rand$1).toString(16), Go$String));
			}
			i = i + 1 >> 0;
		}
		return uuid;
	};
	var UuidNative = go$pkg.UuidNative = function() {
		var uuid, i, x, x$1, random, _ref, _ref$1;
		uuid = "";
		i = 0;
		while (i < 32) {
			rand.Seed((x = time.Now().UnixNano(), x$1 = new Go$Int64(0, i), new Go$Int64(x.high + x$1.high, x.low + x$1.low)));
			random = rand.Intn(16);
			_ref = i;
			if (_ref === 8 || _ref === 12 || _ref === 16 || _ref === 20) {
				uuid = uuid + "-";
			}
			_ref$1 = i;
			if (_ref$1 === 12) {
				uuid = uuid + (fmt.Sprintf("%X", new (go$sliceType(go$emptyInterface))([new Go$Int(4)])));
			} else if (_ref$1 === 16) {
				uuid = uuid + (fmt.Sprintf("%X", new (go$sliceType(go$emptyInterface))([new Go$Int(((random & 3) | 8))])));
			} else {
				uuid = uuid + (fmt.Sprintf("%X", new (go$sliceType(go$emptyInterface))([new Go$Int(random)])));
			}
			i = i + 1 >> 0;
		}
		return uuid;
	};
	var CompileHandlebar = go$pkg.CompileHandlebar = function(template) {
		var h;
		h = go$global.Handlebars.compile(go$externalize(template, Go$String));
		return new Handlebar.Ptr(h);
	};
	var RenderHandlebar = go$pkg.RenderHandlebar = function(hb, i) {
		return go$internalize(hb.Object(go$externalize(i, go$emptyInterface)), Go$String);
	};
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$packages["main"] = (function() {
	var go$pkg = {};
	var jquery = go$packages["github.com/rusco/jquery"];
	var utils = go$packages["github.com/rusco/todomvc/utils"];
	var ToDo;
	ToDo = go$newType(0, "Struct", "main.ToDo", "ToDo", "main", function(Id_, Text_, Completed_) {
		this.go$val = this;
		this.Id = Id_ !== undefined ? Id_ : "";
		this.Text = Text_ !== undefined ? Text_ : "";
		this.Completed = Completed_ !== undefined ? Completed_ : false;
	});
	go$pkg.ToDo = ToDo;
	var App;
	App = go$newType(0, "Struct", "main.App", "App", "main", function(todos_, todoHb_, footerHb_, todoAppJq_, headerJq_, mainJq_, footerJq_, newTodoJq_, toggleAllJq_, todoListJq_, countJq_, clearBtnJq_) {
		this.go$val = this;
		this.todos = todos_ !== undefined ? todos_ : (go$sliceType(ToDo)).nil;
		this.todoHb = todoHb_ !== undefined ? todoHb_ : (go$ptrType(utils.Handlebar)).nil;
		this.footerHb = footerHb_ !== undefined ? footerHb_ : (go$ptrType(utils.Handlebar)).nil;
		this.todoAppJq = todoAppJq_ !== undefined ? todoAppJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.headerJq = headerJq_ !== undefined ? headerJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.mainJq = mainJq_ !== undefined ? mainJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.footerJq = footerJq_ !== undefined ? footerJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.newTodoJq = newTodoJq_ !== undefined ? newTodoJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.toggleAllJq = toggleAllJq_ !== undefined ? toggleAllJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.todoListJq = todoListJq_ !== undefined ? todoListJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.countJq = countJq_ !== undefined ? countJq_ : (go$ptrType(jquery.JQuery)).nil;
		this.clearBtnJq = clearBtnJq_ !== undefined ? clearBtnJq_ : (go$ptrType(jquery.JQuery)).nil;
	});
	go$pkg.App = App;
	ToDo.init([["Id", "", Go$String, ""], ["Text", "", Go$String, ""], ["Completed", "", Go$Bool, ""]]);
	App.init([["todos", "main", (go$sliceType(ToDo)), ""], ["todoHb", "main", (go$ptrType(utils.Handlebar)), ""], ["footerHb", "main", (go$ptrType(utils.Handlebar)), ""], ["todoAppJq", "main", (go$ptrType(jquery.JQuery)), ""], ["headerJq", "main", (go$ptrType(jquery.JQuery)), ""], ["mainJq", "main", (go$ptrType(jquery.JQuery)), ""], ["footerJq", "main", (go$ptrType(jquery.JQuery)), ""], ["newTodoJq", "main", (go$ptrType(jquery.JQuery)), ""], ["toggleAllJq", "main", (go$ptrType(jquery.JQuery)), ""], ["todoListJq", "main", (go$ptrType(jquery.JQuery)), ""], ["countJq", "main", (go$ptrType(jquery.JQuery)), ""], ["clearBtnJq", "main", (go$ptrType(jquery.JQuery)), ""]]);
	(go$ptrType(App)).methods = [["activeTodoCount", "main", [], [Go$Int], false], ["bindEvents", "main", [], [], false], ["blurOnEnter", "main", [(go$ptrType(jquery.Event))], [], false], ["create", "main", [(go$ptrType(jquery.Event))], [], false], ["destroy", "main", [(go$ptrType(jquery.Event))], [], false], ["destroyCompleted", "main", [(go$ptrType(jquery.Event))], [], false], ["edit", "main", [(go$ptrType(jquery.Event))], [], false], ["render", "main", [], [], false], ["renderfooter", "main", [], [], false], ["toggle", "main", [(go$ptrType(jquery.Event))], [], false], ["toggleAll", "main", [(go$ptrType(jquery.Event))], [], false], ["update", "main", [(go$ptrType(jquery.Event))], [], false]];
	var main = go$pkg.main = function() {
		var app;
		app = NewApp();
		app.bindEvents();
		app.render();
	};
	var NewApp = go$pkg.NewApp = function() {
		var somethingToDo, v, todoTemplate, todoHb, footerTemplate, footerHb, todoAppJq, headerJq, mainJq, footerJq, newTodoJq, toggleAllJq, todoListJq, countJq, clearBtnJq;
		somethingToDo = (go$sliceType(ToDo)).make(0, 0, function() { return new ToDo.Ptr(); });
		utils.Retrieve("TodoMVC-GopherJS", new (go$ptrType((go$sliceType(ToDo))))(function() { return somethingToDo; }, function(v) { somethingToDo = v; }));
		todoTemplate = jquery.NewJQuery(new (go$sliceType(Go$String))(["#todo-template"])).Html();
		todoHb = utils.CompileHandlebar(todoTemplate);
		footerTemplate = jquery.NewJQuery(new (go$sliceType(Go$String))(["#footer-template"])).Html();
		footerHb = utils.CompileHandlebar(footerTemplate);
		todoAppJq = jquery.NewJQuery(new (go$sliceType(Go$String))(["#todoapp"]));
		headerJq = todoAppJq.Find("#header");
		mainJq = todoAppJq.Find("#main");
		footerJq = todoAppJq.Find("#footer");
		newTodoJq = headerJq.Find("#new-todo");
		toggleAllJq = mainJq.Find("#toggle-all");
		todoListJq = mainJq.Find("#todo-list");
		countJq = footerJq.Find("#todo-count");
		clearBtnJq = footerJq.Find("#clear-completed");
		return new App.Ptr(somethingToDo, todoHb, footerHb, todoAppJq, headerJq, mainJq, footerJq, newTodoJq, toggleAllJq, todoListJq, countJq, clearBtnJq);
	};
	App.Ptr.prototype.bindEvents = function() {
		var a, e, _recv, e$1, _recv$1, e$2, _recv$2, e$3, _recv$3, e$4, _recv$4, e$5, _recv$5, e$6, _recv$6, e$7, _recv$7;
		a = this;
		a.newTodoJq.On("keyup", (_recv = a, function(e) { return _recv.create(e); }));
		a.toggleAllJq.On("change", (_recv$1 = a, function(e$1) { return _recv$1.toggleAll(e$1); }));
		a.footerJq.OnSelector("click", "#clear-completed", (_recv$2 = a, function(e$2) { return _recv$2.destroyCompleted(e$2); }));
		a.todoListJq.OnSelector("change", ".toggle", (_recv$3 = a, function(e$3) { return _recv$3.toggle(e$3); }));
		a.todoListJq.OnSelector("dblclick", "label", (_recv$4 = a, function(e$4) { return _recv$4.edit(e$4); }));
		a.todoListJq.OnSelector("keypress", ".edit", (_recv$5 = a, function(e$5) { return _recv$5.blurOnEnter(e$5); }));
		a.todoListJq.OnSelector("blur", ".edit", (_recv$6 = a, function(e$6) { return _recv$6.update(e$6); }));
		a.todoListJq.OnSelector("click", ".destroy", (_recv$7 = a, function(e$7) { return _recv$7.destroy(e$7); }));
	};
	App.prototype.bindEvents = function() { return this.go$val.bindEvents(); };
	App.Ptr.prototype.render = function() {
		var a, strtodoHb;
		a = this;
		strtodoHb = go$internalize(a.todoHb.Object(go$externalize(a.todos, (go$sliceType(ToDo)))), Go$String);
		a.todoListJq.SetHtml(strtodoHb);
		a.mainJq.Toggle(a.todos.length > 0);
		a.toggleAllJq.SetProp("checked", !((a.activeTodoCount() === 0)));
		a.renderfooter();
		utils.Store("TodoMVC-GopherJS", a.todos);
	};
	App.prototype.render = function() { return this.go$val.render(); };
	App.Ptr.prototype.renderfooter = function() {
		var a, activeTodoCount, activeTodoWord, completedTodos, footerData, footerJqStr;
		a = this;
		activeTodoCount = a.activeTodoCount();
		activeTodoWord = utils.Pluralize(activeTodoCount, "item");
		completedTodos = a.todos.length - activeTodoCount >> 0;
		footerData = new (go$structType([["ActiveTodoCount", "", Go$Int, ""], ["ActiveTodoWord", "", Go$String, ""], ["CompletedTodos", "", Go$Int, ""]])).Ptr(activeTodoCount, activeTodoWord, completedTodos);
		footerJqStr = go$internalize(a.footerHb.Object(go$externalize(footerData, (go$structType([["ActiveTodoCount", "", Go$Int, ""], ["ActiveTodoWord", "", Go$String, ""], ["CompletedTodos", "", Go$Int, ""]])))), Go$String);
		a.footerJq.Toggle(a.todos.length > 0).SetHtml(footerJqStr);
	};
	App.prototype.renderfooter = function() { return this.go$val.renderfooter(); };
	App.Ptr.prototype.toggleAll = function(e) {
		var a, checked, _ref, _i, idx, _slice, _index;
		a = this;
		checked = !a.toggleAllJq.Prop("checked");
		_ref = a.todos;
		_i = 0;
		while (_i < _ref.length) {
			idx = _i;
			(_slice = a.todos, _index = idx, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Completed = checked;
			_i++;
		}
		a.render();
	};
	App.prototype.toggleAll = function(e) { return this.go$val.toggleAll(e); };
	App.Ptr.prototype.activeTodoCount = function() {
		var a, count, _ref, _i, _slice, _index, _struct, val;
		a = this;
		count = 0;
		_ref = a.todos;
		_i = 0;
		while (_i < _ref.length) {
			val = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new ToDo.Ptr(_struct.Id, _struct.Text, _struct.Completed));
			if (!val.Completed) {
				count = count + 1 >> 0;
			}
			_i++;
		}
		return count;
	};
	App.prototype.activeTodoCount = function() { return this.go$val.activeTodoCount(); };
	App.Ptr.prototype.destroyCompleted = function(e) {
		var a, todosTmp, _ref, _i, _slice, _index, _struct, val, _struct$1;
		a = this;
		todosTmp = (go$sliceType(ToDo)).make(0, 0, function() { return new ToDo.Ptr(); });
		_ref = a.todos;
		_i = 0;
		while (_i < _ref.length) {
			val = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new ToDo.Ptr(_struct.Id, _struct.Text, _struct.Completed));
			if (!val.Completed) {
				todosTmp = go$append(todosTmp, (_struct$1 = val, new ToDo.Ptr(_struct$1.Id, _struct$1.Text, _struct$1.Completed)));
			}
			_i++;
		}
		a.todos = (go$sliceType(ToDo)).make(todosTmp.length, 0, function() { return new ToDo.Ptr(); });
		go$copySlice(a.todos, todosTmp);
		a.render();
	};
	App.prototype.destroyCompleted = function(e) { return this.go$val.destroyCompleted(e); };
	App.Ptr.prototype.create = function(e) {
		var a, val, thisKeycode, newToDo, _struct;
		a = this;
		val = jquery.Trim(a.newTodoJq.Val());
		thisKeycode = go$parseInt(e.Object.keyCode) >> 0;
		if (val === "" || !((thisKeycode === 13))) {
			return;
		}
		newToDo = new ToDo.Ptr(utils.Uuid(), val, false);
		a.todos = go$append(a.todos, (_struct = newToDo, new ToDo.Ptr(_struct.Id, _struct.Text, _struct.Completed)));
		a.newTodoJq.SetVal("");
		a.render();
	};
	App.prototype.create = function(e) { return this.go$val.create(e); };
	App.Ptr.prototype.toggle = function(e) {
		var a, id, _ref, _i, _slice, _index, _struct, val, idx, _slice$1, _index$1, _slice$2, _index$2;
		a = this;
		id = jquery.NewJQueryFromObject(e.This).Closest("li").Data("id");
		_ref = a.todos;
		_i = 0;
		while (_i < _ref.length) {
			val = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new ToDo.Ptr(_struct.Id, _struct.Text, _struct.Completed));
			idx = _i;
			if (val.Id === id) {
				(_slice$2 = a.todos, _index$2 = idx, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).Completed = !(_slice$1 = a.todos, _index$1 = idx, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Completed;
			}
			_i++;
		}
		a.render();
	};
	App.prototype.toggle = function(e) { return this.go$val.toggle(e); };
	App.Ptr.prototype.edit = function(e) {
		var a, thisJq, input, val;
		a = this;
		thisJq = jquery.NewJQueryFromObject(e.This);
		input = thisJq.Closest("li").AddClass("editing").Find(".edit");
		val = input.Val();
		input.SetVal(val).Focus();
	};
	App.prototype.edit = function(e) { return this.go$val.edit(e); };
	App.Ptr.prototype.blurOnEnter = function(e) {
		var a, thisKeycode;
		a = this;
		thisKeycode = go$parseInt(e.Object.keyCode) >> 0;
		if (thisKeycode === 13) {
			jquery.NewJQueryFromObject(e.This).Blur();
		}
	};
	App.prototype.blurOnEnter = function(e) { return this.go$val.blurOnEnter(e); };
	App.Ptr.prototype.update = function(e) {
		var a, thisJq, val, id, _ref, _i, idx, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, todosTmp, _ref$1, _i$1, _slice$3, _index$3, _struct, val$1, _struct$1;
		a = this;
		thisJq = jquery.NewJQueryFromObject(e.This);
		val = jquery.Trim(thisJq.Val());
		id = thisJq.Closest("li").RemoveClass("editing").Data("id");
		_ref = a.todos;
		_i = 0;
		while (_i < _ref.length) {
			idx = _i;
			if ((_slice = a.todos, _index = idx, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Id === id) {
				if (val.length > 0) {
					(_slice$1 = a.todos, _index$1 = idx, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Text = val;
				} else {
					(_slice$2 = a.todos, _index$2 = idx, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).Id = "delete";
				}
			}
			_i++;
		}
		todosTmp = (go$sliceType(ToDo)).make(0, 0, function() { return new ToDo.Ptr(); });
		_ref$1 = a.todos;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			val$1 = (_struct = (_slice$3 = _ref$1, _index$3 = _i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")), new ToDo.Ptr(_struct.Id, _struct.Text, _struct.Completed));
			if (!(val$1.Id === "delete")) {
				todosTmp = go$append(todosTmp, (_struct$1 = val$1, new ToDo.Ptr(_struct$1.Id, _struct$1.Text, _struct$1.Completed)));
			}
			_i$1++;
		}
		a.todos = (go$sliceType(ToDo)).make(todosTmp.length, 0, function() { return new ToDo.Ptr(); });
		go$copySlice(a.todos, todosTmp);
		a.render();
	};
	App.prototype.update = function(e) { return this.go$val.update(e); };
	App.Ptr.prototype.destroy = function(e) {
		var a, id, todosTmp, _ref, _i, _slice, _index, _struct, val, _struct$1;
		a = this;
		id = jquery.NewJQueryFromObject(e.This).Closest("li").Data("id");
		todosTmp = (go$sliceType(ToDo)).make(0, 0, function() { return new ToDo.Ptr(); });
		_ref = a.todos;
		_i = 0;
		while (_i < _ref.length) {
			val = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new ToDo.Ptr(_struct.Id, _struct.Text, _struct.Completed));
			if (!(val.Id === id)) {
				todosTmp = go$append(todosTmp, (_struct$1 = val, new ToDo.Ptr(_struct$1.Id, _struct$1.Text, _struct$1.Completed)));
			}
			_i++;
		}
		a.todos = (go$sliceType(ToDo)).make(todosTmp.length, 0, function() { return new ToDo.Ptr(); });
		go$copySlice(a.todos, todosTmp);
		a.render();
	};
	App.prototype.destroy = function(e) { return this.go$val.destroy(e); };
	go$pkg.init = function() {
	};
	return go$pkg;
})();
go$error.implementedBy = [go$packages["encoding/base64"].CorruptInputError, go$packages["encoding/json"].InvalidUTF8Error.Ptr, go$packages["encoding/json"].InvalidUnmarshalError.Ptr, go$packages["encoding/json"].MarshalerError.Ptr, go$packages["encoding/json"].SyntaxError.Ptr, go$packages["encoding/json"].UnmarshalFieldError.Ptr, go$packages["encoding/json"].UnmarshalTypeError.Ptr, go$packages["encoding/json"].UnsupportedTypeError.Ptr, go$packages["encoding/json"].UnsupportedValueError.Ptr, go$packages["errors"].errorString.Ptr, go$packages["github.com/neelance/gopherjs/js"].Error.Ptr, go$packages["os"].LinkError.Ptr, go$packages["os"].PathError.Ptr, go$packages["os"].SyscallError.Ptr, go$packages["reflect"].ValueError.Ptr, go$packages["runtime"].TypeAssertionError.Ptr, go$packages["runtime"].errorCString, go$packages["runtime"].errorString, go$packages["strconv"].NumError.Ptr, go$packages["syscall"].DLLError.Ptr, go$packages["syscall"].Errno, go$packages["time"].ParseError.Ptr, go$ptrType(go$packages["encoding/base64"].CorruptInputError), go$ptrType(go$packages["runtime"].errorCString), go$ptrType(go$packages["runtime"].errorString), go$ptrType(go$packages["syscall"].Errno)];
go$packages["runtime"].Error.implementedBy = [go$packages["runtime"].TypeAssertionError.Ptr, go$packages["runtime"].errorCString, go$packages["runtime"].errorString, go$ptrType(go$packages["runtime"].errorCString), go$ptrType(go$packages["runtime"].errorString)];
go$packages["runtime"].stringer.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].Number, go$packages["encoding/json"].encodeState.Ptr, go$packages["github.com/neelance/gopherjs/js"].Error, go$packages["github.com/neelance/gopherjs/js"].Error.Ptr, go$packages["github.com/rusco/jquery"].Event, go$packages["github.com/rusco/jquery"].Event.Ptr, go$packages["github.com/rusco/todomvc/utils"].Handlebar, go$packages["github.com/rusco/todomvc/utils"].Handlebar.Ptr, go$packages["os"].FileMode, go$packages["os"].ProcessState.Ptr, go$packages["reflect"].ChanDir, go$packages["reflect"].Kind, go$packages["reflect"].Value, go$packages["reflect"].Value.Ptr, go$packages["reflect"].arrayType.Ptr, go$packages["reflect"].chanType.Ptr, go$packages["reflect"].funcType.Ptr, go$packages["reflect"].interfaceType.Ptr, go$packages["reflect"].mapType.Ptr, go$packages["reflect"].ptrType.Ptr, go$packages["reflect"].rtype.Ptr, go$packages["reflect"].sliceType.Ptr, go$packages["reflect"].structType.Ptr, go$packages["strconv"].decimal.Ptr, go$packages["syscall"].Signal, go$packages["time"].Duration, go$packages["time"].Location.Ptr, go$packages["time"].Month, go$packages["time"].Time, go$packages["time"].Time.Ptr, go$packages["time"].Weekday, go$ptrType(go$packages["encoding/json"].Number), go$ptrType(go$packages["os"].FileMode), go$ptrType(go$packages["reflect"].ChanDir), go$ptrType(go$packages["reflect"].Kind), go$ptrType(go$packages["syscall"].Signal), go$ptrType(go$packages["time"].Duration), go$ptrType(go$packages["time"].Month), go$ptrType(go$packages["time"].Weekday)];
go$packages["github.com/neelance/gopherjs/js"].Object.implementedBy = [go$packages["github.com/neelance/gopherjs/js"].Error, go$packages["github.com/neelance/gopherjs/js"].Error.Ptr, go$packages["github.com/rusco/jquery"].Event, go$packages["github.com/rusco/jquery"].Event.Ptr, go$packages["github.com/rusco/todomvc/utils"].Handlebar, go$packages["github.com/rusco/todomvc/utils"].Handlebar.Ptr];
go$packages["sync"].Locker.implementedBy = [go$packages["os"].fileStat.Ptr, go$packages["sync"].Mutex.Ptr, go$packages["sync"].RWMutex.Ptr, go$packages["sync"].rlocker.Ptr];
go$packages["io"].ByteReader.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].ByteScanner.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].ByteWriter.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$ptrType(go$packages["fmt"].buffer)];
go$packages["io"].Closer.implementedBy = [go$packages["encoding/base64"].encoder.Ptr, go$packages["io"].PipeReader.Ptr, go$packages["io"].PipeWriter.Ptr, go$packages["os"].File.Ptr, go$packages["syscall"].Token, go$ptrType(go$packages["syscall"].Token)];
go$packages["io"].ReadCloser.implementedBy = [go$packages["io"].PipeReader.Ptr, go$packages["os"].File.Ptr];
go$packages["io"].ReadSeeker.implementedBy = [go$packages["bytes"].Reader.Ptr, go$packages["io"].SectionReader.Ptr, go$packages["os"].File.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].ReadWriteCloser.implementedBy = [go$packages["os"].File.Ptr];
go$packages["io"].ReadWriteSeeker.implementedBy = [go$packages["os"].File.Ptr];
go$packages["io"].ReadWriter.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["os"].File.Ptr];
go$packages["io"].Reader.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/base64"].decoder.Ptr, go$packages["encoding/base64"].newlineFilteringReader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["fmt"].ss.Ptr, go$packages["io"].LimitedReader.Ptr, go$packages["io"].PipeReader.Ptr, go$packages["io"].SectionReader.Ptr, go$packages["io"].multiReader.Ptr, go$packages["io"].teeReader.Ptr, go$packages["os"].File.Ptr, go$packages["strings"].Reader.Ptr, go$ptrType(go$packages["fmt"].stringReader)];
go$packages["io"].ReaderAt.implementedBy = [go$packages["bytes"].Reader.Ptr, go$packages["io"].SectionReader.Ptr, go$packages["os"].File.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].ReaderFrom.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].encodeState.Ptr];
go$packages["io"].RuneReader.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["fmt"].readRune.Ptr, go$packages["fmt"].ss.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].RuneScanner.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["fmt"].ss.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].Seeker.implementedBy = [go$packages["bytes"].Reader.Ptr, go$packages["io"].SectionReader.Ptr, go$packages["os"].File.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].WriteCloser.implementedBy = [go$packages["encoding/base64"].encoder.Ptr, go$packages["io"].PipeWriter.Ptr, go$packages["os"].File.Ptr];
go$packages["io"].WriteSeeker.implementedBy = [go$packages["os"].File.Ptr];
go$packages["io"].Writer.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/base64"].encoder.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["fmt"].pp.Ptr, go$packages["io"].PipeWriter.Ptr, go$packages["io"].multiWriter.Ptr, go$packages["os"].File.Ptr, go$ptrType(go$packages["fmt"].buffer), go$ptrType(go$packages["strings"].appendSliceWriter)];
go$packages["io"].WriterAt.implementedBy = [go$packages["os"].File.Ptr];
go$packages["io"].WriterTo.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["io"].stringWriter.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["os"].File.Ptr, go$packages["strings"].stringWriter, go$packages["strings"].stringWriter.Ptr, go$ptrType(go$packages["fmt"].buffer), go$ptrType(go$packages["strings"].appendSliceWriter)];
go$packages["encoding"].BinaryMarshaler.implementedBy = [go$packages["time"].Time, go$packages["time"].Time.Ptr];
go$packages["encoding"].BinaryUnmarshaler.implementedBy = [go$packages["time"].Time.Ptr];
go$packages["encoding"].TextMarshaler.implementedBy = [go$packages["time"].Time, go$packages["time"].Time.Ptr];
go$packages["encoding"].TextUnmarshaler.implementedBy = [go$packages["time"].Time.Ptr];
go$packages["strings"].replacer.implementedBy = [go$packages["strings"].Replacer.Ptr, go$packages["strings"].byteReplacer.Ptr, go$packages["strings"].byteStringReplacer.Ptr, go$packages["strings"].genericReplacer.Ptr, go$packages["strings"].singleStringReplacer.Ptr];
go$packages["strings"].stringWriterIface.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["os"].File.Ptr, go$packages["strings"].stringWriter, go$packages["strings"].stringWriter.Ptr, go$ptrType(go$packages["fmt"].buffer), go$ptrType(go$packages["strings"].appendSliceWriter)];
go$packages["syscall"].Sockaddr.implementedBy = [go$packages["syscall"].SockaddrInet4.Ptr, go$packages["syscall"].SockaddrInet6.Ptr, go$packages["syscall"].SockaddrUnix.Ptr];
go$packages["os"].FileInfo.implementedBy = [go$packages["os"].fileStat.Ptr];
go$packages["os"].Signal.implementedBy = [go$packages["syscall"].Signal, go$ptrType(go$packages["syscall"].Signal)];
go$packages["reflect"].Type.implementedBy = [go$packages["reflect"].arrayType.Ptr, go$packages["reflect"].chanType.Ptr, go$packages["reflect"].funcType.Ptr, go$packages["reflect"].interfaceType.Ptr, go$packages["reflect"].mapType.Ptr, go$packages["reflect"].ptrType.Ptr, go$packages["reflect"].rtype.Ptr, go$packages["reflect"].sliceType.Ptr, go$packages["reflect"].structType.Ptr];
go$packages["fmt"].Formatter.implementedBy = [];
go$packages["fmt"].GoStringer.implementedBy = [];
go$packages["fmt"].ScanState.implementedBy = [go$packages["fmt"].ss.Ptr];
go$packages["fmt"].Scanner.implementedBy = [];
go$packages["fmt"].State.implementedBy = [go$packages["fmt"].pp.Ptr];
go$packages["fmt"].Stringer.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["encoding/json"].Number, go$packages["encoding/json"].encodeState.Ptr, go$packages["github.com/neelance/gopherjs/js"].Error, go$packages["github.com/neelance/gopherjs/js"].Error.Ptr, go$packages["github.com/rusco/jquery"].Event, go$packages["github.com/rusco/jquery"].Event.Ptr, go$packages["github.com/rusco/todomvc/utils"].Handlebar, go$packages["github.com/rusco/todomvc/utils"].Handlebar.Ptr, go$packages["os"].FileMode, go$packages["os"].ProcessState.Ptr, go$packages["reflect"].ChanDir, go$packages["reflect"].Kind, go$packages["reflect"].Value, go$packages["reflect"].Value.Ptr, go$packages["reflect"].arrayType.Ptr, go$packages["reflect"].chanType.Ptr, go$packages["reflect"].funcType.Ptr, go$packages["reflect"].interfaceType.Ptr, go$packages["reflect"].mapType.Ptr, go$packages["reflect"].ptrType.Ptr, go$packages["reflect"].rtype.Ptr, go$packages["reflect"].sliceType.Ptr, go$packages["reflect"].structType.Ptr, go$packages["strconv"].decimal.Ptr, go$packages["syscall"].Signal, go$packages["time"].Duration, go$packages["time"].Location.Ptr, go$packages["time"].Month, go$packages["time"].Time, go$packages["time"].Time.Ptr, go$packages["time"].Weekday, go$ptrType(go$packages["encoding/json"].Number), go$ptrType(go$packages["os"].FileMode), go$ptrType(go$packages["reflect"].ChanDir), go$ptrType(go$packages["reflect"].Kind), go$ptrType(go$packages["syscall"].Signal), go$ptrType(go$packages["time"].Duration), go$ptrType(go$packages["time"].Month), go$ptrType(go$packages["time"].Weekday)];
go$packages["fmt"].runeUnreader.implementedBy = [go$packages["bytes"].Buffer.Ptr, go$packages["bytes"].Reader.Ptr, go$packages["encoding/json"].encodeState.Ptr, go$packages["fmt"].ss.Ptr, go$packages["strings"].Reader.Ptr];
go$packages["sort"].Interface.implementedBy = [go$packages["encoding/json"].byIndex, go$packages["encoding/json"].byName, go$packages["encoding/json"].stringValues, go$packages["sort"].Float64Slice, go$packages["sort"].IntSlice, go$packages["sort"].StringSlice, go$packages["sort"].reverse, go$packages["sort"].reverse.Ptr, go$ptrType(go$packages["encoding/json"].byIndex), go$ptrType(go$packages["encoding/json"].byName), go$ptrType(go$packages["encoding/json"].stringValues), go$ptrType(go$packages["sort"].Float64Slice), go$ptrType(go$packages["sort"].IntSlice), go$ptrType(go$packages["sort"].StringSlice)];
go$packages["encoding/json"].Marshaler.implementedBy = [go$packages["time"].Time, go$packages["time"].Time.Ptr, go$ptrType(go$packages["encoding/json"].RawMessage)];
go$packages["encoding/json"].Unmarshaler.implementedBy = [go$packages["time"].Time.Ptr, go$ptrType(go$packages["encoding/json"].RawMessage)];
go$packages["math/rand"].Source.implementedBy = [go$packages["math/rand"].Rand.Ptr, go$packages["math/rand"].lockedSource.Ptr, go$packages["math/rand"].rngSource.Ptr];
go$packages["runtime"].init();
go$packages["github.com/neelance/gopherjs/js"].init();
go$packages["github.com/rusco/jquery"].init();
go$packages["errors"].init();
go$packages["sync/atomic"].init();
go$packages["sync"].init();
go$packages["io"].init();
go$packages["unicode"].init();
go$packages["unicode/utf8"].init();
go$packages["bytes"].init();
go$packages["encoding"].init();
go$packages["math"].init();
go$packages["strconv"].init();
go$packages["strings"].init();
go$packages["encoding/base64"].init();
go$packages["unicode/utf16"].init();
go$packages["syscall"].init();
go$packages["time"].init();
go$packages["os"].init();
go$packages["reflect"].init();
go$packages["fmt"].init();
go$packages["sort"].init();
go$packages["encoding/json"].init();
go$packages["math/rand"].init();
go$packages["github.com/rusco/todomvc/utils"].init();
go$packages["main"].init();
go$packages["main"].main();
